{"version":3,"sources":["../../../../src/lib/worker-api/create-worker.ts"],"names":["requestId","inputBatches","options","createWorker","process","processInBatches","self","context","processOnMainThread","WorkerBody","onmessage","type","payload","Error","result","input","postMessage","AsyncQueue","resultIterator","batch","push","close","error","message","arrayBuffer","Promise","resolve","reject","id","onMessage","removeEventListener","addEventListener"],"mappings":"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","sourcesContent":["import type {\n  WorkerMessageType,\n  WorkerMessagePayload,\n  WorkerContext,\n  Process,\n  ProcessInBatches\n} from '../../types';\nimport AsyncQueue from '../async-queue/async-queue';\nimport WorkerBody from '../worker-farm/worker-body';\n// import {validateWorkerVersion} from './validate-worker-version';\n\n/** Counter for jobs */\nlet requestId = 0;\nlet inputBatches;\nlet options;\n\nexport type ProcessOnMainThread = (data: any, options?: {[key: string]: any}, context?) => any;\n\n/**\n * Set up a WebWorkerGlobalScope to talk with the main thread\n */\nexport function createWorker(process: Process, processInBatches?: ProcessInBatches): void {\n  // Check that we are actually in a worker thread\n  if (typeof self === 'undefined') {\n    return;\n  }\n\n  const context: WorkerContext = {\n    process: processOnMainThread\n  };\n\n  // eslint-disable-next-line complexity\n  WorkerBody.onmessage = async (type: WorkerMessageType, payload: WorkerMessagePayload) => {\n    try {\n      switch (type) {\n        case 'process':\n          if (!process) {\n            throw new Error('Worker does not support atomic processing');\n          }\n          const result = await process(payload.input, payload.options || {}, context);\n          WorkerBody.postMessage('done', {result});\n          break;\n\n        case 'process-in-batches':\n          if (!processInBatches) {\n            throw new Error('Worker does not support batched processing');\n          }\n          inputBatches = new AsyncQueue();\n          options = payload.options || {};\n          const resultIterator = processInBatches(inputBatches, options, context?.processInBatches);\n          for await (const batch of resultIterator) {\n            WorkerBody.postMessage('output-batch', {result: batch});\n          }\n          WorkerBody.postMessage('done', {});\n          break;\n\n        case 'input-batch':\n          inputBatches.push(payload.input);\n          break;\n\n        case 'input-done':\n          inputBatches.close();\n          break;\n\n        default:\n      }\n    } catch (error) {\n      const message = error instanceof Error ? error.message : '';\n      WorkerBody.postMessage('error', {error: message});\n    }\n  };\n}\n\nfunction processOnMainThread(arrayBuffer, options = {}) {\n  return new Promise((resolve, reject) => {\n    const id = requestId++;\n\n    /**\n     */\n    const onMessage = (type, payload) => {\n      if (payload.id !== id) {\n        // not ours\n        return;\n      }\n\n      switch (type) {\n        case 'done':\n          WorkerBody.removeEventListener(onMessage);\n          resolve(payload.result);\n          break;\n\n        case 'error':\n          WorkerBody.removeEventListener(onMessage);\n          reject(payload.error);\n          break;\n\n        default:\n        // ignore\n      }\n    };\n\n    WorkerBody.addEventListener(onMessage);\n\n    // Ask the main thread to decode data\n    const payload = {id, input: arrayBuffer, options};\n    WorkerBody.postMessage('process', payload);\n  });\n}\n"],"file":"create-worker.js"}