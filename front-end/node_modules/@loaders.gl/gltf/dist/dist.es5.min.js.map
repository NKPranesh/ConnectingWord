{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///../worker-utils/src/lib/env-utils/assert.ts","webpack:///./src/lib/gltf-utils/gltf-constants.ts","webpack:///../loader-utils/src/index.ts","webpack:///./src/lib/utils/assert.js","webpack:///./src/lib/api/gltf-scenegraph.ts","webpack:////Users/kbarron/github/mapping/loaders.gl/node_modules/@probe.gl/stats/dist/esm/utils/hi-res-timestamp.js","webpack:///(webpack)/buildin/global.js","webpack:///./src/lib/utils/version.js","webpack:///../images/src/lib/utils/assert.js","webpack:////Users/kbarron/github/mapping/loaders.gl/node_modules/process/browser.js","webpack:///../images/src/lib/category-api/parsed-image-api.ts","webpack:///../worker-utils/src/lib/env-utils/version.ts","webpack:///../images/src/lib/utils/globals.ts","webpack:///../images/src/lib/category-api/binary-image-api.ts","webpack:///../worker-utils/src/index.ts","webpack:///../worker-utils/src/lib/env-utils/globals.ts","webpack:///../worker-utils/src/lib/worker-farm/worker-thread.ts","webpack:///../worker-utils/src/lib/worker-utils/get-transfer-list.ts","webpack:///../schema/src/lib/schema/index.ts","webpack:///./src/lib/gltf-utils/gltf-utils.ts","webpack:///../images/src/index.ts","webpack:///../images/src/lib/utils/version.ts","webpack:///../images/src/lib/parsers/parse-image.ts","webpack:///../images/src/lib/category-api/image-type.ts","webpack:///../images/src/lib/parsers/parse-to-image.ts","webpack:///../images/src/lib/parsers/svg-utils.ts","webpack:///../loader-utils/src/lib/env-utils/assert.ts","webpack:///../worker-utils/src/lib/worker-farm/worker-job.ts","webpack:///../worker-utils/src/lib/worker-farm/worker-farm.ts","webpack:///../worker-utils/src/lib/worker-farm/worker-pool.ts","webpack:///../worker-utils/src/lib/worker-farm/worker-body.ts","webpack:///../worker-utils/src/lib/worker-api/get-worker-url.ts","webpack:///../worker-utils/src/lib/async-queue/async-queue.ts","webpack:///../loader-utils/src/lib/binary-utils/get-first-characters.ts","webpack:///../loader-utils/src/lib/binary-utils/array-buffer-utils.ts","webpack:///../loader-utils/src/lib/binary-utils/buffer-utils.ts","webpack:///../loader-utils/src/lib/binary-utils/memory-copy-utils.ts","webpack:///../draco/src/lib/utils/version.ts","webpack:///../schema/src/index.ts","webpack:///../schema/src/lib/table/row-table-batch-aggregator.ts","webpack:///../schema/src/lib/utils/row-utils.ts","webpack:///../schema/src/lib/table/columnar-table-batch-aggregator.ts","webpack:///../draco/src/lib/draco-module-loader.ts","webpack:///./src/lib/api/post-process-gltf.js","webpack:///./src/lib/parsers/parse-glb.ts","webpack:///./src/lib/encoders/encode-glb.js","webpack:///./src/bundle.ts","webpack:///./src/index.ts","webpack:///./src/gltf-loader.ts","webpack:///./src/lib/parsers/parse-gltf.ts","webpack:///../images/src/image-loader.ts","webpack:///../images/src/lib/parsers/parse-to-image-bitmap.ts","webpack:///../images/src/lib/parsers/parse-to-node-image.ts","webpack:///../images/src/image-writer.ts","webpack:///../images/src/lib/encoders/encode-image.ts","webpack:///../images/src/lib/texture-api/load-image.ts","webpack:///../images/src/lib/texture-api/generate-url.ts","webpack:///../loader-utils/src/lib/env-utils/globals.ts","webpack:///../loader-utils/src/lib/worker-loader-utils/create-loader-worker.ts","webpack:///../worker-utils/src/lib/worker-utils/get-loadable-worker-url.ts","webpack:///../worker-utils/src/lib/worker-api/process-on-worker.ts","webpack:///../worker-utils/src/lib/worker-utils/remove-nontransferable-options.ts","webpack:///../worker-utils/src/lib/worker-api/create-worker.ts","webpack:///../worker-utils/src/lib/worker-api/validate-worker-version.ts","webpack:///../worker-utils/src/lib/library-utils/library-utils.ts","webpack:///../loader-utils/src/lib/worker-loader-utils/parse-with-worker.ts","webpack:///../loader-utils/src/lib/parser-utils/parse-json.ts","webpack:///../loader-utils/src/lib/binary-utils/binary-copy-utils.ts","webpack:///../loader-utils/src/lib/binary-utils/encode-utils.ts","webpack:///../loader-utils/src/lib/iterators/text-iterators.ts","webpack:///../loader-utils/src/lib/iterators/async-iteration.ts","webpack:///../loader-utils/src/lib/request-utils/request-scheduler.ts","webpack:///../loader-utils/src/lib/path-utils/file-aliases.ts","webpack:///../loader-utils/src/json-loader.ts","webpack:///../loader-utils/src/lib/path-utils/path.ts","webpack:///../loader-utils/src/lib/filesystems/node-filesystem.ts","webpack:///../images/src/lib/texture-api/deep-load.ts","webpack:///../images/src/lib/texture-api/async-deep-map.ts","webpack:///./src/lib/gltf-utils/resolve-url.ts","webpack:///./src/lib/gltf-utils/get-typed-array.ts","webpack:///./src/lib/extensions/gltf-extensions.ts","webpack:///./src/lib/extensions/KHR_draco_mesh_compression.ts","webpack:///../draco/src/index.ts","webpack:///../draco/src/draco-loader.ts","webpack:///../draco/src/lib/draco-parser.ts","webpack:///../schema/src/lib/table/table-batch-builder.ts","webpack:///../schema/src/lib/table/base-table-batch-aggregator.ts","webpack:///../schema/src/category/mesh/mesh-utils.ts","webpack:///../schema/src/lib/schema/impl/schema.ts","webpack:///../schema/src/lib/utils/assert.ts","webpack:///../schema/src/lib/schema/impl/field.ts","webpack:///../schema/src/lib/schema/impl/type.ts","webpack:///../schema/src/lib/schema/impl/enum.ts","webpack:///../schema/src/lib/schema-utils/deduce-table-schema.ts","webpack:///../schema/src/lib/schema-utils/get-type-info.ts","webpack:///../schema/src/lib/schema-utils/type-utils.ts","webpack:///../schema/src/lib/utils/async-queue.ts","webpack:///../draco/src/lib/utils/schema-attribute-utils.ts","webpack:///../draco/src/draco-writer.ts","webpack:///../draco/src/lib/draco-builder.ts","webpack:///./src/lib/gltf-utils/gltf-attribute-utils.ts","webpack:///./src/lib/extensions/KHR_materials_unlit.ts","webpack:///./src/lib/extensions/KHR_lights_punctual.ts","webpack:///./src/lib/extensions/KHR_techniques_webgl.ts","webpack:///./src/lib/api/normalize-gltf-v1.js","webpack:///./src/lib/extensions/KHR_binary_gltf.ts","webpack:///./src/gltf-writer.ts","webpack:///./src/lib/encoders/encode-gltf.js","webpack:///./src/glb-loader.ts","webpack:///./src/glb-writer.ts","webpack:////Users/kbarron/github/mapping/loaders.gl/node_modules/@probe.gl/stats/dist/esm/lib/stat.js","webpack:////Users/kbarron/github/mapping/loaders.gl/node_modules/@probe.gl/stats/dist/esm/lib/stats.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","condition","message","Error","componentType","BYTES","type","COMPONENTS","parameter","magFilter","minFilter","wrapS","wrapT","SCALAR","VEC2","VEC3","VEC4","MAT2","MAT3","MAT4","5120","5121","5122","5123","5125","5126","DEFAULT_GLTF_JSON","asset","version","generator","buffers","GLTFScenegraph","gltf","this","json","sourceBuffers","byteLength","extras","extensionName","isExtension","getUsedExtensions","find","extensions","getRequiredExtensions","getExtension","extensionsRequired","extensionsUsed","index","getObject","array","bufferView","bufferIndex","getBufferView","buffer","binChunk","assert","byteOffset","Uint8Array","arrayBuffer","accessor","getAccessor","getBuffer","data","getAccessorArrayTypeAndLength","ArrayType","length","image","registerUsedExtension","extension","extensionData","addExtension","registerRequiredExtension","ext","push","_removeStringFromArray","sceneIndex","scene","nodeIndices","scenes","nodes","node","meshIndex","matrix","nodeData","mesh","attributes","indices","material","glTFMesh","primitives","_addAttributes","indicesAccessor","_addIndices","Number","isFinite","meshes","imageData","mimeTypeOpt","metadata","getBinaryImageMetadata","mimeType","glTFImage","addBufferView","images","glTFBufferView","padToNBytes","bufferViews","bufferViewIndex","glTFAccessor","getAccessorTypeFromSize","size","count","max","min","accessors","sourceBuffer","minMax","_getAccessorMinMax","accessorDefaults","getComponentTypeFromArray","Math","round","addAccessor","assign","texture","glTFTexture","source","imageIndex","textures","pbrMaterialInfo","materials","totalByteLength","ArrayBuffer","targetArray","dstByteOffset","copyToArray","binary","string","found","indexOf","splice","result","attributeKey","attributeData","attrName","_getGltfAttributeName","addBinaryBuffer","attributeName","toLowerCase","subarray","componentIndex","getHiResTimestamp","timestamp","window","performance","now","process","hrtime","timeParts","Date","g","Function","e","cachedSetTimeout","cachedClearTimeout","defaultSetTimout","defaultClearTimeout","runTimeout","fun","setTimeout","clearTimeout","currentQueue","queue","draining","queueIndex","cleanUpNextTick","concat","drainQueue","timeout","len","run","marker","runClearTimeout","Item","noop","nextTick","args","Array","arguments","apply","title","browser","env","argv","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","binding","cwd","chdir","dir","umask","getImageType","format","getImageTypeOrNull","getImageData","canvas","document","createElement","context","getContext","width","height","drawImage","ImageBitmap","Image","Boolean","close","globals","self","global","self_","window_","global_","document_","isBrowser","String","isWorker","importScripts","matches","exec","nodeVersion","parseFloat","binaryData","dataView","toDataView","getUint32","getPngMetadata","getUint16","getUint8","tableMarkers","Set","add","sofMarkers","getJpegMarkers","has","getJpegMetadata","getGifMetadata","getBmpMetadata","DataView","isView","NullWorker","id","VERSION","options","null","isMobile","orientation","NOOP","WorkerThread","props","url","onMessage","onError","error","console","log","worker","_createBrowserWorker","Worker","terminate","terminated","transferList","getTransferList","postMessage","event","lineno","colno","_loadableURL","getLoadableWorkerURL","onmessage","onerror","_getErrorFromErrorEvent","onmessageerror","isTransferable","MessagePort","OffscreenCanvas","recursive","transfers","transfersSet","undefined","from","TYPES","typedArray","ARRAY_TO_COMPONENT_TYPE","constructor","ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY","components","ATTRIBUTE_TYPE_TO_COMPONENTS","bytesPerComponent","ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE","ARRAY_CONSTRUCTOR_TO_WEBGL_CONSTANT","Int8Array","Int16Array","Uint16Array","Uint32Array","Float32Array","Float64Array","Map","imageOptions","imageType","loadType","getLoadableImageType","getDefaultImageType","isImageTypeSupported","IMAGE_BITMAP_SUPPORTED","IMAGE_SUPPORTED","DATA_SUPPORTED","_parseImageNode","NODE_IMAGE_SUPPORTED","blobOrDataUrl","getBlobOrSVGDataUrl","URL","webkitURL","objectUrl","createObjectURL","loadToImage","revokeObjectURL","src","decode","Promise","resolve","reject","onload","err","isSVG","xmlText","TextDecoder","unescape","encodeURIComponent","btoa","getBlob","SVG_DATA_URL_PATTERN","SVG_URL_PATTERN","test","Blob","WorkerJob","jobName","workerThread","isRunning","_resolve","_reject","payload","DEFAULT_PROPS","maxConcurrency","maxMobileConcurrency","onDebug","reuseWorkers","WorkerFarm","setProps","workerPools","isSupported","_workerFarm","values","destroy","_getWorkerPoolProps","workerPool","WorkerPool","set","idleQueue","forEach","isDestroyed","job","done","startPromise","onStart","jobQueue","_startQueuedJob","_getAvailableWorker","queuedJob","shift","backlog","returnWorkerToQueue","_getMaxConcurrency","onMessageWrapperMap","WorkerBody","isKnownMessage","onMessageWrapper","addEventListener","removeEventListener","startsWith","warning","workerOptions","workerFile","workerUrl","_workerType","versionTag","asyncIterator","AsyncQueue","_values","_settlers","_closed","enqueue","settler","getMagicString","magic","fromCharCode","slice","isBuffer","bufferToArrayBuffer","text","TextEncoder","encode","_toArrayBuffer","arrayBuffer1","arrayBuffer2","array1","array2","sources","sourceArrays","map","source2","reduce","offset","sourceArray","typedArrays","arrays","TypedArrayConstructor","sumLength","acc","subArray","toBuffer","toArrayBuffer","targetBuffer","target","targetOffset","srcByteOffset","srcByteLength","padding","RowTableBatchAggregator","schema","isArray","_headers","row","cursor","shape","rowObject","convertToObjectRow","addObjectRow","arrayRows","rowArray","convertToArrayRow","addArrayRow","objectRows","rows","batchType","arrayRow","headers","objectRow","ColumnarTableBatchAggregator","_reallocateColumns","fieldName","columns","_pruneColumns","field","allocated","oldColumn","entries","columnName","column","loadDecoderPromise","loadEncoderPromise","DRACO_JS_DECODER_URL","DRACO_WASM_WRAPPER_URL","DRACO_WASM_DECODER_URL","DRACO_ENCODER_URL","draco3d","createDecoderModule","then","draco","loadDracoDecoder","createEncoderModule","loadDracoEncoder","decoderType","loadLibrary","DracoDecoderModule","all","wasmBinary","globalThis","initializeDracoDecoder","onModuleLoaded","DracoEncoderModule","GLTFPostProcessor","postProcess","GL_SAMPLER","TEXTURE_MAG_FILTER","TEXTURE_MIN_FILTER","TEXTURE_WRAP_S","TEXTURE_WRAP_T","REPEAT","LINEAR","NEAREST_MIPMAP_LINEAR","SAMPLER_PARAMETER_GLTF_TO_GL","DEFAULT_SAMPLER","TEXTURE_WRAP_","baseUri","_resolveTree","bufView","_resolveBufferView","_resolveImage","samplers","sampler","_resolveSampler","_resolveTexture","_resolveAccessor","_resolveMaterial","_resolveMesh","_resolveNode","skins","skin","_resolveSkin","_resolveScene","_get","warn","getNode","children","child","getMesh","accum","camera","getCamera","getSkin","inverseBindMatrices","primitive","attribute","getMaterial","normalTexture","getTexture","occlusionTexture","occlustionTexture","emissiveTexture","emmisiveTexture","emissiveFactor","pbrMetallicRoughness","mr","baseColorTexture","metallicRoughnessTexture","bytesPerElement","cutBufffer","getSampler","getImage","parameters","glEnum","_enumSamplerParameter","preloadedImage","perspective","orthographic","magic1","glb","header","hasBinChunk","binChunks","parseGLBV1","parseGLBV2","GLB_FILE_HEADER_SIZE","contentLength","contentFormat","parseJSONChunk","parseBINChunk","chunkLength","chunkFormat","strict","parseGLBChunksSync","jsonChunk","jsonText","JSON","parse","byteOffsetStart","setUint32","byteOffsetFileLength","byteOffsetJsonHeader","jsonString","stringify","copyPaddedStringToDataView","jsonByteLength","byteOffsetBinHeader","copyPaddedArrayBufferToDataView","binByteLength","fileByteLength","moduleExports","require","_global","loaders","GLTFLoader","mimeTypes","tests","normalize","loadBuffers","loadImages","decompressMeshes","deprecatedOptions","fetchImages","createImages","decompress","parseGLTF","isGLB","arrayBufferOrString","parseGLTFContainerSync","normalizeGLTFV1","promises","promise","decodeExtensions","postProcessGLTF","uri","parseJSON","_glb","fill","fetch","resolveUrl","response","loadImage","getTypedArrayForBufferView","sliceArrayBuffer","ImageLoader","parsedImage","parseImage","_typecheckImageLoader","EMPTY_OBJECT","imagebitmapOptionsSupported","blob","imagebitmapOptions","imagebitmap","safeCreateImageBitmap","isEmptyObject","createImageBitmap","ImageWriter","jpegQuality","encodeImage","_encodeImageNode","encodeImageInBrowser","qualityParamSupported","getImageSize","drawImageToCanvas","toBlob","x","y","transferFromImageBitmap","clampedArray","Uint8ClampedArray","ImageData","putImageData","getUrl","getImageUrls","imageUrls","deepLoad","urlOptions","mipLevels","getMipmappedImageUrls","generateUrl","urls","lod","shallowLoad","getMipLevels","mipLevel","floor","log2","baseUrl","resolvePath","loader","input","parseData","parseOnMainThread","requestId","parseSync","parser","parseTextSync","textDecoder","workerURL","workerURLCache","getLoadableWorkerURLFromSource","getLoadableWorkerURLFromURL","workerSource","getWorkerName","getWorkerURL","workerFarm","getWorkerFarm","getWorkerPool","startJob","transferableOptions","removeNontransferableOptions","v","cache","processInBatches","processOnMainThread","inputBatches","resultIterator","batch","coreVersion","workerVersion","loadLibraryPromises","libraryUrl","moduleName","getLibraryUrl","loadLibraryFromFile","library","CDN","endsWith","requireFromFile","scriptSource","loadLibraryFromString","requireFromString","eval","script","appendChild","createTextNode","body","_","getFirstCharacters","stringBuffer","paddedLength","padLength","setUint8","byteAlignment","ceil","whitespace","charCodeAt","arrayBufferIterator","stream","textIterator","textEncoder","previous","eolIndex","line","lineIterator","counter","iterator","visitor","next","arrayBuffers","chunk","concatenateArrayBuffers","strings","join","throttleRequests","maxRequests","RequestScheduler","stats","Stats","handle","getPriority","requestMap","request","priority","requestQueue","_issueNewRequests","isDone","activeRequestCount","deferredUpdate","_issueNewRequestsAsync","freeSlots","_updateAllRequests","_issueRequest","_updateRequest","sort","a","b","prefix","pathPrefix","aliases","fileAliases","filename","alias","replacement","replace","JSONLoader","category","_typecheckJSONLoader","slashIndex","lastIndexOf","substr","parts","separator","part","RegExp","NodeFileSystem","_fetch","dirname","fs","readdir","path","stat","info","isDirectory","fallbackFetch","flags","open","fd","fstat","position","totalBytesRead","read","bytesRead","urlTree","load","asyncDeepMap","isObject","tree","func","mapSubtree","mapArray","mapObject","urlArray","EXTENSIONS","KHR_draco_mesh_compression","KHR_materials_unlit","KHR_lights_punctual","KHR_techniques_webgl","excludes","excludeExtensions","gltfData","scenegraph","Scenegraph","compressMesh","addRequiredExtension","KHR_DRACO_MESH_COMPRESSION","makeMeshPrimitiveIterator","getObjectExtension","decompressPrimitive","removeExtension","dracoExtension","bufferCopy","dracoOptions","DracoLoader","decodedData","decodedAttributes","getGLTFAccessors","decodedAttribute","accessorIndex","getGLTFAccessor","checkPrimitive","DracoWriter","compressedData","encodeSync","fauxAccessors","_addFauxAttributes","keys","f","DracoWorkerLoader","loadDracoDecoderModule","dracoParser","DracoParser","_TypecheckDracoLoader","DEFAULT_DRACO_OPTIONS","WebAssembly","libraryPath","extraAttributes","attributeNameEntry","DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP","POSITION","NORMAL","COLOR","TEX_COORD","DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP","1","2","3","4","5","Int32Array","6","9","decoder","Decoder","metadataQuerier","MetadataQuerier","DecoderBuffer","Init","_disableAttributeTransforms","geometry_type","GetEncodedGeometryType","dracoGeometry","TRIANGULAR_MESH","Mesh","PointCloud","dracoStatus","DecodeBufferToMesh","POINT_CLOUD","DecodeBufferToPointCloud","ok","ptr","error_msg","loaderData","_getDracoLoaderData","geometry","_getMeshData","boundingBox","getMeshBoundingBox","makeSchemaFromAttributes","vertexCount","num_points","_getTopLevelMetadata","_getDracoAttributes","num_attributes","num_faces","dracoAttributes","attributeId","dracoAttribute","GetAttribute","_getAttributeMetadata","unique_id","attribute_type","data_type","num_components","byte_offset","byte_stride","normalized","attribute_index","quantization","_getQuantizationTransform","quantization_transform","octahedron","_getOctahedronTransform","octahedron_transform","_getMeshAttributes","topology","_getTriangleStripIndices","_getTriangleListIndices","loaderAttribute","_deduceAttributeName","_getAttributeValues","byteStride","numIndices","_malloc","GetTrianglesUInt32Array","HEAPF32","_free","dracoArray","DracoInt32Array","GetTriangleStripsFromMesh","numValues","intArray","GetValue","getUint32Array","TypedArrayCtor","numComponents","BYTES_PER_ELEMENT","dataType","attributeType","DT_FLOAT32","DT_INT8","DT_INT16","DT_INT32","DT_UINT8","DT_UINT16","DT_UINT32","DT_INVALID","getDracoDataType","GetAttributeDataArrayForAllPoints","uniqueId","thisAttributeType","dracoAttributeConstant","entryName","dracoMetadata","GetMetadata","_getDracoMetadata","GetAttributeMetadata","numEntries","NumEntries","entryIndex","GetEntryName","_getDracoMetadataField","GetIntEntryArray","getInt32Array","int","GetIntEntry","GetStringEntry","double","GetDoubleEntry","quantizedAttributes","octahedronAttributes","dracoAttributeName","SkipAttributeTransform","includes","transform","AttributeQuantizationTransform","InitFromAttribute","quantization_bits","range","min_values","min_value","DEFAULT_OPTIONS","batchSize","batchDebounceMs","limit","_limitMB","TableBatchBuilder","totalLength","totalBytes","limitReached","rowBytes","_estimateRowMB","aggregator","TableBatchType","_getTableBatchType","bytesUsed","isChunkComplete","_isFull","_getBatch","rowCount","lastBatchEmittedMs","normalizedBatch","getBatch","batchCount","BaseTableBatchAggregator","ArrowBatch","minX","Infinity","minY","minZ","maxX","maxY","maxZ","positions","z","Schema","fields","usedNames","checkNames","other","compareTo","nameMap","columnNames","selectedFields","filter","columnIndices","schemaOrFields","otherSchema","mergeMaps","fieldMap","m1","m2","Field","nullable","typeId","DataType","Type","NONE","Null","Int","Float","Binary","Utf8","Bool","Decimal","Time","Timestamp","Interval","List","Struct","Union","FixedSizeBinary","FixedSizeList","Dictionary","isSigned","bitWidth","Int8","Int16","Int32","Int64","Uint8","Uint16","Uint32","Uint64","Precision","precision","Float16","Float32","Float64","DateUnit","DAY","MILLISECOND","unit","DateDay","DateMillisecond","TimeUnit","SECOND","MICROSECOND","NANOSECOND","TimeSecond","TimeMillisecond","timezone","TimestampSecond","TimestampMillisecond","TimestampMicrosecond","TimestampNanosecond","IntervalUnit","DAY_TIME","YEAR_MONTH","IntervalDayTime","IntervalYearMonth","listSize","valueType","deduceTypeFromValue","table","deducedSchema","rowTable","deduceSchemaForRowTable","columnarTable","deduceSchemaForColumnarTable","arrowTypeLike","typeName","toString","typeEnumName","getTypeKey","ReverseType","typeKey","ArrayQueue","dequeue","asyncIterable","metadataMap","makeMetadata","namedLoaderDataAttributes","transformAttributesLoaderData","getArrowFieldFromAttribute","indicesField","getArrowTypeFromTypedArray","pointcloud","loadDracoEncoderModule","dracoBuilder","DRACOBuilder","GLTF_TO_DRACO_ATTRIBUTE_NAME_MAP","COLOR_0","TEXCOORD_0","DracoBuilder","dracoEncoder","Encoder","dracoMeshBuilder","MeshBuilder","dracoMetadataBuilder","MetadataBuilder","destroyEncodedObject","_setOptions","_encodePointCloud","_encodeMesh","dracoPointCloud","_addGeometryMetadata","_getAttributesFromMesh","_createDracoPointCloud","dracoData","DracoInt8Array","encodedLen","EncodePointCloudToDracoBuffer","dracoInt8ArrayToArrayBuffer","dracoMesh","_createDracoMesh","EncodeMeshToDracoBuffer","SetSpeedOptions","speed","dracoMethod","method","SetEncodingMethod","bits","dracoPosition","SetAttributeQuantization","optionalMetadata","attributesMetadata","_getPositionAttribute","_addAttributeToMesh","_addAttributeMetadata","_getDracoAttributeType","numFaces","AddFacesToMesh","builder","AddInt8Attribute","AddInt16Attribute","AddInt32Attribute","AddUInt8Attribute","AddUInt16Attribute","AddUInt32Attribute","AddFloatAttribute","GENERIC","Metadata","_populateDracoMetadata","AddMetadata","uniqueAttributeId","dracoAttributeMetadata","SetMetadataForAttribute","container","trunc","AddIntEntry","AddDoubleEntry","AddIntEntryArray","AddStringEntry","outputBuffer","outputData","convertTypedArrays","toTypedArray","getAccessorData","gltfScenegraph","unlit","addObjectExtension","KHR_MATERIALS_UNLIT","removeObjectExtension","KHR_LIGHTS_PUNCTUAL","lights","nodeExtension","light","KHR_TECHNIQUES_WEBGL","techniques","resolveTechniques","materialExtension","technique","resolveValues","techniquesExtension","programs","shaders","shader","code","program","fragmentShader","vertexShader","uniforms","uniform","GLTFV1Normalizer","GLTF_ARRAYS","animations","GLTF_KEYS","idToIndexMap","_addAsset","_convertTopLevelObjectsToArrays","KHR_binary_glTF","_convertObjectIdsToArrayIndices","_updateObjects","_updateMaterial","arrayName","_convertTopLevelObjectToArray","mapName","objectMap","_convertIdsToIndices","_convertIdToIndex","_convertTextureIds","_convertMeshIds","_convertNodeIds","_convertSceneIds","topLevelArrayName","baseColorFactor","metallicFactor","roughnessFactor","textureId","tex","textureIndex","findIndex","KHR_BINARY_GLTF","GLTFWriter","encodeGLTFSync","_TypecheckGLBLoader","firstBuffer","convertBuffersToBase64","GLBLoader","GLBWriter","sampleSize","reset","samples","addCount","subtractCount","_count","_samples","_checkSampling","time","_time","lastTiming","_startTime","_timerPending","addTime","lastSampleCount","lastSampleTime","_initializeStats","seal","_getOrCreate","fn","average","getAverageTime","hz","getHz"],"mappings":"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","file":"dist.es5.min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 46);\n","// Replacement for the external assert method to reduce bundle size\n// Note: We don't use the second \"message\" argument in calling code,\n// so no need to support it here\n\n/** Throws an `Error` with the optional `message` if `condition` is falsy */\nexport function assert(condition: any, message?: string): void {\n  if (!condition) {\n    throw new Error(message || 'loaders.gl assertion failed.');\n  }\n}\n","// GLTF 1.0 extensions\nexport const KHR_BINARY_GLTF = 'KHR_binary_glTF';\n\n// GLTF 2.0 extensions\nexport const KHR_DRACO_MESH_COMPRESSION = 'KHR_draco_mesh_compression';\nexport const KHR_LIGHTS_PUNCTUAL = 'KHR_lights_punctual';\nexport const KHR_MATERIALS_UNLIT = 'KHR_materials_unlit';\nexport const KHR_TECHNIQUES_WEBGL = 'KHR_techniques_webgl';\n\n// External extensions\nexport const EXT_MESHOPT_COMPRESSION = 'EXT_meshopt_compression';\n\nconst COMPONENTS = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n};\n\nconst BYTES = {\n  5120: 1, // BYTE\n  5121: 1, // UNSIGNED_BYTE\n  5122: 2, // SHORT\n  5123: 2, // UNSIGNED_SHORT\n  5125: 4, // UNSIGNED_INT\n  5126: 4 // FLOAT\n};\n\n// ENUM LOOKUP\n\nexport function getBytesFromComponentType(componentType) {\n  return BYTES[componentType];\n}\n\nexport function getSizeFromAccessorType(type) {\n  return COMPONENTS[type];\n}\n\nexport function getGLEnumFromSamplerParameter(parameter) {\n  const GL_TEXTURE_MAG_FILTER = 0x2800;\n  const GL_TEXTURE_MIN_FILTER = 0x2801;\n  const GL_TEXTURE_WRAP_S = 0x2802;\n  const GL_TEXTURE_WRAP_T = 0x2803;\n\n  const PARAMETER_MAP = {\n    magFilter: GL_TEXTURE_MAG_FILTER,\n    minFilter: GL_TEXTURE_MIN_FILTER,\n    wrapS: GL_TEXTURE_WRAP_S,\n    wrapT: GL_TEXTURE_WRAP_T\n  };\n\n  return PARAMETER_MAP[parameter];\n}\n","// TYPES\nexport type {\n  Loader,\n  LoaderWithParser,\n  LoaderContext,\n  LoaderOptions,\n  Writer,\n  WriterOptions,\n  DataType,\n  SyncDataType,\n  BatchableDataType,\n  IFileSystem,\n  IRandomAccessReadFileSystem\n} from './types';\n\n// GENERAL UTILS\nexport {assert} from './lib/env-utils/assert';\nexport {\n  isBrowser,\n  isWorker,\n  nodeVersion,\n  self,\n  window,\n  global,\n  document\n} from './lib/env-utils/globals';\n\n// LOADERS.GL-SPECIFIC WORKER UTILS\nexport {createLoaderWorker} from './lib/worker-loader-utils/create-loader-worker';\nexport {parseWithWorker, canParseWithWorker} from './lib/worker-loader-utils/parse-with-worker';\n\n// PARSER UTILS\nexport {parseJSON} from './lib/parser-utils/parse-json';\n\n// MEMORY COPY UTILS\nexport {\n  toArrayBuffer,\n  sliceArrayBuffer,\n  concatenateArrayBuffers,\n  concatenateTypedArrays,\n  compareArrayBuffers\n} from './lib/binary-utils/array-buffer-utils';\nexport {padToNBytes, copyToArray, copyArrayBuffer} from './lib/binary-utils/memory-copy-utils';\nexport {\n  copyPaddedArrayBufferToDataView,\n  copyPaddedStringToDataView\n} from './lib/binary-utils/binary-copy-utils';\nexport {\n  padStringToByteAlignment,\n  copyStringToDataView,\n  copyBinaryToDataView\n} from './lib/binary-utils/encode-utils';\nexport {getFirstCharacters, getMagicString} from './lib/binary-utils/get-first-characters';\n\n// ITERATOR UTILS\nexport {\n  makeTextEncoderIterator,\n  makeTextDecoderIterator,\n  makeLineIterator,\n  makeNumberedLineIterator\n} from './lib/iterators/text-iterators';\nexport {forEach, concatenateArrayBuffersAsync} from './lib/iterators/async-iteration';\n\n// REQUEST UTILS\nexport {default as RequestScheduler} from './lib/request-utils/request-scheduler';\n\n// PATH HELPERS\nexport {setPathPrefix, getPathPrefix, resolvePath} from './lib/path-utils/file-aliases';\nexport {addAliases as _addAliases} from './lib/path-utils/file-aliases';\n\n// MICRO LOADERS\nexport {JSONLoader} from './json-loader';\n\n// NODE support\n\n// Node.js emulation (can be used in browser)\n\n// `path` replacement (avoids bundling big path polyfill)\nimport * as path from './lib/path-utils/path';\nexport {path};\n\n// Avoid direct use of `Buffer` which pulls in 50KB polyfill\nexport {isBuffer, toBuffer, bufferToArrayBuffer} from './lib/binary-utils/buffer-utils';\n\n// Note.js wrappers (can be safely imported, but not used in browser)\n\n// Use instead of importing 'util'\nimport * as util from './lib/node/util';\nexport {util};\n// TODO - remove\nexport {promisify} from './lib/node/util';\n\n// Use instead of importing 'fs';`\nimport * as fs from './lib/node/fs';\nexport {fs};\n\n// EXPERIMENTAL\nexport {default as _NodeFileSystem} from './lib/filesystems/node-filesystem';\n","// Replacement for the external assert method to reduce bundle size\n// Note: We don't use the second \"message\" argument in calling code,\n// so no need to support it here\nexport function assert(condition, message) {\n  if (!condition) {\n    throw new Error(message || 'assert failed: gltf');\n  }\n}\n","import type {\n  GLTF,\n  GLTFScene,\n  GLTFNode,\n  GLTFMesh,\n  GLTFSkin,\n  GLTFMaterial,\n  GLTFAccessor,\n  GLTFSampler,\n  GLTFTexture,\n  GLTFImage,\n  GLTFBuffer,\n  GLTFBufferView\n} from '../types/gltf-types';\n\nimport {getBinaryImageMetadata} from '@loaders.gl/images';\nimport {padToNBytes, copyToArray} from '@loaders.gl/loader-utils';\nimport {assert} from '../utils/assert';\nimport {\n  getAccessorArrayTypeAndLength,\n  getAccessorTypeFromSize,\n  getComponentTypeFromArray\n} from '../gltf-utils/gltf-utils';\n\ntype GLTFWithBuffers = {\n  json: GLTF;\n  buffers: any[];\n  binary?: ArrayBuffer;\n};\n\nconst DEFAULT_GLTF_JSON: GLTF = {\n  asset: {\n    version: '2.0',\n    generator: 'loaders.gl'\n  },\n  buffers: []\n};\n\n/**\n * Class for structured access to GLTF data\n */\nexport default class GLTFScenegraph {\n  // internal\n  gltf: GLTFWithBuffers;\n  sourceBuffers: any[];\n  byteLength: number;\n\n  constructor(gltf?: {json: GLTF; buffers?: any[]}) {\n    // @ts-ignore\n    this.gltf = gltf || {\n      json: {...DEFAULT_GLTF_JSON},\n      buffers: []\n    };\n    this.sourceBuffers = [];\n    this.byteLength = 0;\n\n    // Initialize buffers\n    if (this.gltf.buffers && this.gltf.buffers[0]) {\n      this.byteLength = this.gltf.buffers[0].byteLength;\n      this.sourceBuffers = [this.gltf.buffers[0]];\n    }\n  }\n\n  // Accessors\n\n  get json(): GLTF {\n    return this.gltf.json;\n  }\n\n  getApplicationData(key: string): {[key: string]: any} {\n    // TODO - Data is already unpacked by GLBParser\n    const data = this.json[key];\n    return data;\n  }\n\n  getExtraData(key: string): {[key: string]: any} {\n    // TODO - Data is already unpacked by GLBParser\n    const extras = this.json.extras || {};\n    return extras[key];\n  }\n\n  getExtension(extensionName: string): {[key: string]: any} | null {\n    const isExtension = this.getUsedExtensions().find((name) => name === extensionName);\n    const extensions = this.json.extensions || {};\n    return isExtension ? extensions[extensionName] || true : null;\n  }\n\n  getRequiredExtension(extensionName: string): {[key: string]: any} | null {\n    const isRequired = this.getRequiredExtensions().find((name) => name === extensionName);\n    return isRequired ? this.getExtension(extensionName) : null;\n  }\n\n  getRequiredExtensions(): string[] {\n    return this.json.extensionsRequired || [];\n  }\n\n  getUsedExtensions(): string[] {\n    return this.json.extensionsUsed || [];\n  }\n\n  getObjectExtension(\n    object: {[key: string]: any},\n    extensionName: string\n  ): {[key: string]: any} | null {\n    const extensions = object.extensions || {};\n    return extensions[extensionName];\n  }\n\n  getScene(index: number): GLTFScene {\n    return this.getObject('scenes', index) as GLTFScene;\n  }\n\n  getNode(index: number): GLTFNode {\n    return this.getObject('nodes', index) as GLTFNode;\n  }\n\n  getSkin(index: number): GLTFSkin {\n    return this.getObject('skins', index) as GLTFSkin;\n  }\n\n  getMesh(index: number): GLTFMesh {\n    return this.getObject('meshes', index) as GLTFMesh;\n  }\n\n  getMaterial(index: number): GLTFMaterial {\n    return this.getObject('materials', index) as GLTFMaterial;\n  }\n\n  getAccessor(index: number): GLTFAccessor {\n    return this.getObject('accessors', index) as GLTFAccessor;\n  }\n\n  // getCamera(index: number): object | null {\n  //   return null; // TODO: fix thi: object  as null;\n  // }\n\n  getTexture(index: number): GLTFTexture {\n    return this.getObject('textures', index) as GLTFTexture;\n  }\n\n  getSampler(index: number): GLTFSampler {\n    return this.getObject('samplers', index) as GLTFSampler;\n  }\n\n  getImage(index: number): GLTFImage {\n    return this.getObject('images', index) as GLTFImage;\n  }\n\n  getBufferView(index: number | object): GLTFBufferView {\n    return this.getObject('bufferViews', index) as GLTFBufferView;\n  }\n\n  getBuffer(index: number): GLTFBuffer {\n    return this.getObject('buffers', index) as GLTFBuffer;\n  }\n\n  getObject(array: string, index: number | object): object {\n    // check if already resolved\n    if (typeof index === 'object') {\n      return index;\n    }\n    const object = this.json[array] && this.json[array][index];\n    if (!object) {\n      throw new Error(`glTF file error: Could not find ${array}[${index}]`); // eslint-disable-line\n    }\n    return object;\n  }\n\n  /**\n   * Accepts buffer view index or buffer view object\n   * @returns a `Uint8Array`\n   */\n  getTypedArrayForBufferView(bufferView: number | object): Uint8Array {\n    bufferView = this.getBufferView(bufferView);\n    // @ts-ignore\n    const bufferIndex = bufferView.buffer;\n\n    // Get hold of the arrayBuffer\n    // const buffer = this.getBuffer(bufferIndex);\n    const binChunk = this.gltf.buffers[bufferIndex];\n    assert(binChunk);\n\n    // @ts-ignore\n    const byteOffset = (bufferView.byteOffset || 0) + binChunk.byteOffset;\n    // @ts-ignore\n    return new Uint8Array(binChunk.arrayBuffer, byteOffset, bufferView.byteLength);\n  }\n\n  /** Accepts accessor index or accessor object\n   * @returns a typed array with type that matches the types\n   */\n  getTypedArrayForAccessor(accessor: number | object): any {\n    // @ts-ignore\n    accessor = this.getAccessor(accessor);\n    // @ts-ignore\n    const bufferView = this.getBufferView(accessor.bufferView);\n    const buffer = this.getBuffer(bufferView.buffer);\n    // @ts-ignore\n    const arrayBuffer = buffer.data;\n\n    // Create a new typed array as a view into the combined buffer\n    const {ArrayType, length} = getAccessorArrayTypeAndLength(accessor, bufferView);\n    // @ts-ignore\n    const byteOffset = bufferView.byteOffset + accessor.byteOffset;\n    return new ArrayType(arrayBuffer, byteOffset, length);\n  }\n\n  /** accepts accessor index or accessor object\n   * returns a `Uint8Array`\n   */\n  getTypedArrayForImageData(image: number | object): Uint8Array {\n    // @ts-ignore\n    image = this.getAccessor(image);\n    // @ts-ignore\n    const bufferView = this.getBufferView(image.bufferView);\n    const buffer = this.getBuffer(bufferView.buffer);\n    // @ts-ignore\n    const arrayBuffer = buffer.data;\n\n    const byteOffset = bufferView.byteOffset || 0;\n    return new Uint8Array(arrayBuffer, byteOffset, bufferView.byteLength);\n  }\n\n  // MODIFERS\n\n  /**\n   * Add an extra application-defined key to the top-level data structure\n   */\n  addApplicationData(key: string, data: object): GLTFScenegraph {\n    this.json[key] = data;\n    return this;\n  }\n\n  /**\n   * `extras` - Standard GLTF field for storing application specific data\n   */\n  addExtraData(key: string, data: object): GLTFScenegraph {\n    this.json.extras = this.json.extras || {};\n    this.json.extras[key] = data;\n    return this;\n  }\n\n  addObjectExtension(object: object, extensionName: string, data: object): GLTFScenegraph {\n    // @ts-ignore\n    object.extensions = object.extensions || {};\n    // TODO - clobber or merge?\n    // @ts-ignore\n    object.extensions[extensionName] = data;\n    this.registerUsedExtension(extensionName);\n    return this;\n  }\n\n  setObjectExtension(object: object, extensionName: string, data: object): void {\n    // @ts-ignore\n    const extensions = object.extensions || {};\n    extensions[extensionName] = data;\n    // TODO - add to usedExtensions...\n  }\n\n  removeObjectExtension(object: object, extensionName: string): object {\n    // @ts-ignore\n    const extensions = object.extensions || {};\n    const extension = extensions[extensionName];\n    delete extensions[extensionName];\n    return extension;\n  }\n\n  /**\n   * Add to standard GLTF top level extension object, mark as used\n   */\n  addExtension(extensionName: string, extensionData: object = {}): object {\n    assert(extensionData);\n    this.json.extensions = this.json.extensions || {};\n    this.json.extensions[extensionName] = extensionData;\n    this.registerUsedExtension(extensionName);\n    return extensionData;\n  }\n\n  /**\n   * Standard GLTF top level extension object, mark as used and required\n   */\n  addRequiredExtension(extensionName, extensionData: object = {}): object {\n    assert(extensionData);\n    this.addExtension(extensionName, extensionData);\n    this.registerRequiredExtension(extensionName);\n    return extensionData;\n  }\n\n  /**\n   * Add extensionName to list of used extensions\n   */\n  registerUsedExtension(extensionName: string): void {\n    this.json.extensionsUsed = this.json.extensionsUsed || [];\n    if (!this.json.extensionsUsed.find((ext) => ext === extensionName)) {\n      this.json.extensionsUsed.push(extensionName);\n    }\n  }\n\n  /**\n   * Add extensionName to list of required extensions\n   */\n  registerRequiredExtension(extensionName: string): void {\n    this.registerUsedExtension(extensionName);\n    this.json.extensionsRequired = this.json.extensionsRequired || [];\n    if (!this.json.extensionsRequired.find((ext) => ext === extensionName)) {\n      this.json.extensionsRequired.push(extensionName);\n    }\n  }\n\n  /**\n   * Removes an extension from the top-level list\n   */\n  removeExtension(extensionName: string): void {\n    if (this.json.extensionsRequired) {\n      this._removeStringFromArray(this.json.extensionsRequired, extensionName);\n    }\n    if (this.json.extensionsUsed) {\n      this._removeStringFromArray(this.json.extensionsUsed, extensionName);\n    }\n    if (this.json.extensions) {\n      delete this.json.extensions[extensionName];\n    }\n  }\n\n  /**\n   *  Set default scene which is to be displayed at load time\n   */\n  setDefaultScene(sceneIndex: number): void {\n    this.json.scene = sceneIndex;\n  }\n\n  /**\n   * @todo: add more properties for scene initialization:\n   *   name`, `extensions`, `extras`\n   *   https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#reference-scene\n   */\n  addScene(scene: {nodeIndices: number[]}): number {\n    const {nodeIndices} = scene;\n    this.json.scenes = this.json.scenes || [];\n    this.json.scenes.push({nodes: nodeIndices});\n    return this.json.scenes.length - 1;\n  }\n\n  /**\n   * @todo: add more properties for node initialization:\n   *   `name`, `extensions`, `extras`, `camera`, `children`, `skin`, `rotation`, `scale`, `translation`, `weights`\n   *   https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#node\n   */\n  addNode(node: {meshIndex: number; matrix: number[]}): number {\n    const {meshIndex, matrix} = node;\n    this.json.nodes = this.json.nodes || [];\n    const nodeData = {mesh: meshIndex};\n    if (matrix) {\n      // @ts-ignore\n      nodeData.matrix = matrix;\n    }\n    this.json.nodes.push(nodeData);\n    return this.json.nodes.length - 1;\n  }\n\n  /** Adds a mesh to the json part */\n  addMesh(mesh: {attributes: object; indices: object; material: number; mode: number}): number {\n    const {attributes, indices, material, mode = 4} = mesh;\n    const accessors = this._addAttributes(attributes);\n\n    const glTFMesh = {\n      primitives: [\n        {\n          attributes: accessors,\n          mode\n        }\n      ]\n    };\n\n    if (indices) {\n      const indicesAccessor = this._addIndices(indices);\n      // @ts-ignore\n      glTFMesh.primitives[0].indices = indicesAccessor;\n    }\n\n    if (Number.isFinite(material)) {\n      // @ts-ignore\n      glTFMesh.primitives[0].material = material;\n    }\n\n    this.json.meshes = this.json.meshes || [];\n    this.json.meshes.push(glTFMesh);\n    return this.json.meshes.length - 1;\n  }\n\n  addPointCloud(attributes: object): number {\n    // @ts-ignore\n    const accessorIndices = this._addAttributes(attributes);\n\n    const glTFMesh = {\n      primitives: [\n        {\n          attributes: accessorIndices,\n          mode: 0 // GL.POINTS\n        }\n      ]\n    };\n\n    this.json.meshes = this.json.meshes || [];\n    this.json.meshes.push(glTFMesh);\n    return this.json.meshes.length - 1;\n  }\n\n  /**\n   * Adds a binary image. Builds glTF \"JSON metadata\" and saves buffer reference\n   * Buffer will be copied into BIN chunk during \"pack\"\n   * Currently encodes as glTF image\n   * @param imageData\n   * @param mimeType\n   */\n  addImage(imageData: any, mimeTypeOpt?: string): number {\n    // If image is referencing a bufferView instead of URI, mimeType must be defined:\n    //   https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#images\n    //   \"a reference to a bufferView; in that case mimeType must be defined.\"\n    const metadata = getBinaryImageMetadata(imageData);\n    const mimeType = mimeTypeOpt || metadata?.mimeType;\n\n    const bufferViewIndex = this.addBufferView(imageData);\n\n    const glTFImage = {\n      bufferView: bufferViewIndex,\n      mimeType\n    };\n\n    this.json.images = this.json.images || [];\n    this.json.images.push(glTFImage);\n    return this.json.images.length - 1;\n  }\n\n  /**\n   * Add one untyped source buffer, create a matching glTF `bufferView`, and return its index\n   * @param buffer\n   */\n  addBufferView(buffer: any): number {\n    const byteLength = buffer.byteLength;\n    assert(Number.isFinite(byteLength));\n\n    // Add this buffer to the list of buffers to be written to the body.\n    this.sourceBuffers = this.sourceBuffers || [];\n    this.sourceBuffers.push(buffer);\n\n    const glTFBufferView = {\n      buffer: 0,\n      // Write offset from the start of the binary body\n      byteOffset: this.byteLength,\n      byteLength\n    };\n\n    // We've now added the contents to the body, so update the total length\n    // Every sub-chunk needs to be 4-byte align ed\n    this.byteLength += padToNBytes(byteLength, 4);\n\n    // Add a bufferView indicating start and length of this binary sub-chunk\n    this.json.bufferViews = this.json.bufferViews || [];\n    this.json.bufferViews.push(glTFBufferView);\n    return this.json.bufferViews.length - 1;\n  }\n\n  /**\n   * Adds an accessor to a bufferView\n   * @param bufferViewIndex\n   * @param accessor\n   */\n  addAccessor(bufferViewIndex: number, accessor: object): number {\n    const glTFAccessor = {\n      bufferView: bufferViewIndex,\n      // @ts-ignore\n      type: getAccessorTypeFromSize(accessor.size),\n      // @ts-ignore\n      componentType: accessor.componentType,\n      // @ts-ignore\n      count: accessor.count,\n      // @ts-ignore\n      max: accessor.max,\n      // @ts-ignore\n      min: accessor.min\n    };\n\n    this.json.accessors = this.json.accessors || [];\n    this.json.accessors.push(glTFAccessor);\n    return this.json.accessors.length - 1;\n  }\n\n  /**\n   * Add a binary buffer. Builds glTF \"JSON metadata\" and saves buffer reference\n   * Buffer will be copied into BIN chunk during \"pack\"\n   * Currently encodes buffers as glTF accessors, but this could be optimized\n   * @param sourceBuffer\n   * @param accessor\n   */\n  addBinaryBuffer(sourceBuffer: any, accessor: object = {size: 3}): number {\n    const bufferViewIndex = this.addBufferView(sourceBuffer);\n    // @ts-ignore\n    let minMax = {min: accessor.min, max: accessor.max};\n    if (!minMax.min || !minMax.max) {\n      // @ts-ignore\n      minMax = this._getAccessorMinMax(sourceBuffer, accessor.size);\n    }\n\n    const accessorDefaults = {\n      // @ts-ignore\n      size: accessor.size,\n      componentType: getComponentTypeFromArray(sourceBuffer),\n      // @ts-ignore\n      count: Math.round(sourceBuffer.length / accessor.size),\n      min: minMax.min,\n      max: minMax.max\n    };\n\n    return this.addAccessor(bufferViewIndex, Object.assign(accessorDefaults, accessor));\n  }\n\n  /**\n   * Adds a texture to the json part\n   * @todo: add more properties for texture initialization\n   * `sampler`, `name`, `extensions`, `extras`\n   * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#texture\n   */\n  addTexture(texture: {imageIndex: number}): number {\n    const {imageIndex} = texture;\n    const glTFTexture = {\n      source: imageIndex\n    };\n\n    this.json.textures = this.json.textures || [];\n    this.json.textures.push(glTFTexture);\n    return this.json.textures.length - 1;\n  }\n\n  /** Adds a material to the json part */\n  addMaterial(pbrMaterialInfo: Object): number {\n    this.json.materials = this.json.materials || [];\n    this.json.materials.push(pbrMaterialInfo);\n    return this.json.materials.length - 1;\n  }\n\n  /** Pack the binary chunk */\n  createBinaryChunk(): void {\n    // Encoder expects this array undefined or empty\n    this.gltf.buffers = [];\n\n    // Allocate total array\n    const totalByteLength = this.byteLength;\n    const arrayBuffer = new ArrayBuffer(totalByteLength);\n    const targetArray = new Uint8Array(arrayBuffer);\n\n    // Copy each array into\n    let dstByteOffset = 0;\n    for (const sourceBuffer of this.sourceBuffers || []) {\n      dstByteOffset = copyToArray(sourceBuffer, targetArray, dstByteOffset);\n    }\n\n    // Update the glTF BIN CHUNK byte length\n    if (this.json?.buffers?.[0]) {\n      this.json.buffers[0].byteLength = totalByteLength;\n    } else {\n      this.json.buffers = [{byteLength: totalByteLength}];\n    }\n\n    // Save generated arrayBuffer\n    this.gltf.binary = arrayBuffer;\n\n    // Put arrayBuffer to sourceBuffers for possible additional writing data in the chunk\n    this.sourceBuffers = [arrayBuffer];\n  }\n\n  // PRIVATE\n\n  _removeStringFromArray(array, string) {\n    let found = true;\n    while (found) {\n      const index = array.indexOf(string);\n      if (index > -1) {\n        array.splice(index, 1);\n      } else {\n        found = false;\n      }\n    }\n  }\n\n  /**\n   * Add attributes to buffers and create `attributes` object which is part of `mesh`\n   */\n  _addAttributes(attributes = {}) {\n    const result = {};\n    for (const attributeKey in attributes) {\n      const attributeData = attributes[attributeKey];\n      const attrName = this._getGltfAttributeName(attributeKey);\n      const accessor = this.addBinaryBuffer(attributeData.value, attributeData);\n      result[attrName] = accessor;\n    }\n    return result;\n  }\n\n  /**\n   * Add indices to buffers\n   */\n  _addIndices(indices) {\n    return this.addBinaryBuffer(indices, {size: 1});\n  }\n\n  /**\n   * Deduce gltf specific attribue name from input attribute name\n   */\n  _getGltfAttributeName(attributeName) {\n    switch (attributeName.toLowerCase()) {\n      case 'position':\n      case 'positions':\n      case 'vertices':\n        return 'POSITION';\n      case 'normal':\n      case 'normals':\n        return 'NORMAL';\n      case 'color':\n      case 'colors':\n        return 'COLOR_0';\n      case 'texcoord':\n      case 'texcoords':\n        return 'TEXCOORD_0';\n      default:\n        return attributeName;\n    }\n  }\n\n  /**\n   * Calculate `min` and `max` arrays of accessor according to spec:\n   * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#reference-accessor\n   */\n  _getAccessorMinMax(buffer, size) {\n    const result = {min: null, max: null};\n    if (buffer.length < size) {\n      return result;\n    }\n    // @ts-ignore\n    result.min = [];\n    // @ts-ignore\n    result.max = [];\n    const initValues = buffer.subarray(0, size);\n    for (const value of initValues) {\n      // @ts-ignore\n      result.min.push(value);\n      // @ts-ignore\n      result.max.push(value);\n    }\n\n    for (let index = size; index < buffer.length; index += size) {\n      for (let componentIndex = 0; componentIndex < size; componentIndex++) {\n        // @ts-ignore\n        result.min[0 + componentIndex] = Math.min(\n          // @ts-ignore\n          result.min[0 + componentIndex],\n          buffer[index + componentIndex]\n        );\n        // @ts-ignore\n        result.max[0 + componentIndex] = Math.max(\n          // @ts-ignore\n          result.max[0 + componentIndex],\n          buffer[index + componentIndex]\n        );\n      }\n    }\n    return result;\n  }\n}\n","export default function getHiResTimestamp() {\n  let timestamp;\n\n  if (typeof window !== 'undefined' && window.performance) {\n    timestamp = window.performance.now();\n  } else if (typeof process !== 'undefined' && process.hrtime) {\n    const timeParts = process.hrtime();\n    timestamp = timeParts[0] * 1000 + timeParts[1] / 1e6;\n  } else {\n    timestamp = Date.now();\n  }\n\n  return timestamp;\n}\n//# sourceMappingURL=hi-res-timestamp.js.map","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","// Version constant cannot be imported, it needs to correspond to the build version of **this** module.\n// __VERSION__ is injected by babel-plugin-version-inline\n// @ts-ignore TS2304: Cannot find name '__VERSION__'.\nexport const VERSION = typeof __VERSION__ !== 'undefined' ? __VERSION__ : 'latest';\n","export function assert(condition, message) {\n  if (!condition) {\n    throw new Error(message);\n  }\n}\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","import type {ImageType, ImageTypeEnum, ImageDataType} from '../../types';\n\nexport function isImage(image: ImageType): boolean {\n  return Boolean(getImageTypeOrNull(image));\n}\n\nexport function deleteImage(image: ImageType): void {\n  switch (getImageType(image)) {\n    case 'imagebitmap':\n      (image as ImageBitmap).close();\n      break;\n    default:\n    // Nothing to do for images and image data objects\n  }\n}\n\nexport function getImageType(image: ImageType): ImageTypeEnum {\n  const format = getImageTypeOrNull(image);\n  if (!format) {\n    throw new Error('Not an image');\n  }\n  return format;\n}\n\nexport function getImageSize(image: ImageType): {width: number; height: number} {\n  return getImageData(image);\n}\n\nexport function getImageData(image: ImageType): ImageDataType | ImageData {\n  switch (getImageType(image)) {\n    case 'data':\n      return image as unknown as ImageData;\n\n    case 'image':\n    case 'imagebitmap':\n      // Extract the image data from the image via a canvas\n      const canvas = document.createElement('canvas');\n      // TODO - reuse the canvas?\n      const context = canvas.getContext('2d');\n      if (!context) {\n        throw new Error('getImageData');\n      }\n      // @ts-ignore\n      canvas.width = image.width;\n      // @ts-ignore\n      canvas.height = image.height;\n      // @ts-ignore\n      context.drawImage(image, 0, 0);\n      // @ts-ignore\n      return context.getImageData(0, 0, image.width, image.height);\n\n    default:\n      throw new Error('getImageData');\n  }\n}\n\n// PRIVATE\n\n// eslint-disable-next-line complexity\nfunction getImageTypeOrNull(image) {\n  if (typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {\n    return 'imagebitmap';\n  }\n  if (typeof Image !== 'undefined' && image instanceof Image) {\n    return 'image';\n  }\n  if (image && typeof image === 'object' && image.data && image.width && image.height) {\n    return 'data';\n  }\n  return null;\n}\n","// Version constant cannot be imported, it needs to correspond to the build version of **this** module.\n// __VERSION__ is injected by babel-plugin-version-inline\n\n// Change to `latest` on production branches\nconst DEFAULT_VERSION = 'beta';\ndeclare let __VERSION__;\nexport const VERSION = typeof __VERSION__ !== 'undefined' ? __VERSION__ : DEFAULT_VERSION;\nif (typeof __VERSION__ === 'undefined') {\n  // eslint-disable-next-line\n  console.error(\n    'loaders.gl: The __VERSION__ variable is not injected using babel plugin. Latest unstable workers would be fetched from the CDN.'\n  );\n}\n","// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n// Purpose: include this in your module to avoids adding dependencies on\n// micro modules like 'global' and 'is-browser';\n\n/* eslint-disable no-restricted-globals */\nconst globals = {\n  self: typeof self !== 'undefined' && self,\n  window: typeof window !== 'undefined' && window,\n  global: typeof global !== 'undefined' && global,\n  document: typeof document !== 'undefined' && document\n};\n\nconst self_ = globals.self || globals.window || globals.global;\nconst window_ = globals.window || globals.self || globals.global;\nconst global_ = globals.global || globals.self || globals.window;\nconst document_ = globals.document || {};\n\nexport {self_ as self, window_ as window, global_ as global, document_ as document};\n\nexport const isBrowser =\n  // @ts-ignore\n  typeof process !== 'object' || String(process) !== '[object process]' || process.browser;\n\nexport const isWorker = typeof importScripts === 'function';\n\n// Extract node major version\nconst matches =\n  typeof process !== 'undefined' && process.version && /v([0-9]*)/.exec(process.version);\nexport const nodeVersion = (matches && parseFloat(matches[1])) || 0;\n","// Attributions\n// * Based on binary-gltf-utils under MIT license: Copyright (c) 2016-17 Karl Cheng\n\n// TODO: make these functions work for Node.js buffers?\n// Quarantine references to Buffer to prevent bundler from adding big polyfills\n// import {bufferToArrayBuffer} from '../node/buffer-to-array-buffer';\n// TODO - this should be handled in @loaders.gl/polyfills\n\n/** MIME type, width and height extracted from binary compressed image data */\nexport type BinaryImageMetadata = {\n  mimeType: string;\n  width: number;\n  height: number;\n};\n\nconst BIG_ENDIAN = false;\nconst LITTLE_ENDIAN = true;\n\n/**\n * Extracts `{mimeType, width and height}` from a memory buffer containing a known image format\n * Currently supports `image/png`, `image/jpeg`, `image/bmp` and `image/gif`.\n * @param binaryData image file memory to parse\n * @returns metadata or null if memory is not a valid image file format layout.\n */\nexport function getBinaryImageMetadata(\n  binaryData: DataView | ArrayBuffer\n): BinaryImageMetadata | null {\n  const dataView = toDataView(binaryData);\n  return (\n    getPngMetadata(dataView) ||\n    getJpegMetadata(dataView) ||\n    getGifMetadata(dataView) ||\n    getBmpMetadata(dataView)\n  );\n}\n\n// PNG\n\nfunction getPngMetadata(binaryData) {\n  const dataView = toDataView(binaryData);\n  // Check file contains the first 4 bytes of the PNG signature.\n  const isPng = dataView.byteLength >= 24 && dataView.getUint32(0, BIG_ENDIAN) === 0x89504e47;\n  if (!isPng) {\n    return null;\n  }\n\n  // Extract size from a binary PNG file\n  return {\n    mimeType: 'image/png',\n    width: dataView.getUint32(16, BIG_ENDIAN),\n    height: dataView.getUint32(20, BIG_ENDIAN)\n  };\n}\n\n// GIF\n\n// Extract size from a binary GIF file\n// TODO: GIF is not this simple\nfunction getGifMetadata(binaryData) {\n  const dataView = toDataView(binaryData);\n  // Check first 4 bytes of the GIF signature (\"GIF8\").\n  const isGif = dataView.byteLength >= 10 && dataView.getUint32(0, BIG_ENDIAN) === 0x47494638;\n  if (!isGif) {\n    return null;\n  }\n\n  // GIF is little endian.\n  return {\n    mimeType: 'image/gif',\n    width: dataView.getUint16(6, LITTLE_ENDIAN),\n    height: dataView.getUint16(8, LITTLE_ENDIAN)\n  };\n}\n\n// BMP\n\n// TODO: BMP is not this simple\nexport function getBmpMetadata(binaryData) {\n  const dataView = toDataView(binaryData);\n  // Check magic number is valid (first 2 characters should be \"BM\").\n  // The mandatory bitmap file header is 14 bytes long.\n  const isBmp =\n    dataView.byteLength >= 14 &&\n    dataView.getUint16(0, BIG_ENDIAN) === 0x424d &&\n    dataView.getUint32(2, LITTLE_ENDIAN) === dataView.byteLength;\n\n  if (!isBmp) {\n    return null;\n  }\n\n  // BMP is little endian.\n  return {\n    mimeType: 'image/bmp',\n    width: dataView.getUint32(18, LITTLE_ENDIAN),\n    height: dataView.getUint32(22, LITTLE_ENDIAN)\n  };\n}\n\n// JPEG\n\n// Extract width and height from a binary JPEG file\nfunction getJpegMetadata(binaryData) {\n  const dataView = toDataView(binaryData);\n  // Check file contains the JPEG \"start of image\" (SOI) marker\n  // followed by another marker.\n  const isJpeg =\n    dataView.byteLength >= 3 &&\n    dataView.getUint16(0, BIG_ENDIAN) === 0xffd8 &&\n    dataView.getUint8(2) === 0xff;\n\n  if (!isJpeg) {\n    return null;\n  }\n\n  const {tableMarkers, sofMarkers} = getJpegMarkers();\n\n  // Exclude the two byte SOI marker.\n  let i = 2;\n  while (i + 9 < dataView.byteLength) {\n    const marker = dataView.getUint16(i, BIG_ENDIAN);\n\n    // The frame that contains the width and height of the JPEG image.\n    if (sofMarkers.has(marker)) {\n      return {\n        mimeType: 'image/jpeg',\n        height: dataView.getUint16(i + 5, BIG_ENDIAN), // Number of lines\n        width: dataView.getUint16(i + 7, BIG_ENDIAN) // Number of pixels per line\n      };\n    }\n\n    // Miscellaneous tables/data preceding the frame header.\n    if (!tableMarkers.has(marker)) {\n      return null;\n    }\n\n    // Length includes size of length parameter but not the two byte header.\n    i += 2;\n    i += dataView.getUint16(i, BIG_ENDIAN);\n  }\n\n  return null;\n}\n\nfunction getJpegMarkers() {\n  // Tables/misc header markers.\n  // DQT, DHT, DAC, DRI, COM, APP_n\n  const tableMarkers = new Set([0xffdb, 0xffc4, 0xffcc, 0xffdd, 0xfffe]);\n  for (let i = 0xffe0; i < 0xfff0; ++i) {\n    tableMarkers.add(i);\n  }\n\n  // SOF markers and DHP marker.\n  // These markers are after tables/misc data.\n  const sofMarkers = new Set([\n    0xffc0, 0xffc1, 0xffc2, 0xffc3, 0xffc5, 0xffc6, 0xffc7, 0xffc9, 0xffca, 0xffcb, 0xffcd, 0xffce,\n    0xffcf, 0xffde\n  ]);\n\n  return {tableMarkers, sofMarkers};\n}\n\n// TODO - move into image module?\nfunction toDataView(data) {\n  if (data instanceof DataView) {\n    return data;\n  }\n  if (ArrayBuffer.isView(data)) {\n    return new DataView(data.buffer);\n  }\n\n  // TODO: make these functions work for Node.js buffers?\n  // if (bufferToArrayBuffer) {\n  //   data = bufferToArrayBuffer(data);\n  // }\n\n  // Careful - Node Buffers will look like ArrayBuffers (keep after isBuffer)\n  if (data instanceof ArrayBuffer) {\n    return new DataView(data);\n  }\n  throw new Error('toDataView');\n}\n","import type {WorkerObject} from './types';\nimport {VERSION} from './lib/env-utils/version';\n\n// TYPES\nexport type {\n  WorkerObject,\n  WorkerOptions,\n  // Protocol\n  WorkerMessage,\n  WorkerMessageType,\n  WorkerMessageData,\n  WorkerMessagePayload\n} from './types';\n\n// GENERAL UTILS\nexport {assert} from './lib/env-utils/assert';\nexport {isBrowser, isWorker} from './lib/env-utils/globals';\n\n// WORKER UTILS - TYPES\nexport {default as WorkerJob} from './lib/worker-farm/worker-job';\nexport {default as WorkerThread} from './lib/worker-farm/worker-thread';\n\n// WORKER FARMS\nexport {default as WorkerFarm} from './lib/worker-farm/worker-farm';\nexport {default as WorkerPool} from './lib/worker-farm/worker-pool';\nexport {default as WorkerBody} from './lib/worker-farm/worker-body';\n\nexport {processOnWorker, canProcessOnWorker} from './lib/worker-api/process-on-worker';\nexport {createWorker} from './lib/worker-api/create-worker';\n\n// WORKER UTILS - EXPORTS\nexport {getWorkerURL} from './lib/worker-api/get-worker-url';\nexport {validateWorkerVersion} from './lib/worker-api/validate-worker-version';\nexport {getTransferList} from './lib/worker-utils/get-transfer-list';\n\n// LIBRARY UTILS\nexport {getLibraryUrl, loadLibrary} from './lib/library-utils/library-utils';\n\n// PARSER UTILS\nexport {default as AsyncQueue} from './lib/async-queue/async-queue';\n\n// PROCESS UTILS\nexport {default as ChildProcessProxy} from './lib/process-utils/child-process-proxy';\n\n// WORKER OBJECTS\n\n/** A null worker to test that worker processing is functional */\nexport const NullWorker: WorkerObject = {\n  id: 'null',\n  name: 'null',\n  module: 'worker-utils',\n  version: VERSION,\n  options: {\n    null: {}\n  }\n};\n","// Purpose: include this in your module to avoids adding dependencies on\n// micro modules like 'global' and 'is-browser';\n\n/* eslint-disable no-restricted-globals */\nconst globals = {\n  self: typeof self !== 'undefined' && self,\n  window: typeof window !== 'undefined' && window,\n  global: typeof global !== 'undefined' && global,\n  document: typeof document !== 'undefined' && document\n};\n\nconst self_: {[key: string]: any} = globals.self || globals.window || globals.global || {};\nconst window_: {[key: string]: any} = globals.window || globals.self || globals.global || {};\nconst global_: {[key: string]: any} = globals.global || globals.self || globals.window || {};\nconst document_: {[key: string]: any} = globals.document || {};\n\nexport {self_ as self, window_ as window, global_ as global, document_ as document};\n\n/** true if running in the browser, false if running in Node.js */\nexport const isBrowser: boolean =\n  // @ts-ignore process.browser\n  typeof process !== 'object' || String(process) !== '[object process]' || process.browser;\n\n/** true if running on a worker thread */\nexport const isWorker: boolean = typeof importScripts === 'function';\n\n/** true if running on a mobile device */\nexport const isMobile: boolean =\n  typeof window !== 'undefined' && typeof window.orientation !== 'undefined';\n\n// Extract node major version\nconst matches =\n  typeof process !== 'undefined' && process.version && /v([0-9]*)/.exec(process.version);\n\n/** Version of Node.js if running under Node, otherwise 0 */\nexport const nodeVersion: number = (matches && parseFloat(matches[1])) || 0;\n","import {assert} from '../env-utils/assert';\nimport {getLoadableWorkerURL} from '../worker-utils/get-loadable-worker-url';\nimport {getTransferList} from '../worker-utils/get-transfer-list';\n\nconst NOOP = () => {};\n\nexport type WorkerThreadProps = {\n  name: string;\n  source?: string;\n  url?: string;\n};\n\n/**\n * Represents one worker thread\n */\nexport default class WorkerThread {\n  readonly name: string;\n  readonly source: string | undefined;\n  readonly url: string | undefined;\n  terminated: boolean = false;\n  worker: Worker;\n  onMessage: (message: any) => void;\n  onError: (error: Error) => void;\n\n  private _loadableURL: string = '';\n\n  static isSupported(): boolean {\n    return typeof Worker !== 'undefined';\n  }\n\n  constructor(props: WorkerThreadProps) {\n    const {name, source, url} = props;\n    assert(source || url); // Either source or url must be defined\n    this.name = name;\n    this.source = source;\n    this.url = url;\n    this.onMessage = NOOP;\n    this.onError = (error) => console.log(error); // eslint-disable-line\n\n    this.worker = this._createBrowserWorker();\n  }\n\n  /**\n   * Terminate this worker thread\n   * @note Can free up significant memory\n   */\n  destroy(): void {\n    this.onMessage = NOOP;\n    this.onError = NOOP;\n    // @ts-ignore\n    this.worker.terminate();\n    this.terminated = true;\n  }\n\n  get isRunning() {\n    return Boolean(this.onMessage);\n  }\n\n  /**\n   * Send a message to this worker thread\n   * @param data any data structure, ideally consisting mostly of transferrable objects\n   * @param transferList If not supplied, calculated automatically by traversing data\n   */\n  postMessage(data: any, transferList?: any[]): void {\n    transferList = transferList || getTransferList(data);\n    // @ts-ignore\n    this.worker.postMessage(data, transferList);\n  }\n\n  // PRIVATE\n\n  /**\n   * Generate a standard Error from an ErrorEvent\n   * @param {ErrorEvent} event\n   */\n  _getErrorFromErrorEvent(event) {\n    // Note Error object does not have the expected fields if loading failed completely\n    // https://developer.mozilla.org/en-US/docs/Web/API/Worker#Event_handlers\n    // https://developer.mozilla.org/en-US/docs/Web/API/ErrorEvent\n    let message = 'Failed to load ';\n    message += `worker ${this.name}. `;\n    if (event.message) {\n      message += `${event.message} in `;\n    }\n    // const hasFilename = event.filename && !event.filename.startsWith('blob:');\n    // message += hasFilename ? event.filename : this.source.slice(0, 100);\n    if (event.lineno) {\n      message += `:${event.lineno}:${event.colno}`;\n    }\n    return new Error(message);\n  }\n\n  /**\n   * Creates a worker thread on the browser\n   */\n  _createBrowserWorker() {\n    this._loadableURL = getLoadableWorkerURL({source: this.source, url: this.url});\n    const worker = new Worker(this._loadableURL, {name: this.name});\n\n    worker.onmessage = (event) => {\n      if (!event.data) {\n        this.onError(new Error('No data received'));\n      } else {\n        this.onMessage(event.data);\n      }\n    };\n    // This callback represents an uncaught exception in the worker thread\n    worker.onerror = (error) => {\n      this.onError(this._getErrorFromErrorEvent(error));\n      this.terminated = true;\n    };\n    // TODO - not clear when this would be called, for now just log in case it happens\n    worker.onmessageerror = (event) => console.error(event); // eslint-disable-line\n\n    return worker;\n  }\n}\n","// NOTE - there is a copy of this function is both in core and loader-utils\n// core does not need all the utils in loader-utils, just this one.\n\n/**\n * Returns an array of Transferrable objects that can be used with postMessage\n * https://developer.mozilla.org/en-US/docs/Web/API/Worker/postMessage\n * @param object data to be sent via postMessage\n * @param recursive - not for application use\n * @param transfers - not for application use\n * @returns a transfer list that can be passed to postMessage\n */\nexport function getTransferList(\n  object: any,\n  recursive: boolean = true,\n  transfers?: Set<any>\n): Transferable[] {\n  // Make sure that items in the transfer list is unique\n  const transfersSet = transfers || new Set();\n\n  if (!object) {\n    // ignore\n  } else if (isTransferable(object)) {\n    transfersSet.add(object);\n  } else if (isTransferable(object.buffer)) {\n    // Typed array\n    transfersSet.add(object.buffer);\n  } else if (ArrayBuffer.isView(object)) {\n    // object is a TypeArray viewing into a SharedArrayBuffer (not transferable)\n    // Do not iterate through the content in this case\n  } else if (recursive && typeof object === 'object') {\n    for (const key in object) {\n      // Avoid perf hit - only go one level deep\n      getTransferList(object[key], recursive, transfersSet);\n    }\n  }\n\n  // If transfers is defined, is internal recursive call\n  // Otherwise it's called by the user\n  return transfers === undefined ? Array.from(transfersSet) : [];\n}\n\n// https://developer.mozilla.org/en-US/docs/Web/API/Transferable\nfunction isTransferable(object) {\n  if (!object) {\n    return false;\n  }\n  if (object instanceof ArrayBuffer) {\n    return true;\n  }\n  if (typeof MessagePort !== 'undefined' && object instanceof MessagePort) {\n    return true;\n  }\n  if (typeof ImageBitmap !== 'undefined' && object instanceof ImageBitmap) {\n    return true;\n  }\n  // @ts-ignore\n  if (typeof OffscreenCanvas !== 'undefined' && object instanceof OffscreenCanvas) {\n    return true;\n  }\n  return false;\n}\n","/*\nexport {\n  Schema,\n  Field,\n  DataType,\n  Null,\n  Bool,\n  Int,\n  Int8,\n  Int16,\n  Int32,\n  Int64,\n  Uint8,\n  Uint16,\n  Uint32,\n  Uint64,\n  Float,\n  Float16,\n  Float32,\n  Float64,\n  Binary,\n  Utf8,\n  Date,\n  DateDay,\n  DateMillisecond,\n  Time,\n  TimeSecond,\n  TimeMillisecond,\n  TimeMicrosecond,\n  TimeNanosecond,\n  Timestamp,\n  TimestampSecond,\n  TimestampMillisecond,\n  TimestampMicrosecond,\n  TimestampNanosecond,\n  Interval,\n  IntervalDayTime,\n  IntervalYearMonth,\n  FixedSizeList\n} from 'apache-arrow';\n*/\nexport {default as Schema} from './impl/schema';\nexport {default as Field} from './impl/field';\nexport {Type} from './impl/type';\nexport {\n  DataType,\n  Null,\n  Bool,\n  Int,\n  Int8,\n  Int16,\n  Int32,\n  Int64,\n  Uint8,\n  Uint16,\n  Uint32,\n  Uint64,\n  Float,\n  Float16,\n  Float32,\n  Float64,\n  Binary,\n  Utf8,\n  Date,\n  DateDay,\n  DateMillisecond,\n  Time,\n  TimeSecond,\n  TimeMillisecond,\n  // TimeMicrosecond,\n  // TimeNanosecond,\n  Timestamp,\n  TimestampSecond,\n  TimestampMillisecond,\n  TimestampMicrosecond,\n  TimestampNanosecond,\n  Interval,\n  IntervalDayTime,\n  IntervalYearMonth,\n  FixedSizeList\n} from './impl/type';\n","import {assert} from '../utils/assert';\n\nconst TYPES = ['SCALAR', 'VEC2', 'VEC3', 'VEC4'];\n\ntype TypedArrayConstructor =\n  | Int8ArrayConstructor\n  | Uint8ArrayConstructor\n  | Int16ArrayConstructor\n  | Uint16ArrayConstructor\n  | Int32ArrayConstructor\n  | Uint32ArrayConstructor\n  | Int32ArrayConstructor\n  | Uint32ArrayConstructor\n  | Float32ArrayConstructor\n  | Float64ArrayConstructor;\n\nconst ARRAY_CONSTRUCTOR_TO_WEBGL_CONSTANT: [TypedArrayConstructor, number][] = [\n  [Int8Array, 5120],\n  [Uint8Array, 5121],\n  [Int16Array, 5122],\n  [Uint16Array, 5123],\n  [Uint32Array, 5125],\n  [Float32Array, 5126],\n  [Float64Array, 5130]\n];\nconst ARRAY_TO_COMPONENT_TYPE = new Map<TypedArrayConstructor, number>(\n  ARRAY_CONSTRUCTOR_TO_WEBGL_CONSTANT\n);\n\nconst ATTRIBUTE_TYPE_TO_COMPONENTS = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n};\n\nconst ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE = {\n  5120: 1,\n  5121: 1,\n  5122: 2,\n  5123: 2,\n  5125: 4,\n  5126: 4\n};\n\nconst ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY = {\n  5120: Int8Array,\n  5121: Uint8Array,\n  5122: Int16Array,\n  5123: Uint16Array,\n  5125: Uint32Array,\n  5126: Float32Array\n};\n\nexport function getAccessorTypeFromSize(size) {\n  const type = TYPES[size - 1];\n  return type || TYPES[0];\n}\n\nexport function getComponentTypeFromArray(typedArray) {\n  const componentType = ARRAY_TO_COMPONENT_TYPE.get(typedArray.constructor);\n  if (!componentType) {\n    throw new Error('Illegal typed array');\n  }\n  return componentType;\n}\n\nexport function getAccessorArrayTypeAndLength(accessor, bufferView) {\n  const ArrayType = ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY[accessor.componentType];\n  const components = ATTRIBUTE_TYPE_TO_COMPONENTS[accessor.type];\n  const bytesPerComponent = ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE[accessor.componentType];\n  const length = accessor.count * components;\n  const byteLength = accessor.count * components * bytesPerComponent;\n  assert(byteLength >= 0 && byteLength <= bufferView.byteLength);\n  return {ArrayType, length, byteLength};\n}\n","// TYPES\nexport type {ImageDataType, ImageType, ImageTypeEnum} from './types';\n\n// LOADERS AND WRITERS\nexport {ImageLoader} from './image-loader';\nexport {ImageWriter} from './image-writer';\n\n// IMAGE CATEGORY API\n\n// Binary Image API\nexport {getBinaryImageMetadata} from './lib/category-api/binary-image-api';\n\n// Parsed Image API\nexport {isImageTypeSupported, getDefaultImageType} from './lib/category-api/image-type';\n\nexport {\n  isImage,\n  getImageType,\n  getImageSize,\n  getImageData\n} from './lib/category-api/parsed-image-api';\n\n// DEPRECATED - Remove in V3 (fix dependency in luma.gl)\nexport {loadImage} from './lib/texture-api/load-image';\n","// Version constant cannot be imported, it needs to correspond to the build version of **this** module.\n// __VERSION__ is injected by babel-plugin-version-inline\n// @ts-ignore TS2304: Cannot find name '__VERSION__'.\nexport const VERSION = typeof __VERSION__ !== 'undefined' ? __VERSION__ : 'latest';\n","import {assert} from '../utils/assert';\nimport {isImageTypeSupported, getDefaultImageType} from '../category-api/image-type';\nimport {getImageData} from '../category-api/parsed-image-api';\nimport parseToImage from './parse-to-image';\nimport parseToImageBitmap from './parse-to-image-bitmap';\nimport parseToNodeImage from './parse-to-node-image';\n\n// Parse to platform defined image type (data on node, ImageBitmap or HTMLImage on browser)\n// eslint-disable-next-line complexity\nexport default async function parseImage(arrayBuffer, options, context) {\n  options = options || {};\n  const imageOptions = options.image || {};\n\n  // The user can request a specific output format via `options.image.type`\n  const imageType = imageOptions.type || 'auto';\n\n  const {url} = context || {};\n\n  // Note: For options.image.type === `data`, we may still need to load as `image` or `imagebitmap`\n  const loadType = getLoadableImageType(imageType);\n\n  let image;\n  switch (loadType) {\n    case 'imagebitmap':\n      image = await parseToImageBitmap(arrayBuffer, options, url);\n      break;\n    case 'image':\n      image = await parseToImage(arrayBuffer, options, url);\n      break;\n    case 'data':\n      // Node.js loads imagedata directly\n      image = await parseToNodeImage(arrayBuffer, options);\n      break;\n    default:\n      assert(false);\n  }\n\n  // Browser: if options.image.type === 'data', we can now extract data from the loaded image\n  if (imageType === 'data') {\n    image = getImageData(image);\n  }\n\n  return image;\n}\n\n// Get a loadable image type from image type\nfunction getLoadableImageType(type) {\n  switch (type) {\n    case 'auto':\n    case 'data':\n      // Browser: For image data we need still need to load using an image format\n      // Node: the default image type is `data`.\n      return getDefaultImageType();\n    default:\n      // Throw an error if not supported\n      isImageTypeSupported(type);\n      return type;\n  }\n}\n","import type {ImageTypeEnum} from '../../types';\nimport {global, isBrowser} from '../utils/globals';\n\n// @ts-ignore TS2339: Property does not exist on type\nconst {_parseImageNode} = global;\n\nconst IMAGE_SUPPORTED = typeof Image !== 'undefined'; // NOTE: \"false\" positives if jsdom is installed\nconst IMAGE_BITMAP_SUPPORTED = typeof ImageBitmap !== 'undefined';\nconst NODE_IMAGE_SUPPORTED = Boolean(_parseImageNode);\nconst DATA_SUPPORTED = isBrowser ? true : NODE_IMAGE_SUPPORTED;\n\n/**\n * Checks if a loaders.gl image type is supported\n * @param type image type string\n */\nexport function isImageTypeSupported(type: string): boolean {\n  switch (type) {\n    case 'auto':\n      // Should only ever be false in Node.js, if polyfills have not been installed...\n      return IMAGE_BITMAP_SUPPORTED || IMAGE_SUPPORTED || DATA_SUPPORTED;\n\n    case 'imagebitmap':\n      return IMAGE_BITMAP_SUPPORTED;\n    case 'image':\n      return IMAGE_SUPPORTED;\n    case 'data':\n      return DATA_SUPPORTED;\n\n    default:\n      throw new Error(`@loaders.gl/images: image ${type} not supported in this environment`);\n  }\n}\n\n/**\n * Returns the \"most performant\" supported image type on this platform\n * @returns image type string\n */\nexport function getDefaultImageType(): ImageTypeEnum {\n  if (IMAGE_BITMAP_SUPPORTED) {\n    return 'imagebitmap';\n  }\n  if (IMAGE_SUPPORTED) {\n    return 'image';\n  }\n  if (DATA_SUPPORTED) {\n    return 'data';\n  }\n\n  // This should only happen in Node.js\n  throw new Error('Install \\'@loaders.gl/polyfills\\' to parse images under Node.js');\n}\n","import {getBlobOrSVGDataUrl} from './svg-utils';\n\n// Parses html image from array buffer\nexport default async function parseToImage(arrayBuffer, options, url) {\n  // Note: image parsing requires conversion to Blob (for createObjectURL).\n  // Potentially inefficient for not using `response.blob()` (and for File / Blob inputs)...\n  // But presumably not worth adding 'blob' flag to loader objects?\n\n  const blobOrDataUrl = getBlobOrSVGDataUrl(arrayBuffer, url);\n  const URL = self.URL || self.webkitURL;\n  const objectUrl = typeof blobOrDataUrl !== 'string' && URL.createObjectURL(blobOrDataUrl);\n  try {\n    return await loadToImage(objectUrl || blobOrDataUrl, options);\n  } finally {\n    if (objectUrl) {\n      URL.revokeObjectURL(objectUrl);\n    }\n  }\n}\n\nexport async function loadToImage(url, options) {\n  const image = new Image();\n  image.src = url;\n\n  // The `image.onload()` callback does not guarantee that the image has been decoded\n  // so a main thread \"freeze\" can be incurred when using the image for the first time.\n  // `Image.decode()` returns a promise that completes when image is decoded.\n\n  // https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/decode\n  // Note: When calling `img.decode()`, we do not need to wait for `img.onload()`\n  // Note: `HTMLImageElement.decode()` is not available in Edge and IE11\n  if (options.image && options.image.decode && image.decode) {\n    await image.decode();\n    return image;\n  }\n\n  // Create a promise that tracks onload/onerror callbacks\n  return await new Promise((resolve, reject) => {\n    try {\n      image.onload = () => resolve(image);\n      image.onerror = (err) => reject(new Error(`Could not load image ${url}: ${err}`));\n    } catch (error) {\n      reject(error);\n    }\n  });\n}\n","// SVG parsing has limitations, e.g:\n// https://bugs.chromium.org/p/chromium/issues/detail?id=606319\n\nconst SVG_DATA_URL_PATTERN = /^data:image\\/svg\\+xml/;\nconst SVG_URL_PATTERN = /\\.svg((\\?|#).*)?$/;\n\nexport function isSVG(url) {\n  return url && (SVG_DATA_URL_PATTERN.test(url) || SVG_URL_PATTERN.test(url));\n}\n\nexport function getBlobOrSVGDataUrl(arrayBuffer, url) {\n  if (isSVG(url)) {\n    // Prepare a properly tagged data URL, and load using normal mechanism\n    const textDecoder = new TextDecoder();\n    let xmlText = textDecoder.decode(arrayBuffer);\n    // TODO Escape in browser to support e.g. Chinese characters\n    try {\n      if (typeof unescape === 'function' && typeof encodeURIComponent === 'function') {\n        xmlText = unescape(encodeURIComponent(xmlText));\n      }\n    } catch (error) {\n      throw new Error((error as Error).message);\n    }\n    // base64 encoding is safer. utf-8 fails in some browsers\n    const src = `data:image/svg+xml;base64,${btoa(xmlText)}`;\n    return src;\n  }\n  return getBlob(arrayBuffer, url);\n}\n\nexport function getBlob(arrayBuffer, url) {\n  if (isSVG(url)) {\n    // https://bugs.chromium.org/p/chromium/issues/detail?id=606319\n    // return new Blob([new Uint8Array(arrayBuffer)], {type: 'image/svg+xml'});\n    throw new Error('SVG cannot be parsed directly to imagebitmap');\n  }\n  // TODO - how to determine mime type? Param? Sniff here?\n  return new Blob([new Uint8Array(arrayBuffer)]); // MIME type not needed?\n}\n","/**\n * Throws an `Error` with the optional `message` if `condition` is falsy\n * @note Replacement for the external assert method to reduce bundle size\n */\nexport function assert(condition: any, message?: string): void {\n  if (!condition) {\n    throw new Error(message || 'loader assertion failed.');\n  }\n}\n","import type {WorkerMessageType, WorkerMessagePayload} from '../../types';\nimport WorkerThread from './worker-thread';\nimport {assert} from '../env-utils/assert';\n\n/**\n * Represents one Job handled by a WorkerPool or WorkerFarm\n */\nexport default class WorkerJob {\n  readonly name: string;\n  readonly workerThread: WorkerThread;\n  isRunning: boolean;\n  /** Promise that resolves when Job is done */\n  readonly result: Promise<any>;\n\n  private _resolve: (value: any) => void;\n  private _reject: (reason?: any) => void;\n\n  constructor(jobName: string, workerThread: WorkerThread) {\n    this.name = jobName;\n    this.workerThread = workerThread;\n    this.isRunning = true;\n    this._resolve = () => {};\n    this._reject = () => {};\n    this.result = new Promise((resolve, reject) => {\n      this._resolve = resolve;\n      this._reject = reject;\n    });\n  }\n\n  /**\n   * Send a message to the job's worker thread\n   * @param data any data structure, ideally consisting mostly of transferrable objects\n   */\n  postMessage(type: WorkerMessageType, payload: WorkerMessagePayload): void {\n    this.workerThread.postMessage({\n      source: 'loaders.gl', // Lets worker ignore unrelated messages\n      type,\n      payload\n    });\n  }\n\n  /**\n   * Call to resolve the `result` Promise with the supplied value\n   */\n  done(value): void {\n    assert(this.isRunning);\n    this.isRunning = false;\n    this._resolve(value);\n  }\n\n  /**\n   * Call to reject the `result` Promise with the supplied error\n   */\n  error(error): void {\n    assert(this.isRunning);\n    this.isRunning = false;\n    this._reject(error);\n  }\n}\n","import WorkerPool from './worker-pool';\nimport WorkerThread from './worker-thread';\n\n/**\n * @param maxConcurrency {number} - max count of workers\n */\nexport type WorkerFarmProps = {\n  maxConcurrency?: number;\n  maxMobileConcurrency?: number;\n  reuseWorkers?: boolean;\n  onDebug?: () => void;\n};\n\nconst DEFAULT_PROPS: WorkerFarmProps = {\n  maxConcurrency: 3,\n  maxMobileConcurrency: 1,\n  onDebug: () => {},\n  reuseWorkers: true\n};\n\n/**\n * Process multiple jobs with a \"farm\" of different workers in worker pools.\n */\nexport default class WorkerFarm {\n  private props: WorkerFarmProps;\n  private workerPools = new Map<string, WorkerPool>();\n  // singleton\n  private static _workerFarm?: WorkerFarm;\n\n  /** Check if Workers are supported */\n  static isSupported(): boolean {\n    return WorkerThread.isSupported();\n  }\n\n  /** Get the singleton instance of the global worker farm */\n  static getWorkerFarm(props: WorkerFarmProps = {}): WorkerFarm {\n    WorkerFarm._workerFarm = WorkerFarm._workerFarm || new WorkerFarm({});\n    WorkerFarm._workerFarm.setProps(props);\n    return WorkerFarm._workerFarm;\n  }\n\n  /** get global instance with WorkerFarm.getWorkerFarm() */\n  private constructor(props: WorkerFarmProps) {\n    this.props = {...DEFAULT_PROPS};\n    this.setProps(props);\n    /** @type Map<string, WorkerPool>} */\n    this.workerPools = new Map();\n  }\n\n  /**\n   * Terminate all workers in the farm\n   * @note Can free up significant memory\n   */\n  destroy(): void {\n    for (const workerPool of this.workerPools.values()) {\n      workerPool.destroy();\n    }\n  }\n\n  /**\n   * Set props used when initializing worker pools\n   * @param props\n   */\n  setProps(props: WorkerFarmProps): void {\n    this.props = {...this.props, ...props};\n    // Update worker pool props\n    for (const workerPool of this.workerPools.values()) {\n      workerPool.setProps(this._getWorkerPoolProps());\n    }\n  }\n\n  /**\n   * Returns a worker pool for the specified worker\n   * @param options - only used first time for a specific worker name\n   * @param options.name - the name of the worker - used to identify worker pool\n   * @param options.url -\n   * @param options.source -\n   * @example\n   *   const job = WorkerFarm.getWorkerFarm().getWorkerPool({name, url}).startJob(...);\n   */\n  getWorkerPool(options: {name: string; source?: string; url?: string}): WorkerPool {\n    const {name, source, url} = options;\n    let workerPool = this.workerPools.get(name);\n    if (!workerPool) {\n      workerPool = new WorkerPool({\n        name,\n        source,\n        url\n      });\n      workerPool.setProps(this._getWorkerPoolProps());\n      this.workerPools.set(name, workerPool);\n    }\n    return workerPool;\n  }\n\n  _getWorkerPoolProps() {\n    return {\n      maxConcurrency: this.props.maxConcurrency,\n      maxMobileConcurrency: this.props.maxMobileConcurrency,\n      reuseWorkers: this.props.reuseWorkers,\n      onDebug: this.props.onDebug\n    };\n  }\n}\n","import type {WorkerMessageType, WorkerMessagePayload} from '../../types';\nimport {isMobile} from '../env-utils/globals';\nimport WorkerThread from './worker-thread';\nimport WorkerJob from './worker-job';\n\n/** WorkerPool onDebug Callback Parameters */\ntype OnDebugParameters = {\n  message: string;\n  worker: string;\n  name: string;\n  job: string;\n  backlog: number;\n  workerThread: WorkerThread;\n};\n\n/** WorkerPool Properties */\nexport type WorkerPoolProps = {\n  name?: string;\n  source?: string; // | Function;\n  url?: string;\n  maxConcurrency?: number;\n  maxMobileConcurrency?: number;\n  onDebug?: (options: OnDebugParameters) => any;\n  reuseWorkers?: boolean;\n};\n\n/** Private helper types */\ntype OnMessage = (job: WorkerJob, type: WorkerMessageType, payload: WorkerMessagePayload) => void;\ntype OnError = (job: WorkerJob, error: Error) => void;\n\ntype QueuedJob = {\n  name: string;\n  onMessage: OnMessage;\n  onError: OnError;\n  onStart: (value: any) => void; // Resolve job start promise\n};\n\n/**\n * Process multiple data messages with small pool of identical workers\n */\nexport default class WorkerPool {\n  name: string = 'unnamed';\n  source?: string; // | Function;\n  url?: string;\n  maxConcurrency: number = 1;\n  maxMobileConcurrency: number = 1;\n  onDebug: (options: OnDebugParameters) => any = () => {};\n  reuseWorkers: boolean = true;\n\n  private props: WorkerPoolProps = {};\n  private jobQueue: QueuedJob[] = [];\n  private idleQueue: WorkerThread[] = [];\n  private count = 0;\n  private isDestroyed = false;\n\n  /**\n   * @param processor - worker function\n   * @param maxConcurrency - max count of workers\n   */\n  constructor(props: WorkerPoolProps) {\n    this.source = props.source;\n    this.url = props.url;\n    this.setProps(props);\n  }\n\n  /**\n   * Terminates all workers in the pool\n   * @note Can free up significant memory\n   */\n  destroy(): void {\n    // Destroy idle workers, active Workers will be destroyed on completion\n    this.idleQueue.forEach((worker) => worker.destroy());\n    this.isDestroyed = true;\n  }\n\n  setProps(props: WorkerPoolProps) {\n    this.props = {...this.props, ...props};\n\n    if (props.name !== undefined) {\n      this.name = props.name;\n    }\n    if (props.maxConcurrency !== undefined) {\n      this.maxConcurrency = props.maxConcurrency;\n    }\n    if (props.maxMobileConcurrency !== undefined) {\n      this.maxMobileConcurrency = props.maxMobileConcurrency;\n    }\n    if (props.reuseWorkers !== undefined) {\n      this.reuseWorkers = props.reuseWorkers;\n    }\n    if (props.onDebug !== undefined) {\n      this.onDebug = props.onDebug;\n    }\n  }\n\n  async startJob(\n    name: string,\n    onMessage: OnMessage = (job, type, data) => job.done(data),\n    onError: OnError = (job, error) => job.error(error)\n  ): Promise<WorkerJob> {\n    // Promise resolves when thread starts working on this job\n    const startPromise = new Promise<WorkerJob>((onStart) => {\n      // Promise resolves when thread completes or fails working on this job\n      this.jobQueue.push({name, onMessage, onError, onStart});\n      return this;\n    });\n    this._startQueuedJob(); // eslint-disable-line @typescript-eslint/no-floating-promises\n    return await startPromise;\n  }\n\n  // PRIVATE\n\n  /**\n   * Starts first queued job if worker is available or can be created\n   * Called when job is started and whenever a worker returns to the idleQueue\n   */\n  async _startQueuedJob(): Promise<void> {\n    if (!this.jobQueue.length) {\n      return;\n    }\n\n    const workerThread = this._getAvailableWorker();\n    if (!workerThread) {\n      return;\n    }\n\n    // We have a worker, dequeue and start the job\n    const queuedJob = this.jobQueue.shift();\n    if (queuedJob) {\n      // Emit a debug event\n      // @ts-ignore\n      this.onDebug({\n        message: 'Starting job',\n        name: queuedJob.name,\n        workerThread,\n        backlog: this.jobQueue.length\n      });\n\n      // Create a worker job to let the app access thread and manage job completion\n      const job = new WorkerJob(queuedJob.name, workerThread);\n\n      // Set the worker thread's message handlers\n      workerThread.onMessage = (data) => queuedJob.onMessage(job, data.type, data.payload);\n      workerThread.onError = (error) => queuedJob.onError(job, error);\n\n      // Resolve the start promise so that the app can start sending messages to worker\n      queuedJob.onStart(job);\n\n      // Wait for the app to signal that the job is complete, then return worker to queue\n      try {\n        await job.result;\n      } finally {\n        this.returnWorkerToQueue(workerThread);\n      }\n    }\n  }\n\n  /**\n   * Returns a worker to the idle queue\n   * Destroys the worker if\n   *  - pool is destroyed\n   *  - if this pool doesn't reuse workers\n   *  - if maxConcurrency has been lowered\n   * @param worker\n   */\n  returnWorkerToQueue(worker: WorkerThread) {\n    const shouldDestroyWorker =\n      this.isDestroyed || !this.reuseWorkers || this.count > this._getMaxConcurrency();\n\n    if (shouldDestroyWorker) {\n      worker.destroy();\n      this.count--;\n    } else {\n      this.idleQueue.push(worker);\n    }\n\n    if (!this.isDestroyed) {\n      this._startQueuedJob(); // eslint-disable-line @typescript-eslint/no-floating-promises\n    }\n  }\n\n  /**\n   * Returns idle worker or creates new worker if maxConcurrency has not been reached\n   */\n  _getAvailableWorker(): WorkerThread | null {\n    // If a worker has completed and returned to the queue, it can be used\n    if (this.idleQueue.length > 0) {\n      return this.idleQueue.shift() || null;\n    }\n\n    // Create fresh worker if we haven't yet created the max amount of worker threads for this worker source\n    if (this.count < this._getMaxConcurrency()) {\n      this.count++;\n      const name = `${this.name.toLowerCase()} (#${this.count} of ${this.maxConcurrency})`;\n      return new WorkerThread({name, source: this.source, url: this.url});\n    }\n\n    // No worker available, have to wait\n    return null;\n  }\n\n  _getMaxConcurrency() {\n    return isMobile ? this.maxMobileConcurrency : this.maxConcurrency;\n  }\n}\n","import type {WorkerMessageData, WorkerMessageType, WorkerMessagePayload} from '../../types';\nimport {getTransferList} from '../worker-utils/get-transfer-list';\n\nconst onMessageWrapperMap = new Map();\n\n/**\n * Type safe wrapper for worker code\n */\nexport default class WorkerBody {\n  /*\n   * (type: WorkerMessageType, payload: WorkerMessagePayload) => any\n   */\n  static set onmessage(onMessage: (type: WorkerMessageType, payload: WorkerMessagePayload) => any) {\n    // eslint-disable-next-line no-restricted-globals\n    self.onmessage = (message) => {\n      if (!isKnownMessage(message)) {\n        return;\n      }\n\n      // Confusingly the message itself also has a 'type' field which is always set to 'message'\n      const {type, payload} = message.data;\n      onMessage(type, payload);\n    };\n  }\n\n  static addEventListener(\n    onMessage: (type: WorkerMessageType, payload: WorkerMessagePayload) => any\n  ) {\n    let onMessageWrapper = onMessageWrapperMap.get(onMessage);\n\n    if (!onMessageWrapper) {\n      onMessageWrapper = (message) => {\n        if (!isKnownMessage(message)) {\n          return;\n        }\n\n        // Confusingly the message itself also has a 'type' field which is always set to 'message'\n        const {type, payload} = message.data;\n        onMessage(type, payload);\n      };\n    }\n\n    // eslint-disable-next-line no-restricted-globals\n    self.addEventListener('message', onMessageWrapper);\n  }\n\n  static removeEventListener(\n    onMessage: (type: WorkerMessageType, payload: WorkerMessagePayload) => any\n  ) {\n    const onMessageWrapper = onMessageWrapperMap.get(onMessage);\n    onMessageWrapperMap.delete(onMessage);\n    // eslint-disable-next-line no-restricted-globals\n    self.removeEventListener('message', onMessageWrapper);\n  }\n\n  /**\n   * Send a message from a worker to creating thread (main thread)\n   * @param type\n   * @param payload\n   */\n  static postMessage(type: WorkerMessageType, payload: WorkerMessagePayload): void {\n    if (self) {\n      const data: WorkerMessageData = {source: 'loaders.gl', type, payload};\n      const transferList = getTransferList(payload);\n      // eslint-disable-next-line no-restricted-globals\n      // @ts-ignore\n      self.postMessage(data, transferList);\n    }\n  }\n}\n\n// Filter out noise messages sent to workers\nfunction isKnownMessage(message) {\n  const {type, data} = message;\n  return (\n    type === 'message' &&\n    data &&\n    typeof data.source === 'string' &&\n    data.source.startsWith('loaders.gl')\n  );\n}\n","import type {WorkerObject, WorkerOptions} from '../../types';\nimport {assert} from '../env-utils/assert';\nimport {VERSION as __VERSION__} from '../env-utils/version';\n\nconst NPM_TAG = 'latest';\nconst VERSION = typeof __VERSION__ !== 'undefined' ? __VERSION__ : NPM_TAG;\n\n/**\n * Gets worker object's name (for debugging in Chrome thread inspector window)\n */\nexport function getWorkerName(worker: WorkerObject): string {\n  const warning = worker.version !== VERSION ? ` (worker-utils@${VERSION})` : '';\n  return `${worker.name}@${worker.version}${warning}`;\n}\n\n/**\n * Generate a worker URL based on worker object and options\n * @returns A URL to one of the following:\n * - a published worker on unpkg CDN\n * - a local test worker\n * - a URL provided by the user in options\n */\nexport function getWorkerURL(worker: WorkerObject, options: WorkerOptions = {}): string {\n  const workerOptions = options[worker.id] || {};\n\n  const workerFile = `${worker.id}-worker.js`;\n\n  let url = workerOptions.workerUrl;\n\n  // HACK: Allow for non-nested workerUrl for the CompressionWorker.\n  // For the compression worker, workerOptions is currently not nested correctly. For most loaders,\n  // you'd have options within an object, i.e. `{mvt: {coordinates: ...}}` but the CompressionWorker\n  // puts options at the top level, not within a `compression` key (its `id`). For this reason, the\n  // above `workerOptions` will always be a string (i.e. `'gzip'`) for the CompressionWorker. To not\n  // break backwards compatibility, we allow the CompressionWorker to have options at the top level.\n  if (!url && worker.id === 'compression') {\n    url = options.workerUrl;\n  }\n\n  // If URL is test, generate local loaders.gl url\n  // @ts-ignore _workerType\n  if (options._workerType === 'test') {\n    url = `modules/${worker.module}/dist/${workerFile}`;\n  }\n\n  // If url override is not provided, generate a URL to published version on npm CDN unpkg.com\n  if (!url) {\n    // GENERATE\n    let version = worker.version;\n    // On master we need to load npm alpha releases published with the `beta` tag\n    if (version === 'latest') {\n      // throw new Error('latest worker version specified');\n      version = NPM_TAG;\n    }\n    const versionTag = version ? `@${version}` : '';\n    url = `https://unpkg.com/@loaders.gl/${worker.module}${versionTag}/dist/${workerFile}`;\n  }\n\n  assert(url);\n\n  // Allow user to override location\n  return url;\n}\n","// From https://github.com/rauschma/async-iter-demo/tree/master/src under MIT license\n// http://2ality.com/2016/10/asynchronous-iteration.html\n\n/**\n * Async Queue\n * - AsyncIterable: An async iterator can be\n * - Values can be pushed onto the queue\n * @example\n *   const asyncQueue = new AsyncQueue();\n *   setTimeout(() => asyncQueue.enqueue('tick'), 1000);\n *   setTimeout(() => asyncQueue.enqueue(new Error('done')), 10000);\n *   for await (const value of asyncQueue) {\n *     console.log(value); // tick\n *   }\n */\nexport default class AsyncQueue<T> {\n  private _values: any[];\n  private _settlers: any[];\n  private _closed: boolean;\n\n  constructor() {\n    this._values = []; // enqueues > dequeues\n    this._settlers = []; // dequeues > enqueues\n    this._closed = false;\n  }\n\n  /** Return an async iterator for this queue */\n  [Symbol.asyncIterator](): AsyncIterator<T> {\n    return this;\n  }\n\n  /** Push a new value - the async iterator will yield a promise resolved to this value */\n  push(value: T): void {\n    return this.enqueue(value);\n  }\n\n  /**\n   * Push a new value - the async iterator will yield a promise resolved to this value\n   * Add an error - the async iterator will yield a promise rejected with this value\n   */\n  enqueue(value: T | Error): void {\n    if (this._closed) {\n      throw new Error('Closed');\n    }\n\n    if (this._settlers.length > 0) {\n      if (this._values.length > 0) {\n        throw new Error('Illegal internal state');\n      }\n      const settler = this._settlers.shift();\n      if (value instanceof Error) {\n        settler.reject(value);\n      } else {\n        settler.resolve({value});\n      }\n    } else {\n      this._values.push(value);\n    }\n  }\n\n  /** Indicate that we not waiting for more values - The async iterator will be done */\n  close(): void {\n    while (this._settlers.length > 0) {\n      const settler = this._settlers.shift();\n      settler.resolve({done: true});\n    }\n    this._closed = true;\n  }\n\n  // ITERATOR IMPLEMENTATION\n\n  /** @returns a Promise for an IteratorResult */\n  next(): Promise<IteratorResult<T, any>> {\n    // If values in queue, yield the first value\n    if (this._values.length > 0) {\n      const value = this._values.shift();\n      if (value instanceof Error) {\n        return Promise.reject(value);\n      }\n      return Promise.resolve({done: false, value});\n    }\n\n    // If queue is closed, the iterator is done\n    if (this._closed) {\n      if (this._settlers.length > 0) {\n        throw new Error('Illegal internal state');\n      }\n      return Promise.resolve({done: true, value: undefined});\n    }\n\n    // Yield a promise that waits for new values to be enqueued\n    return new Promise((resolve, reject) => {\n      this._settlers.push({resolve, reject});\n    });\n  }\n}\n","export function getFirstCharacters(data, length = 5): string {\n  if (typeof data === 'string') {\n    return data.slice(0, length);\n  } else if (ArrayBuffer.isView(data)) {\n    // Typed Arrays can have offsets into underlying buffer\n    return getMagicString(data.buffer, data.byteOffset, length);\n  } else if (data instanceof ArrayBuffer) {\n    const byteOffset = 0;\n    return getMagicString(data, byteOffset, length);\n  }\n  return '';\n}\n\nexport function getMagicString(\n  arrayBuffer: ArrayBuffer,\n  byteOffset: number,\n  length: number\n): string {\n  if (arrayBuffer.byteLength <= byteOffset + length) {\n    return '';\n  }\n  const dataView = new DataView(arrayBuffer);\n  let magic = '';\n  for (let i = 0; i < length; i++) {\n    magic += String.fromCharCode(dataView.getUint8(byteOffset + i));\n  }\n  return magic;\n}\n","import {TypedArray} from '../../types';\nimport * as node from './buffer-utils';\n\n/**\n * Convert an object to an array buffer\n */\nexport function toArrayBuffer(data: any): ArrayBuffer {\n  // Note: Should be called first, Buffers can trigger other detections below\n  if (node.isBuffer(data)) {\n    // TODO - per docs we should just be able to call buffer.buffer, but there are issues\n    data = node.bufferToArrayBuffer(data);\n  }\n\n  if (data instanceof ArrayBuffer) {\n    return data;\n  }\n\n  // Careful - Node Buffers look like Uint8Arrays (keep after isBuffer)\n  if (ArrayBuffer.isView(data)) {\n    if (data.byteOffset === 0 && data.byteLength === data.buffer.byteLength) {\n      return data.buffer;\n    }\n    return data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength);\n  }\n\n  if (typeof data === 'string') {\n    const text = data;\n    const uint8Array = new TextEncoder().encode(text);\n    return uint8Array.buffer;\n  }\n\n  // HACK to support Blob polyfill\n  if (data && typeof data === 'object' && data._toArrayBuffer) {\n    return data._toArrayBuffer();\n  }\n\n  throw new Error('toArrayBuffer');\n}\n\n/**\n * compare two binary arrays for equality\n * @param {ArrayBuffer} a\n * @param {ArrayBuffer} b\n * @param {number} byteLength\n */\nexport function compareArrayBuffers(\n  arrayBuffer1: ArrayBuffer,\n  arrayBuffer2: ArrayBuffer,\n  byteLength?: number\n): boolean {\n  byteLength = byteLength || arrayBuffer1.byteLength;\n  if (arrayBuffer1.byteLength < byteLength || arrayBuffer2.byteLength < byteLength) {\n    return false;\n  }\n  const array1 = new Uint8Array(arrayBuffer1);\n  const array2 = new Uint8Array(arrayBuffer2);\n  for (let i = 0; i < array1.length; ++i) {\n    if (array1[i] !== array2[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Concatenate a sequence of ArrayBuffers\n * @return A concatenated ArrayBuffer\n */\nexport function concatenateArrayBuffers(...sources: (ArrayBuffer | Uint8Array)[]): ArrayBuffer {\n  // Make sure all inputs are wrapped in typed arrays\n  const sourceArrays = sources.map((source2) =>\n    source2 instanceof ArrayBuffer ? new Uint8Array(source2) : source2\n  );\n\n  // Get length of all inputs\n  const byteLength = sourceArrays.reduce((length, typedArray) => length + typedArray.byteLength, 0);\n\n  // Allocate array with space for all inputs\n  const result = new Uint8Array(byteLength);\n\n  // Copy the subarrays\n  let offset = 0;\n  for (const sourceArray of sourceArrays) {\n    result.set(sourceArray, offset);\n    offset += sourceArray.byteLength;\n  }\n\n  // We work with ArrayBuffers, discard the typed array wrapper\n  return result.buffer;\n}\n\n/**\n * Concatenate arbitrary count of typed arrays\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Typed_arrays\n * @param {...*} arrays - list of arrays. All arrays should be the same type\n * @return A concatenated TypedArray\n */\nexport function concatenateTypedArrays<T>(...typedArrays: T[]): T {\n  // @ts-ignore\n  const arrays = typedArrays as TypedArray[];\n  // @ts-ignore\n  const TypedArrayConstructor = (arrays && arrays.length > 1 && arrays[0].constructor) || null;\n  if (!TypedArrayConstructor) {\n    throw new Error(\n      '\"concatenateTypedArrays\" - incorrect quantity of arguments or arguments have incompatible data types'\n    );\n  }\n\n  const sumLength = arrays.reduce((acc, value) => acc + value.length, 0);\n  // @ts-ignore typescript does not like dynamic constructors\n  const result = new TypedArrayConstructor(sumLength);\n  let offset = 0;\n  for (const array of arrays) {\n    result.set(array, offset);\n    offset += array.length;\n  }\n  return result;\n}\n\n/**\n * Copy a view of an ArrayBuffer into new ArrayBuffer with byteOffset = 0\n * @param arrayBuffer\n * @param byteOffset\n * @param byteLength\n */\nexport function sliceArrayBuffer(\n  arrayBuffer: ArrayBuffer,\n  byteOffset: number,\n  byteLength?: number\n): ArrayBuffer {\n  const subArray =\n    byteLength !== undefined\n      ? new Uint8Array(arrayBuffer).subarray(byteOffset, byteOffset + byteLength)\n      : new Uint8Array(arrayBuffer).subarray(byteOffset);\n  const arrayCopy = new Uint8Array(subArray);\n  return arrayCopy.buffer;\n}\n","import * as node from '../node/buffer';\n\n/**\n * Check for Node.js `Buffer` (without triggering bundler to include Buffer polyfill on browser)\n */\nexport function isBuffer(value: any): boolean {\n  return value && typeof value === 'object' && value.isBuffer;\n}\n\n/**\n * Converts to Node.js `Buffer` (without triggering bundler to include Buffer polyfill on browser)\n * @todo better data type\n */\nexport function toBuffer(data: any): Buffer {\n  return node.toBuffer ? node.toBuffer(data) : data;\n}\n\n/**\n * Converts Node.js `Buffer` to `ArrayBuffer` (without triggering bundler to include Buffer polyfill on browser)\n * @todo better data type\n */\nexport function bufferToArrayBuffer(data: any): ArrayBuffer {\n  if (node.toArrayBuffer) {\n    // TODO - per docs we should just be able to call buffer.buffer, but there are issues\n    return node.toArrayBuffer(data);\n  }\n  return data;\n}\n","import {assert} from '../env-utils/assert';\n\n/**\n * Calculate new size of an arrayBuffer to be aligned to an n-byte boundary\n * This function increases `byteLength` by the minimum delta,\n * allowing the total length to be divided by `padding`\n * @param byteLength\n * @param padding\n */\nexport function padToNBytes(byteLength: number, padding: number): number {\n  assert(byteLength >= 0); // `Incorrect 'byteLength' value: ${byteLength}`\n  assert(padding > 0); // `Incorrect 'padding' value: ${padding}`\n  return (byteLength + (padding - 1)) & ~(padding - 1);\n}\n\n/**\n * Creates a new Uint8Array based on two different ArrayBuffers\n * @param targetBuffer The first buffer.\n * @param sourceBuffer The second buffer.\n * @return The new ArrayBuffer created out of the two.\n */\nexport function copyArrayBuffer(\n  targetBuffer: ArrayBuffer,\n  sourceBuffer: ArrayBuffer,\n  byteOffset: number,\n  byteLength: number = sourceBuffer.byteLength\n): ArrayBuffer {\n  const targetArray = new Uint8Array(targetBuffer, byteOffset, byteLength);\n  const sourceArray = new Uint8Array(sourceBuffer);\n  targetArray.set(sourceArray);\n  return targetBuffer;\n}\n\n/**\n * Copy from source to target at the targetOffset\n *\n * @param source - The data to copy\n * @param target - The destination to copy data into\n * @param targetOffset - The start offset into target to place the copied data\n * @returns the new offset taking into account proper padding\n */\nexport function copyToArray(source: ArrayBuffer | any, target: any, targetOffset: number): number {\n  let sourceArray;\n\n  if (source instanceof ArrayBuffer) {\n    sourceArray = new Uint8Array(source);\n  } else {\n    // Pack buffer onto the big target array\n    //\n    // 'source.data.buffer' could be a view onto a larger buffer.\n    // We MUST use this constructor to ensure the byteOffset and byteLength is\n    // set to correct values from 'source.data' and not the underlying\n    // buffer for target.set() to work properly.\n    const srcByteOffset = source.byteOffset;\n    const srcByteLength = source.byteLength;\n    // In gltf parser it is set as \"arrayBuffer\" instead of \"buffer\"\n    // https://github.com/visgl/loaders.gl/blob/1e3a82a0a65d7b6a67b1e60633453e5edda2960a/modules/gltf/src/lib/parse-gltf.js#L85\n    sourceArray = new Uint8Array(source.buffer || source.arrayBuffer, srcByteOffset, srcByteLength);\n  }\n\n  // Pack buffer onto the big target array\n  target.set(sourceArray, targetOffset);\n\n  return targetOffset + padToNBytes(sourceArray.byteLength, 4);\n}\n","// Version constant cannot be imported, it needs to correspond to the build version of **this** module.\n// __VERSION__ is injected by babel-plugin-version-inline\n// @ts-ignore TS2304: Cannot find name '__VERSION__'.\nexport const VERSION = typeof __VERSION__ !== 'undefined' ? __VERSION__ : 'latest';\n","// COMMON CATEGORY\nexport type {TypedArray, NumberArray, AnyArray} from './types';\n\nexport type {Batch} from './category/common';\n\n// TABLE CATEGORY TYPES\n\nexport type {\n  Table,\n  ArrayRowTable,\n  ObjectRowTable,\n  ColumnarTable,\n  ArrowTable\n} from './category/table';\nexport type {\n  TableBatch,\n  RowArrayTableBatch,\n  RowObjectTableBatch,\n  ColumnarTableBatch,\n  ArrowTableBatch\n} from './category/table';\n\n// TABLE CATEGORY UTILS\nexport {default as TableBatchBuilder} from './lib/table/table-batch-builder';\nexport type {TableBatchAggregator} from './lib/table/table-batch-aggregator';\nexport {default as RowTableBatchAggregator} from './lib/table/row-table-batch-aggregator';\nexport {default as ColumnarTableBatchAggregator} from './lib/table/columnar-table-batch-aggregator';\n\nexport {convertToObjectRow, convertToArrayRow} from './lib/utils/row-utils';\n\n// MESH CATEGORY\nexport type {MeshTable, MeshArrowTable, Mesh, MeshAttribute} from './category/mesh';\n\n// MESH CATEGORY UTILS\nexport type {Attributes as _Attributes} from './category/mesh/mesh-utils';\nexport {getMeshSize, getMeshBoundingBox} from './category/mesh/mesh-utils';\n\n// TYPES\n// GIS CATEGORY - GEOJSON\nexport type {GeoJSON, Feature, Geometry, Position, GeoJsonProperties} from './category/gis';\nexport type {\n  Point,\n  MultiPoint,\n  LineString,\n  MultiLineString,\n  Polygon,\n  MultiPolygon\n} from './category/gis';\n\n// GIS CATEGORY - BINARY\nexport type {\n  BinaryGeometryType,\n  BinaryGeometry,\n  BinaryPointGeometry,\n  BinaryLineGeometry,\n  BinaryPolygonGeometry,\n  BinaryAttribute\n} from './category/gis';\nexport type {\n  BinaryFeatures,\n  BinaryPointFeatures,\n  BinaryLineFeatures,\n  BinaryPolygonFeatures\n} from './category/gis';\n\n// SCHEMA\nexport {\n  Schema,\n  Field,\n  DataType,\n  Null,\n  Binary,\n  Bool,\n  Int,\n  Int8,\n  Int16,\n  Int32,\n  Int64,\n  Uint8,\n  Uint16,\n  Uint32,\n  Uint64,\n  Float,\n  Float16,\n  Float32,\n  Float64,\n  Utf8,\n  Date,\n  DateDay,\n  DateMillisecond,\n  Time,\n  TimeMillisecond,\n  TimeSecond,\n  Timestamp,\n  TimestampSecond,\n  TimestampMillisecond,\n  TimestampMicrosecond,\n  TimestampNanosecond,\n  Interval,\n  IntervalDayTime,\n  IntervalYearMonth,\n  FixedSizeList\n} from './lib/schema';\n\n// SCHEMA UTILS\nexport {deduceTableSchema} from './lib/schema-utils/deduce-table-schema';\nexport {getTypeInfo} from './lib/schema-utils/get-type-info';\nexport {getArrowTypeFromTypedArray} from './lib/schema-utils/type-utils';\n\n// EXPERIMENTAL APIs\nexport {default as AsyncQueue} from './lib/utils/async-queue';\n","import type {Schema} from '../schema';\nimport type {TableBatch} from '../../category/table';\n// import type {ArrayRowTableBatch, ObjectRowTableBatch} from '../../category/table';\nimport {convertToArrayRow, convertToObjectRow} from '../utils/row-utils';\nimport {TableBatchAggregator, TableBatchOptions} from './table-batch-aggregator';\n\nconst DEFAULT_ROW_COUNT = 100;\n\nexport default class RowTableBatchAggregator implements TableBatchAggregator {\n  schema: Schema;\n  options: TableBatchOptions;\n\n  length: number = 0;\n  objectRows: {[columnName: string]: any} | null = null;\n  arrayRows: any[] | null = null;\n  cursor: number = 0;\n  private _headers: string[] = [];\n\n  constructor(schema: Schema, options: TableBatchOptions) {\n    this.options = options;\n    this.schema = schema;\n\n    // schema is an array if there're no headers\n    // object if there are headers\n    if (!Array.isArray(schema)) {\n      this._headers = [];\n      for (const key in schema) {\n        this._headers[schema[key].index] = schema[key].name;\n      }\n    }\n  }\n\n  rowCount(): number {\n    return this.length;\n  }\n\n  addArrayRow(row: any[], cursor?: number): void {\n    if (Number.isFinite(cursor)) {\n      this.cursor = cursor as number;\n    }\n\n    // eslint-disable-next-line default-case\n    switch (this.options.shape) {\n      case 'object-row-table':\n        const rowObject = convertToObjectRow(row, this._headers);\n        this.addObjectRow(rowObject, cursor);\n        break;\n      case 'array-row-table':\n        this.arrayRows = this.arrayRows || new Array(DEFAULT_ROW_COUNT);\n        this.arrayRows[this.length] = row;\n        this.length++;\n        break;\n    }\n  }\n\n  addObjectRow(row: {[columnName: string]: any}, cursor?: number): void {\n    if (Number.isFinite(cursor)) {\n      this.cursor = cursor as number;\n    }\n\n    // eslint-disable-next-line default-case\n    switch (this.options.shape) {\n      case 'array-row-table':\n        const rowArray = convertToArrayRow(row, this._headers);\n        this.addArrayRow(rowArray, cursor);\n        break;\n      case 'object-row-table':\n        this.objectRows = this.objectRows || new Array(DEFAULT_ROW_COUNT);\n        this.objectRows[this.length] = row;\n        this.length++;\n        break;\n    }\n  }\n\n  getBatch(): TableBatch | null {\n    let rows = this.arrayRows || this.objectRows;\n    if (!rows) {\n      return null;\n    }\n\n    rows = rows.slice(0, this.length);\n    this.arrayRows = null;\n    this.objectRows = null;\n\n    return {\n      shape: this.options.shape,\n      batchType: 'data',\n      data: rows,\n      length: this.length,\n      schema: this.schema,\n      cursor: this.cursor\n    };\n  }\n}\n","/** Convert an object row to an array row */\nexport function convertToObjectRow(\n  arrayRow: any[],\n  headers: string[]\n): {[columnName: string]: any} {\n  if (!arrayRow) {\n    throw new Error('null row');\n  }\n  if (!headers) {\n    throw new Error('no headers');\n  }\n  const objectRow = {};\n  for (let i = 0; i < headers.length; i++) {\n    objectRow[headers[i]] = arrayRow[i];\n  }\n  return objectRow;\n}\n\n/** Convert an object row to an array row */\nexport function convertToArrayRow(\n  objectRow: {[columnName: string]: any},\n  headers: string[]\n): any[] {\n  if (!objectRow) {\n    throw new Error('null row');\n  }\n  if (!headers) {\n    throw new Error('no headers');\n  }\n  const arrayRow = new Array(headers.length);\n  for (let i = 0; i < headers.length; i++) {\n    arrayRow[i] = objectRow[headers[i]];\n  }\n  return arrayRow;\n}\n","import type {Schema} from '../schema';\nimport type {ColumnarTableBatch, ArrowTableBatch} from '../../category/table';\nimport {TableBatchAggregator} from './table-batch-aggregator';\n\ntype ColumnarTableBatchOptions = {};\n\nconst DEFAULT_ROW_COUNT = 100;\n\nexport default class ColumnarTableBatchAggregator implements TableBatchAggregator {\n  schema: Schema;\n  length: number = 0;\n  allocated: number = 0;\n  columns: {[columnName: string]: any[]} = {};\n\n  constructor(schema: Schema, options: ColumnarTableBatchOptions) {\n    this.schema = schema;\n    this._reallocateColumns();\n  }\n\n  rowCount(): number {\n    return this.length;\n  }\n\n  addArrayRow(row: any[]) {\n    // If user keeps pushing rows beyond batch size, reallocate\n    this._reallocateColumns();\n    let i = 0;\n    // TODO what if no csv header, columns not populated?\n    for (const fieldName in this.columns) {\n      this.columns[fieldName][this.length] = row[i++];\n    }\n    this.length++;\n  }\n\n  addObjectRow(row: {[columnName: string]: any}): void {\n    // If user keeps pushing rows beyond batch size, reallocate\n    this._reallocateColumns();\n    for (const fieldName in row) {\n      this.columns[fieldName][this.length] = row[fieldName];\n    }\n    this.length++;\n  }\n\n  getBatch(): ColumnarTableBatch | ArrowTableBatch | null {\n    this._pruneColumns();\n    const columns = Array.isArray(this.schema) ? this.columns : {};\n\n    // schema is an array if there're no headers\n    // object if there are headers\n    // columns should match schema format\n    if (!Array.isArray(this.schema)) {\n      for (const fieldName in this.schema) {\n        const field = this.schema[fieldName];\n        columns[field.name] = this.columns[field.index];\n      }\n    }\n\n    this.columns = {};\n\n    const batch: ColumnarTableBatch = {\n      shape: 'columnar-table',\n      batchType: 'data',\n      data: columns,\n      schema: this.schema,\n      length: this.length\n    };\n\n    return batch;\n  }\n\n  // HELPERS\n\n  _reallocateColumns() {\n    if (this.length < this.allocated) {\n      return;\n    }\n\n    // @ts-ignore TODO\n    this.allocated = this.allocated > 0 ? (this.allocated *= 2) : DEFAULT_ROW_COUNT;\n    this.columns = {};\n\n    for (const fieldName in this.schema) {\n      const field = this.schema[fieldName];\n      const ArrayType = field.type || Float32Array;\n      const oldColumn = this.columns[field.index];\n\n      if (oldColumn && ArrayBuffer.isView(oldColumn)) {\n        // Copy the old data to the new array\n        const typedArray = new ArrayType(this.allocated);\n        typedArray.set(oldColumn);\n        this.columns[field.index] = typedArray;\n      } else if (oldColumn) {\n        // Plain array\n        oldColumn.length = this.allocated;\n        this.columns[field.index] = oldColumn;\n      } else {\n        // Create new\n        this.columns[field.index] = new ArrayType(this.allocated);\n      }\n    }\n  }\n\n  _pruneColumns() {\n    for (const [columnName, column] of Object.entries(this.columns)) {\n      this.columns[columnName] = column.slice(0, this.length);\n    }\n  }\n}\n","// Dynamic DRACO module loading inspired by THREE.DRACOLoader\n// https://github.com/mrdoob/three.js/blob/398c4f39ebdb8b23eefd4a7a5ec49ec0c96c7462/examples/jsm/loaders/DRACOLoader.js\n// by Don McCurdy / https://www.donmccurdy.com / MIT license\n\nimport {loadLibrary} from '@loaders.gl/worker-utils';\n\nconst DRACO_VERSION = '1.4.1';\nconst DRACO_JS_DECODER_URL = `https://www.gstatic.com/draco/versioned/decoders/${DRACO_VERSION}/draco_decoder.js`;\nconst DRACO_WASM_WRAPPER_URL = `https://www.gstatic.com/draco/versioned/decoders/${DRACO_VERSION}/draco_wasm_wrapper.js`;\nconst DRACO_WASM_DECODER_URL = `https://www.gstatic.com/draco/versioned/decoders/${DRACO_VERSION}/draco_decoder.wasm`;\n\nconst DRACO_ENCODER_URL = `https://raw.githubusercontent.com/google/draco/${DRACO_VERSION}/javascript/draco_encoder.js`;\n\nlet loadDecoderPromise;\nlet loadEncoderPromise;\n\nexport async function loadDracoDecoderModule(options) {\n  const modules = options.modules || {};\n\n  // Check if a bundled draco3d library has been supplied by application\n  if (modules.draco3d) {\n    loadDecoderPromise =\n      loadDecoderPromise ||\n      modules.draco3d.createDecoderModule({}).then((draco) => {\n        return {draco};\n      });\n  } else {\n    // If not, dynamically load the WASM script from our CDN\n    loadDecoderPromise = loadDecoderPromise || loadDracoDecoder(options);\n  }\n  return await loadDecoderPromise;\n}\n\nexport async function loadDracoEncoderModule(options) {\n  const modules = options.modules || {};\n\n  // Check if a bundled draco3d library has been supplied by application\n  if (modules.draco3d) {\n    loadEncoderPromise =\n      loadEncoderPromise ||\n      modules.draco3d.createEncoderModule({}).then((draco) => {\n        return {draco};\n      });\n  } else {\n    // If not, dynamically load the WASM script from our CDN\n    loadEncoderPromise = loadEncoderPromise || loadDracoEncoder(options);\n  }\n  return await loadEncoderPromise;\n}\n\n// DRACO DECODER LOADING\n\nasync function loadDracoDecoder(options) {\n  let DracoDecoderModule;\n  let wasmBinary;\n  switch (options.draco && options.draco.decoderType) {\n    case 'js':\n      DracoDecoderModule = await loadLibrary(DRACO_JS_DECODER_URL, 'draco', options);\n      break;\n\n    case 'wasm':\n    default:\n      [DracoDecoderModule, wasmBinary] = await Promise.all([\n        await loadLibrary(DRACO_WASM_WRAPPER_URL, 'draco', options),\n        await loadLibrary(DRACO_WASM_DECODER_URL, 'draco', options)\n      ]);\n  }\n  // Depends on how import happened...\n  // @ts-ignore\n  DracoDecoderModule = DracoDecoderModule || globalThis.DracoDecoderModule;\n  return await initializeDracoDecoder(DracoDecoderModule, wasmBinary);\n}\n\nfunction initializeDracoDecoder(DracoDecoderModule, wasmBinary) {\n  const options: {wasmBinary?: any} = {};\n  if (wasmBinary) {\n    options.wasmBinary = wasmBinary;\n  }\n\n  return new Promise((resolve) => {\n    DracoDecoderModule({\n      ...options,\n      onModuleLoaded: (draco) => resolve({draco}) // Module is Promise-like. Wrap in object to avoid loop.\n    });\n  });\n}\n\n// ENCODER\n\nasync function loadDracoEncoder(options) {\n  let DracoEncoderModule = await loadLibrary(DRACO_ENCODER_URL, 'draco', options);\n  // @ts-ignore\n  DracoEncoderModule = DracoEncoderModule || globalThis.DracoEncoderModule;\n\n  return new Promise((resolve) => {\n    DracoEncoderModule({\n      onModuleLoaded: (draco) => resolve({draco}) // Module is Promise-like. Wrap in object to avoid loop.\n    });\n  });\n}\n","import {assert} from '../utils/assert';\nimport {getAccessorArrayTypeAndLength} from '../gltf-utils/gltf-utils';\n\n// This is a post processor for loaded glTF files\n// The goal is to make the loaded data easier to use in WebGL applications\n//\n// Functions:\n// * Resolve indexed arrays structure of glTF into a linked tree.\n// * Translate stringified enum keys and values into WebGL constants.\n// * Load images (optional)\n\n// ENUM LOOKUP\n\nconst COMPONENTS = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n};\n\nconst BYTES = {\n  5120: 1, // BYTE\n  5121: 1, // UNSIGNED_BYTE\n  5122: 2, // SHORT\n  5123: 2, // UNSIGNED_SHORT\n  5125: 4, // UNSIGNED_INT\n  5126: 4 // FLOAT\n};\n\nconst GL_SAMPLER = {\n  // Sampler parameters\n  TEXTURE_MAG_FILTER: 0x2800,\n  TEXTURE_MIN_FILTER: 0x2801,\n  TEXTURE_WRAP_S: 0x2802,\n  TEXTURE_WRAP_T: 0x2803,\n\n  // Sampler default values\n  REPEAT: 0x2901,\n  LINEAR: 0x2601,\n  NEAREST_MIPMAP_LINEAR: 0x2702\n};\n\nconst SAMPLER_PARAMETER_GLTF_TO_GL = {\n  magFilter: GL_SAMPLER.TEXTURE_MAG_FILTER,\n  minFilter: GL_SAMPLER.TEXTURE_MIN_FILTER,\n  wrapS: GL_SAMPLER.TEXTURE_WRAP_S,\n  wrapT: GL_SAMPLER.TEXTURE_WRAP_T\n};\n\n// When undefined, a sampler with repeat wrapping and auto filtering should be used.\n// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#texture\nconst DEFAULT_SAMPLER = {\n  [GL_SAMPLER.TEXTURE_MAG_FILTER]: GL_SAMPLER.LINEAR,\n  [GL_SAMPLER.TEXTURE_MIN_FILTER]: GL_SAMPLER.NEAREST_MIPMAP_LINEAR,\n  [GL_SAMPLER.TEXTURE_WRAP_S]: GL_SAMPLER.REPEAT,\n  [GL_SAMPLER.TEXTURE_WRAP_]: GL_SAMPLER.REPEAT\n};\n\nfunction getBytesFromComponentType(componentType) {\n  return BYTES[componentType];\n}\n\nfunction getSizeFromAccessorType(type) {\n  return COMPONENTS[type];\n}\n\nclass GLTFPostProcessor {\n  postProcess(gltf, options = {}) {\n    const {json, buffers = [], images = [], baseUri = ''} = gltf;\n    assert(json);\n\n    this.baseUri = baseUri;\n    this.json = json;\n    this.buffers = buffers;\n    this.images = images;\n\n    this._resolveTree(this.json, options);\n\n    return this.json;\n  }\n\n  // Convert indexed glTF structure into tree structure\n  // cross-link index resolution, enum lookup, convenience calculations\n  // eslint-disable-next-line complexity\n  _resolveTree(json, options = {}) {\n    if (json.bufferViews) {\n      json.bufferViews = json.bufferViews.map((bufView, i) => this._resolveBufferView(bufView, i));\n    }\n    if (json.images) {\n      json.images = json.images.map((image, i) => this._resolveImage(image, i));\n    }\n    if (json.samplers) {\n      json.samplers = json.samplers.map((sampler, i) => this._resolveSampler(sampler, i));\n    }\n    if (json.textures) {\n      json.textures = json.textures.map((texture, i) => this._resolveTexture(texture, i));\n    }\n    if (json.accessors) {\n      json.accessors = json.accessors.map((accessor, i) => this._resolveAccessor(accessor, i));\n    }\n    if (json.materials) {\n      json.materials = json.materials.map((material, i) => this._resolveMaterial(material, i));\n    }\n    if (json.meshes) {\n      json.meshes = json.meshes.map((mesh, i) => this._resolveMesh(mesh, i));\n    }\n    if (json.nodes) {\n      json.nodes = json.nodes.map((node, i) => this._resolveNode(node, i));\n    }\n    if (json.skins) {\n      json.skins = json.skins.map((skin, i) => this._resolveSkin(skin, i));\n    }\n    if (json.scenes) {\n      json.scenes = json.scenes.map((scene, i) => this._resolveScene(scene, i));\n    }\n    if (json.scene !== undefined) {\n      json.scene = json.scenes[this.json.scene];\n    }\n  }\n\n  getScene(index) {\n    return this._get('scenes', index);\n  }\n\n  getNode(index) {\n    return this._get('nodes', index);\n  }\n\n  getSkin(index) {\n    return this._get('skins', index);\n  }\n\n  getMesh(index) {\n    return this._get('meshes', index);\n  }\n\n  getMaterial(index) {\n    return this._get('materials', index);\n  }\n\n  getAccessor(index) {\n    return this._get('accessors', index);\n  }\n\n  getCamera(index) {\n    return null; // TODO: fix this\n  }\n\n  getTexture(index) {\n    return this._get('textures', index);\n  }\n\n  getSampler(index) {\n    return this._get('samplers', index);\n  }\n\n  getImage(index) {\n    return this._get('images', index);\n  }\n\n  getBufferView(index) {\n    return this._get('bufferViews', index);\n  }\n\n  getBuffer(index) {\n    return this._get('buffers', index);\n  }\n\n  _get(array, index) {\n    // check if already resolved\n    if (typeof index === 'object') {\n      return index;\n    }\n    const object = this.json[array] && this.json[array][index];\n    if (!object) {\n      console.warn(`glTF file error: Could not find ${array}[${index}]`); // eslint-disable-line\n    }\n    return object;\n  }\n\n  // PARSING HELPERS\n\n  _resolveScene(scene, index) {\n    // scene = {...scene};\n    scene.id = scene.id || `scene-${index}`;\n    scene.nodes = (scene.nodes || []).map((node) => this.getNode(node));\n    return scene;\n  }\n\n  _resolveNode(node, index) {\n    // node = {...node};\n    node.id = node.id || `node-${index}`;\n    if (node.children) {\n      node.children = node.children.map((child) => this.getNode(child));\n    }\n    if (node.mesh !== undefined) {\n      node.mesh = this.getMesh(node.mesh);\n    } else if (node.meshes !== undefined && node.meshes.length) {\n      node.mesh = node.meshes.reduce(\n        (accum, meshIndex) => {\n          const mesh = this.getMesh(meshIndex);\n          accum.id = mesh.id;\n          accum.primitives = accum.primitives.concat(mesh.primitives);\n          return accum;\n        },\n        {primitives: []}\n      );\n    }\n    if (node.camera !== undefined) {\n      node.camera = this.getCamera(node.camera);\n    }\n    if (node.skin !== undefined) {\n      node.skin = this.getSkin(node.skin);\n    }\n    return node;\n  }\n\n  _resolveSkin(skin, index) {\n    // skin = {...skin};\n    skin.id = skin.id || `skin-${index}`;\n    skin.inverseBindMatrices = this.getAccessor(skin.inverseBindMatrices);\n    return skin;\n  }\n\n  _resolveMesh(mesh, index) {\n    // mesh = {...mesh};\n    mesh.id = mesh.id || `mesh-${index}`;\n    if (mesh.primitives) {\n      mesh.primitives = mesh.primitives.map((primitive) => {\n        primitive = {...primitive};\n        const attributes = primitive.attributes;\n        primitive.attributes = {};\n        for (const attribute in attributes) {\n          primitive.attributes[attribute] = this.getAccessor(attributes[attribute]);\n        }\n        if (primitive.indices !== undefined) {\n          primitive.indices = this.getAccessor(primitive.indices);\n        }\n        if (primitive.material !== undefined) {\n          primitive.material = this.getMaterial(primitive.material);\n        }\n        return primitive;\n      });\n    }\n    return mesh;\n  }\n\n  _resolveMaterial(material, index) {\n    // material = {...material};\n    material.id = material.id || `material-${index}`;\n    if (material.normalTexture) {\n      material.normalTexture = {...material.normalTexture};\n      material.normalTexture.texture = this.getTexture(material.normalTexture.index);\n    }\n    if (material.occlusionTexture) {\n      material.occlustionTexture = {...material.occlustionTexture};\n      material.occlusionTexture.texture = this.getTexture(material.occlusionTexture.index);\n    }\n    if (material.emissiveTexture) {\n      material.emmisiveTexture = {...material.emmisiveTexture};\n      material.emissiveTexture.texture = this.getTexture(material.emissiveTexture.index);\n    }\n    if (!material.emissiveFactor) {\n      material.emissiveFactor = material.emmisiveTexture ? [1, 1, 1] : [0, 0, 0];\n    }\n\n    if (material.pbrMetallicRoughness) {\n      material.pbrMetallicRoughness = {...material.pbrMetallicRoughness};\n      const mr = material.pbrMetallicRoughness;\n      if (mr.baseColorTexture) {\n        mr.baseColorTexture = {...mr.baseColorTexture};\n        mr.baseColorTexture.texture = this.getTexture(mr.baseColorTexture.index);\n      }\n      if (mr.metallicRoughnessTexture) {\n        mr.metallicRoughnessTexture = {...mr.metallicRoughnessTexture};\n        mr.metallicRoughnessTexture.texture = this.getTexture(mr.metallicRoughnessTexture.index);\n      }\n    }\n    return material;\n  }\n\n  _resolveAccessor(accessor, index) {\n    // accessor = {...accessor};\n    accessor.id = accessor.id || `accessor-${index}`;\n    if (accessor.bufferView !== undefined) {\n      // Draco encoded meshes don't have bufferView\n      accessor.bufferView = this.getBufferView(accessor.bufferView);\n    }\n\n    // Look up enums\n    accessor.bytesPerComponent = getBytesFromComponentType(accessor.componentType);\n    accessor.components = getSizeFromAccessorType(accessor.type);\n    accessor.bytesPerElement = accessor.bytesPerComponent * accessor.components;\n\n    // Create TypedArray for the accessor\n    // Note: The canonical way to instantiate is to ignore this array and create\n    // WebGLBuffer's using the bufferViews.\n    if (accessor.bufferView) {\n      const buffer = accessor.bufferView.buffer;\n      const {ArrayType, byteLength} = getAccessorArrayTypeAndLength(accessor, accessor.bufferView);\n      const byteOffset =\n        (accessor.bufferView.byteOffset || 0) + (accessor.byteOffset || 0) + buffer.byteOffset;\n      const cutBufffer = buffer.arrayBuffer.slice(byteOffset, byteOffset + byteLength);\n      accessor.value = new ArrayType(cutBufffer);\n    }\n\n    return accessor;\n  }\n\n  _resolveTexture(texture, index) {\n    // texture = {...texture};\n    texture.id = texture.id || `texture-${index}`;\n    texture.sampler = 'sampler' in texture ? this.getSampler(texture.sampler) : DEFAULT_SAMPLER;\n    texture.source = this.getImage(texture.source);\n    return texture;\n  }\n\n  _resolveSampler(sampler, index) {\n    // sampler = {...sampler};\n    sampler.id = sampler.id || `sampler-${index}`;\n    // Map textual parameters to GL parameter values\n    sampler.parameters = {};\n    for (const key in sampler) {\n      const glEnum = this._enumSamplerParameter(key);\n      if (glEnum !== undefined) {\n        sampler.parameters[glEnum] = sampler[key];\n      }\n    }\n    return sampler;\n  }\n\n  _enumSamplerParameter(key) {\n    return SAMPLER_PARAMETER_GLTF_TO_GL[key];\n  }\n\n  _resolveImage(image, index) {\n    // image = {...image};\n    image.id = image.id || `image-${index}`;\n    if (image.bufferView !== undefined) {\n      image.bufferView = this.getBufferView(image.bufferView);\n    }\n\n    // Check if image has been preloaded by the GLTFLoader\n    // If so, link it into the JSON and drop the URI\n    const preloadedImage = this.images[index];\n    if (preloadedImage) {\n      image.image = preloadedImage;\n    }\n\n    return image;\n  }\n\n  _resolveBufferView(bufferView, index) {\n    // bufferView = {...bufferView};\n    bufferView.id = bufferView.id || `bufferView-${index}`;\n    const bufferIndex = bufferView.buffer;\n    bufferView.buffer = this.buffers[bufferIndex];\n\n    const arrayBuffer = this.buffers[bufferIndex].arrayBuffer;\n    let byteOffset = this.buffers[bufferIndex].byteOffset || 0;\n\n    if ('byteOffset' in bufferView) {\n      byteOffset += bufferView.byteOffset;\n    }\n\n    bufferView.data = new Uint8Array(arrayBuffer, byteOffset, bufferView.byteLength);\n    return bufferView;\n  }\n\n  _resolveCamera(camera, index) {\n    camera.id = camera.id || `camera-${index}`;\n    // TODO - create 4x4 matrices\n    if (camera.perspective) {\n      // camera.matrix = createPerspectiveMatrix(camera.perspective);\n    }\n    if (camera.orthographic) {\n      // camera.matrix = createOrthographicMatrix(camera.orthographic);\n    }\n    return camera;\n  }\n}\n\nexport function postProcessGLTF(gltf, options) {\n  return new GLTFPostProcessor().postProcess(gltf, options);\n}\n","/* eslint-disable camelcase, max-statements */\n// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#glb-file-format-specification\n// https://github.com/KhronosGroup/glTF/tree/master/extensions/1.0/Khronos/KHR_binary_glTF\nimport type {GLB} from '../types/glb-types';\nimport {padToNBytes, assert} from '@loaders.gl/loader-utils';\n\nexport type GLBParseOptions = {\n  magic?: number;\n  strict?: boolean;\n};\n\nconst MAGIC_glTF = 0x676c5446; // glTF in Big-Endian ASCII\n\nconst GLB_FILE_HEADER_SIZE = 12;\nconst GLB_CHUNK_HEADER_SIZE = 8;\n\nconst GLB_CHUNK_TYPE_JSON = 0x4e4f534a;\nconst GLB_CHUNK_TYPE_BIN = 0x004e4942;\nconst GLB_CHUNK_TYPE_JSON_XVIZ_DEPRECATED = 0; // DEPRECATED - Backward compatibility for old xviz files\nconst GLB_CHUNK_TYPE_BIX_XVIZ_DEPRECATED = 1; // DEPRECATED - Backward compatibility for old xviz files\n\nconst GLB_V1_CONTENT_FORMAT_JSON = 0x0;\n\nconst LE = true; // Binary GLTF is little endian.\n\nfunction getMagicString(dataView, byteOffset = 0) {\n  return `\\\n${String.fromCharCode(dataView.getUint8(byteOffset + 0))}\\\n${String.fromCharCode(dataView.getUint8(byteOffset + 1))}\\\n${String.fromCharCode(dataView.getUint8(byteOffset + 2))}\\\n${String.fromCharCode(dataView.getUint8(byteOffset + 3))}`;\n}\n\n// Check if a data view is a GLB\nexport function isGLB(\n  arrayBuffer: ArrayBuffer,\n  byteOffset: number = 0,\n  options: GLBParseOptions = {}\n): boolean {\n  const dataView = new DataView(arrayBuffer);\n  // Check that GLB Header starts with the magic number\n  const {magic = MAGIC_glTF} = options;\n  const magic1 = dataView.getUint32(byteOffset, false);\n  return magic1 === magic || magic1 === MAGIC_glTF;\n}\n\nexport default function parseGLBSync(\n  glb: GLB,\n  arrayBuffer: ArrayBuffer,\n  byteOffset: number = 0,\n  options: GLBParseOptions = {}\n) {\n  // Check that GLB Header starts with the magic number\n  const dataView = new DataView(arrayBuffer);\n\n  // Compare format with GLBLoader documentation\n  const type = getMagicString(dataView, byteOffset + 0);\n  const version = dataView.getUint32(byteOffset + 4, LE); // Version 2 of binary glTF container format\n  const byteLength = dataView.getUint32(byteOffset + 8, LE); // Total byte length of binary file\n\n  Object.assign(glb, {\n    // Put less important stuff in a header, to avoid clutter\n    header: {\n      byteOffset, // Byte offset into the initial arrayBuffer\n      byteLength,\n      hasBinChunk: false\n    },\n\n    type,\n    version,\n\n    json: {},\n    binChunks: []\n  } as GLB);\n\n  byteOffset += GLB_FILE_HEADER_SIZE;\n\n  switch (glb.version) {\n    case 1:\n      // eslint-disable-next-line\n      return parseGLBV1(glb, dataView, byteOffset);\n    case 2:\n      // eslint-disable-next-line\n      return parseGLBV2(glb, dataView, byteOffset, (options = {}));\n    default:\n      throw new Error(`Invalid GLB version ${glb.version}. Only supports v1 and v2.`);\n  }\n}\n\nfunction parseGLBV1(glb: GLB, dataView: DataView, byteOffset: number): number {\n  // Sanity: ensure file is big enough to hold at least the headers\n  assert(glb.header.byteLength > GLB_FILE_HEADER_SIZE + GLB_CHUNK_HEADER_SIZE);\n\n  // Explanation of GLB structure:\n  // https://cloud.githubusercontent.com/assets/3479527/22600725/36b87122-ea55-11e6-9d40-6fd42819fcab.png\n  const contentLength = dataView.getUint32(byteOffset + 0, LE); // Byte length of chunk\n  const contentFormat = dataView.getUint32(byteOffset + 4, LE); // Chunk format as uint32\n  byteOffset += GLB_CHUNK_HEADER_SIZE;\n\n  // GLB v1 only supports a single chunk type\n  assert(contentFormat === GLB_V1_CONTENT_FORMAT_JSON);\n\n  parseJSONChunk(glb, dataView, byteOffset, contentLength);\n  // No need to call the function padToBytes() from parseJSONChunk()\n  byteOffset += contentLength;\n  byteOffset += parseBINChunk(glb, dataView, byteOffset, glb.header.byteLength);\n\n  return byteOffset;\n}\n\nfunction parseGLBV2(\n  glb: GLB,\n  dataView: DataView,\n  byteOffset: number,\n  options: GLBParseOptions\n): number {\n  // Sanity: ensure file is big enough to hold at least the first chunk header\n  assert(glb.header.byteLength > GLB_FILE_HEADER_SIZE + GLB_CHUNK_HEADER_SIZE);\n\n  parseGLBChunksSync(glb, dataView, byteOffset, options);\n\n  return byteOffset + glb.header.byteLength;\n}\n\nfunction parseGLBChunksSync(\n  glb: GLB,\n  dataView: DataView,\n  byteOffset: number,\n  options: GLBParseOptions\n) {\n  // Per spec we must iterate over chunks, ignoring all except JSON and BIN\n  // Iterate as long as there is space left for another chunk header\n  while (byteOffset + 8 <= glb.header.byteLength) {\n    const chunkLength = dataView.getUint32(byteOffset + 0, LE); // Byte length of chunk\n    const chunkFormat = dataView.getUint32(byteOffset + 4, LE); // Chunk format as uint32\n    byteOffset += GLB_CHUNK_HEADER_SIZE;\n\n    // Per spec we must iterate over chunks, ignoring all except JSON and BIN\n    switch (chunkFormat) {\n      case GLB_CHUNK_TYPE_JSON:\n        parseJSONChunk(glb, dataView, byteOffset, chunkLength);\n        break;\n      case GLB_CHUNK_TYPE_BIN:\n        parseBINChunk(glb, dataView, byteOffset, chunkLength);\n        break;\n\n      // Backward compatibility for very old xviz files\n      case GLB_CHUNK_TYPE_JSON_XVIZ_DEPRECATED:\n        if (!options.strict) {\n          parseJSONChunk(glb, dataView, byteOffset, chunkLength);\n        }\n        break;\n      case GLB_CHUNK_TYPE_BIX_XVIZ_DEPRECATED:\n        if (!options.strict) {\n          parseBINChunk(glb, dataView, byteOffset, chunkLength);\n        }\n        break;\n\n      default:\n        // Ignore, per spec\n        // console.warn(`Unknown GLB chunk type`); // eslint-disable-line\n        break;\n    }\n\n    byteOffset += padToNBytes(chunkLength, 4);\n  }\n\n  return byteOffset;\n}\n\n// Parse a GLB JSON chunk\nfunction parseJSONChunk(glb: GLB, dataView: DataView, byteOffset: number, chunkLength: number) {\n  // 1. Create a \"view\" of the binary encoded JSON data inside the GLB\n  const jsonChunk = new Uint8Array(dataView.buffer, byteOffset, chunkLength);\n\n  // 2. Decode the JSON binary array into clear text\n  const textDecoder = new TextDecoder('utf8');\n  const jsonText = textDecoder.decode(jsonChunk);\n\n  // 3. Parse the JSON text into a JavaScript data structure\n  glb.json = JSON.parse(jsonText);\n\n  return padToNBytes(chunkLength, 4);\n}\n\n// Parse a GLB BIN chunk\nfunction parseBINChunk(glb: GLB, dataView, byteOffset, chunkLength) {\n  // Note: BIN chunk can be optional\n  glb.header.hasBinChunk = true;\n  glb.binChunks.push({\n    byteOffset,\n    byteLength: chunkLength,\n    arrayBuffer: dataView.buffer\n    // TODO - copy, or create typed array view?\n  });\n\n  return padToNBytes(chunkLength, 4);\n}\n","/* eslint-disable camelcase, max-statements */\nimport {\n  copyPaddedStringToDataView,\n  copyPaddedArrayBufferToDataView\n} from '@loaders.gl/loader-utils';\n\nconst MAGIC_glTF = 0x46546c67; // glTF in ASCII\nconst MAGIC_JSON = 0x4e4f534a; // JSON in ASCII\nconst MAGIC_BIN = 0x004e4942; // BIN\\0 in ASCII\n\nconst LE = true; // Binary GLTF is little endian.\n\n// Encode the full GLB buffer with header etc\n// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#\n// glb-file-format-specification\nexport default function encodeGLBSync(glb, dataView, byteOffset = 0, options = {}) {\n  const {magic = MAGIC_glTF, version = 2, json = {}, binary} = glb;\n\n  const byteOffsetStart = byteOffset;\n\n  // Write GLB Header\n  if (dataView) {\n    dataView.setUint32(byteOffset + 0, magic, LE); // Magic number (the ASCII string 'glTF').\n    dataView.setUint32(byteOffset + 4, version, LE); // Version 2 of binary glTF container format uint32\n    dataView.setUint32(byteOffset + 8, 0, LE); // Total byte length of generated file (uint32), will be set last\n  }\n  const byteOffsetFileLength = byteOffset + 8;\n  byteOffset += 12; // GLB_FILE_HEADER_SIZE\n\n  // Write the JSON chunk header\n  const byteOffsetJsonHeader = byteOffset;\n  if (dataView) {\n    dataView.setUint32(byteOffset + 0, 0, LE); // Byte length of json chunk (will be written later)\n    dataView.setUint32(byteOffset + 4, MAGIC_JSON, LE); // Chunk type\n  }\n  byteOffset += 8; // GLB_CHUNK_HEADER_SIZE\n\n  // Write the JSON chunk\n  const jsonString = JSON.stringify(json);\n  byteOffset = copyPaddedStringToDataView(dataView, byteOffset, jsonString, 4);\n\n  // Now we know the JSON chunk length so we can write it.\n  if (dataView) {\n    const jsonByteLength = byteOffset - byteOffsetJsonHeader - 8; // GLB_CHUNK_HEADER_SIZE\n    dataView.setUint32(byteOffsetJsonHeader + 0, jsonByteLength, LE); // Byte length of json chunk (uint32)\n  }\n\n  // Write the BIN chunk if present. The BIN chunk is optional.\n  if (binary) {\n    const byteOffsetBinHeader = byteOffset;\n\n    // Write the BIN chunk header\n    if (dataView) {\n      dataView.setUint32(byteOffset + 0, 0, LE); // Byte length BIN (uint32)\n      dataView.setUint32(byteOffset + 4, MAGIC_BIN, LE); // Chunk type\n    }\n    byteOffset += 8; // GLB_CHUNK_HEADER_SIZE\n\n    byteOffset = copyPaddedArrayBufferToDataView(dataView, byteOffset, binary, 4);\n\n    // Now we know the BIN chunk length so we can write it.\n    if (dataView) {\n      const binByteLength = byteOffset - byteOffsetBinHeader - 8; // GLB_CHUNK_HEADER_SIZE\n      dataView.setUint32(byteOffsetBinHeader + 0, binByteLength, LE); // Byte length BIN (uint32)\n    }\n  }\n\n  // Now we know the glb file length so we can write it.\n  if (dataView) {\n    const fileByteLength = byteOffset - byteOffsetStart;\n    dataView.setUint32(byteOffsetFileLength, fileByteLength, LE); // Total byte length of generated file (uint32)\n  }\n\n  return byteOffset;\n}\n","// @ts-nocheck\nconst moduleExports = require('./index');\nconst _global = typeof window === 'undefined' ? global : window;\n_global.loaders = _global.loaders || {};\nmodule.exports = Object.assign(_global.loaders, moduleExports);\n","export type {GLB} from './lib/types/glb-types';\nexport type {\n  GLTF,\n  GLTFAccessor,\n  GLTFBuffer,\n  GLTFBufferView,\n  GLTFMeshPrimitive,\n  GLTFMesh,\n  GLTFNode,\n  GLTFMaterial,\n  GLTFSampler,\n  GLTFScene,\n  GLTFSkin,\n  GLTFTexture,\n  GLTFImage\n} from './lib/types/gltf-types';\n\n// Constants\nexport {KHR_DRACO_MESH_COMPRESSION} from './lib/gltf-utils/gltf-constants';\n\n// glTF loader/writer definition objects\nexport {GLTFLoader} from './gltf-loader';\nexport {GLTFWriter} from './gltf-writer';\n\n// GLB Loader & Writer (for custom formats that want to leverage the GLB binary \"envelope\")\nexport {GLBLoader} from './glb-loader';\nexport {GLBWriter} from './glb-writer';\n\n// glTF Data Access Helper Class\nexport {default as GLTFScenegraph} from './lib/api/gltf-scenegraph';\nexport {postProcessGLTF} from './lib/api/post-process-gltf';\nexport type {Mesh} from './lib/types/gltf-json-schema';\nexport type {GLTFObject} from './lib/types/gltf-types';\n","import type {LoaderWithParser, LoaderOptions} from '@loaders.gl/loader-utils';\nimport type {DracoLoaderOptions} from '@loaders.gl/draco';\n// import type {ImageLoaderOptions} from '@loaders.gl/images';\n// import type {TextureLoaderOptions} from '@loaders.gl/textures';\nimport type {GLTFParseOptions} from './lib/parsers/parse-gltf';\nimport {VERSION} from './lib/utils/version';\nimport {parseGLTF} from './lib/parsers/parse-gltf';\nimport {GLBLoaderOptions} from './glb-loader';\n\n/**\n * GLTF loader options\n */\nexport type GLTFLoaderOptions = LoaderOptions &\n  GLBLoaderOptions &\n  DracoLoaderOptions & {\n    gltf?: GLTFParseOptions;\n  };\n\n/**\n * GLTF loader\n */\nexport const GLTFLoader: LoaderWithParser = {\n  name: 'glTF',\n  id: 'gltf',\n  module: 'gltf',\n  version: VERSION,\n  extensions: ['gltf', 'glb'],\n  mimeTypes: ['model/gltf+json', 'model/gltf-binary'],\n\n  text: true,\n  binary: true,\n  tests: ['glTF'],\n  parse,\n\n  options: {\n    gltf: {\n      normalize: true, // Normalize glTF v1 to glTF v2 format (not yet stable)\n      loadBuffers: true, // Fetch any linked .BIN buffers, decode base64\n      loadImages: true, // Create image objects\n      decompressMeshes: true, // Decompress Draco encoded meshes\n      postProcess: true // Postprocess glTF and return json structure directly\n    },\n\n    // common?\n    log: console // eslint-disable-line\n  },\n  deprecatedOptions: {\n    fetchImages: 'gltf.loadImages',\n    createImages: 'gltf.loadImages',\n    decompress: 'gltf.decompressMeshes',\n    postProcess: 'gltf.postProcess',\n    gltf: {\n      decompress: 'gltf.decompressMeshes'\n    }\n  }\n};\n\nexport async function parse(arrayBuffer, options: GLTFLoaderOptions = {}, context) {\n  // Apps can call the parse method directly, we so apply default options here\n  options = {...GLTFLoader.options, ...options};\n  // @ts-ignore\n  options.gltf = {...GLTFLoader.options.gltf, ...options.gltf};\n\n  const {byteOffset = 0} = options;\n  const gltf = {};\n  return await parseGLTF(gltf, arrayBuffer, byteOffset, options, context);\n}\n","/* eslint-disable camelcase, max-statements, no-restricted-globals */\nimport type {LoaderContext} from '@loaders.gl/loader-utils';\nimport type {GLB} from '../types/glb-types';\nimport type {GLBParseOptions} from './parse-glb';\n\nimport {ImageLoader} from '@loaders.gl/images';\nimport {parseJSON, sliceArrayBuffer} from '@loaders.gl/loader-utils';\nimport {assert} from '../utils/assert';\nimport {resolveUrl} from '../gltf-utils/resolve-url';\nimport {getTypedArrayForBufferView} from '../gltf-utils/get-typed-array';\nimport {decodeExtensions} from '../extensions/gltf-extensions';\nimport {normalizeGLTFV1} from '../api/normalize-gltf-v1';\nimport {postProcessGLTF} from '../api/post-process-gltf';\nimport parseGLBSync, {isGLB} from './parse-glb';\n\nexport type GLTFParseOptions = {\n  excludeExtensions?: string[];\n  decompressMeshes?: boolean;\n  normalize?: boolean;\n  loadBuffers?: boolean;\n  loadImages?: boolean;\n  postProcess?: boolean;\n};\n\n// export type GLTFOptions = {\n//   gltf?: GLTFParseOptions;\n// };\n\nexport function isGLTF(arrayBuffer, options?): boolean {\n  const byteOffset = 0;\n  return isGLB(arrayBuffer, byteOffset, options);\n}\n\nexport async function parseGLTF(\n  gltf,\n  arrayBufferOrString,\n  byteOffset = 0,\n  options: {\n    gltf?: GLTFParseOptions;\n    glb?: GLBParseOptions;\n  },\n  context: LoaderContext\n) {\n  parseGLTFContainerSync(gltf, arrayBufferOrString, byteOffset, options);\n\n  normalizeGLTFV1(gltf, {normalize: options?.gltf?.normalize});\n\n  const promises: Promise<any>[] = [];\n\n  // Load linked buffers asynchronously and decodes base64 buffers in parallel\n  if (options?.gltf?.loadBuffers && gltf.json.buffers) {\n    await loadBuffers(gltf, options, context);\n  }\n\n  if (options?.gltf?.loadImages) {\n    const promise = loadImages(gltf, options, context);\n    promises.push(promise);\n  }\n\n  const promise = decodeExtensions(gltf, options, context);\n  promises.push(promise);\n\n  // Parallelize image loading and buffer loading/extension decoding\n  await Promise.all(promises);\n\n  // Post processing resolves indices to objects, buffers\n  return options?.gltf?.postProcess ? postProcessGLTF(gltf, options) : gltf;\n}\n\n// `data` - can be ArrayBuffer (GLB), ArrayBuffer (Binary JSON), String (JSON), or Object (parsed JSON)\nfunction parseGLTFContainerSync(gltf, data, byteOffset, options) {\n  // Initialize gltf container\n  if (options.uri) {\n    gltf.baseUri = options.uri;\n  }\n\n  // If data is binary and starting with magic bytes, assume binary JSON text, convert to string\n  if (data instanceof ArrayBuffer && !isGLB(data, byteOffset, options)) {\n    const textDecoder = new TextDecoder();\n    data = textDecoder.decode(data);\n  }\n\n  if (typeof data === 'string') {\n    // If string, try to parse as JSON\n    gltf.json = parseJSON(data);\n  } else if (data instanceof ArrayBuffer) {\n    // If still ArrayBuffer, parse as GLB container\n    const glb: GLB = {} as GLB;\n    byteOffset = parseGLBSync(glb, data, byteOffset, options.glb);\n\n    assert(glb.type === 'glTF', `Invalid GLB magic string ${glb.type}`);\n\n    gltf._glb = glb;\n    gltf.json = glb.json;\n  } else {\n    assert(false, 'GLTF: must be ArrayBuffer or string');\n  }\n\n  // Populate buffers\n  // Create an external buffers array to hold binary data\n  const buffers = gltf.json.buffers || [];\n  gltf.buffers = new Array(buffers.length).fill(null);\n\n  // Populates JSON and some bin chunk info\n  if (gltf._glb && gltf._glb.header.hasBinChunk) {\n    const {binChunks} = gltf._glb;\n    gltf.buffers[0] = {\n      arrayBuffer: binChunks[0].arrayBuffer,\n      byteOffset: binChunks[0].byteOffset,\n      byteLength: binChunks[0].byteLength\n    };\n\n    // TODO - this modifies JSON and is a post processing thing\n    // gltf.json.buffers[0].data = gltf.buffers[0].arrayBuffer;\n    // gltf.json.buffers[0].byteOffset = gltf.buffers[0].byteOffset;\n  }\n\n  // Populate images\n  const images = gltf.json.images || [];\n  gltf.images = new Array(images.length).fill({});\n}\n\n// Asynchronously fetch and parse buffers, store in buffers array outside of json\nasync function loadBuffers(gltf, options, context: LoaderContext) {\n  for (let i = 0; i < gltf.json.buffers.length; ++i) {\n    const buffer = gltf.json.buffers[i];\n    if (buffer.uri) {\n      const {fetch} = context;\n      assert(fetch);\n\n      const uri = resolveUrl(buffer.uri, options);\n      const response = await context?.fetch?.(uri);\n      const arrayBuffer = await response?.arrayBuffer?.();\n\n      gltf.buffers[i] = {\n        arrayBuffer,\n        byteOffset: 0,\n        byteLength: arrayBuffer.byteLength\n      };\n\n      delete buffer.uri;\n    }\n  }\n}\n\nasync function loadImages(gltf, options, context: LoaderContext) {\n  const images = gltf.json.images || [];\n\n  const promises: Promise<any>[] = [];\n  for (let i = 0; i < images.length; ++i) {\n    promises.push(loadImage(gltf, images[i], i, options, context));\n  }\n\n  return await Promise.all(promises);\n}\n\n// Asynchronously fetches and parses one image, store in images array outside of json\nasync function loadImage(gltf, image, index: number, options, context: LoaderContext) {\n  const {fetch, parse} = context;\n\n  let arrayBuffer;\n\n  if (image.uri) {\n    const uri = resolveUrl(image.uri, options);\n    const response = await fetch(uri);\n    arrayBuffer = await response.arrayBuffer();\n  }\n\n  if (Number.isFinite(image.bufferView)) {\n    const array = getTypedArrayForBufferView(gltf.json, gltf.buffers, image.bufferView);\n    arrayBuffer = sliceArrayBuffer(array.buffer, array.byteOffset, array.byteLength);\n  }\n\n  assert(arrayBuffer, 'glTF image has no data');\n\n  // Call `parse`\n  const parsedImage = await parse(arrayBuffer, ImageLoader, {}, context);\n  // TODO making sure ImageLoader is overridable by using array of loaders\n  // const parsedImage = await parse(arrayBuffer, [ImageLoader]);\n\n  gltf.images[index] = parsedImage;\n}\n","import type {LoaderWithParser} from '@loaders.gl/loader-utils';\nimport {VERSION} from './lib/utils/version';\nimport parseImage from './lib/parsers/parse-image';\nimport {getBinaryImageMetadata} from './lib/category-api/binary-image-api';\n\nconst EXTENSIONS = ['png', 'jpg', 'jpeg', 'gif', 'webp', 'bmp', 'ico', 'svg'];\nconst MIME_TYPES = [\n  'image/png',\n  'image/jpeg',\n  'image/gif',\n  'image/webp',\n  'image/bmp',\n  'image/vnd.microsoft.icon',\n  'image/svg+xml'\n];\n\n/**\n * Loads a platform-specific image type\n * Note: This type can be used as input data to WebGL texture creation\n */\nexport const ImageLoader = {\n  id: 'image',\n  module: 'images',\n  name: 'Images',\n  version: VERSION,\n  mimeTypes: MIME_TYPES,\n  extensions: EXTENSIONS,\n  parse: parseImage,\n  // TODO: byteOffset, byteLength;\n  tests: [(arrayBuffer) => Boolean(getBinaryImageMetadata(new DataView(arrayBuffer)))],\n  options: {\n    image: {\n      type: 'auto',\n      decode: true // if format is HTML\n    }\n    // imagebitmap: {} - passes (platform dependent) parameters to ImageBitmap constructor\n  }\n};\n\nexport const _typecheckImageLoader: LoaderWithParser = ImageLoader;\n","import {isSVG, getBlob} from './svg-utils';\nimport parseToImage from './parse-to-image';\n\nconst EMPTY_OBJECT = {};\n\nlet imagebitmapOptionsSupported = true;\n\n/**\n * Asynchronously parses an array buffer into an ImageBitmap - this contains the decoded data\n * ImageBitmaps are supported on worker threads, but not supported on Edge, IE11 and Safari\n * https://developer.mozilla.org/en-US/docs/Web/API/ImageBitmap#Browser_compatibility\n *\n * TODO - createImageBitmap supports source rect (5 param overload), pass through?\n */\nexport default async function parseToImageBitmap(arrayBuffer, options, url) {\n  let blob;\n\n  // Cannot parse SVG directly to ImageBitmap, parse to Image first\n  if (isSVG(url)) {\n    // Note: this only works on main thread\n    const image = await parseToImage(arrayBuffer, options, url);\n    blob = image;\n  } else {\n    // Create blob from the array buffer\n    blob = getBlob(arrayBuffer, url);\n  }\n\n  const imagebitmapOptions = options && options.imagebitmap;\n\n  return await safeCreateImageBitmap(blob, imagebitmapOptions);\n}\n\n/**\n * Safely creates an imageBitmap with options\n * *\n * Firefox crashes if imagebitmapOptions is supplied\n * Avoid supplying if not provided or supported, remember if not supported\n */\nasync function safeCreateImageBitmap(blob, imagebitmapOptions = null) {\n  if (isEmptyObject(imagebitmapOptions) || !imagebitmapOptionsSupported) {\n    imagebitmapOptions = null;\n  }\n\n  if (imagebitmapOptions) {\n    try {\n      // @ts-ignore Options\n      return await createImageBitmap(blob, imagebitmapOptions);\n    } catch (error) {\n      console.warn(error); // eslint-disable-line\n      imagebitmapOptionsSupported = false;\n    }\n  }\n\n  return await createImageBitmap(blob);\n}\n\nfunction isEmptyObject(object) {\n  // @ts-ignore\n  for (const key in object || EMPTY_OBJECT) {\n    return false;\n  }\n  return true;\n}\n","import {global} from '../utils/globals';\nimport {assert} from '../utils/assert';\nimport {getBinaryImageMetadata} from '../category-api/binary-image-api';\n\n// Use polyfills if installed to p[arsed image using get-pixels\nexport default function parseToNodeImage(arrayBuffer, options) {\n  const {mimeType} = getBinaryImageMetadata(arrayBuffer) || {};\n\n  // @ts-ignore\n  const {_parseImageNode} = global;\n  assert(_parseImageNode); // '@loaders.gl/polyfills not installed'\n\n  return _parseImageNode(arrayBuffer, mimeType, options);\n}\n","// import type {Writer} from '@loaders.gl/loader-utils';\nimport {VERSION} from './lib/utils/version';\nimport {encodeImage} from './lib/encoders/encode-image';\n\nexport const ImageWriter = {\n  name: 'Images',\n  id: 'image',\n  module: 'images',\n  version: VERSION,\n  extensions: ['jpeg'],\n  options: {\n    image: {\n      mimeType: 'image/png',\n      jpegQuality: null\n    }\n  },\n  encode: encodeImage\n};\n","// Image loading/saving for browser and Node.js\nimport {global} from '../utils/globals';\nimport {getImageSize} from '../category-api/parsed-image-api';\n\n// @ts-ignore TS2339: Property does not exist on type\nconst {_encodeImageNode} = global;\n\n/**\n * Returns data bytes representing a compressed image in PNG or JPG format,\n * This data can be saved using file system (f) methods or used in a request.\n * @param image - ImageBitmap Image or Canvas\n * @param options\n * param opt.type='png' - png, jpg or image/png, image/jpg are valid\n * param mimeType= - Whether to include a data URI header\n */\nexport async function encodeImage(\n  image: any,\n  options?: {[key: string]: any}\n): Promise<ArrayBuffer> {\n  options = options || {};\n  options.image = options.image || ({} as {[key: string]: any});\n\n  return _encodeImageNode\n    ? _encodeImageNode(image, {type: options.image.mimeType})\n    : encodeImageInBrowser(image, options);\n}\n\n// In case we get exceptions from canvas.toBlob(resolve, type, quality)\nlet qualityParamSupported = true;\n\n/**\n *\n * @param image\n * @param options\n * @note Based on canvas.toBlob\n * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob\n */\nasync function encodeImageInBrowser(image, options) {\n  const {mimeType, jpegQuality} = options.image;\n\n  const {width, height} = getImageSize(image);\n\n  // create a canvas and resize it to the size of our image\n  const canvas = document.createElement('canvas');\n  canvas.width = width;\n  canvas.height = height;\n\n  drawImageToCanvas(image, canvas);\n\n  // The actual encoding is done asynchronously with `canvas.toBlob()`\n  const blob = await new Promise<Blob | null>((resolve) => {\n    // get it back as a Blob\n    if (jpegQuality && qualityParamSupported) {\n      try {\n        canvas.toBlob(resolve, mimeType, jpegQuality);\n        return;\n      } catch (error) {\n        qualityParamSupported = false;\n      }\n    }\n    canvas.toBlob(resolve, mimeType);\n  });\n\n  if (!blob) {\n    throw new Error('image encoding failed');\n  }\n\n  return await blob.arrayBuffer();\n}\n\nfunction drawImageToCanvas(image, canvas, x = 0, y = 0) {\n  // Try optimized path for ImageBitmaps via bitmaprenderer context\n  if (x === 0 && y === 0 && typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {\n    const context = canvas.getContext('bitmaprenderer');\n    if (context) {\n      // transfer the ImageBitmap to it\n      context.transferFromImageBitmap(image);\n      return canvas;\n    }\n  }\n\n  // Available on most platforms, except IE11 and Andriod WebViews...\n  const context = canvas.getContext('2d');\n  if (image.data) {\n    // ImageData constructor expects clamped array even though getImageData does not return a clamped array...\n    const clampedArray = new Uint8ClampedArray(image.data);\n    const imageData = new ImageData(clampedArray, image.width, image.height);\n    context.putImageData(imageData, 0, 0);\n    return canvas;\n  }\n\n  // Fall back to generic image/image bitmap rendering path\n  context.drawImage(image, 0, 0);\n  return canvas;\n}\n","import {assert} from '../utils/assert';\nimport parseImage from '../parsers/parse-image';\nimport {getImageSize} from '../category-api/parsed-image-api';\nimport {generateUrl} from './generate-url';\nimport {deepLoad, shallowLoad} from './deep-load';\n\nexport async function loadImage(getUrl, options = {}) {\n  const imageUrls = await getImageUrls(getUrl, options);\n  return await deepLoad(imageUrls, parseImage, options);\n}\n\nexport async function getImageUrls(getUrl, options, urlOptions = {}) {\n  const mipLevels = (options && options.image && options.image.mipLevels) || 0;\n  return mipLevels !== 0\n    ? await getMipmappedImageUrls(getUrl, mipLevels, options, urlOptions)\n    : generateUrl(getUrl, options, urlOptions);\n}\n\nasync function getMipmappedImageUrls(getUrl, mipLevels, options, urlOptions) {\n  const urls: string[] = [];\n\n  // If no mip levels supplied, we need to load the level 0 image and calculate based on size\n  if (mipLevels === 'auto') {\n    const url = generateUrl(getUrl, options, {...urlOptions, lod: 0});\n    const image = await shallowLoad(url, parseImage, options);\n\n    const {width, height} = getImageSize(image);\n    mipLevels = getMipLevels({width, height});\n\n    // TODO - push image and make `deepLoad` pass through non-url values, avoid loading twice?\n    urls.push(url);\n  }\n\n  // We now know how many mipLevels we need, remaining image urls can now be constructed\n  assert(mipLevels > 0);\n\n  for (let mipLevel = urls.length; mipLevel < mipLevels; ++mipLevel) {\n    const url = generateUrl(getUrl, options, {...urlOptions, lod: mipLevel});\n    urls.push(url);\n  }\n\n  return urls;\n}\n\n// Calculates number of mipmaps based on texture size (log2)\nexport function getMipLevels({width, height}) {\n  return 1 + Math.floor(Math.log2(Math.max(width, height)));\n}\n","import {resolvePath} from '@loaders.gl/loader-utils';\nimport {assert} from '../utils/assert';\n\n// Generate a url by calling getUrl with mix of options, applying options.baseUrl\nexport function generateUrl(getUrl, options, urlOptions) {\n  // Get url\n  let url = getUrl;\n  if (typeof getUrl === 'function') {\n    url = getUrl({...options, ...urlOptions});\n  }\n  assert(typeof url === 'string');\n\n  // Apply options.baseUrl\n  const {baseUrl} = options;\n  if (baseUrl) {\n    url = baseUrl[baseUrl.length - 1] === '/' ? `${baseUrl}${url}` : `${baseUrl}/${url}`;\n  }\n\n  return resolvePath(url);\n}\n","// Purpose: include this in your module to avoid\n// dependencies on micro modules like 'global' and 'is-browser';\n\n/* eslint-disable no-restricted-globals */\nconst globals = {\n  self: typeof self !== 'undefined' && self,\n  window: typeof window !== 'undefined' && window,\n  global: typeof global !== 'undefined' && global,\n  document: typeof document !== 'undefined' && document\n};\n\ntype obj = {[key: string]: any};\nconst self_: obj = globals.self || globals.window || globals.global || {};\nconst window_: obj = globals.window || globals.self || globals.global || {};\nconst global_: obj = globals.global || globals.self || globals.window || {};\nconst document_: obj = globals.document || {};\n\nexport {self_ as self, window_ as window, global_ as global, document_ as document};\n\n/** true if running in a browser */\nexport const isBrowser: boolean =\n  // @ts-ignore process does not exist on browser\n  typeof process !== 'object' || String(process) !== '[object process]' || process.browser;\n\n/** true if running in a worker thread */\nexport const isWorker: boolean = typeof importScripts === 'function';\n\n// Extract node major version\nconst matches =\n  typeof process !== 'undefined' && process.version && /v([0-9]*)/.exec(process.version);\n/** Major Node version (as a number) */\nexport const nodeVersion: number = (matches && parseFloat(matches[1])) || 0;\n","/* eslint-disable no-restricted-globals */\nimport type {LoaderWithParser} from '../../types';\nimport {WorkerBody} from '@loaders.gl/worker-utils';\n// import {validateLoaderVersion} from './validate-loader-version';\n\nlet requestId = 0;\n\n/**\n * Set up a WebWorkerGlobalScope to talk with the main thread\n * @param loader\n */\nexport function createLoaderWorker(loader: LoaderWithParser) {\n  // Check that we are actually in a worker thread\n  if (typeof self === 'undefined') {\n    return;\n  }\n\n  WorkerBody.onmessage = async (type, payload) => {\n    switch (type) {\n      case 'process':\n        try {\n          // validateLoaderVersion(loader, data.source.split('@')[1]);\n\n          const {input, options = {}} = payload;\n\n          const result = await parseData({\n            loader,\n            arrayBuffer: input,\n            options,\n            context: {\n              parse: parseOnMainThread\n            }\n          });\n          WorkerBody.postMessage('done', {result});\n        } catch (error) {\n          const message = error instanceof Error ? error.message : '';\n          WorkerBody.postMessage('error', {error: message});\n        }\n        break;\n      default:\n    }\n  };\n}\n\nfunction parseOnMainThread(arrayBuffer: ArrayBuffer, options: {[key: string]: any}): Promise<void> {\n  return new Promise((resolve, reject) => {\n    const id = requestId++;\n\n    /**\n     */\n    const onMessage = (type, payload) => {\n      if (payload.id !== id) {\n        // not ours\n        return;\n      }\n\n      switch (type) {\n        case 'done':\n          WorkerBody.removeEventListener(onMessage);\n          resolve(payload.result);\n          break;\n\n        case 'error':\n          WorkerBody.removeEventListener(onMessage);\n          reject(payload.error);\n          break;\n\n        default:\n        // ignore\n      }\n    };\n\n    WorkerBody.addEventListener(onMessage);\n\n    // Ask the main thread to decode data\n    const payload = {id, input: arrayBuffer, options};\n    WorkerBody.postMessage('process', payload);\n  });\n}\n\n// TODO - Support byteOffset and byteLength (enabling parsing of embedded binaries without copies)\n// TODO - Why not support async loader.parse* funcs here?\n// TODO - Why not reuse a common function instead of reimplementing loader.parse* selection logic? Keeping loader small?\n// TODO - Lack of appropriate parser functions can be detected when we create worker, no need to wait until parse\nasync function parseData({loader, arrayBuffer, options, context}) {\n  let data;\n  let parser;\n  if (loader.parseSync || loader.parse) {\n    data = arrayBuffer;\n    parser = loader.parseSync || loader.parse;\n  } else if (loader.parseTextSync) {\n    const textDecoder = new TextDecoder();\n    data = textDecoder.decode(arrayBuffer);\n    parser = loader.parseTextSync;\n  } else {\n    throw new Error(`Could not load data with ${loader.name} loader`);\n  }\n\n  // TODO - proper merge in of loader options...\n  options = {\n    ...options,\n    modules: (loader && loader.options && loader.options.modules) || {},\n    worker: false\n  };\n\n  return await parser(data, {...options}, context, loader);\n}\n","import {assert} from '../env-utils/assert';\n\nconst workerURLCache = new Map();\n\n/**\n * Creates a loadable URL from worker source or URL\n * that can be used to create `Worker` instances.\n * Due to CORS issues it may be necessary to wrap a URL in a small importScripts\n * @param props\n * @param props.source Worker source\n * @param props.url Worker URL\n * @returns loadable url\n */\nexport function getLoadableWorkerURL(props: {source?: string; url?: string}) {\n  assert((props.source && !props.url) || (!props.source && props.url)); // Either source or url must be defined\n\n  let workerURL = workerURLCache.get(props.source || props.url);\n  if (!workerURL) {\n    // Differentiate worker urls from worker source code\n    if (props.url) {\n      workerURL = getLoadableWorkerURLFromURL(props.url);\n      workerURLCache.set(props.url, workerURL);\n    }\n\n    if (props.source) {\n      workerURL = getLoadableWorkerURLFromSource(props.source);\n      workerURLCache.set(props.source, workerURL);\n    }\n  }\n\n  assert(workerURL);\n  return workerURL;\n}\n\n/**\n * Build a loadable worker URL from worker URL\n * @param url\n * @returns loadable URL\n */\nfunction getLoadableWorkerURLFromURL(url: string): string {\n  // A local script url, we can use it to initialize a Worker directly\n  if (!url.startsWith('http')) {\n    return url;\n  }\n\n  // A remote script, we need to use `importScripts` to load from different origin\n  const workerSource = buildScriptSource(url);\n  return getLoadableWorkerURLFromSource(workerSource);\n}\n\n/**\n * Build a loadable worker URL from worker source\n * @param workerSource\n * @returns loadable url\n */\nfunction getLoadableWorkerURLFromSource(workerSource: string): string {\n  // NOTE: webworkify was previously used\n  // const blob = webworkify(workerSource, {bare: true});\n  const blob = new Blob([workerSource], {type: 'application/javascript'});\n  return URL.createObjectURL(blob);\n}\n\n/**\n * Per spec, worker cannot be initialized with a script from a different origin\n * However a local worker script can still import scripts from other origins,\n * so we simply build a wrapper script.\n *\n * @param workerUrl\n * @returns source\n */\nfunction buildScriptSource(workerUrl: string): string {\n  return `\\\ntry {\n  importScripts('${workerUrl}');\n} catch (error) {\n  console.error(error);\n  throw error;\n}`;\n}\n","import type {\n  WorkerObject,\n  WorkerOptions,\n  WorkerContext,\n  WorkerMessageType,\n  WorkerMessagePayload\n} from '../../types';\nimport type WorkerJob from '../worker-farm/worker-job';\nimport WorkerFarm from '../worker-farm/worker-farm';\nimport {removeNontransferableOptions} from '../worker-utils/remove-nontransferable-options';\nimport {getWorkerURL, getWorkerName} from './get-worker-url';\n\ntype ProcessOnWorkerOptions = WorkerOptions & {\n  jobName?: string;\n  [key: string]: any;\n};\n\n/**\n * Determines if we can parse with worker\n * @param loader\n * @param data\n * @param options\n */\nexport function canProcessOnWorker(worker: WorkerObject, options?: WorkerOptions) {\n  if (!WorkerFarm.isSupported()) {\n    return false;\n  }\n\n  return worker.worker && options?.worker;\n}\n\n/**\n * This function expects that the worker thread sends certain messages,\n * Creating such a worker can be automated if the worker is wrapper by a call to\n * createWorker in @loaders.gl/worker-utils.\n */\nexport async function processOnWorker(\n  worker: WorkerObject,\n  data: any,\n  options: ProcessOnWorkerOptions = {},\n  context: WorkerContext = {}\n): Promise<any> {\n  const name = getWorkerName(worker);\n  const url = getWorkerURL(worker, options);\n\n  const workerFarm = WorkerFarm.getWorkerFarm(options);\n  const workerPool = workerFarm.getWorkerPool({name, url});\n\n  const jobName = options.jobName || worker.name;\n  const job = await workerPool.startJob(\n    jobName,\n    // eslint-disable-next-line\n    onMessage.bind(null, context)\n  );\n\n  // Kick off the processing in the worker\n  const transferableOptions = removeNontransferableOptions(options);\n  job.postMessage('process', {input: data, options: transferableOptions});\n\n  const result = await job.result;\n  return result.result;\n}\n\n/**\n * Job completes when we receive the result\n * @param job\n * @param message\n */\nasync function onMessage(\n  context: WorkerContext,\n  job: WorkerJob,\n  type: WorkerMessageType,\n  payload: WorkerMessagePayload\n) {\n  switch (type) {\n    case 'done':\n      // Worker is done\n      job.done(payload);\n      break;\n\n    case 'error':\n      // Worker encountered an error\n      job.error(payload.error);\n      break;\n\n    case 'process':\n      // Worker is asking for us (main thread) to process something\n      const {id, input, options} = payload;\n      try {\n        if (!context.process) {\n          job.postMessage('error', {id, error: 'Worker not set up to process on main thread'});\n          return;\n        }\n        const result = await context.process(input, options);\n        job.postMessage('done', {id, result});\n      } catch (error) {\n        const message = error instanceof Error ? error.message : 'unknown error';\n        job.postMessage('error', {id, error: message});\n      }\n      break;\n\n    default:\n      // eslint-disable-next-line\n      console.warn(`process-on-worker: unknown message ${type}`);\n  }\n}\n","/**\n * Safely stringify JSON (drop non serializable values like functions and regexps)\n * @param value\n */\nexport function removeNontransferableOptions(object: object): object {\n  // options.log object contains functions which cannot be transferred\n  // TODO - decide how to handle logging on workers\n  // TODO - warn if options stringification is long\n  return JSON.parse(stringifyJSON(object));\n}\n\nfunction stringifyJSON(v) {\n  const cache = new Set();\n  return JSON.stringify(v, (key, value) => {\n    if (typeof value === 'object' && value !== null) {\n      if (cache.has(value)) {\n        // Circular reference found\n        try {\n          // If this value does not reference a parent it can be deduped\n          return JSON.parse(JSON.stringify(value));\n        } catch (err) {\n          // discard key if value cannot be deduped\n          return undefined;\n        }\n      }\n      // Store value in our set\n      cache.add(value);\n    }\n    return value;\n  });\n}\n","import type {\n  WorkerMessageType,\n  WorkerMessagePayload,\n  WorkerContext,\n  Process,\n  ProcessInBatches\n} from '../../types';\nimport AsyncQueue from '../async-queue/async-queue';\nimport WorkerBody from '../worker-farm/worker-body';\n// import {validateWorkerVersion} from './validate-worker-version';\n\n/** Counter for jobs */\nlet requestId = 0;\nlet inputBatches;\nlet options;\n\nexport type ProcessOnMainThread = (data: any, options?: {[key: string]: any}, context?) => any;\n\n/**\n * Set up a WebWorkerGlobalScope to talk with the main thread\n */\nexport function createWorker(process: Process, processInBatches?: ProcessInBatches): void {\n  // Check that we are actually in a worker thread\n  if (typeof self === 'undefined') {\n    return;\n  }\n\n  const context: WorkerContext = {\n    process: processOnMainThread\n  };\n\n  // eslint-disable-next-line complexity\n  WorkerBody.onmessage = async (type: WorkerMessageType, payload: WorkerMessagePayload) => {\n    try {\n      switch (type) {\n        case 'process':\n          if (!process) {\n            throw new Error('Worker does not support atomic processing');\n          }\n          const result = await process(payload.input, payload.options || {}, context);\n          WorkerBody.postMessage('done', {result});\n          break;\n\n        case 'process-in-batches':\n          if (!processInBatches) {\n            throw new Error('Worker does not support batched processing');\n          }\n          inputBatches = new AsyncQueue();\n          options = payload.options || {};\n          const resultIterator = processInBatches(inputBatches, options, context?.processInBatches);\n          for await (const batch of resultIterator) {\n            WorkerBody.postMessage('output-batch', {result: batch});\n          }\n          WorkerBody.postMessage('done', {});\n          break;\n\n        case 'input-batch':\n          inputBatches.push(payload.input);\n          break;\n\n        case 'input-done':\n          inputBatches.close();\n          break;\n\n        default:\n      }\n    } catch (error) {\n      const message = error instanceof Error ? error.message : '';\n      WorkerBody.postMessage('error', {error: message});\n    }\n  };\n}\n\nfunction processOnMainThread(arrayBuffer, options = {}) {\n  return new Promise((resolve, reject) => {\n    const id = requestId++;\n\n    /**\n     */\n    const onMessage = (type, payload) => {\n      if (payload.id !== id) {\n        // not ours\n        return;\n      }\n\n      switch (type) {\n        case 'done':\n          WorkerBody.removeEventListener(onMessage);\n          resolve(payload.result);\n          break;\n\n        case 'error':\n          WorkerBody.removeEventListener(onMessage);\n          reject(payload.error);\n          break;\n\n        default:\n        // ignore\n      }\n    };\n\n    WorkerBody.addEventListener(onMessage);\n\n    // Ask the main thread to decode data\n    const payload = {id, input: arrayBuffer, options};\n    WorkerBody.postMessage('process', payload);\n  });\n}\n","import type {WorkerObject} from '../../types';\nimport {assert} from '../env-utils/assert';\nimport {VERSION} from '../env-utils/version';\n\n/**\n * Check if worker is compatible with this library version\n * @param worker\n * @param libVersion\n * @returns `true` if the two versions are compatible\n */\nexport function validateWorkerVersion(\n  worker: WorkerObject,\n  coreVersion: string = VERSION\n): boolean {\n  assert(worker, 'no worker provided');\n\n  const workerVersion = worker.version;\n  if (!coreVersion || !workerVersion) {\n    return false;\n  }\n\n  // TODO enable when fix the __version__ injection\n  // const coreVersions = parseVersion(coreVersion);\n  // const workerVersions = parseVersion(workerVersion);\n  // assert(\n  //   coreVersion.major === workerVersion.major && coreVersion.minor <= workerVersion.minor,\n  //   `worker: ${worker.name} is not compatible. ${coreVersion.major}.${\n  //     coreVersion.minor\n  //   }+ is required.`\n  // );\n\n  return true;\n}\n\n// @ts-ignore\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction parseVersion(version) {\n  const parts = version.split('.').map(Number);\n  return {major: parts[0], minor: parts[1]};\n}\n","/* global importScripts */\nimport {global, isBrowser, isWorker} from '../env-utils/globals';\nimport * as node from '../node/require-utils.node';\nimport {assert} from '../env-utils/assert';\nimport {VERSION as __VERSION__} from '../env-utils/version';\n\n// TODO - unpkg.com doesn't seem to have a `latest` specifier for alpha releases...\nconst LATEST = 'beta';\nconst VERSION = typeof __VERSION__ !== 'undefined' ? __VERSION__ : LATEST;\n\nconst loadLibraryPromises = {}; // promises\n\n/**\n * Dynamically loads a library (\"module\")\n *\n * - wasm library: Array buffer is returned\n * - js library: Parse JS is returned\n *\n * Method depends on environment\n * - browser - script element is created and installed on document\n * - worker - eval is called on global context\n * - node - file is required\n *\n * @param libraryUrl\n * @param moduleName\n * @param options\n */\nexport async function loadLibrary(\n  libraryUrl: string,\n  moduleName: string | null = null,\n  options: object = {}\n): Promise<any> {\n  if (moduleName) {\n    libraryUrl = getLibraryUrl(libraryUrl, moduleName, options);\n  }\n\n  // Ensure libraries are only loaded once\n  loadLibraryPromises[libraryUrl] =\n    loadLibraryPromises[libraryUrl] || loadLibraryFromFile(libraryUrl);\n  return await loadLibraryPromises[libraryUrl];\n}\n\n// TODO - sort out how to resolve paths for main/worker and dev/prod\nexport function getLibraryUrl(library, moduleName?: string, options?): string {\n  // Check if already a URL\n  if (library.startsWith('http')) {\n    return library;\n  }\n\n  // Allow application to import and supply libraries through `options.modules`\n  const modules = options.modules || {};\n  if (modules[library]) {\n    return modules[library];\n  }\n\n  // Load from local files, not from CDN scripts in Node.js\n  // TODO - needs to locate the modules directory when installed!\n  if (!isBrowser) {\n    return `modules/${moduleName}/dist/libs/${library}`;\n  }\n\n  // In browser, load from external scripts\n  if (options.CDN) {\n    assert(options.CDN.startsWith('http'));\n    return `${options.CDN}/${moduleName}@${VERSION}/dist/libs/${library}`;\n  }\n\n  // TODO - loading inside workers requires paths relative to worker script location...\n  if (isWorker) {\n    return `../src/libs/${library}`;\n  }\n\n  return `modules/${moduleName}/src/libs/${library}`;\n}\n\nasync function loadLibraryFromFile(libraryUrl) {\n  if (libraryUrl.endsWith('wasm')) {\n    const response = await fetch(libraryUrl);\n    return await response.arrayBuffer();\n  }\n\n  if (!isBrowser) {\n    return node.requireFromFile && (await node.requireFromFile(libraryUrl));\n  }\n  if (isWorker) {\n    return importScripts(libraryUrl);\n  }\n  // TODO - fix - should be more secure than string parsing since observes CORS\n  // if (isBrowser) {\n  //   return await loadScriptFromFile(libraryUrl);\n  // }\n\n  const response = await fetch(libraryUrl);\n  const scriptSource = await response.text();\n  return loadLibraryFromString(scriptSource, libraryUrl);\n}\n\n/*\nasync function loadScriptFromFile(libraryUrl) {\n  const script = document.createElement('script');\n  script.src = libraryUrl;\n  return await new Promise((resolve, reject) => {\n    script.onload = data => {\n      resolve(data);\n    };\n    script.onerror = reject;\n  });\n}\n*/\n\n// TODO - Needs security audit...\n//  - Raw eval call\n//  - Potentially bypasses CORS\n// Upside is that this separates fetching and parsing\n// we could create a`LibraryLoader` or`ModuleLoader`\nfunction loadLibraryFromString(scriptSource, id) {\n  if (!isBrowser) {\n    return node.requireFromString && node.requireFromString(scriptSource, id);\n  }\n\n  if (isWorker) {\n    // Use lvalue trick to make eval run in global scope\n    eval.call(global, scriptSource); // eslint-disable-line no-eval\n    // https://stackoverflow.com/questions/9107240/1-evalthis-vs-evalthis-in-javascript\n    // http://perfectionkills.com/global-eval-what-are-the-options/\n    return null;\n  }\n\n  const script = document.createElement('script');\n  script.id = id;\n  // most browsers like a separate text node but some throw an error. The second method covers those.\n  try {\n    script.appendChild(document.createTextNode(scriptSource));\n  } catch (e) {\n    script.text = scriptSource;\n  }\n  document.body.appendChild(script);\n  return null;\n}\n\n// TODO - technique for module injection into worker, from THREE.DracoLoader...\n/*\nfunction combineWorkerWithLibrary(worker, jsContent) {\n  var fn = wWorker.toString();\n  var body = [\n    '// injected',\n    jsContent,\n    '',\n    '// worker',\n    fn.substring(fn.indexOf('{') + 1, fn.lastIndexOf('}'))\n  ].join('\\n');\n  this.workerSourceURL = URL.createObjectURL(new Blob([body]));\n}\n*/\n","import type {WorkerJob, WorkerMessageType, WorkerMessagePayload} from '@loaders.gl/worker-utils';\nimport type {Loader, LoaderOptions, LoaderContext} from '../../types';\nimport {WorkerFarm, getWorkerURL} from '@loaders.gl/worker-utils';\n\n/**\n * Determines if a loader can parse with worker\n * @param loader\n * @param options\n */\nexport function canParseWithWorker(loader: Loader, options?: LoaderOptions) {\n  if (!WorkerFarm.isSupported()) {\n    return false;\n  }\n\n  return loader.worker && options?.worker;\n}\n\n/**\n * this function expects that the worker function sends certain messages,\n * this can be automated if the worker is wrapper by a call to createLoaderWorker in @loaders.gl/loader-utils.\n */\nexport async function parseWithWorker(\n  loader: Loader,\n  data,\n  options?: LoaderOptions,\n  context?: LoaderContext,\n  parseOnMainThread?: (arrayBuffer: ArrayBuffer, options: {[key: string]: any}) => Promise<void>\n) {\n  const name = loader.id; // TODO\n  const url = getWorkerURL(loader, options);\n\n  const workerFarm = WorkerFarm.getWorkerFarm(options);\n  const workerPool = workerFarm.getWorkerPool({name, url});\n\n  // options.log object contains functions which cannot be transferred\n  // TODO - decide how to handle logging on workers\n  options = JSON.parse(JSON.stringify(options));\n\n  const job = await workerPool.startJob(\n    'process-on-worker',\n    // eslint-disable-next-line\n    onMessage.bind(null, parseOnMainThread)\n  );\n\n  job.postMessage('process', {\n    // @ts-ignore\n    input: data,\n    options\n  });\n\n  const result = await job.result;\n  return await result.result;\n}\n\n/**\n * Handle worker's responses to the main thread\n * @param job\n * @param type\n * @param payload\n */\nasync function onMessage(\n  parseOnMainThread,\n  job: WorkerJob,\n  type: WorkerMessageType,\n  payload: WorkerMessagePayload\n) {\n  switch (type) {\n    case 'done':\n      job.done(payload);\n      break;\n\n    case 'error':\n      job.error(payload.error);\n      break;\n\n    case 'process':\n      // Worker is asking for main thread to parseO\n      const {id, input, options} = payload;\n      try {\n        const result = await parseOnMainThread(input, options);\n        job.postMessage('done', {id, result});\n      } catch (error) {\n        const message = error instanceof Error ? error.message : 'unknown error';\n        job.postMessage('error', {id, error: message});\n      }\n      break;\n\n    default:\n      // eslint-disable-next-line\n      console.warn(`parse-with-worker unknown message ${type}`);\n  }\n}\n","import {getFirstCharacters} from '../binary-utils/get-first-characters';\n\n/**\n * Minimal JSON parser that throws more meaningful error messages\n */\nexport function parseJSON(string: string): any {\n  try {\n    return JSON.parse(string);\n  } catch (_) {\n    throw new Error(`Failed to parse JSON from data starting with \"${getFirstCharacters(string)}\"`);\n  }\n}\n","import {TypedArray} from '../../types';\nimport {padToNBytes} from './memory-copy-utils';\n\n/**\n * Copy sourceBuffer to dataView with some padding\n *\n * @param {DataView | null} dataView - destination data container. If null - only new offset is calculated\n * @param {number} byteOffset - destination byte offset to copy to\n * @param {Array | TypedArray} sourceBuffer - source data buffer\n * @param {number} padding - pad the resulting array to multiple of \"padding\" bytes. Additional bytes are filled with 0x20 (ASCII space)\n *\n * @return new byteOffset of resulting dataView\n */\nexport function copyPaddedArrayBufferToDataView(\n  dataView: DataView | null,\n  byteOffset: number,\n  sourceBuffer: TypedArray,\n  padding: number\n) {\n  const paddedLength = padToNBytes(sourceBuffer.byteLength, padding);\n  const padLength = paddedLength - sourceBuffer.byteLength;\n\n  if (dataView) {\n    // Copy array\n    const targetArray = new Uint8Array(\n      dataView.buffer,\n      dataView.byteOffset + byteOffset,\n      sourceBuffer.byteLength\n    );\n    const sourceArray = new Uint8Array(sourceBuffer);\n    targetArray.set(sourceArray);\n\n    // Add PADDING\n    for (let i = 0; i < padLength; ++i) {\n      // json chunk is padded with spaces (ASCII 0x20)\n      dataView.setUint8(byteOffset + sourceBuffer.byteLength + i, 0x20);\n    }\n  }\n  byteOffset += paddedLength;\n  return byteOffset;\n}\n\n/**\n * Copy string to dataView with some padding\n *\n * @param {DataView | null} dataView - destination data container. If null - only new offset is calculated\n * @param {number} byteOffset - destination byte offset to copy to\n * @param {string} string - source string\n * @param {number} padding - pad the resulting array to multiple of \"padding\" bytes. Additional bytes are filled with 0x20 (ASCII space)\n *\n * @return new byteOffset of resulting dataView\n */\nexport function copyPaddedStringToDataView(\n  dataView: DataView | null,\n  byteOffset: number,\n  string: string,\n  padding: number\n): number {\n  const textEncoder = new TextEncoder();\n  // PERFORMANCE IDEA: We encode twice, once to get size and once to store\n  // PERFORMANCE IDEA: Use TextEncoder.encodeInto() to avoid temporary copy\n  const stringBuffer = textEncoder.encode(string);\n\n  byteOffset = copyPaddedArrayBufferToDataView(dataView, byteOffset, stringBuffer, padding);\n\n  return byteOffset;\n}\n","// Note: These were broken out from gltf loader...\n// eslint-disable-next-line complexity\n\n// PERFORMANCE IDEA: No need to copy string twice...\nexport function padStringToByteAlignment(string, byteAlignment) {\n  const length = string.length;\n  const paddedLength = Math.ceil(length / byteAlignment) * byteAlignment; // Round up to the required alignment\n  const padding = paddedLength - length;\n  let whitespace = '';\n  for (let i = 0; i < padding; ++i) {\n    whitespace += ' ';\n  }\n  return string + whitespace;\n}\n\nexport function copyStringToDataView(dataView, byteOffset, string, byteLength) {\n  if (dataView) {\n    for (let i = 0; i < byteLength; i++) {\n      dataView.setUint8(byteOffset + i, string.charCodeAt(i));\n    }\n  }\n  return byteOffset + byteLength;\n}\n\nexport function copyBinaryToDataView(dataView, byteOffset, binary, byteLength) {\n  if (dataView) {\n    for (let i = 0; i < byteLength; i++) {\n      dataView.setUint8(byteOffset + i, binary[i]);\n    }\n  }\n  return byteOffset + byteLength;\n}\n","// TextDecoder iterators\n// TextDecoder will keep any partial undecoded bytes between calls to `decode`\n\nexport async function* makeTextDecoderIterator(\n  arrayBufferIterator: AsyncIterable<ArrayBuffer> | Iterable<ArrayBuffer>,\n  options: TextDecoderOptions = {}\n): AsyncIterable<string> {\n  const textDecoder = new TextDecoder(undefined, options);\n  for await (const arrayBuffer of arrayBufferIterator) {\n    yield typeof arrayBuffer === 'string'\n      ? arrayBuffer\n      : textDecoder.decode(arrayBuffer, {stream: true});\n  }\n}\n\n// TextEncoder iterator\n// TODO - this is not useful unless min chunk size is given\n// TextEncoder will keep any partial undecoded bytes between calls to `encode`\n// If iterator does not yield strings, assume arrayBuffer and return unencoded\n\nexport async function* makeTextEncoderIterator(\n  textIterator: AsyncIterable<string> | Iterable<ArrayBuffer>\n): AsyncIterable<ArrayBuffer> {\n  const textEncoder = new TextEncoder();\n  for await (const text of textIterator) {\n    yield typeof text === 'string' ? textEncoder.encode(text) : text;\n  }\n}\n\n/**\n * @param textIterator async iterable yielding strings\n * @returns an async iterable over lines\n * See http://2ality.com/2018/04/async-iter-nodejs.html\n */\n\nexport async function* makeLineIterator(\n  textIterator: AsyncIterable<string>\n): AsyncIterable<string> {\n  let previous = '';\n  for await (const textChunk of textIterator) {\n    previous += textChunk;\n    let eolIndex;\n    while ((eolIndex = previous.indexOf('\\n')) >= 0) {\n      // line includes the EOL\n      const line = previous.slice(0, eolIndex + 1);\n      previous = previous.slice(eolIndex + 1);\n      yield line;\n    }\n  }\n\n  if (previous.length > 0) {\n    yield previous;\n  }\n}\n\n/**\n * @param lineIterator async iterable yielding lines\n * @returns async iterable yielding numbered lines\n *\n * See http://2ality.com/2018/04/async-iter-nodejs.html\n */\nexport async function* makeNumberedLineIterator(\n  lineIterator: AsyncIterable<string>\n): AsyncIterable<{counter: number; line: string}> {\n  let counter = 1;\n  for await (const line of lineIterator) {\n    yield {counter, line};\n    counter++;\n  }\n}\n","import {concatenateArrayBuffers} from '../binary-utils/array-buffer-utils';\n\n// GENERAL UTILITIES\n\n/**\n * Iterate over async iterator, without resetting iterator if end is not reached\n * - forEach intentionally does not reset iterator if exiting loop prematurely\n *   so that iteration can continue in a second loop\n * - It is recommended to use a standard for-await as last loop to ensure\n *   iterator gets properly reset\n *\n * TODO - optimize using sync iteration if argument is an Iterable?\n *\n * @param iterator\n * @param visitor\n */\nexport async function forEach(iterator, visitor) {\n  // eslint-disable-next-line\n  while (true) {\n    const {done, value} = await iterator.next();\n    if (done) {\n      iterator.return();\n      return;\n    }\n    const cancel = visitor(value);\n    if (cancel) {\n      return;\n    }\n  }\n}\n\n// Breaking big data into iterable chunks, concatenating iterable chunks into big data objects\n\n/**\n * Concatenates all data chunks yielded by an (async) iterator\n * This function can e.g. be used to enable atomic parsers to work on (async) iterator inputs\n */\n\nexport async function concatenateArrayBuffersAsync(\n  asyncIterator: AsyncIterable<ArrayBuffer> | Iterable<ArrayBuffer>\n): Promise<ArrayBuffer> {\n  const arrayBuffers: ArrayBuffer[] = [];\n  for await (const chunk of asyncIterator) {\n    arrayBuffers.push(chunk);\n  }\n  return concatenateArrayBuffers(...arrayBuffers);\n}\n\nexport async function concatenateStringsAsync(\n  asyncIterator: AsyncIterable<string> | Iterable<string>\n): Promise<string> {\n  const strings: string[] = [];\n  for await (const chunk of asyncIterator) {\n    strings.push(chunk);\n  }\n  return strings.join('');\n}\n","import {Stats} from '@probe.gl/stats';\n\ntype Handle = any;\ntype DoneFunction = () => any;\ntype GetPriorityFunction = () => number;\ntype RequestResult = {\n  done: DoneFunction;\n} | null;\n\n/** RequestScheduler Options */\nexport type RequestSchedulerProps = {\n  id?: string;\n  throttleRequests?: boolean;\n  maxRequests?: number;\n};\n\nconst STAT_QUEUED_REQUESTS = 'Queued Requests';\nconst STAT_ACTIVE_REQUESTS = 'Active Requests';\nconst STAT_CANCELLED_REQUESTS = 'Cancelled Requests';\nconst STAT_QUEUED_REQUESTS_EVER = 'Queued Requests Ever';\nconst STAT_ACTIVE_REQUESTS_EVER = 'Active Requests Ever';\n\nconst DEFAULT_PROPS: Required<RequestSchedulerProps> = {\n  id: 'request-scheduler',\n  // Specifies if the request scheduler should throttle incoming requests, mainly for comparative testing\n  throttleRequests: true,\n  // The maximum number of simultaneous active requests. Un-throttled requests do not observe this limit.\n  maxRequests: 6\n};\n\n/** Tracks one request */\ntype Request = {\n  handle: Handle;\n  priority: number;\n  getPriority: GetPriorityFunction;\n  resolve?: (value: any) => any;\n};\n\n/**\n * Used to issue a request, without having them \"deeply queued\" by the browser.\n * @todo - Track requests globally, across multiple servers\n */\nexport default class RequestScheduler {\n  readonly props: Required<RequestSchedulerProps>;\n  readonly stats: Stats;\n  activeRequestCount: number = 0;\n\n  /** Tracks the number of active requests and prioritizes/cancels queued requests. */\n  private requestQueue: Request[] = [];\n  private requestMap: Map<Handle, Promise<RequestResult>> = new Map();\n  private deferredUpdate: any = null;\n\n  constructor(props: RequestSchedulerProps = {}) {\n    this.props = {...DEFAULT_PROPS, ...props};\n\n    // Returns the statistics used by the request scheduler.\n    this.stats = new Stats({id: this.props.id});\n    this.stats.get(STAT_QUEUED_REQUESTS);\n    this.stats.get(STAT_ACTIVE_REQUESTS);\n    this.stats.get(STAT_CANCELLED_REQUESTS);\n    this.stats.get(STAT_QUEUED_REQUESTS_EVER);\n    this.stats.get(STAT_ACTIVE_REQUESTS_EVER);\n  }\n\n  /**\n   * Called by an application that wants to issue a request, without having it deeply queued by the browser\n   *\n   * When the returned promise resolved, it is OK for the application to issue a request.\n   * The promise resolves to an object that contains a `done` method.\n   * When the application's request has completed (or failed), the application must call the `done` function\n   *\n   * @param handle\n   * @param getPriority will be called when request \"slots\" open up,\n   *    allowing the caller to update priority or cancel the request\n   *    Highest priority executes first, priority < 0 cancels the request\n   * @returns a promise\n   *   - resolves to a object (with a `done` field) when the request can be issued without queueing,\n   *   - resolves to `null` if the request has been cancelled (by the callback return < 0).\n   *     In this case the application should not issue the request\n   */\n  scheduleRequest(\n    handle: Handle,\n    getPriority: GetPriorityFunction = () => 0\n  ): Promise<RequestResult> {\n    // Allows throttling to be disabled\n    if (!this.props.throttleRequests) {\n      return Promise.resolve({done: () => {}});\n    }\n\n    // dedupe\n    if (this.requestMap.has(handle)) {\n      return this.requestMap.get(handle) as Promise<any>;\n    }\n\n    const request: Request = {handle, priority: 0, getPriority};\n    const promise = new Promise<RequestResult>((resolve) => {\n      // @ts-ignore\n      request.resolve = resolve;\n      return request;\n    });\n\n    this.requestQueue.push(request);\n    this.requestMap.set(handle, promise);\n    this._issueNewRequests();\n    return promise;\n  }\n\n  // PRIVATE\n\n  _issueRequest(request: Request): Promise<any> {\n    const {handle, resolve} = request;\n    let isDone = false;\n\n    const done = () => {\n      // can only be called once\n      if (!isDone) {\n        isDone = true;\n\n        // Stop tracking a request - it has completed, failed, cancelled etc\n        this.requestMap.delete(handle);\n        this.activeRequestCount--;\n        // A slot just freed up, see if any queued requests are waiting\n        this._issueNewRequests();\n      }\n    };\n\n    // Track this request\n    this.activeRequestCount++;\n\n    return resolve ? resolve({done}) : Promise.resolve({done});\n  }\n\n  /** We check requests asynchronously, to prevent multiple updates */\n  _issueNewRequests(): void {\n    if (!this.deferredUpdate) {\n      this.deferredUpdate = setTimeout(() => this._issueNewRequestsAsync(), 0);\n    }\n  }\n\n  /** Refresh all requests  */\n  _issueNewRequestsAsync() {\n    // TODO - shouldn't we clear the timeout?\n    this.deferredUpdate = null;\n\n    const freeSlots = Math.max(this.props.maxRequests - this.activeRequestCount, 0);\n\n    if (freeSlots === 0) {\n      return;\n    }\n\n    this._updateAllRequests();\n\n    // Resolve pending promises for the top-priority requests\n    for (let i = 0; i < freeSlots; ++i) {\n      const request = this.requestQueue.shift();\n      if (request) {\n        this._issueRequest(request); // eslint-disable-line @typescript-eslint/no-floating-promises\n      }\n    }\n\n    // Uncomment to debug\n    // console.log(`${freeSlots} free slots, ${this.requestQueue.length} queued requests`);\n  }\n\n  /** Ensure all requests have updated priorities, and that no longer valid requests are cancelled */\n  _updateAllRequests() {\n    const requestQueue = this.requestQueue;\n    for (let i = 0; i < requestQueue.length; ++i) {\n      const request = requestQueue[i];\n      if (!this._updateRequest(request)) {\n        // Remove the element and make sure to adjust the counter to account for shortened array\n        requestQueue.splice(i, 1);\n        this.requestMap.delete(request.handle);\n        i--;\n      }\n    }\n\n    // Sort the remaining requests based on priority\n    requestQueue.sort((a, b) => a.priority - b.priority);\n  }\n\n  /** Update a single request by calling the callback */\n  _updateRequest(request) {\n    request.priority = request.getPriority(request.handle); // eslint-disable-line callback-return\n\n    // by returning a negative priority, the callback cancels the request\n    if (request.priority < 0) {\n      request.resolve(null);\n      return false;\n    }\n    return true;\n  }\n}\n","// Simple file alias mechanisms for tests.\n\nlet pathPrefix = '';\nconst fileAliases: {[aliasPath: string]: string} = {};\n\n/*\n * Set a relative path prefix\n */\nexport function setPathPrefix(prefix: string): void {\n  pathPrefix = prefix;\n}\n\n/*\n * Get the relative path prefix\n */\nexport function getPathPrefix(): string {\n  return pathPrefix;\n}\n\n/**\n *\n * @param aliases\n *\n * Note: addAliases are an experimental export, they are only for testing of loaders.gl loaders\n * not intended as a generic aliasing mechanism\n */\nexport function addAliases(aliases: {[aliasPath: string]: string}): void {\n  Object.assign(fileAliases, aliases);\n}\n\n/**\n * Resolves aliases and adds path-prefix to paths\n */\nexport function resolvePath(filename: string): string {\n  for (const alias in fileAliases) {\n    if (filename.startsWith(alias)) {\n      const replacement = fileAliases[alias];\n      filename = filename.replace(alias, replacement);\n    }\n  }\n  if (!filename.startsWith('http://') && !filename.startsWith('https://')) {\n    filename = `${pathPrefix}${filename}`;\n  }\n  return filename;\n}\n","import type {LoaderWithParser} from './types';\n\n// __VERSION__ is injected by babel-plugin-version-inline\n// @ts-ignore TS2304: Cannot find name '__VERSION__'.\nconst VERSION = typeof __VERSION__ !== 'undefined' ? __VERSION__ : 'latest';\n\n/**\n * A JSON Micro loader (minimal bundle size)\n * Alternative to `@loaders.gl/json`\n */\nexport const JSONLoader = {\n  name: 'JSON',\n  id: 'json',\n  module: 'json',\n  version: VERSION,\n  extensions: ['json', 'geojson'],\n  mimeTypes: ['application/json'],\n  category: 'json',\n  text: true,\n  parseTextSync,\n  parse: async (arrayBuffer) => parseTextSync(new TextDecoder().decode(arrayBuffer)),\n  options: {}\n};\n\n// TODO - deprecated\nfunction parseTextSync(text) {\n  return JSON.parse(text);\n}\n\nexport const _typecheckJSONLoader: LoaderWithParser = JSONLoader;\n","// Beginning of a minimal implementation of the Node.js path API, that doesn't pull in big polyfills.\n\n/**\n * Replacement for Node.js path.dirname\n * @param url\n */\nexport function dirname(url: string): string {\n  const slashIndex = url && url.lastIndexOf('/');\n  return slashIndex >= 0 ? url.substr(0, slashIndex as number) : '';\n}\n\n/**\n * Replacement for Node.js path.join\n * @param parts\n */\nexport function join(...parts: string[]): string {\n  const separator = '/';\n  parts = parts.map((part, index) => {\n    if (index) {\n      part = part.replace(new RegExp(`^${separator}`), '');\n    }\n    if (index !== parts.length - 1) {\n      part = part.replace(new RegExp(`${separator}$`), '');\n    }\n    return part;\n  });\n  return parts.join(separator);\n}\n","import * as fs from '../node/fs';\nimport {IFileSystem, IRandomAccessReadFileSystem} from '@loaders.gl/loader-utils';\n// import {fetchFile} from \"../fetch/fetch-file\"\n// import {selectLoader} from \"../api/select-loader\";\n\ntype Stat = {\n  size: number;\n  isDirectory: () => boolean;\n  info?: fs.Stats;\n};\n\ntype ReadOptions = {\n  buffer?: Buffer;\n  offset?: number;\n  length?: number;\n  position?: number;\n};\n\n/**\n * FileSystem pass-through for Node.js\n * Compatible with BrowserFileSystem.\n * @param options\n */\nexport default class NodeFileSystem implements IFileSystem, IRandomAccessReadFileSystem {\n  // implements IFileSystem\n  constructor(options: {[key: string]: any}) {\n    this.fetch = options._fetch;\n  }\n\n  async readdir(dirname = '.', options?: {}): Promise<any[]> {\n    return await fs.readdir(dirname, options);\n  }\n\n  async stat(path: string, options?: {}): Promise<Stat> {\n    const info = await fs.stat(path, options);\n    return {size: Number(info.size), isDirectory: () => false, info};\n  }\n\n  async fetch(path: string, options: {[key: string]: any}) {\n    // Falls back to handle https:/http:/data: etc fetches\n    // eslint-disable-next-line\n    const fallbackFetch = options.fetch || this.fetch;\n    return fallbackFetch(path, options);\n  }\n\n  // implements IRandomAccessFileSystem\n  async open(path: string, flags: string | number, mode?: any): Promise<number> {\n    return await fs.open(path, flags);\n  }\n\n  async close(fd: number): Promise<void> {\n    return await fs.close(fd);\n  }\n\n  async fstat(fd: number): Promise<Stat> {\n    const info = await fs.fstat(fd);\n    return info;\n  }\n\n  async read(\n    fd: number,\n    // @ts-ignore Possibly null\n    {buffer = null, offset = 0, length = buffer.byteLength, position = null}: ReadOptions\n  ): Promise<{bytesRead: number; buffer: Buffer}> {\n    let totalBytesRead = 0;\n    // Read in loop until we get required number of bytes\n    while (totalBytesRead < length) {\n      const {bytesRead} = await fs.read(\n        fd,\n        buffer,\n        offset + totalBytesRead,\n        length - totalBytesRead,\n        position + totalBytesRead\n      );\n      totalBytesRead += bytesRead;\n    }\n    return {bytesRead: totalBytesRead, buffer};\n  }\n}\n","import {asyncDeepMap} from './async-deep-map';\n\nexport async function deepLoad(urlTree, load, options) {\n  return await asyncDeepMap(urlTree, (url) => shallowLoad(url, load, options));\n}\n\nexport async function shallowLoad(url, load, options) {\n  // console.error('loading', url);\n  const response = await fetch(url, options.fetch);\n  const arrayBuffer = await response.arrayBuffer();\n  return await load(arrayBuffer, options);\n}\n","/*\nAsynchronously maps a deep structure of values (e.g. objects and arrays of urls).\n\nE.g. a mipmapped cubemap\n{\n  [CUBE_FACE_FRONT]: [\n    \"image-front-0.jpg\",\n    \"image-front-1.jpg\",\n    \"image-front-2.jpg\",\n  ],\n  [CUBE_MAP_BACK]: [\n    ...\n  ]\n}\n*/\n\nconst isObject = (value) => value && typeof value === 'object';\n\n// Loads a deep structure of urls (objects and arrays of urls)\n// Returns an object with six key-value pairs containing the images (or image mip arrays)\n// for each cube face\nexport async function asyncDeepMap(tree, func, options = {}) {\n  return await mapSubtree(tree, func, options);\n}\n\nexport async function mapSubtree(object, func, options) {\n  if (Array.isArray(object)) {\n    return await mapArray(object, func, options);\n  }\n\n  if (isObject(object)) {\n    return await mapObject(object, func, options);\n  }\n\n  // TODO - ignore non-urls, non-arraybuffers?\n  const url = object;\n  return await func(url, options);\n}\n\n// HELPERS\n\nasync function mapObject(object, func, options) {\n  const promises: Promise<any>[] = [];\n  const values = {};\n\n  for (const key in object) {\n    const url = object[key];\n    const promise = mapSubtree(url, func, options).then((value) => {\n      values[key] = value;\n    });\n    promises.push(promise);\n  }\n\n  await Promise.all(promises);\n\n  return values;\n}\n\nasync function mapArray(urlArray, func, options = {}) {\n  const promises = urlArray.map((url) => mapSubtree(url, func, options));\n  return await Promise.all(promises);\n}\n","// Resolves a relative url against a baseUrl\n// If url is absolute, return it unchanged\nexport function resolveUrl(url, options) {\n  // TODO: Use better logic to handle all protocols plus not delay on data\n  const absolute = url.startsWith('data:') || url.startsWith('http:') || url.startsWith('https:');\n  if (absolute) {\n    return url;\n  }\n  const baseUrl = options.baseUri || options.uri;\n  if (!baseUrl) {\n    throw new Error(`'baseUri' must be provided to resolve relative url ${url}`);\n  }\n  return baseUrl.substr(0, baseUrl.lastIndexOf('/') + 1) + url;\n}\n","// TODO - GLTFScenegraph should use these\nimport {assert} from '../utils/assert';\n\n// accepts buffer view index or buffer view object\n// returns a `Uint8Array`\nexport function getTypedArrayForBufferView(json, buffers, bufferViewIndex) {\n  const bufferView = json.bufferViews[bufferViewIndex];\n  assert(bufferView);\n\n  // Get hold of the arrayBuffer\n  const bufferIndex = bufferView.buffer;\n  const binChunk = buffers[bufferIndex];\n  assert(binChunk);\n\n  const byteOffset = (bufferView.byteOffset || 0) + binChunk.byteOffset;\n  return new Uint8Array(binChunk.arrayBuffer, byteOffset, bufferView.byteLength);\n}\n\n// accepts accessor index or accessor object\n// returns a `Uint8Array`\nexport function getTypedArrayForImageData(json, buffers, imageIndex) {\n  const image = json.images[imageIndex];\n  const bufferViewIndex = json.bufferViews[image.bufferView];\n  return getTypedArrayForBufferView(json, buffers, bufferViewIndex);\n}\n\n/*\n// accepts accessor index or accessor object\n// returns a typed array with type that matches the types\nexport function getTypedArrayForAccessor(accessor) {\n  accessor = this.getAccessor(accessor);\n  const bufferView = this.getBufferView(accessor.bufferView);\n  const buffer = this.getBuffer(bufferView.buffer);\n  const arrayBuffer = buffer.data;\n\n  // Create a new typed array as a view into the combined buffer\n  const {ArrayType, length} = getAccessorArrayTypeAndLength(accessor, bufferView);\n  const byteOffset = bufferView.byteOffset + accessor.byteOffset;\n  return new ArrayType(arrayBuffer, byteOffset, length);\n}\n*/\n","/* eslint-disable camelcase */\nimport {GLTF} from '../types/gltf-types';\nimport type {GLTFLoaderOptions} from '../../gltf-loader';\n\n// GLTF 1.0 extensions (read only)\n// import * as KHR_binary_gltf from './KHR_draco_mesh_compression';\n\n// GLTF 2.0 extensions (read/write)\nimport * as KHR_draco_mesh_compression from './KHR_draco_mesh_compression';\nimport * as KHR_materials_unlit from './KHR_materials_unlit';\nimport * as KHR_lights_punctual from './KHR_lights_punctual';\nimport * as KHR_techniques_webgl from './KHR_techniques_webgl';\n\ntype GLTFExtensionPlugin = {\n  decode: (gltfData: {json: GLTF}, options: GLTFLoaderOptions, context) => Promise<void>;\n\n  encode: (gltfData: {json: GLTF}, options: GLTFLoaderOptions) => void;\n};\n\n/**\n * List of extensions processed by the GLTFLoader\n * Note that may extensions can only be handled on the rendering stage and are left out here\n * These are just extensions that can be handled fully or partially during loading.\n */\nexport const EXTENSIONS: {[extensionName: string]: GLTFExtensionPlugin} = {\n  // 1.0\n  // KHR_binary_gltf is handled separately - must be processed before other parsing starts\n  // KHR_binary_gltf,\n\n  // 2.0\n  KHR_draco_mesh_compression,\n  KHR_materials_unlit,\n  KHR_lights_punctual,\n  KHR_techniques_webgl\n};\n\nexport async function decodeExtensions(gltf, options: GLTFLoaderOptions = {}, context?) {\n  for (const extensionName in EXTENSIONS) {\n    const excludes = options?.gltf?.excludeExtensions || {};\n    const exclude = extensionName in excludes && !excludes[extensionName];\n    if (!exclude) {\n      const extension = EXTENSIONS[extensionName];\n      // Note: We decode async extensions sequentially, this might not be necessary\n      // Currently we only have Draco, but when we add Basis we may revisit\n      await extension.decode(gltf, options, context);\n    }\n  }\n}\n","// https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression\n// Only TRIANGLES: 0x0004 and TRIANGLE_STRIP: 0x0005 are supported\n\n/* eslint-disable camelcase */\nimport type {GLTF, GLTFAccessor, GLTFMeshPrimitive} from '../types/gltf-types';\nimport type {GLTFLoaderOptions} from '../../gltf-loader';\n\nimport type {LoaderContext} from '@loaders.gl/loader-utils';\nimport {DracoLoader} from '@loaders.gl/draco';\nimport {DracoLoaderOptions, DracoMeshData} from '@loaders.gl/draco';\nimport {sliceArrayBuffer} from '@loaders.gl/loader-utils';\nimport {default as Scenegraph} from '../api/gltf-scenegraph';\nimport {KHR_DRACO_MESH_COMPRESSION} from '../gltf-utils/gltf-constants';\nimport {getGLTFAccessors, getGLTFAccessor} from '../gltf-utils/gltf-attribute-utils';\n\n// Note: We have a \"soft dependency\" on DracoWriter to avoid bundling it when not needed\nexport async function decode(\n  gltfData: {json: GLTF},\n  options: GLTFLoaderOptions,\n  context: LoaderContext\n): Promise<void> {\n  if (!options?.gltf?.decompressMeshes) {\n    return;\n  }\n\n  const scenegraph = new Scenegraph(gltfData);\n  const promises: Promise<void>[] = [];\n  for (const primitive of makeMeshPrimitiveIterator(scenegraph)) {\n    if (scenegraph.getObjectExtension(primitive, KHR_DRACO_MESH_COMPRESSION)) {\n      promises.push(decompressPrimitive(scenegraph, primitive, options, context));\n    }\n  }\n\n  // Decompress meshes in parallel\n  await Promise.all(promises);\n\n  // We have now decompressed all primitives, so remove the top-level extensions\n  scenegraph.removeExtension(KHR_DRACO_MESH_COMPRESSION);\n}\n\nexport function encode(gltfData, options: GLTFLoaderOptions = {}): void {\n  const scenegraph = new Scenegraph(gltfData);\n\n  for (const mesh of scenegraph.json.meshes || []) {\n    // eslint-disable-next-line camelcase\n    // @ts-ignore\n    compressMesh(mesh, options);\n    // NOTE: Only add the extension if something was actually compressed\n    scenegraph.addRequiredExtension(KHR_DRACO_MESH_COMPRESSION);\n  }\n}\n\n// DECODE\n\n// Unpacks one mesh primitive and removes the extension from the primitive\n// DracoDecoder needs to be imported and registered by app\n// Returns: Promise that resolves when all pending draco decoder jobs for this mesh complete\n\n// TODO - Implement fallback behavior per KHR_DRACO_MESH_COMPRESSION spec\n\nasync function decompressPrimitive(\n  scenegraph: Scenegraph,\n  primitive: GLTFMeshPrimitive,\n  options: GLTFLoaderOptions,\n  context: LoaderContext\n): Promise<void> {\n  const dracoExtension = scenegraph.getObjectExtension(primitive, KHR_DRACO_MESH_COMPRESSION);\n  if (!dracoExtension) {\n    return;\n  }\n\n  const buffer = scenegraph.getTypedArrayForBufferView(dracoExtension.bufferView);\n  // TODO - parse does not yet deal well with byte offsets embedded in typed arrays. Copy buffer\n  // TODO - remove when `parse` is fixed to handle `byteOffset`s\n  const bufferCopy = sliceArrayBuffer(buffer.buffer, buffer.byteOffset); // , buffer.byteLength);\n\n  const {parse} = context;\n  const dracoOptions: DracoLoaderOptions = {...options};\n\n  // TODO - remove hack: The entire tileset might be included, too expensive to serialize\n  delete dracoOptions['3d-tiles'];\n  const decodedData = (await parse(\n    bufferCopy,\n    DracoLoader,\n    dracoOptions,\n    context\n  )) as DracoMeshData;\n\n  const decodedAttributes: {[key: string]: GLTFAccessor} = getGLTFAccessors(decodedData.attributes);\n\n  // Restore min/max values\n  for (const [attributeName, decodedAttribute] of Object.entries(decodedAttributes)) {\n    if (attributeName in primitive.attributes) {\n      const accessorIndex: number = primitive.attributes[attributeName];\n      const accessor = scenegraph.getAccessor(accessorIndex);\n      if (accessor?.min && accessor?.max) {\n        decodedAttribute.min = accessor.min;\n        decodedAttribute.max = accessor.max;\n      }\n    }\n  }\n\n  // @ts-ignore\n  primitive.attributes = decodedAttributes;\n  if (decodedData.indices) {\n    // @ts-ignore\n    primitive.indices = getGLTFAccessor(decodedData.indices);\n  }\n\n  // Extension has been processed, delete it\n  // delete primitive.extensions[KHR_DRACO_MESH_COMPRESSION];\n\n  checkPrimitive(primitive);\n}\n\n// ENCODE\n\n// eslint-disable-next-line max-len\n// Only TRIANGLES: 0x0004 and TRIANGLE_STRIP: 0x0005 are supported\nfunction compressMesh(attributes, indices, mode: number = 4, options, context: LoaderContext) {\n  if (!options.DracoWriter) {\n    throw new Error('options.gltf.DracoWriter not provided');\n  }\n\n  // TODO - use DracoWriter using encode w/ registered DracoWriter...\n  const compressedData = options.DracoWriter.encodeSync({attributes});\n\n  // Draco compression may change the order and number of vertices in a mesh.\n  // To satisfy the requirement that accessors properties be correct for both\n  // compressed and uncompressed data, generators should create uncompressed\n  // attributes and indices using data that has been decompressed from the Draco buffer,\n  // rather than the original source data.\n  // @ts-ignore TODO this needs to be fixed\n  const decodedData = context?.parseSync?.({attributes});\n  const fauxAccessors = options._addFauxAttributes(decodedData.attributes);\n\n  const bufferViewIndex = options.addBufferView(compressedData);\n\n  const glTFMesh = {\n    primitives: [\n      {\n        attributes: fauxAccessors, // TODO - verify with spec\n        mode, // GL.POINTS\n        extensions: {\n          [KHR_DRACO_MESH_COMPRESSION]: {\n            bufferView: bufferViewIndex,\n            attributes: fauxAccessors // TODO - verify with spec\n          }\n        }\n      }\n    ]\n  };\n\n  return glTFMesh;\n}\n\n// UTILS\n\nfunction checkPrimitive(primitive: GLTFMeshPrimitive) {\n  if (!primitive.attributes && Object.keys(primitive.attributes).length > 0) {\n    throw new Error('glTF: Empty primitive detected: Draco decompression failure?');\n  }\n}\n\nfunction* makeMeshPrimitiveIterator(scenegraph) {\n  for (const mesh of scenegraph.json.meshes || []) {\n    for (const primitive of mesh.primitives) {\n      yield primitive;\n    }\n  }\n}\n","import type {LoaderWithParser} from '@loaders.gl/loader-utils';\nimport type {DracoMeshData, DracoLoaderData} from './lib/draco-types';\nimport type {DracoLoaderOptions} from './draco-loader';\nimport {DracoLoader as DracoWorkerLoader} from './draco-loader';\nimport DracoParser from './lib/draco-parser';\nimport {loadDracoDecoderModule} from './lib/draco-module-loader';\n\n// Draco data types\n\nexport type {DracoMeshData, DracoLoaderData};\n\n// Draco Writer\n\nexport type {DracoWriterOptions} from './draco-writer';\nexport {DracoWriter} from './draco-writer';\n\n// Draco Loader\n\nexport type {DracoLoaderOptions};\nexport {DracoWorkerLoader};\n\n/**\n * Loader for Draco3D compressed geometries\n */\nexport const DracoLoader = {\n  ...DracoWorkerLoader,\n  parse\n};\n\nasync function parse(\n  arrayBuffer: ArrayBuffer,\n  options?: DracoLoaderOptions\n): Promise<DracoMeshData> {\n  const {draco} = await loadDracoDecoderModule(options);\n  const dracoParser = new DracoParser(draco);\n  try {\n    return dracoParser.parseSync(arrayBuffer, options?.draco);\n  } finally {\n    dracoParser.destroy();\n  }\n}\n\n// TYPE TESTS - TODO find a better way than exporting junk\nexport const _TypecheckDracoLoader: LoaderWithParser = DracoLoader;\n","import type {Loader, LoaderOptions} from '@loaders.gl/loader-utils';\nimport type {DracoParseOptions} from './lib/draco-parser';\n// import type {DracoMeshData} from './types';\nimport {VERSION} from './lib/utils/version';\n\nexport type DracoLoaderOptions = LoaderOptions & {\n  draco?: DracoParseOptions & {\n    decoderType?: 'wasm' | 'js';\n    libraryPath?: string;\n    extraAttributes?;\n    attributeNameEntry?: string;\n  };\n};\n\nconst DEFAULT_DRACO_OPTIONS: DracoLoaderOptions = {\n  draco: {\n    decoderType: typeof WebAssembly === 'object' ? 'wasm' : 'js', // 'js' for IE11\n    libraryPath: 'libs/',\n    extraAttributes: {},\n    attributeNameEntry: undefined\n  }\n};\n\n/**\n * Worker loader for Draco3D compressed geometries\n */\nexport const DracoLoader = {\n  name: 'Draco',\n  id: 'draco',\n  module: 'draco',\n  version: VERSION,\n  worker: true,\n  extensions: ['drc'],\n  mimeTypes: ['application/octet-stream'],\n  binary: true,\n  tests: ['DRACO'],\n  options: DEFAULT_DRACO_OPTIONS\n};\n\nexport const _TypecheckDracoLoader: Loader = DracoLoader;\n","/* eslint-disable camelcase */\n\n// Draco types (input)\nimport type {\n  Draco3D,\n  Decoder,\n  Mesh,\n  PointCloud,\n  PointAttribute,\n  Metadata,\n  MetadataQuerier,\n  DracoInt32Array,\n  draco_DataType\n} from '../draco3d/draco3d-types';\n\n// Parsed data types (output)\nimport type {\n  TypedArray,\n  // standard mesh output data\n  MeshData,\n  MeshAttribute,\n  // standard mesh with draco metadata\n  DracoMeshData,\n  DracoLoaderData,\n  DracoAttribute,\n  DracoMetadataEntry,\n  DracoQuantizationTransform,\n  DracoOctahedronTransform\n} from './draco-types';\n\nimport {getMeshBoundingBox} from '@loaders.gl/schema';\nimport {makeSchemaFromAttributes} from './utils/schema-attribute-utils';\n\n/**\n * @param topology - How triangle indices should be generated (mesh only)\n * @param attributeNameEntry\n * @param extraAttributes\n * @param quantizedAttributes\n * @param octahedronAttributes\n */\nexport type DracoParseOptions = {\n  topology?: 'triangle-list' | 'triangle-strip';\n  attributeNameEntry?: string;\n  extraAttributes?: {[uniqueId: string]: number};\n  quantizedAttributes?: ('POSITION' | 'NORMAL' | 'COLOR' | 'TEX_COORD' | 'GENERIC')[];\n  octahedronAttributes?: ('POSITION' | 'NORMAL' | 'COLOR' | 'TEX_COORD' | 'GENERIC')[];\n};\n\n// @ts-ignore\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst GEOMETRY_TYPE = {\n  TRIANGULAR_MESH: 0,\n  POINT_CLOUD: 1\n};\n\n// Native Draco attribute names to GLTF attribute names.\nconst DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP = {\n  POSITION: 'POSITION',\n  NORMAL: 'NORMAL',\n  COLOR: 'COLOR_0',\n  TEX_COORD: 'TEXCOORD_0'\n};\n\nconst DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP = {\n  1: Int8Array,\n  2: Uint8Array,\n  3: Int16Array,\n  4: Uint16Array,\n  5: Int32Array,\n  6: Uint32Array,\n  9: Float32Array\n};\n\nconst INDEX_ITEM_SIZE = 4;\n\nexport default class DracoParser {\n  draco: Draco3D;\n  decoder: Decoder;\n  metadataQuerier: MetadataQuerier;\n\n  // draco - the draco decoder, either import `draco3d` or load dynamically\n  constructor(draco: Draco3D) {\n    this.draco = draco;\n    this.decoder = new this.draco.Decoder();\n    this.metadataQuerier = new this.draco.MetadataQuerier();\n  }\n\n  /**\n   * Destroy draco resources\n   */\n  destroy(): void {\n    this.draco.destroy(this.decoder);\n    this.draco.destroy(this.metadataQuerier);\n  }\n\n  /**\n   * NOTE: caller must call `destroyGeometry` on the return value after using it\n   * @param arrayBuffer\n   * @param options\n   */\n  parseSync(arrayBuffer: ArrayBuffer, options: DracoParseOptions = {}): DracoMeshData {\n    const buffer = new this.draco.DecoderBuffer();\n    buffer.Init(new Int8Array(arrayBuffer), arrayBuffer.byteLength);\n\n    this._disableAttributeTransforms(options);\n\n    const geometry_type = this.decoder.GetEncodedGeometryType(buffer);\n    const dracoGeometry =\n      geometry_type === this.draco.TRIANGULAR_MESH\n        ? new this.draco.Mesh()\n        : new this.draco.PointCloud();\n\n    try {\n      let dracoStatus;\n      switch (geometry_type) {\n        case this.draco.TRIANGULAR_MESH:\n          dracoStatus = this.decoder.DecodeBufferToMesh(buffer, dracoGeometry as Mesh);\n          break;\n\n        case this.draco.POINT_CLOUD:\n          dracoStatus = this.decoder.DecodeBufferToPointCloud(buffer, dracoGeometry);\n          break;\n\n        default:\n          throw new Error('DRACO: Unknown geometry type.');\n      }\n\n      if (!dracoStatus.ok() || !dracoGeometry.ptr) {\n        const message = `DRACO decompression failed: ${dracoStatus.error_msg()}`;\n        // console.error(message);\n        throw new Error(message);\n      }\n\n      const loaderData = this._getDracoLoaderData(dracoGeometry, geometry_type, options);\n\n      const geometry = this._getMeshData(dracoGeometry, loaderData, options);\n\n      const boundingBox = getMeshBoundingBox(geometry.attributes);\n\n      const schema = makeSchemaFromAttributes(geometry.attributes, loaderData, geometry.indices);\n\n      const data: DracoMeshData = {\n        loader: 'draco',\n        loaderData,\n        header: {\n          vertexCount: dracoGeometry.num_points(),\n          boundingBox\n        },\n        ...geometry,\n        schema\n      };\n      return data;\n    } finally {\n      this.draco.destroy(buffer);\n      if (dracoGeometry) {\n        this.draco.destroy(dracoGeometry);\n      }\n    }\n  }\n\n  // Draco specific \"loader data\"\n\n  /**\n   * Extract\n   * @param dracoGeometry\n   * @param geometry_type\n   * @param options\n   * @returns\n   */\n  _getDracoLoaderData(\n    dracoGeometry: Mesh | PointCloud,\n    geometry_type,\n    options: DracoParseOptions\n  ): DracoLoaderData {\n    const metadata = this._getTopLevelMetadata(dracoGeometry);\n    const attributes = this._getDracoAttributes(dracoGeometry, options);\n\n    return {\n      geometry_type,\n      num_attributes: dracoGeometry.num_attributes(),\n      num_points: dracoGeometry.num_points(),\n      num_faces: dracoGeometry instanceof this.draco.Mesh ? dracoGeometry.num_faces() : 0,\n      metadata,\n      attributes\n    };\n  }\n\n  /**\n   * Extract all draco provided information and metadata for each attribute\n   * @param dracoGeometry\n   * @param options\n   * @returns\n   */\n  _getDracoAttributes(\n    dracoGeometry: Mesh | PointCloud,\n    options: DracoParseOptions\n  ): {[unique_id: number]: DracoAttribute} {\n    const dracoAttributes: {[unique_id: number]: DracoAttribute} = {};\n\n    for (let attributeId = 0; attributeId < dracoGeometry.num_attributes(); attributeId++) {\n      // Note: Draco docs do not seem clear on `GetAttribute` ids just being a zero-based index,\n      // but it does seems to work this way\n      const dracoAttribute = this.decoder.GetAttribute(dracoGeometry, attributeId);\n\n      const metadata = this._getAttributeMetadata(dracoGeometry, attributeId);\n\n      dracoAttributes[dracoAttribute.unique_id()] = {\n        unique_id: dracoAttribute.unique_id(),\n        attribute_type: dracoAttribute.attribute_type(),\n        data_type: dracoAttribute.data_type(),\n        num_components: dracoAttribute.num_components(),\n\n        byte_offset: dracoAttribute.byte_offset(),\n        byte_stride: dracoAttribute.byte_stride(),\n        normalized: dracoAttribute.normalized(),\n        attribute_index: attributeId,\n\n        metadata\n      };\n\n      // Add transformation parameters for any attributes app wants untransformed\n      const quantization = this._getQuantizationTransform(dracoAttribute, options);\n      if (quantization) {\n        dracoAttributes[dracoAttribute.unique_id()].quantization_transform = quantization;\n      }\n\n      const octahedron = this._getOctahedronTransform(dracoAttribute, options);\n      if (octahedron) {\n        dracoAttributes[dracoAttribute.unique_id()].octahedron_transform = octahedron;\n      }\n    }\n\n    return dracoAttributes;\n  }\n\n  /**\n   * Get standard loaders.gl mesh category data\n   * Extracts the geometry from draco\n   * @param dracoGeometry\n   * @param options\n   */\n  _getMeshData(\n    dracoGeometry: Mesh | PointCloud,\n    loaderData: DracoLoaderData,\n    options: DracoParseOptions\n  ): MeshData {\n    const attributes = this._getMeshAttributes(loaderData, dracoGeometry, options);\n\n    const positionAttribute = attributes.POSITION;\n    if (!positionAttribute) {\n      throw new Error('DRACO: No position attribute found.');\n    }\n\n    // For meshes, we need indices to define the faces.\n    if (dracoGeometry instanceof this.draco.Mesh) {\n      switch (options.topology) {\n        case 'triangle-strip':\n          return {\n            topology: 'triangle-strip',\n            mode: 4, // GL.TRIANGLES\n            attributes,\n            indices: {\n              value: this._getTriangleStripIndices(dracoGeometry),\n              size: 1\n            }\n          };\n        case 'triangle-list':\n        default:\n          return {\n            topology: 'triangle-list',\n            mode: 5, // GL.TRIANGLE_STRIP\n            attributes,\n            indices: {\n              value: this._getTriangleListIndices(dracoGeometry),\n              size: 1\n            }\n          };\n      }\n    }\n\n    // PointCloud - must come last as Mesh inherits from PointCloud\n    return {\n      topology: 'point-list',\n      mode: 0, // GL.POINTS\n      attributes\n    };\n  }\n\n  _getMeshAttributes(\n    loaderData: DracoLoaderData,\n    dracoGeometry: Mesh | PointCloud,\n    options: DracoParseOptions\n  ): {[attributeName: string]: MeshAttribute} {\n    const attributes: {[key: string]: MeshAttribute} = {};\n\n    for (const loaderAttribute of Object.values(loaderData.attributes)) {\n      const attributeName = this._deduceAttributeName(loaderAttribute, options);\n      loaderAttribute.name = attributeName;\n      const {value, size} = this._getAttributeValues(dracoGeometry, loaderAttribute);\n      attributes[attributeName] = {\n        value,\n        size,\n        byteOffset: loaderAttribute.byte_offset,\n        byteStride: loaderAttribute.byte_stride,\n        normalized: loaderAttribute.normalized\n      };\n    }\n\n    return attributes;\n  }\n\n  // MESH INDICES EXTRACTION\n\n  /**\n   * For meshes, we need indices to define the faces.\n   * @param dracoGeometry\n   */\n  _getTriangleListIndices(dracoGeometry: Mesh) {\n    // Example on how to retrieve mesh and attributes.\n    const numFaces = dracoGeometry.num_faces();\n    const numIndices = numFaces * 3;\n    const byteLength = numIndices * INDEX_ITEM_SIZE;\n\n    const ptr = this.draco._malloc(byteLength);\n    try {\n      this.decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr);\n      return new Uint32Array(this.draco.HEAPF32.buffer, ptr, numIndices).slice();\n    } finally {\n      this.draco._free(ptr);\n    }\n  }\n\n  /**\n   * For meshes, we need indices to define the faces.\n   * @param dracoGeometry\n   */\n  _getTriangleStripIndices(dracoGeometry: Mesh) {\n    const dracoArray = new this.draco.DracoInt32Array();\n    try {\n      /* const numStrips = */ this.decoder.GetTriangleStripsFromMesh(dracoGeometry, dracoArray);\n      return getUint32Array(dracoArray);\n    } finally {\n      this.draco.destroy(dracoArray);\n    }\n  }\n\n  /**\n   *\n   * @param dracoGeometry\n   * @param dracoAttribute\n   * @param attributeName\n   */\n  _getAttributeValues(\n    dracoGeometry: Mesh | PointCloud,\n    attribute: DracoAttribute\n  ): {value: TypedArray; size: number} {\n    const TypedArrayCtor = DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP[attribute.data_type];\n    const numComponents = attribute.num_components;\n    const numPoints = dracoGeometry.num_points();\n    const numValues = numPoints * numComponents;\n\n    const byteLength = numValues * TypedArrayCtor.BYTES_PER_ELEMENT;\n    const dataType = getDracoDataType(this.draco, TypedArrayCtor);\n\n    let value: TypedArray;\n\n    const ptr = this.draco._malloc(byteLength);\n    try {\n      const dracoAttribute = this.decoder.GetAttribute(dracoGeometry, attribute.attribute_index);\n      this.decoder.GetAttributeDataArrayForAllPoints(\n        dracoGeometry,\n        dracoAttribute,\n        dataType,\n        byteLength,\n        ptr\n      );\n      value = new TypedArrayCtor(this.draco.HEAPF32.buffer, ptr, numValues).slice();\n    } finally {\n      this.draco._free(ptr);\n    }\n\n    return {value, size: numComponents};\n  }\n\n  // Attribute names\n\n  /** \n   * DRACO does not store attribute names - We need to deduce an attribute name\n   * for each attribute\n  _getAttributeNames(\n    dracoGeometry: Mesh | PointCloud,\n    options: DracoParseOptions\n  ): {[unique_id: number]: string} {\n    const attributeNames: {[unique_id: number]: string} = {};\n    for (let attributeId = 0; attributeId < dracoGeometry.num_attributes(); attributeId++) {\n      const dracoAttribute = this.decoder.GetAttribute(dracoGeometry, attributeId);\n      const attributeName = this._deduceAttributeName(dracoAttribute, options);\n      attributeNames[attributeName] = attributeName;\n    }\n    return attributeNames;\n  }\n   */\n\n  /**\n   * Deduce an attribute name.\n   * @note DRACO does not save attribute names, just general type (POSITION, COLOR)\n   * to help optimize compression. We generate GLTF compatible names for the Draco-recognized\n   * types\n   * @param attributeData\n   */\n  _deduceAttributeName(attribute: DracoAttribute, options: DracoParseOptions): string {\n    // Deduce name based on application provided map\n    const uniqueId = attribute.unique_id;\n    for (const [attributeName, attributeUniqueId] of Object.entries(\n      options.extraAttributes || {}\n    )) {\n      if (attributeUniqueId === uniqueId) {\n        return attributeName;\n      }\n    }\n\n    // Deduce name based on attribute type\n    const thisAttributeType = attribute.attribute_type;\n    for (const dracoAttributeConstant in DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP) {\n      const attributeType = this.draco[dracoAttributeConstant];\n      if (attributeType === thisAttributeType) {\n        // TODO - Return unique names if there multiple attributes per type\n        // (e.g. multiple TEX_COORDS or COLORS)\n        return DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP[dracoAttributeConstant];\n      }\n    }\n\n    // Look up in metadata\n    // TODO - shouldn't this have priority?\n    const entryName = options.attributeNameEntry || 'name';\n    if (attribute.metadata[entryName]) {\n      return attribute.metadata[entryName].string;\n    }\n\n    // Attribute of \"GENERIC\" type, we need to assign some name\n    return `CUSTOM_ATTRIBUTE_${uniqueId}`;\n  }\n\n  // METADATA EXTRACTION\n\n  /** Get top level metadata */\n  _getTopLevelMetadata(dracoGeometry: Mesh | PointCloud) {\n    const dracoMetadata = this.decoder.GetMetadata(dracoGeometry);\n    return this._getDracoMetadata(dracoMetadata);\n  }\n\n  /** Get per attribute metadata */\n  _getAttributeMetadata(dracoGeometry: Mesh | PointCloud, attributeId: number) {\n    const dracoMetadata = this.decoder.GetAttributeMetadata(dracoGeometry, attributeId);\n    return this._getDracoMetadata(dracoMetadata);\n  }\n\n  /**\n   * Extract metadata field values\n   * @param dracoMetadata\n   * @returns\n   */\n  _getDracoMetadata(dracoMetadata: Metadata): {[entry: string]: DracoMetadataEntry} {\n    // The not so wonderful world of undocumented Draco APIs :(\n    if (!dracoMetadata || !dracoMetadata.ptr) {\n      return {};\n    }\n    const result = {};\n    const numEntries = this.metadataQuerier.NumEntries(dracoMetadata);\n    for (let entryIndex = 0; entryIndex < numEntries; entryIndex++) {\n      const entryName = this.metadataQuerier.GetEntryName(dracoMetadata, entryIndex);\n      result[entryName] = this._getDracoMetadataField(dracoMetadata, entryName);\n    }\n    return result;\n  }\n\n  /**\n   * Extracts possible values for one metadata entry by name\n   * @param dracoMetadata\n   * @param entryName\n   */\n  _getDracoMetadataField(dracoMetadata: Metadata, entryName: string): DracoMetadataEntry {\n    const dracoArray = new this.draco.DracoInt32Array();\n    try {\n      // Draco metadata fields can hold int32 arrays\n      this.metadataQuerier.GetIntEntryArray(dracoMetadata, entryName, dracoArray);\n      const intArray = getInt32Array(dracoArray);\n      return {\n        int: this.metadataQuerier.GetIntEntry(dracoMetadata, entryName),\n        string: this.metadataQuerier.GetStringEntry(dracoMetadata, entryName),\n        double: this.metadataQuerier.GetDoubleEntry(dracoMetadata, entryName),\n        intArray\n      };\n    } finally {\n      this.draco.destroy(dracoArray);\n    }\n  }\n\n  // QUANTIZED ATTRIBUTE SUPPORT (NO DECOMPRESSION)\n\n  /** Skip transforms for specific attribute types */\n  _disableAttributeTransforms(options: DracoParseOptions) {\n    const {quantizedAttributes = [], octahedronAttributes = []} = options;\n    const skipAttributes = [...quantizedAttributes, ...octahedronAttributes];\n    for (const dracoAttributeName of skipAttributes) {\n      this.decoder.SkipAttributeTransform(this.draco[dracoAttributeName]);\n    }\n  }\n\n  /**\n   * Extract (and apply?) Position Transform\n   * @todo not used\n   */\n  _getQuantizationTransform(\n    dracoAttribute: PointAttribute,\n    options: DracoParseOptions\n  ): DracoQuantizationTransform | null {\n    const {quantizedAttributes = []} = options;\n    const attribute_type = dracoAttribute.attribute_type();\n    const skip = quantizedAttributes.map((type) => this.decoder[type]).includes(attribute_type);\n    if (skip) {\n      const transform = new this.draco.AttributeQuantizationTransform();\n      try {\n        if (transform.InitFromAttribute(dracoAttribute)) {\n          return {\n            quantization_bits: transform.quantization_bits(),\n            range: transform.range(),\n            min_values: new Float32Array([1, 2, 3]).map((i) => transform.min_value(i))\n          };\n        }\n      } finally {\n        this.draco.destroy(transform);\n      }\n    }\n    return null;\n  }\n\n  _getOctahedronTransform(\n    dracoAttribute: PointAttribute,\n    options: DracoParseOptions\n  ): DracoOctahedronTransform | null {\n    const {octahedronAttributes = []} = options;\n    const attribute_type = dracoAttribute.attribute_type();\n    const octahedron = octahedronAttributes\n      .map((type) => this.decoder[type])\n      .includes(attribute_type);\n    if (octahedron) {\n      const transform = new this.draco.AttributeQuantizationTransform();\n      try {\n        if (transform.InitFromAttribute(dracoAttribute)) {\n          return {\n            quantization_bits: transform.quantization_bits()\n          };\n        }\n      } finally {\n        this.draco.destroy(transform);\n      }\n    }\n    return null;\n  }\n\n  // HELPERS\n}\n\n/**\n * Get draco specific data type by TypedArray constructor type\n * @param attributeType\n * @returns draco specific data type\n */\nfunction getDracoDataType(draco: Draco3D, attributeType: any): draco_DataType {\n  switch (attributeType) {\n    case Float32Array:\n      return draco.DT_FLOAT32;\n    case Int8Array:\n      return draco.DT_INT8;\n    case Int16Array:\n      return draco.DT_INT16;\n    case Int32Array:\n      return draco.DT_INT32;\n    case Uint8Array:\n      return draco.DT_UINT8;\n    case Uint16Array:\n      return draco.DT_UINT16;\n    case Uint32Array:\n      return draco.DT_UINT32;\n    default:\n      return draco.DT_INVALID;\n  }\n}\n\n/**\n * Copy a Draco int32 array into a JS typed array\n */\nfunction getInt32Array(dracoArray: DracoInt32Array): Int32Array {\n  const numValues = dracoArray.size();\n  const intArray = new Int32Array(numValues);\n  for (let i = 0; i < numValues; i++) {\n    intArray[i] = dracoArray.GetValue(i);\n  }\n  return intArray;\n}\n\n/**\n * Copy a Draco int32 array into a JS typed array\n */\nfunction getUint32Array(dracoArray: DracoInt32Array): Int32Array {\n  const numValues = dracoArray.size();\n  const intArray = new Int32Array(numValues);\n  for (let i = 0; i < numValues; i++) {\n    intArray[i] = dracoArray.GetValue(i);\n  }\n  return intArray;\n}\n","import type {Schema} from '../schema';\nimport type {TableBatch} from '../../category/table';\nimport type {TableBatchAggregator, TableBatchConstructor} from './table-batch-aggregator';\nimport BaseTableBatchAggregator from './base-table-batch-aggregator';\nimport RowTableBatchAggregator from './row-table-batch-aggregator';\nimport ColumnarTableBatchAggregator from './columnar-table-batch-aggregator';\n\n// TODO define interface instead\ntype TableBatchBuilderOptions = {\n  shape: 'row-table' | 'array-row-table' | 'object-row-table' | 'columnar-table' | 'arrow-table';\n  batchSize?: number | 'auto';\n  batchDebounceMs?: number;\n  limit: number;\n  _limitMB: number;\n};\n\ntype GetBatchOptions = {\n  bytesUsed?: number;\n  [key: string]: any;\n};\n\nconst DEFAULT_OPTIONS: Required<TableBatchBuilderOptions> = {\n  shape: 'array-row-table',\n  batchSize: 'auto',\n  batchDebounceMs: 0,\n  limit: 0,\n  _limitMB: 0\n};\n\nconst ERR_MESSAGE = 'TableBatchBuilder';\n\n/** Incrementally builds batches from a stream of rows */\nexport default class TableBatchBuilder {\n  schema: Schema;\n  options: Required<TableBatchBuilderOptions>;\n\n  private aggregator: TableBatchAggregator | null = null;\n  private batchCount: number = 0;\n  private bytesUsed: number = 0;\n  private isChunkComplete: boolean = false;\n  private lastBatchEmittedMs: number = Date.now();\n  private totalLength: number = 0;\n  private totalBytes: number = 0;\n  private rowBytes: number = 0;\n\n  static ArrowBatch?: TableBatchConstructor;\n\n  constructor(schema: Schema, options?: TableBatchBuilderOptions) {\n    this.schema = schema;\n    this.options = {...DEFAULT_OPTIONS, ...options};\n  }\n\n  limitReached(): boolean {\n    if (Boolean(this.options?.limit) && this.totalLength >= this.options.limit) {\n      return true;\n    }\n    if (Boolean(this.options?._limitMB) && this.totalBytes / 1e6 >= this.options._limitMB) {\n      return true;\n    }\n    return false;\n  }\n\n  /** @deprecated Use addArrayRow or addObjectRow */\n  addRow(row: any[] | {[columnName: string]: any}): void {\n    if (this.limitReached()) {\n      return;\n    }\n    this.totalLength++;\n    this.rowBytes = this.rowBytes || this._estimateRowMB(row);\n    this.totalBytes += this.rowBytes;\n    if (Array.isArray(row)) {\n      this.addArrayRow(row);\n    } else {\n      this.addObjectRow(row);\n    }\n  }\n\n  /** Add one row to the batch */\n  protected addArrayRow(row: any[]) {\n    if (!this.aggregator) {\n      const TableBatchType = this._getTableBatchType();\n      this.aggregator = new TableBatchType(this.schema, this.options);\n    }\n    this.aggregator.addArrayRow(row);\n  }\n\n  /** Add one row to the batch */\n  protected addObjectRow(row: {[columnName: string]: any}): void {\n    if (!this.aggregator) {\n      const TableBatchType = this._getTableBatchType();\n      this.aggregator = new TableBatchType(this.schema, this.options);\n    }\n    this.aggregator.addObjectRow(row);\n  }\n\n  /** Mark an incoming raw memory chunk has completed */\n  chunkComplete(chunk: ArrayBuffer | string): void {\n    if (chunk instanceof ArrayBuffer) {\n      this.bytesUsed += chunk.byteLength;\n    }\n    if (typeof chunk === 'string') {\n      this.bytesUsed += chunk.length;\n    }\n    this.isChunkComplete = true;\n  }\n\n  getFullBatch(options?: GetBatchOptions): TableBatch | null {\n    return this._isFull() ? this._getBatch(options) : null;\n  }\n\n  getFinalBatch(options?: GetBatchOptions): TableBatch | null {\n    return this._getBatch(options);\n  }\n\n  // INTERNAL\n\n  _estimateRowMB(row) {\n    return Array.isArray(row) ? row.length * 8 : Object.keys(row).length * 8;\n  }\n\n  private _isFull(): boolean {\n    // No batch, not ready\n    if (!this.aggregator || this.aggregator.rowCount() === 0) {\n      return false;\n    }\n\n    // if batchSize === 'auto' we wait for chunk to complete\n    // if batchSize === number, ensure we have enough rows\n    if (this.options.batchSize === 'auto') {\n      if (!this.isChunkComplete) {\n        return false;\n      }\n    } else if (this.options.batchSize > this.aggregator.rowCount()) {\n      return false;\n    }\n\n    // Debounce batches\n    if (this.options.batchDebounceMs > Date.now() - this.lastBatchEmittedMs) {\n      return false;\n    }\n\n    // Emit batch\n    this.isChunkComplete = false;\n    this.lastBatchEmittedMs = Date.now();\n    return true;\n  }\n\n  /**\n   * bytesUsed can be set via chunkComplete or via getBatch*\n   */\n  private _getBatch(options?: GetBatchOptions): TableBatch | null {\n    if (!this.aggregator) {\n      return null;\n    }\n\n    // TODO - this can overly increment bytes used?\n    if (options?.bytesUsed) {\n      this.bytesUsed = options.bytesUsed;\n    }\n    const normalizedBatch = this.aggregator.getBatch() as TableBatch;\n    normalizedBatch.count = this.batchCount;\n    normalizedBatch.bytesUsed = this.bytesUsed;\n    Object.assign(normalizedBatch, options);\n\n    this.batchCount++;\n    this.aggregator = null;\n    return normalizedBatch;\n  }\n\n  private _getTableBatchType(): TableBatchConstructor {\n    switch (this.options.shape) {\n      case 'row-table':\n        return BaseTableBatchAggregator;\n      case 'array-row-table':\n      case 'object-row-table':\n        return RowTableBatchAggregator;\n      case 'columnar-table':\n        return ColumnarTableBatchAggregator;\n      case 'arrow-table':\n        if (!TableBatchBuilder.ArrowBatch) {\n          throw new Error(ERR_MESSAGE);\n        }\n        return TableBatchBuilder.ArrowBatch;\n      default:\n        throw new Error(ERR_MESSAGE);\n    }\n  }\n}\n","import type {Schema} from '../schema';\nimport type {TableBatch} from '../../category/table';\nimport {TableBatchAggregator, TableBatchOptions} from './table-batch-aggregator';\n\nconst DEFAULT_ROW_COUNT = 100;\n\nexport default class RowTableBatchAggregator implements TableBatchAggregator {\n  schema: Schema;\n  options: TableBatchOptions;\n\n  length: number = 0;\n  rows: any[] | null = null;\n  cursor: number = 0;\n  private _headers: string[] = [];\n\n  constructor(schema: Schema, options: TableBatchOptions) {\n    this.options = options;\n    this.schema = schema;\n\n    // schema is an array if there're no headers\n    // object if there are headers\n    if (!Array.isArray(schema)) {\n      this._headers = [];\n      for (const key in schema) {\n        this._headers[schema[key].index] = schema[key].name;\n      }\n    }\n  }\n\n  rowCount(): number {\n    return this.length;\n  }\n\n  addArrayRow(row: any[], cursor?: number): void {\n    if (Number.isFinite(cursor)) {\n      this.cursor = cursor as number;\n    }\n\n    this.rows = this.rows || new Array(DEFAULT_ROW_COUNT);\n    this.rows[this.length] = row;\n    this.length++;\n  }\n\n  addObjectRow(row: {[columnName: string]: any}, cursor?: number): void {\n    if (Number.isFinite(cursor)) {\n      this.cursor = cursor as number;\n    }\n\n    this.rows = this.rows || new Array(DEFAULT_ROW_COUNT);\n    this.rows[this.length] = row;\n    this.length++;\n  }\n\n  getBatch(): TableBatch | null {\n    let rows = this.rows;\n    if (!rows) {\n      return null;\n    }\n\n    rows = rows.slice(0, this.length);\n    this.rows = null;\n\n    const batch: TableBatch = {\n      shape: this.options.shape,\n      batchType: 'data',\n      data: rows,\n      length: this.length,\n      schema: this.schema,\n      cursor: this.cursor\n    };\n\n    return batch;\n  }\n}\n","// Mesh category utilities\n// TODO - move to mesh category module, or to math.gl/geometry module\nimport {TypedArray} from '../../types';\n\ntype Attribute = {\n  size?: number;\n  type?: number;\n  normalized?: boolean;\n  value: TypedArray;\n};\n\ntype TypedArrays = {[key: string]: TypedArray};\nexport type Attributes = {[key: string]: Attribute};\n\n/**\n * Holds an axis aligned bounding box\n * TODO - make sure AxisAlignedBoundingBox in math.gl/culling understands this format (or change this format)\n */\ntype BoundingBox = [[number, number, number], [number, number, number]];\n\n/**\n * Get number of vertices in mesh\n * @param attributes\n */\nexport function getMeshSize(attributes: TypedArrays): number {\n  let size = 0;\n  for (const attributeName in attributes) {\n    const attribute = attributes[attributeName];\n    if (ArrayBuffer.isView(attribute)) {\n      // @ts-ignore DataView doesn't have BYTES_PER_ELEMENT\n      size += attribute.byteLength * attribute.BYTES_PER_ELEMENT;\n    }\n  }\n  return size;\n}\n\n/**\n * Get the (axis aligned) bounding box of a mesh\n * @param attributes\n * @returns array of two vectors representing the axis aligned bounding box\n */\n// eslint-disable-next-line complexity\nexport function getMeshBoundingBox(attributes: Attributes): BoundingBox {\n  let minX = Infinity;\n  let minY = Infinity;\n  let minZ = Infinity;\n  let maxX = -Infinity;\n  let maxY = -Infinity;\n  let maxZ = -Infinity;\n\n  const positions = attributes.POSITION ? attributes.POSITION.value : [];\n  const len = positions && positions.length;\n\n  for (let i = 0; i < len; i += 3) {\n    const x = positions[i];\n    const y = positions[i + 1];\n    const z = positions[i + 2];\n\n    minX = x < minX ? x : minX;\n    minY = y < minY ? y : minY;\n    minZ = z < minZ ? z : minZ;\n\n    maxX = x > maxX ? x : maxX;\n    maxY = y > maxY ? y : maxY;\n    maxZ = z > maxZ ? z : maxZ;\n  }\n  return [\n    [minX, minY, minZ],\n    [maxX, maxY, maxZ]\n  ];\n}\n","import {assert} from '../../utils/assert';\nimport Field from './field';\n\nexport type SchemaMetadata = Map<string, any>;\n\n/**\n * ArrowJS `Schema` API-compatible class for row-based tables (returned from `DataTable`)\n * https://loaders.gl/arrowjs/docs/api-reference/schema\n */\nexport default class Schema {\n  fields: Field[];\n  // TODO - Arrow just allows Map<string, string>\n  metadata: SchemaMetadata;\n\n  constructor(fields: Field[], metadata?: SchemaMetadata) {\n    assert(Array.isArray(fields));\n    checkNames(fields);\n    // For kepler fields, create arrow compatible `Fields` that have kepler fields as `metadata`\n    this.fields = fields;\n    this.metadata = metadata || new Map();\n  }\n\n  // TODO - arrow only seems to compare fields, not metadata\n  compareTo(other: Schema): boolean {\n    if (this.metadata !== other.metadata) {\n      return false;\n    }\n    if (this.fields.length !== other.fields.length) {\n      return false;\n    }\n    for (let i = 0; i < this.fields.length; ++i) {\n      if (!this.fields[i].compareTo(other.fields[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  select(...columnNames: string[]): Schema {\n    // Ensure column names reference valid fields\n    const nameMap = Object.create(null);\n    for (const name of columnNames) {\n      nameMap[name] = true;\n    }\n    const selectedFields = this.fields.filter((field) => nameMap[field.name]);\n    return new Schema(selectedFields, this.metadata);\n  }\n\n  selectAt(...columnIndices: number[]): Schema {\n    // Ensure column indices reference valid fields\n    const selectedFields = columnIndices.map((index) => this.fields[index]).filter(Boolean);\n    return new Schema(selectedFields, this.metadata);\n  }\n\n  assign(schemaOrFields: Schema | Field[]): Schema {\n    let fields: Field[];\n    let metadata: SchemaMetadata = this.metadata;\n\n    if (schemaOrFields instanceof Schema) {\n      const otherSchema = schemaOrFields;\n      fields = otherSchema.fields;\n      metadata = mergeMaps(mergeMaps(new Map(), this.metadata), otherSchema.metadata);\n    } else {\n      fields = schemaOrFields;\n    }\n\n    // Create a merged list of fields, overwrite fields in place, new fields at end\n    const fieldMap: {[key: string]: Field} = Object.create(null);\n\n    for (const field of this.fields) {\n      fieldMap[field.name] = field;\n    }\n\n    for (const field of fields) {\n      fieldMap[field.name] = field;\n    }\n\n    const mergedFields = Object.values(fieldMap);\n\n    return new Schema(mergedFields, metadata);\n  }\n}\n\n// Warn if any duplicated field names\nfunction checkNames(fields) {\n  const usedNames = {};\n  for (const field of fields) {\n    if (usedNames[field.name]) {\n      // eslint-disable-next-line\n      console.warn('Schema: duplicated field name', field.name, field);\n    }\n    usedNames[field.name] = true;\n  }\n}\n\nfunction mergeMaps<T>(m1: T, m2: T): T {\n  // @ts-ignore\n  return new Map([...(m1 || new Map()), ...(m2 || new Map())]);\n}\n","// Replacement for the external assert method to reduce bundle size\n// Note: We don't use the second \"message\" argument in calling code,\n// so no need to support it here\nexport function assert(condition: boolean, message?: string) {\n  if (!condition) {\n    throw new Error(message || 'loader assertion failed.');\n  }\n}\n","import {DataType} from './type';\n\n/**\n * ArrowJS `Field` API-compatible class for row-based tables\n * https://loaders.gl/arrowjs/docs/api-reference/field\n * A field holds name, nullable, and metadata information about a table \"column\"\n * A Schema is essentially a list of fields\n */\nexport default class Field {\n  name: string;\n  type: DataType;\n  nullable: boolean;\n  metadata: Map<string, string>;\n\n  constructor(\n    name: string,\n    type: DataType,\n    nullable = false,\n    metadata: Map<string, string> = new Map()\n  ) {\n    this.name = name;\n    this.type = type;\n    this.nullable = nullable;\n    this.metadata = metadata;\n  }\n\n  get typeId(): number {\n    return this.type && this.type.typeId;\n  }\n\n  clone(): Field {\n    return new Field(this.name, this.type, this.nullable, this.metadata);\n  }\n\n  compareTo(other: this): boolean {\n    return (\n      this.name === other.name &&\n      this.type === other.type &&\n      this.nullable === other.nullable &&\n      this.metadata === other.metadata\n    );\n  }\n\n  toString(): string {\n    return `${this.type}${this.nullable ? ', nullable' : ''}${\n      this.metadata ? `, metadata: ${this.metadata}` : ''\n    }`;\n  }\n}\n","// This code is adapted from ArrowJS https://github.com/apache/arrow\n// under Apache license http://www.apache.org/licenses/LICENSE-2.0\n\nimport {Type} from './enum';\n\nimport Field from './field';\n\nexport {Type} from './enum';\n\nexport type TypedIntArray =\n  | Int8Array\n  | Uint8Array\n  | Int16Array\n  | Uint16Array\n  | Int32Array\n  | Uint32Array\n  | Int32Array\n  | Uint32Array\n  | Uint8ClampedArray;\n\nexport type TypedFloatArray = Float32Array | Float64Array;\n\nexport type TypedArray = TypedIntArray | TypedFloatArray;\n\nexport type AnyArrayType = Array<any> | TypedIntArray | TypedFloatArray;\n\nexport class DataType {\n  static isNull(x: any): boolean {\n    return x && x.typeId === Type.Null;\n  }\n  static isInt(x: any): boolean {\n    return x && x.typeId === Type.Int;\n  }\n  static isFloat(x: any): boolean {\n    return x && x.typeId === Type.Float;\n  }\n  static isBinary(x: any): boolean {\n    return x && x.typeId === Type.Binary;\n  }\n  static isUtf8(x: any): boolean {\n    return x && x.typeId === Type.Utf8;\n  }\n  static isBool(x: any): boolean {\n    return x && x.typeId === Type.Bool;\n  }\n  static isDecimal(x: any): boolean {\n    return x && x.typeId === Type.Decimal;\n  }\n  static isDate(x: any): boolean {\n    return x && x.typeId === Type.Date;\n  }\n  static isTime(x: any): boolean {\n    return x && x.typeId === Type.Time;\n  }\n  static isTimestamp(x: any): boolean {\n    return x && x.typeId === Type.Timestamp;\n  }\n  static isInterval(x: any): boolean {\n    return x && x.typeId === Type.Interval;\n  }\n  static isList(x: any): boolean {\n    return x && x.typeId === Type.List;\n  }\n  static isStruct(x: any): boolean {\n    return x && x.typeId === Type.Struct;\n  }\n  static isUnion(x: any): boolean {\n    return x && x.typeId === Type.Union;\n  }\n  static isFixedSizeBinary(x: any): boolean {\n    return x && x.typeId === Type.FixedSizeBinary;\n  }\n  static isFixedSizeList(x: any): boolean {\n    return x && x.typeId === Type.FixedSizeList;\n  }\n  static isMap(x: any): boolean {\n    return x && x.typeId === Type.Map;\n  }\n  static isDictionary(x: any): boolean {\n    return x && x.typeId === Type.Dictionary;\n  }\n\n  get typeId(): Type {\n    return Type.NONE;\n  }\n\n  // get ArrayType(): AnyArrayType {\n  //   return Int8Array;\n  // }\n\n  // get ArrayType() { return Array; }\n  compareTo(other: DataType): boolean {\n    // TODO\n    return this === other; // comparer.visit(this, other);\n  }\n}\n\n// NULL\n\nexport class Null extends DataType {\n  get typeId(): Type {\n    return Type.Null;\n  }\n  get [Symbol.toStringTag](): string {\n    return 'Null';\n  }\n  toString(): string {\n    return 'Null';\n  }\n}\n\n// BOOLEANS\n\nexport class Bool extends DataType {\n  get typeId(): Type {\n    return Type.Bool;\n  }\n  // get ArrayType() {\n  //   return Uint8Array;\n  // }\n  get [Symbol.toStringTag](): string {\n    return 'Bool';\n  }\n  toString(): string {\n    return 'Bool';\n  }\n}\n\n// INTS\n\nexport class Int extends DataType {\n  readonly isSigned: boolean;\n  readonly bitWidth: number;\n  constructor(isSigned, bitWidth) {\n    super();\n    this.isSigned = isSigned;\n    this.bitWidth = bitWidth;\n  }\n  get typeId(): Type {\n    return Type.Int;\n  }\n  // get ArrayType() {\n  //   switch (this.bitWidth) {\n  //     case 8:\n  //       return this.isSigned ? Int8Array : Uint8Array;\n  //     case 16:\n  //       return this.isSigned ? Int16Array : Uint16Array;\n  //     case 32:\n  //       return this.isSigned ? Int32Array : Uint32Array;\n  //     case 64:\n  //       return this.isSigned ? Int32Array : Uint32Array;\n  //     default:\n  //       throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`);\n  //   }\n  // }\n  get [Symbol.toStringTag](): string {\n    return 'Int';\n  }\n  toString(): string {\n    return `${this.isSigned ? 'I' : 'Ui'}nt${this.bitWidth}`;\n  }\n}\n\nexport class Int8 extends Int {\n  constructor() {\n    super(true, 8);\n  }\n}\nexport class Int16 extends Int {\n  constructor() {\n    super(true, 16);\n  }\n}\nexport class Int32 extends Int {\n  constructor() {\n    super(true, 32);\n  }\n}\nexport class Int64 extends Int {\n  constructor() {\n    super(true, 64);\n  }\n}\nexport class Uint8 extends Int {\n  constructor() {\n    super(false, 8);\n  }\n}\nexport class Uint16 extends Int {\n  constructor() {\n    super(false, 16);\n  }\n}\nexport class Uint32 extends Int {\n  constructor() {\n    super(false, 32);\n  }\n}\nexport class Uint64 extends Int {\n  constructor() {\n    super(false, 64);\n  }\n}\n\n// FLOATS\n\nconst Precision = {\n  HALF: 16,\n  SINGLE: 32,\n  DOUBLE: 64\n};\n\nexport class Float extends DataType {\n  readonly precision: number;\n  constructor(precision) {\n    super();\n    this.precision = precision;\n  }\n  get typeId(): Type {\n    return Type.Float;\n  }\n  // get ArrayType() {\n  //   switch (this.precision) {\n  //     case Precision.HALF:\n  //       return Uint16Array;\n  //     case Precision.SINGLE:\n  //       return Float32Array;\n  //     case Precision.DOUBLE:\n  //       return Float64Array;\n  //     default:\n  //       throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`);\n  //   }\n  // }\n  get [Symbol.toStringTag](): string {\n    return 'Float';\n  }\n  toString(): string {\n    return `Float${this.precision}`;\n  }\n}\n\nexport class Float16 extends Float {\n  constructor() {\n    super(Precision.HALF);\n  }\n}\nexport class Float32 extends Float {\n  constructor() {\n    super(Precision.SINGLE);\n  }\n}\nexport class Float64 extends Float {\n  constructor() {\n    super(Precision.DOUBLE);\n  }\n}\n\nexport class Binary extends DataType {\n  constructor() {\n    super();\n  }\n  get typeId() {\n    return Type.Binary;\n  }\n  toString() {\n    return 'Binary';\n  }\n  get [Symbol.toStringTag]() {\n    return 'Binary';\n  }\n}\n\n// STRINGS\n\nexport class Utf8 extends DataType {\n  get typeId(): Type {\n    return Type.Utf8;\n  }\n  // get ArrayType() {\n  //   return Uint8Array;\n  // }\n  get [Symbol.toStringTag](): string {\n    return 'Utf8';\n  }\n  toString(): string {\n    return 'Utf8';\n  }\n}\n\n// DATES, TIMES AND INTERVALS\n\nconst DateUnit = {\n  DAY: 0,\n  MILLISECOND: 1\n};\n\nexport class Date extends DataType {\n  readonly unit: number;\n  constructor(unit) {\n    super();\n    this.unit = unit;\n  }\n  get typeId(): Type {\n    return Type.Date;\n  }\n  // get ArrayType() {\n  //   return Int32Array;\n  // }\n  get [Symbol.toStringTag](): string {\n    return 'Date';\n  }\n  toString(): string {\n    return `Date${(this.unit + 1) * 32}<${DateUnit[this.unit]}>`;\n  }\n}\n\nexport class DateDay extends Date {\n  constructor() {\n    super(DateUnit.DAY);\n  }\n}\nexport class DateMillisecond extends Date {\n  constructor() {\n    super(DateUnit.MILLISECOND);\n  }\n}\n\nconst TimeUnit = {\n  SECOND: 1,\n  MILLISECOND: 1e3,\n  MICROSECOND: 1e6,\n  NANOSECOND: 1e9\n};\n\nexport class Time extends DataType {\n  readonly unit: number;\n  readonly bitWidth: number;\n\n  constructor(unit, bitWidth) {\n    super();\n    this.unit = unit;\n    this.bitWidth = bitWidth;\n  }\n  get typeId(): Type {\n    return Type.Time;\n  }\n  toString(): string {\n    return `Time${this.bitWidth}<${TimeUnit[this.unit]}>`;\n  }\n  get [Symbol.toStringTag](): string {\n    return 'Time';\n  }\n  // get ArrayType() {\n  //   return Int32Array;\n  // }\n}\n\nexport class TimeSecond extends Time {\n  constructor() {\n    super(TimeUnit.SECOND, 32);\n  }\n}\nexport class TimeMillisecond extends Time {\n  constructor() {\n    super(TimeUnit.MILLISECOND, 32);\n  }\n}\n// export class TimeMicrosecond extends Time { constructor() { super(TimeUnit.MICROSECOND, 64); } }\n// export class TimeNanosecond extends Time { constructor() { super(TimeUnit.NANOSECOND, 64); } }\n\nexport class Timestamp extends DataType {\n  readonly unit: any;\n  readonly timezone: any;\n\n  constructor(unit: any, timezone = null) {\n    super();\n    this.unit = unit;\n    this.timezone = timezone;\n  }\n  get typeId(): Type {\n    return Type.Timestamp;\n  }\n  // get ArrayType() {\n  //   return Int32Array;\n  // }\n  get [Symbol.toStringTag](): string {\n    return 'Timestamp';\n  }\n  toString(): string {\n    return `Timestamp<${TimeUnit[this.unit]}${this.timezone ? `, ${this.timezone}` : ''}>`;\n  }\n}\n\nexport class TimestampSecond extends Timestamp {\n  constructor(timezone = null) {\n    super(TimeUnit.SECOND, timezone);\n  }\n}\nexport class TimestampMillisecond extends Timestamp {\n  constructor(timezone = null) {\n    super(TimeUnit.MILLISECOND, timezone);\n  }\n}\nexport class TimestampMicrosecond extends Timestamp {\n  constructor(timezone = null) {\n    super(TimeUnit.MICROSECOND, timezone);\n  }\n}\nexport class TimestampNanosecond extends Timestamp {\n  constructor(timezone = null) {\n    super(TimeUnit.NANOSECOND, timezone);\n  }\n}\n\nconst IntervalUnit = {\n  DAY_TIME: 0,\n  YEAR_MONTH: 1\n};\n\nexport class Interval extends DataType {\n  readonly unit: number;\n  constructor(unit: number) {\n    super();\n    this.unit = unit;\n  }\n  get typeId(): Type {\n    return Type.Interval;\n  }\n  // get ArrayType() {\n  //   return Int32Array;\n  // }\n  get [Symbol.toStringTag](): string {\n    return 'Interval';\n  }\n  toString(): string {\n    return `Interval<${IntervalUnit[this.unit]}>`;\n  }\n}\n\nexport class IntervalDayTime extends Interval {\n  constructor() {\n    super(IntervalUnit.DAY_TIME);\n  }\n}\nexport class IntervalYearMonth extends Interval {\n  constructor() {\n    super(IntervalUnit.YEAR_MONTH);\n  }\n}\n\nexport class FixedSizeList extends DataType {\n  readonly listSize: number;\n  readonly children: Field[];\n\n  constructor(listSize: number, child: Field) {\n    super();\n    this.listSize = listSize;\n    this.children = [child];\n  }\n  get typeId(): Type {\n    return Type.FixedSizeList;\n  }\n  get valueType() {\n    return this.children[0].type;\n  }\n  get valueField() {\n    return this.children[0];\n  }\n  // get ArrayType() {\n  //   return this.valueType.ArrayType;\n  // }\n  get [Symbol.toStringTag](): string {\n    return 'FixedSizeList';\n  }\n  toString(): string {\n    return `FixedSizeList[${this.listSize}]<${this.valueType}>`;\n  }\n}\n","// This code is adapted from ArrowJS https://github.com/apache/arrow\n// under Apache license http://www.apache.org/licenses/LICENSE-2.0\n\n/**\n * Main data type enumeration.\n *\n * Data types in this library are all *logical*. They can be expressed as\n * either a primitive physical type (bytes or bits of some fixed size), a\n * nested type consisting of other data types, or another data type (e.g. a\n * timestamp encoded as an int64).\n *\n * **Note**: Only enum values 0-17 (NONE through Map) are written to an Arrow\n * IPC payload.\n *\n * The rest of the values are specified here so TypeScript can narrow the type\n * signatures further beyond the base Arrow Types. The Arrow DataTypes include\n * metadata like `bitWidth` that impact the type signatures of the values we\n * accept and return.\n *\n * For example, the `Int8Vector` reads 1-byte numbers from an `Int8Array`, an\n * `Int32Vector` reads a 4-byte number from an `Int32Array`, and an `Int64Vector`\n * reads a pair of 4-byte lo, hi 32-bit integers as a zero-copy slice from the\n * underlying `Int32Array`.\n *\n * Library consumers benefit by knowing the narrowest type, since we can ensure\n * the types across all public methods are propagated, and never bail to `any`.\n * These values are _never_ used at runtime, and they will _never_ be written\n * to the flatbuffers metadata of serialized Arrow IPC payloads.\n */\nexport enum Type {\n  /** The default placeholder type */\n  NONE = 0,\n  /** A NULL type having no physical storage */\n  Null = 1,\n  /** Signed or unsigned 8, 16, 32, or 64-bit little-endian integer */\n  Int = 2,\n  /** 2, 4, or 8-byte floating point value */\n  Float = 3,\n  /** Variable-length bytes (no guarantee of UTF8-ness) */\n  Binary = 4,\n  /** UTF8 variable-length string as List<Char> */\n  Utf8 = 5,\n  /** Boolean as 1 bit, LSB bit-packed ordering */\n  Bool = 6,\n  /** Precision-and-scale-based decimal type. Storage type depends on the parameters. */\n  Decimal = 7,\n  /** int32_t days or int64_t milliseconds since the UNIX epoch */\n  Date = 8,\n  /** Time as signed 32 or 64-bit integer, representing either seconds, milliseconds, microseconds, or nanoseconds since midnight since midnight */\n  Time = 9,\n  /** Exact timestamp encoded with int64 since UNIX epoch (Default unit millisecond) */\n  Timestamp = 10,\n  /** YEAR_MONTH or DAY_TIME interval in SQL style */\n  Interval = 11,\n  /** A list of some logical data type */\n  List = 12,\n  /** Struct of logical types */\n  Struct = 13,\n  /** Union of logical types */\n  Union = 14,\n  /** Fixed-size binary. Each value occupies the same number of bytes */\n  FixedSizeBinary = 15,\n  /** Fixed-size list. Each value occupies the same number of bytes */\n  FixedSizeList = 16,\n  /** Map of named logical types */\n  Map = 17,\n\n  /** Dictionary aka Category type */\n  Dictionary = -1,\n  Int8 = -2,\n  Int16 = -3,\n  Int32 = -4,\n  Int64 = -5,\n  Uint8 = -6,\n  Uint16 = -7,\n  Uint32 = -8,\n  Uint64 = -9,\n  Float16 = -10,\n  Float32 = -11,\n  Float64 = -12,\n  DateDay = -13,\n  DateMillisecond = -14,\n  TimestampSecond = -15,\n  TimestampMillisecond = -16,\n  TimestampMicrosecond = -17,\n  TimestampNanosecond = -18,\n  TimeSecond = -19,\n  TimeMillisecond = -20,\n  TimeMicrosecond = -21,\n  TimeNanosecond = -22,\n  DenseUnion = -23,\n  SparseUnion = -24,\n  IntervalDayTime = -25,\n  IntervalYearMonth = -26\n}\n","// Type deduction\nimport {\n  Schema\n  // Int,\n  // Int8,\n  // Int16,\n  // Int32,\n  // Uint8,\n  // Uint16,\n  // Uint32,\n  // Float32,\n  // Float64\n  // Bool,\n  // Utf8,\n  // TimestampMillisecond,\n  // Null\n} from '../schema';\n\n// const TYPED_ARRAY_TO_TYPE = {\n//   Int8Array: new Int8(),\n//   Int16Array: new Int16(),\n//   Int32Array: new Int32(),\n//   Uint8Array: new Uint8(),\n//   Uint8ClampedArray: new Uint8(),\n//   Uint16Array: new Uint16(),\n//   Uint32Array: new Uint32(),\n//   Float32Array: new Float32(),\n//   Float64Array: new Float64()\n// };\n\n// if (typeof BigInt64Array !== 'undefined') {\n//   TYPED_ARRAY_TO_TYPE.BigInt64Array = new Int64();\n//   TYPED_ARRAY_TO_TYPE.BigUint64Array = new Uint64();\n// }\n\n/**\n * SCHEMA SUPPORT - AUTODEDUCTION\n * @param {*} table\n * @param {*} schema\n * @returns\n */\nexport function deduceTableSchema(table, schema?: Schema) {\n  const deducedSchema = Array.isArray(table)\n    ? deduceSchemaForRowTable(table)\n    : deduceSchemaForColumnarTable(table);\n  // Deduced schema will fill in missing info from partial options.schema, if provided\n  return Object.assign(deducedSchema, schema);\n}\n\nfunction deduceSchemaForColumnarTable(columnarTable) {\n  const schema = {};\n  for (const field in columnarTable) {\n    const column = columnarTable[field];\n    // Check if column is typed, if so we are done\n    if (ArrayBuffer.isView(column)) {\n      schema[field] = column.constructor;\n      // else we need data\n    } else if (column.length) {\n      const value = column[0];\n      schema[field] = deduceTypeFromValue(value);\n      // TODO - support nested schemas?\n    }\n    // else we mark as present but unknow\n    schema[field] = schema[field] || null;\n  }\n  return schema;\n}\n\nfunction deduceSchemaForRowTable(rowTable) {\n  const schema = {};\n  if (rowTable.length) {\n    const row = rowTable[0];\n    // TODO - Could look at additional rows if nulls in first row\n    for (const field in row) {\n      const value = row[field];\n      schema[field] = deduceTypeFromValue(value);\n    }\n  }\n  return schema;\n}\n\nfunction deduceTypeFromValue(value) {\n  if (value instanceof Date) {\n    return Date;\n  } else if (value instanceof Number) {\n    return Float32Array;\n  } else if (typeof value === 'string') {\n    return String;\n  }\n  return null;\n}\n\n/*\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction deduceSchema(rows) {\n  const row = rows[0];\n\n  const schema = {};\n  let i = 0;\n  for (const columnName in row) {\n    const value = row[columnName];\n    switch (typeof value) {\n      case 'number':\n      case 'boolean':\n        // TODO - booleans could be handled differently...\n        schema[columnName] = {name: String(columnName), index: i, type: Float32Array};\n        break;\n\n      case 'object':\n        schema[columnName] = {name: String(columnName), index: i, type: Array};\n        break;\n\n      case 'string':\n      default:\n        schema[columnName] = {name: String(columnName), index: i, type: Array};\n      // We currently only handle numeric rows\n      // TODO we could offer a function to map strings to numbers?\n    }\n    i++;\n  }\n  return schema;\n}\n*/\n","import {Type} from '../schema';\nimport {AnyArray} from '../../types';\n\n/**\n * Gets type information from an Arrow type object or \"mock\" Arrow type object\n * @param arrowTypeLike Arrow Type or type object of similar shape\n */\nexport function getTypeInfo(arrowTypeLike: any): {\n  typeId: Type;\n  ArrayType: AnyArray;\n  typeName: string;\n  typeEnumName?: string;\n  precision?: number;\n} {\n  return {\n    typeId: arrowTypeLike.typeId,\n    ArrayType: arrowTypeLike.ArrayType,\n    typeName: arrowTypeLike.toString(),\n    typeEnumName: getTypeKey(arrowTypeLike.typeId),\n    precision: arrowTypeLike.precision\n  };\n}\n\nlet ReverseType: {[key: string]: string} | null = null;\n\nfunction getTypeKey(typeKey) {\n  if (!ReverseType) {\n    ReverseType = {};\n    for (const key in Type) {\n      ReverseType[Type[key]] = key;\n    }\n  }\n\n  return ReverseType[typeKey];\n}\n","import type {TypedArray} from '../../types';\nimport {DataType, Float32, Float64, Int16, Int32, Int8, Uint16, Uint32, Uint8} from '../schema';\n\nexport function getArrowTypeFromTypedArray(array: TypedArray): DataType {\n  switch (array.constructor) {\n    case Int8Array:\n      return new Int8();\n    case Uint8Array:\n      return new Uint8();\n    case Int16Array:\n      return new Int16();\n    case Uint16Array:\n      return new Uint16();\n    case Int32Array:\n      return new Int32();\n    case Uint32Array:\n      return new Uint32();\n    case Float32Array:\n      return new Float32();\n    case Float64Array:\n      return new Float64();\n    default:\n      throw new Error('array type not supported');\n  }\n}\n","// From https://github.com/rauschma/async-iter-demo/tree/master/src under MIT license\n// http://2ality.com/2016/10/asynchronous-iteration.html\n\nclass ArrayQueue<T> extends Array<T> {\n  enqueue(value) {\n    // Add at the end\n    return this.push(value);\n  }\n  dequeue(): T {\n    // Remove first element\n    return this.shift() as T;\n  }\n}\n\nexport default class AsyncQueue<T> {\n  private _values: ArrayQueue<T>;\n  private _settlers: ArrayQueue<{resolve; reject}>;\n  private _closed: boolean;\n\n  constructor() {\n    // enqueues > dequeues\n    this._values = new ArrayQueue<T>();\n    // dequeues > enqueues\n    this._settlers = new ArrayQueue<{resolve; reject}>();\n    this._closed = false;\n  }\n\n  close(): void {\n    while (this._settlers.length > 0) {\n      this._settlers.dequeue().resolve({done: true});\n    }\n    this._closed = true;\n  }\n\n  [Symbol.asyncIterator](): AsyncIterator<T> {\n    return this;\n  }\n\n  enqueue(value: T | Error): void {\n    if (this._closed) {\n      throw new Error('Closed');\n    }\n\n    if (this._settlers.length > 0) {\n      if (this._values.length > 0) {\n        throw new Error('Illegal internal state');\n      }\n      const settler = this._settlers.dequeue();\n      if (value instanceof Error) {\n        settler.reject(value);\n      } else {\n        settler.resolve({value});\n      }\n    } else {\n      this._values.enqueue(value);\n    }\n  }\n\n  /**\n   * @returns a Promise for an IteratorResult\n   */\n  next(): Promise<any> {\n    if (this._values.length > 0) {\n      const value = this._values.dequeue();\n      if (value instanceof Error) {\n        return Promise.reject(value);\n      }\n      return Promise.resolve({value});\n    }\n\n    if (this._closed) {\n      if (this._settlers.length > 0) {\n        throw new Error('Illegal internal state');\n      }\n      return Promise.resolve({done: true});\n    }\n    // Wait for new values to be enqueued\n    return new Promise((resolve, reject) => {\n      this._settlers.enqueue({resolve, reject});\n    });\n  }\n}\n\n/**\n * @returns a Promise for an Array with the elements in `asyncIterable`\n */\nexport async function takeAsync(\n  asyncIterable: AsyncIterable<any>,\n  count = Infinity\n): Promise<any[]> {\n  const result: Array<any> = [];\n  const iterator = asyncIterable[Symbol.asyncIterator]();\n  while (result.length < count) {\n    const {value, done} = await iterator.next();\n    if (done) {\n      break;\n    }\n    result.push(value);\n  }\n  return result;\n}\n","import {Schema, Field, FixedSizeList, getArrowTypeFromTypedArray} from '@loaders.gl/schema';\n\nimport {MeshAttribute, DracoAttribute, DracoLoaderData, DracoMetadataEntry} from '../draco-types';\n\nexport function makeSchemaFromAttributes(\n  attributes: {[attributeName: string]: MeshAttribute},\n  loaderData: DracoLoaderData,\n  indices?: MeshAttribute\n): Schema {\n  const metadataMap = makeMetadata(loaderData.metadata);\n  const fields: Field[] = [];\n  const namedLoaderDataAttributes = transformAttributesLoaderData(loaderData.attributes);\n  for (const attributeName in attributes) {\n    const attribute = attributes[attributeName];\n    const field = getArrowFieldFromAttribute(\n      attributeName,\n      attribute,\n      namedLoaderDataAttributes[attributeName]\n    );\n    fields.push(field);\n  }\n  if (indices) {\n    const indicesField = getArrowFieldFromAttribute('indices', indices);\n    fields.push(indicesField);\n  }\n  return new Schema(fields, metadataMap);\n}\n\nfunction transformAttributesLoaderData(loaderData: {[key: number]: DracoAttribute}): {\n  [attributeName: string]: DracoAttribute;\n} {\n  const result: {[attributeName: string]: DracoAttribute} = {};\n  for (const key in loaderData) {\n    const dracoAttribute = loaderData[key];\n    result[dracoAttribute.name || 'undefined'] = dracoAttribute;\n  }\n  return result;\n}\n\nfunction getArrowFieldFromAttribute(\n  attributeName: string,\n  attribute: MeshAttribute,\n  loaderData?: DracoAttribute\n): Field {\n  const metadataMap = loaderData ? makeMetadata(loaderData.metadata) : undefined;\n  const type = getArrowTypeFromTypedArray(attribute.value);\n  return new Field(\n    attributeName,\n    new FixedSizeList(attribute.size, new Field('value', type)),\n    false,\n    metadataMap\n  );\n}\n\nfunction makeMetadata(metadata: {[key: string]: DracoMetadataEntry}): Map<string, string> {\n  const metadataMap = new Map();\n  for (const key in metadata) {\n    metadataMap.set(`${key}.string`, JSON.stringify(metadata[key]));\n  }\n\n  return metadataMap;\n}\n","import type {Writer} from '@loaders.gl/loader-utils';\nimport type {DracoMeshData} from './lib/draco-types';\nimport type {DracoBuildOptions} from './lib/draco-builder';\nimport DRACOBuilder from './lib/draco-builder';\nimport {loadDracoEncoderModule} from './lib/draco-module-loader';\nimport {VERSION} from './lib/utils/version';\n\nexport type DracoWriterOptions = DracoBuildOptions & {};\n\nconst DEFAULT_DRACO_OPTIONS = {\n  pointcloud: false, // Set to true if pointcloud (mode: 0, no indices)\n  attributeNameEntry: 'name'\n  // Draco Compression Parameters\n  // method: 'MESH_EDGEBREAKER_ENCODING',\n  // speed: [5, 5],\n  // quantization: {\n  //   POSITION: 10\n  // }\n};\n\n/**\n * Exporter for Draco3D compressed geometries\n */\nexport const DracoWriter: Writer = {\n  name: 'DRACO',\n  id: 'draco',\n  module: 'draco',\n  version: VERSION,\n  extensions: ['drc'],\n  encode,\n  options: {\n    draco: DEFAULT_DRACO_OPTIONS\n  }\n};\n\nasync function encode(\n  data: DracoMeshData,\n  options: {draco?: DracoWriterOptions} = {}\n): Promise<ArrayBuffer> {\n  // Dynamically load draco\n  const {draco} = await loadDracoEncoderModule(options);\n  const dracoBuilder = new DRACOBuilder(draco);\n\n  try {\n    return dracoBuilder.encodeSync(data, options.draco);\n  } finally {\n    dracoBuilder.destroy();\n  }\n}\n","/* eslint-disable camelcase */\n// This code is inspired by example code in the DRACO repository\nimport type {\n  Draco3D,\n  DracoInt8Array,\n  Encoder,\n  Mesh,\n  MeshBuilder,\n  PointCloud,\n  Metadata,\n  MetadataBuilder,\n  draco_GeometryAttribute_Type\n} from '../draco3d/draco3d-types';\n\nimport type {TypedArray, DracoMeshData} from './draco-types';\n\nexport type DracoBuildOptions = {\n  pointcloud?: boolean;\n  metadata?: {[key: string]: string};\n  attributesMetadata?: {};\n  log?: any;\n\n  // draco encoding options\n  speed?: [number, number];\n  method?: string;\n  quantization?: {[attributeName: string]: number};\n};\n\n// Native Draco attribute names to GLTF attribute names.\nconst GLTF_TO_DRACO_ATTRIBUTE_NAME_MAP = {\n  POSITION: 'POSITION',\n  NORMAL: 'NORMAL',\n  COLOR_0: 'COLOR',\n  TEXCOORD_0: 'TEX_COORD'\n};\n\nconst noop = () => {};\n\nexport default class DracoBuilder {\n  draco: Draco3D;\n  dracoEncoder: Encoder;\n  dracoMeshBuilder: MeshBuilder;\n  dracoMetadataBuilder: MetadataBuilder;\n  log: any;\n\n  // draco - the draco decoder, either import `draco3d` or load dynamically\n  constructor(draco: Draco3D) {\n    this.draco = draco;\n    this.dracoEncoder = new this.draco.Encoder();\n    this.dracoMeshBuilder = new this.draco.MeshBuilder();\n    this.dracoMetadataBuilder = new this.draco.MetadataBuilder();\n  }\n\n  destroy(): void {\n    this.destroyEncodedObject(this.dracoMeshBuilder);\n    this.destroyEncodedObject(this.dracoEncoder);\n    this.destroyEncodedObject(this.dracoMetadataBuilder);\n    // @ts-ignore\n    this.dracoMeshBuilder = null;\n    // @ts-ignore\n    this.dracoEncoder = null;\n    // @ts-ignore\n    this.draco = null;\n  }\n\n  // TBD - when does this need to be called?\n  destroyEncodedObject(object): void {\n    if (object) {\n      this.draco.destroy(object);\n    }\n  }\n\n  /**\n   * Encode mesh or point cloud\n   * @param mesh =({})\n   * @param options\n   */\n  encodeSync(mesh: DracoMeshData, options: DracoBuildOptions = {}): ArrayBuffer {\n    this.log = noop; // TODO\n    this._setOptions(options);\n\n    return options.pointcloud\n      ? this._encodePointCloud(mesh, options)\n      : this._encodeMesh(mesh, options);\n  }\n\n  // PRIVATE\n\n  _getAttributesFromMesh(mesh: DracoMeshData) {\n    // TODO - Change the encodePointCloud interface instead?\n    const attributes = {...mesh, ...mesh.attributes};\n    // Fold indices into the attributes\n    if (mesh.indices) {\n      attributes.indices = mesh.indices;\n    }\n    return attributes;\n  }\n\n  _encodePointCloud(pointcloud: DracoMeshData, options: DracoBuildOptions): ArrayBuffer {\n    const dracoPointCloud = new this.draco.PointCloud();\n\n    if (options.metadata) {\n      this._addGeometryMetadata(dracoPointCloud, options.metadata);\n    }\n\n    const attributes = this._getAttributesFromMesh(pointcloud);\n\n    // Build a `DracoPointCloud` from the input data\n    this._createDracoPointCloud(dracoPointCloud, attributes, options);\n\n    const dracoData = new this.draco.DracoInt8Array();\n\n    try {\n      const encodedLen = this.dracoEncoder.EncodePointCloudToDracoBuffer(\n        dracoPointCloud,\n        false,\n        dracoData\n      );\n\n      if (!(encodedLen > 0)) {\n        throw new Error('Draco encoding failed.');\n      }\n\n      this.log(`DRACO encoded ${dracoPointCloud.num_points()} points\n        with ${dracoPointCloud.num_attributes()} attributes into ${encodedLen} bytes`);\n\n      return dracoInt8ArrayToArrayBuffer(dracoData);\n    } finally {\n      this.destroyEncodedObject(dracoData);\n      this.destroyEncodedObject(dracoPointCloud);\n    }\n  }\n\n  _encodeMesh(mesh: DracoMeshData, options: DracoBuildOptions): ArrayBuffer {\n    const dracoMesh = new this.draco.Mesh();\n\n    if (options.metadata) {\n      this._addGeometryMetadata(dracoMesh, options.metadata);\n    }\n\n    const attributes = this._getAttributesFromMesh(mesh);\n\n    // Build a `DracoMeshData` from the input data\n    this._createDracoMesh(dracoMesh, attributes, options);\n\n    const dracoData = new this.draco.DracoInt8Array();\n\n    try {\n      const encodedLen = this.dracoEncoder.EncodeMeshToDracoBuffer(dracoMesh, dracoData);\n      if (encodedLen <= 0) {\n        throw new Error('Draco encoding failed.');\n      }\n\n      this.log(`DRACO encoded ${dracoMesh.num_points()} points\n        with ${dracoMesh.num_attributes()} attributes into ${encodedLen} bytes`);\n\n      return dracoInt8ArrayToArrayBuffer(dracoData);\n    } finally {\n      this.destroyEncodedObject(dracoData);\n      this.destroyEncodedObject(dracoMesh);\n    }\n  }\n\n  /**\n   * Set encoding options.\n   * @param {{speed?: any; method?: any; quantization?: any;}} options\n   */\n  _setOptions(options: DracoBuildOptions): void {\n    if ('speed' in options) {\n      // @ts-ignore\n      this.dracoEncoder.SetSpeedOptions(...options.speed);\n    }\n    if ('method' in options) {\n      const dracoMethod = this.draco[options.method || 'MESH_SEQUENTIAL_ENCODING'];\n      // assert(dracoMethod)\n      this.dracoEncoder.SetEncodingMethod(dracoMethod);\n    }\n    if ('quantization' in options) {\n      for (const attribute in options.quantization) {\n        const bits = options.quantization[attribute];\n        const dracoPosition = this.draco[attribute];\n        this.dracoEncoder.SetAttributeQuantization(dracoPosition, bits);\n      }\n    }\n  }\n\n  /**\n   * @param {Mesh} dracoMesh\n   * @param {object} attributes\n   * @returns {Mesh}\n   */\n  _createDracoMesh(dracoMesh: Mesh, attributes, options: DracoBuildOptions): Mesh {\n    const optionalMetadata = options.attributesMetadata || {};\n\n    try {\n      const positions = this._getPositionAttribute(attributes);\n      if (!positions) {\n        throw new Error('positions');\n      }\n      const vertexCount = positions.length / 3;\n\n      for (let attributeName in attributes) {\n        const attribute = attributes[attributeName];\n        attributeName = GLTF_TO_DRACO_ATTRIBUTE_NAME_MAP[attributeName] || attributeName;\n        const uniqueId = this._addAttributeToMesh(dracoMesh, attributeName, attribute, vertexCount);\n\n        if (uniqueId !== -1) {\n          this._addAttributeMetadata(dracoMesh, uniqueId, {\n            name: attributeName,\n            ...(optionalMetadata[attributeName] || {})\n          });\n        }\n      }\n    } catch (error) {\n      this.destroyEncodedObject(dracoMesh);\n      throw error;\n    }\n\n    return dracoMesh;\n  }\n\n  /**\n   * @param {} dracoPointCloud\n   * @param {object} attributes\n   */\n  _createDracoPointCloud(\n    dracoPointCloud: PointCloud,\n    attributes: object,\n    options: DracoBuildOptions\n  ): PointCloud {\n    const optionalMetadata = options.attributesMetadata || {};\n\n    try {\n      const positions = this._getPositionAttribute(attributes);\n      if (!positions) {\n        throw new Error('positions');\n      }\n      const vertexCount = positions.length / 3;\n\n      for (let attributeName in attributes) {\n        const attribute = attributes[attributeName];\n        attributeName = GLTF_TO_DRACO_ATTRIBUTE_NAME_MAP[attributeName] || attributeName;\n        const uniqueId = this._addAttributeToMesh(\n          dracoPointCloud,\n          attributeName,\n          attribute,\n          vertexCount\n        );\n        if (uniqueId !== -1) {\n          this._addAttributeMetadata(dracoPointCloud, uniqueId, {\n            name: attributeName,\n            ...(optionalMetadata[attributeName] || {})\n          });\n        }\n      }\n    } catch (error) {\n      this.destroyEncodedObject(dracoPointCloud);\n      throw error;\n    }\n\n    return dracoPointCloud;\n  }\n\n  /**\n   * @param mesh\n   * @param attributeName\n   * @param attribute\n   * @param vertexCount\n   */\n  _addAttributeToMesh(\n    mesh: PointCloud,\n    attributeName: string,\n    attribute: TypedArray,\n    vertexCount: number\n  ) {\n    if (!ArrayBuffer.isView(attribute)) {\n      return -1;\n    }\n\n    const type = this._getDracoAttributeType(attributeName);\n    // @ts-ignore TODO/fix types\n    const size = attribute.length / vertexCount;\n\n    if (type === 'indices') {\n      // @ts-ignore TODO/fix types\n      const numFaces = attribute.length / 3;\n      this.log(`Adding attribute ${attributeName}, size ${numFaces}`);\n\n      // @ts-ignore assumes mesh is a Mesh, not a point cloud\n      this.dracoMeshBuilder.AddFacesToMesh(mesh, numFaces, attribute);\n      return -1;\n    }\n\n    this.log(`Adding attribute ${attributeName}, size ${size}`);\n\n    const builder = this.dracoMeshBuilder;\n    const {buffer} = attribute;\n\n    switch (attribute.constructor) {\n      case Int8Array:\n        return builder.AddInt8Attribute(mesh, type, vertexCount, size, new Int8Array(buffer));\n\n      case Int16Array:\n        return builder.AddInt16Attribute(mesh, type, vertexCount, size, new Int16Array(buffer));\n\n      case Int32Array:\n        return builder.AddInt32Attribute(mesh, type, vertexCount, size, new Int32Array(buffer));\n      case Uint8Array:\n      case Uint8ClampedArray:\n        return builder.AddUInt8Attribute(mesh, type, vertexCount, size, new Uint8Array(buffer));\n\n      case Uint16Array:\n        return builder.AddUInt16Attribute(mesh, type, vertexCount, size, new Uint16Array(buffer));\n\n      case Uint32Array:\n        return builder.AddUInt32Attribute(mesh, type, vertexCount, size, new Uint32Array(buffer));\n\n      case Float32Array:\n      default:\n        return builder.AddFloatAttribute(mesh, type, vertexCount, size, new Float32Array(buffer));\n    }\n  }\n\n  /**\n   * DRACO can compress attributes of know type better\n   * TODO - expose an attribute type map?\n   * @param attributeName\n   */\n  _getDracoAttributeType(attributeName: string): draco_GeometryAttribute_Type | 'indices' {\n    switch (attributeName.toLowerCase()) {\n      case 'indices':\n        return 'indices';\n      case 'position':\n      case 'positions':\n      case 'vertices':\n        return this.draco.POSITION;\n      case 'normal':\n      case 'normals':\n        return this.draco.NORMAL;\n      case 'color':\n      case 'colors':\n        return this.draco.COLOR;\n      case 'texcoord':\n      case 'texcoords':\n        return this.draco.TEX_COORD;\n      default:\n        return this.draco.GENERIC;\n    }\n  }\n\n  _getPositionAttribute(attributes) {\n    for (const attributeName in attributes) {\n      const attribute = attributes[attributeName];\n      const dracoType = this._getDracoAttributeType(attributeName);\n      if (dracoType === this.draco.POSITION) {\n        return attribute;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Add metadata for the geometry.\n   * @param dracoGeometry - WASM Draco Object\n   * @param metadata\n   */\n  _addGeometryMetadata(dracoGeometry: PointCloud, metadata: {[key: string]: string}) {\n    const dracoMetadata = new this.draco.Metadata();\n    this._populateDracoMetadata(dracoMetadata, metadata);\n    this.dracoMeshBuilder.AddMetadata(dracoGeometry, dracoMetadata);\n  }\n\n  /**\n   * Add metadata for an attribute to geometry.\n   * @param dracoGeometry - WASM Draco Object\n   * @param uniqueAttributeId\n   * @param metadata\n   */\n  _addAttributeMetadata(\n    dracoGeometry: PointCloud,\n    uniqueAttributeId: number,\n    metadata: Map<string, string> | {[key: string]: string}\n  ) {\n    // Note: Draco JS IDL doesn't seem to expose draco.AttributeMetadata, however it seems to\n    // create such objects automatically from draco.Metadata object.\n    const dracoAttributeMetadata = new this.draco.Metadata();\n    this._populateDracoMetadata(dracoAttributeMetadata, metadata);\n    // Draco3d doc note: Directly add attribute metadata to geometry.\n    // You can do this without explicitly adding |GeometryMetadata| to mesh.\n    this.dracoMeshBuilder.SetMetadataForAttribute(\n      dracoGeometry,\n      uniqueAttributeId,\n      dracoAttributeMetadata\n    );\n  }\n\n  /**\n   * Add contents of object or map to a WASM Draco Metadata Object\n   * @param dracoMetadata - WASM Draco Object\n   * @param metadata\n   */\n  _populateDracoMetadata(\n    dracoMetadata: Metadata,\n    metadata: Map<string, string> | {[key: string]: string}\n  ) {\n    for (const [key, value] of getEntries(metadata)) {\n      switch (typeof value) {\n        case 'number':\n          if (Math.trunc(value) === value) {\n            this.dracoMetadataBuilder.AddIntEntry(dracoMetadata, key, value);\n          } else {\n            this.dracoMetadataBuilder.AddDoubleEntry(dracoMetadata, key, value);\n          }\n          break;\n        case 'object':\n          if (value instanceof Int32Array) {\n            this.dracoMetadataBuilder.AddIntEntryArray(dracoMetadata, key, value, value.length);\n          }\n          break;\n        case 'string':\n        default:\n          this.dracoMetadataBuilder.AddStringEntry(dracoMetadata, key, value);\n      }\n    }\n  }\n}\n\n// HELPER FUNCTIONS\n\n/**\n * Copy encoded data to buffer\n * @param dracoData\n */\nfunction dracoInt8ArrayToArrayBuffer(dracoData: DracoInt8Array) {\n  const byteLength = dracoData.size();\n  const outputBuffer = new ArrayBuffer(byteLength);\n  const outputData = new Int8Array(outputBuffer);\n  for (let i = 0; i < byteLength; ++i) {\n    outputData[i] = dracoData.GetValue(i);\n  }\n  return outputBuffer;\n}\n\n/** Enable iteration over either an object or a map */\nfunction getEntries(container) {\n  const hasEntriesFunc = container.entries && !container.hasOwnProperty('entries');\n  return hasEntriesFunc ? container.entries() : Object.entries(container);\n}\n","// import type {TypedArray} from '../types/loader-utils';\nimport type {GLTFAccessor} from '../types/gltf-types';\n// TODO - remove\nimport {getAccessorTypeFromSize, getComponentTypeFromArray} from './gltf-utils';\n\n// Returns a fresh attributes object with glTF-standardized attributes names\n// Attributes that cannot be identified will not be included\n// Removes `indices` if present, as it should be stored separately from the attributes\nexport function getGLTFAccessors(attributes): {[key: string]: GLTFAccessor} {\n  const accessors = {};\n  for (const name in attributes) {\n    const attribute = attributes[name];\n    if (name !== 'indices') {\n      const glTFAccessor = getGLTFAccessor(attribute);\n      accessors[name] = glTFAccessor;\n    }\n  }\n  return accessors;\n}\n\n// Fix up a single accessor.\n// Input: typed array or a partial accessor object\n// Return: accessor object\nexport function getGLTFAccessor(attribute) {\n  const {buffer, size, count} = getAccessorData(attribute);\n\n  const glTFAccessor: GLTFAccessor = {\n    // glTF Accessor values\n    // TODO: Instead of a bufferView index we could have an actual buffer (typed array)\n    // bufferView: null,\n    // TODO: Deprecate `value` in favor of bufferView?\n    // @ts-ignore\n    value: buffer,\n    size, // Decoded `type` (e.g. SCALAR)\n\n    byteOffset: 0,\n    count,\n    type: getAccessorTypeFromSize(size),\n    componentType: getComponentTypeFromArray(buffer)\n  };\n\n  return glTFAccessor;\n}\n\n// export function getGLTFAttribute(data, gltfAttributeName): GLTFAccessor {\n//   return data.attributes[data.glTFAttributeMap[gltfAttributeName]];\n// }\n\nfunction getAccessorData(attribute) {\n  let buffer = attribute;\n  let size = 1;\n  let count = 0;\n\n  if (attribute && attribute.value) {\n    buffer = attribute.value;\n    size = attribute.size || 1;\n  }\n\n  if (buffer) {\n    if (!ArrayBuffer.isView(buffer)) {\n      buffer = toTypedArray(buffer, Float32Array);\n    }\n    count = buffer.length / size;\n  }\n\n  return {buffer, size, count};\n}\n\n// Convert non-typed arrays to arrays of specified format\nfunction toTypedArray(array, ArrayType, convertTypedArrays = false) {\n  if (!array) {\n    return null;\n  }\n  if (Array.isArray(array)) {\n    return new ArrayType(array);\n  }\n  if (convertTypedArrays && !(array instanceof ArrayType)) {\n    return new ArrayType(array);\n  }\n  return array;\n}\n","// GLTF EXTENSION: KHR_materials_unlit\n// https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit\n\nimport type {GLTF} from '../types/gltf-types';\n\nimport GLTFScenegraph from '../api/gltf-scenegraph';\nimport {KHR_MATERIALS_UNLIT} from '../gltf-utils/gltf-constants';\n\nexport async function decode(gltfData: {json: GLTF}): Promise<void> {\n  const gltfScenegraph = new GLTFScenegraph(gltfData);\n  const {json} = gltfScenegraph;\n\n  // Remove the top-level extension\n  gltfScenegraph.removeExtension(KHR_MATERIALS_UNLIT);\n\n  // Any nodes that have the extension, add lights field pointing to light object\n  // and remove the extension\n  for (const material of json.materials || []) {\n    const extension = material.extensions && material.extensions.KHR_materials_unlit;\n    if (extension) {\n      // @ts-ignore TODO\n      material.unlit = true;\n    }\n    gltfScenegraph.removeObjectExtension(material, KHR_MATERIALS_UNLIT);\n  }\n}\n\nexport function encode(gltfData) {\n  const gltfScenegraph = new GLTFScenegraph(gltfData);\n  const {json} = gltfScenegraph;\n\n  // Any nodes that have lights field pointing to light object\n  // add the extension\n  // @ts-ignore\n  if (gltfScenegraph.materials) {\n    for (const material of json.materials || []) {\n      // @ts-ignore\n      if (material.unlit) {\n        // @ts-ignore\n        delete material.unlit;\n        gltfScenegraph.addObjectExtension(material, KHR_MATERIALS_UNLIT, {});\n        gltfScenegraph.addExtension(KHR_MATERIALS_UNLIT);\n      }\n    }\n  }\n}\n","// GLTF EXTENSION: KHR_lights_punctual\n// https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual\n\nimport type {GLTF} from '../types/gltf-types';\n\nimport {assert} from '../utils/assert';\nimport GLTFScenegraph from '../api/gltf-scenegraph';\nimport {KHR_LIGHTS_PUNCTUAL} from '../gltf-utils/gltf-constants';\n\nexport async function decode(gltfData: {json: GLTF}): Promise<void> {\n  const gltfScenegraph = new GLTFScenegraph(gltfData);\n  const {json} = gltfScenegraph;\n\n  // Move the light array out of the extension and remove the extension\n  const extension = gltfScenegraph.getExtension(KHR_LIGHTS_PUNCTUAL);\n  if (extension) {\n    // @ts-ignore\n    gltfScenegraph.json.lights = extension.lights;\n    gltfScenegraph.removeExtension(KHR_LIGHTS_PUNCTUAL);\n  }\n\n  // Any nodes that have the extension, add lights field pointing to light object\n  // and remove the extension\n  for (const node of json.nodes || []) {\n    const nodeExtension = gltfScenegraph.getObjectExtension(node, KHR_LIGHTS_PUNCTUAL);\n    if (nodeExtension) {\n      // @ts-ignore\n      node.light = nodeExtension.light;\n    }\n    gltfScenegraph.removeObjectExtension(node, KHR_LIGHTS_PUNCTUAL);\n  }\n}\n\n// Move the light ar ray out of the extension and remove the extension\nexport async function encode(gltfData): Promise<void> {\n  const gltfScenegraph = new GLTFScenegraph(gltfData);\n  const {json} = gltfScenegraph;\n\n  // @ts-ignore\n  if (json.lights) {\n    const extension = gltfScenegraph.addExtension(KHR_LIGHTS_PUNCTUAL);\n    // @ts-ignore\n    assert(!extension.lights);\n    // @ts-ignore\n    extension.lights = json.lights;\n    // @ts-ignore\n    delete json.lights;\n  }\n\n  // Any nodes that have lights field pointing to light object\n  // add the extension\n  // @ts-ignore\n  if (gltfScenegraph.json.lights) {\n    // @ts-ignore\n    for (const light of gltfScenegraph.json.lights) {\n      const node = light.node;\n      gltfScenegraph.addObjectExtension(node, KHR_LIGHTS_PUNCTUAL, light);\n    }\n    // @ts-ignore\n    delete gltfScenegraph.json.lights;\n  }\n}\n","// GLTF EXTENSION: KHR_techniques_webgl\n// https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_techniques_webgl\n\nimport type {GLTF} from '../types/gltf-types';\n\nimport GLTFScenegraph from '../api/gltf-scenegraph';\nimport {KHR_TECHNIQUES_WEBGL} from '../gltf-utils/gltf-constants';\n\nexport async function decode(gltfData: {json: GLTF}): Promise<void> {\n  const gltfScenegraph = new GLTFScenegraph(gltfData);\n  const {json} = gltfScenegraph;\n\n  const extension = gltfScenegraph.getExtension(KHR_TECHNIQUES_WEBGL);\n  if (extension) {\n    const techniques = resolveTechniques(extension, gltfScenegraph);\n\n    for (const material of json.materials || []) {\n      const materialExtension = gltfScenegraph.getObjectExtension(material, KHR_TECHNIQUES_WEBGL);\n      if (materialExtension) {\n        // @ts-ignore TODO\n        material.technique = Object.assign(\n          {},\n          materialExtension,\n          // @ts-ignore\n          techniques[materialExtension.technique]\n        );\n        // @ts-ignore TODO\n        material.technique.values = resolveValues(material.technique, gltfScenegraph);\n      }\n      gltfScenegraph.removeObjectExtension(material, KHR_TECHNIQUES_WEBGL);\n    }\n\n    gltfScenegraph.removeExtension(KHR_TECHNIQUES_WEBGL);\n  }\n}\n// eslint-disable-next-line\nexport async function encode(gltfData, options): Promise<void> {\n  // TODO\n}\n\nfunction resolveTechniques(\n  techniquesExtension: {[key: string]: any},\n  // programs: {[key: string]: any}[],\n  // shaders: {[key: string]: any}[],\n  // techniques: {[key: string]: any}[]\n  gltfScenegraph\n) {\n  const {programs = [], shaders = [], techniques = []} = techniquesExtension;\n  const textDecoder = new TextDecoder();\n\n  shaders.forEach((shader) => {\n    if (Number.isFinite(shader.bufferView)) {\n      shader.code = textDecoder.decode(\n        gltfScenegraph.getTypedArrayForBufferView(shader.bufferView)\n      );\n    } else {\n      // TODO: handle URI shader\n      throw new Error('KHR_techniques_webgl: no shader code');\n    }\n  });\n\n  programs.forEach((program) => {\n    program.fragmentShader = shaders[program.fragmentShader];\n    program.vertexShader = shaders[program.vertexShader];\n  });\n\n  techniques.forEach((technique) => {\n    technique.program = programs[technique.program];\n  });\n\n  return techniques;\n}\n\nfunction resolveValues(technique, gltfScenegraph) {\n  const values = Object.assign({}, technique.values);\n\n  // merge values from uniforms\n  Object.keys(technique.uniforms || {}).forEach((uniform) => {\n    if (technique.uniforms[uniform].value && !(uniform in values)) {\n      values[uniform] = technique.uniforms[uniform].value;\n    }\n  });\n\n  // resolve textures\n  Object.keys(values).forEach((uniform) => {\n    if (typeof values[uniform] === 'object' && values[uniform].index !== undefined) {\n      // Assume this is a texture\n      // TODO: find if there are any other types that can be referenced\n      values[uniform].texture = gltfScenegraph.getTexture(values[uniform].index);\n    }\n  });\n\n  return values;\n}\n","/* eslint-disable camelcase */\nimport * as KHR_binary_glTF from '../extensions/KHR_binary_gltf';\n\n// Binary format changes (mainly implemented by GLBLoader)\n// https://github.com/KhronosGroup/glTF/tree/master/extensions/1.0/Khronos/KHR_binary_glTF\n\n// JSON format changes:\n// https://github.com/khronosgroup/gltf/issues/605\n\n// - [x] Top-level JSON objects are arrays now\n// - [ ] Removed indirection from animation: sampler now refers directly to accessors, #712\n// - [ ] material.parameter.value and technique.parameter.value must be an array, #690\n// - [ ] Node can have only one mesh #821\n// - [ ] Added reqs on JSON encoding\n// - [ ] Added reqs on binary data alignment #802 (comment)\n\n// Additions:\n// - [ ] Added accessor.normalized, #691, #706\n// - [ ] Added glExtensionsUsed property and 5125 (UNSIGNED_INT) accessor.componentType value, #619\n// - [ ] Added extensionsRequired property, #720, #721\n// - [ ] Added \"STEP\" as valid animation.sampler.interpolation value, #712\n\n// Removals:\n// - [x] Removed buffer.type, #786, #629\n// - [ ] Removed revision number from profile.version, #709\n// - [ ] Removed technique.functions.scissor and removed 3089 (SCISSOR_TEST) as a valid value for technique.states.enable, #681\n// - [ ] Techniques, programs, and shaders were moved out to KHR_technique_webgl extension.\n\n// Other edits:\n// - [x] asset is now required, #642\n// - [ ] buffer.byteLength and bufferView.byteLength are now required, #560.\n// - [ ] accessor.min and accessor.max are now required, #593, and clarified that the JSON value and binary data must be the same, #628.\n// - [ ] Clarified animation.sampler and animation.channel restrictions, #712\n// - [ ] skin.inverseBindMatrices is now optional, #461.\n// - [ ] Attribute parameters can't have a value defined in the technique or parameter, #563 (comment).\n// - [ ] Only TEXCOORD and COLOR attribute semantics can be written in the form [semantic]_[set_index], #563 (comment).\n// - [ ] TEXCOORD and COLOR attribute semantics must be written in the form [semantic]_[set_index], e.g., just TEXCOORD should be TEXCOORD_0, and just COLOR should be COLOR_0, #649\n// - [ ] camera.perspective.aspectRatio and camera.perspective.yfov must now be > 0, not >= 0, #563 (comment).\n// - [ ] Application-specific parameter semantics must start with an underscore, e.g., _TEMPERATURE and _SIMULATION_TIME, #563 (comment).\n// - [ ] Properties in technique.parameters must be defined in technique.uniforms or technique.attributes,\n\n// #563 (comment).\n// - [ ] technique.parameter.count can only be defined when the semantic is JOINTMATRIX or an application-specific semantic is used. It can never be defined for attribute parameters; only uniforms, d2f6945\n// - [ ] technique.parameter.semantic is required when the parameter is an attribute, 28e113d\n// - [ ] Mesh-only models are allowed, e.g., without materials, #642\n// - [ ] Skeleton hierarchies (nodes containing jointName) must be separated from non-skeleton hierarchies., #647\n// - [ ] technique.states.functions.blendColor and technique.states.functions.depthRange parameters now must match WebGL function min/max, #707\n\nconst GLTF_ARRAYS = {\n  accessors: 'accessor',\n  animations: 'animation',\n  buffers: 'buffer',\n  bufferViews: 'bufferView',\n  images: 'image',\n  materials: 'material',\n  meshes: 'mesh',\n  nodes: 'node',\n  samplers: 'sampler',\n  scenes: 'scene',\n  skins: 'skin',\n  textures: 'texture'\n};\n\nconst GLTF_KEYS = {\n  accessor: 'accessors',\n  animations: 'animation',\n  buffer: 'buffers',\n  bufferView: 'bufferViews',\n  image: 'images',\n  material: 'materials',\n  mesh: 'meshes',\n  node: 'nodes',\n  sampler: 'samplers',\n  scene: 'scenes',\n  skin: 'skins',\n  texture: 'textures'\n};\n\n/**\n * Converts (normalizes) glTF v1 to v2\n */\nclass GLTFV1Normalizer {\n  constructor(gltf) {\n    this.idToIndexMap = {\n      animations: {},\n      accessors: {},\n      buffers: {},\n      bufferViews: {},\n      images: {},\n      materials: {},\n      meshes: {},\n      nodes: {},\n      samplers: {},\n      scenes: {},\n      skins: {},\n      textures: {}\n    };\n  }\n\n  /**\n   * Convert (normalize) glTF < 2.0 to glTF 2.0\n   * @param gltf - object with json and binChunks\n   * @param options\n   * @param options normalize Whether to actually normalize\n   */\n  normalize(gltf, options) {\n    this.json = gltf.json;\n    const json = gltf.json;\n\n    // Check version\n    switch (json.asset && json.asset.version) {\n      // We are converting to v2 format. Return if there is nothing to do\n      case '2.0':\n        return;\n\n      // This class is written to convert 1.0\n      case undefined:\n      case '1.0':\n        break;\n\n      default:\n        // eslint-disable-next-line no-undef, no-console\n        console.warn(`glTF: Unknown version ${json.asset.version}`);\n        return;\n    }\n\n    if (!options.normalize) {\n      // We are still missing a few conversion tricks, remove once addressed\n      throw new Error('glTF v1 is not supported.');\n    }\n\n    // eslint-disable-next-line no-undef, no-console\n    console.warn('Converting glTF v1 to glTF v2 format. This is experimental and may fail.');\n\n    this._addAsset(json);\n\n    // In glTF2 top-level fields are Arrays not Object maps\n    this._convertTopLevelObjectsToArrays(json);\n\n    // Extract bufferView indices for images\n    // (this extension needs to be invoked early in the normalization process)\n    KHR_binary_glTF.decode(gltf);\n\n    // Convert object references from ids to indices\n    this._convertObjectIdsToArrayIndices(json);\n\n    this._updateObjects(json);\n\n    this._updateMaterial(json);\n  }\n\n  // asset is now required, #642 https://github.com/KhronosGroup/glTF/issues/639\n  _addAsset(json) {\n    json.asset = json.asset || {};\n    // We are normalizing to glTF v2, so change version to \"2.0\"\n    json.asset.version = '2.0';\n    json.asset.generator = json.asset.generator || 'Normalized to glTF 2.0 by loaders.gl';\n  }\n\n  _convertTopLevelObjectsToArrays(json) {\n    // TODO check that all arrays are covered\n    for (const arrayName in GLTF_ARRAYS) {\n      this._convertTopLevelObjectToArray(json, arrayName);\n    }\n  }\n\n  /** Convert one top level object to array */\n  _convertTopLevelObjectToArray(json, mapName) {\n    const objectMap = json[mapName];\n    if (!objectMap || Array.isArray(objectMap)) {\n      return;\n    }\n\n    // Rewrite the top-level field as an array\n    json[mapName] = [];\n    // Copy the map key into object.id\n    for (const id in objectMap) {\n      const object = objectMap[id];\n      object.id = object.id || id; // Mutates the loaded object\n      const index = json[mapName].length;\n      json[mapName].push(object);\n      this.idToIndexMap[mapName][id] = index;\n    }\n  }\n\n  /** Go through all objects in all top-level arrays and replace ids with indices */\n  _convertObjectIdsToArrayIndices(json) {\n    for (const arrayName in GLTF_ARRAYS) {\n      this._convertIdsToIndices(json, arrayName);\n    }\n    if ('scene' in json) {\n      json.scene = this._convertIdToIndex(json.scene, 'scene');\n    }\n\n    // Convert any index references that are not using array names\n\n    // texture.source (image)\n    for (const texture of json.textures) {\n      this._convertTextureIds(texture);\n    }\n    for (const mesh of json.meshes) {\n      this._convertMeshIds(mesh);\n    }\n    for (const node of json.nodes) {\n      this._convertNodeIds(node);\n    }\n    for (const node of json.scenes) {\n      this._convertSceneIds(node);\n    }\n  }\n\n  _convertTextureIds(texture) {\n    if (texture.source) {\n      texture.source = this._convertIdToIndex(texture.source, 'image');\n    }\n  }\n\n  _convertMeshIds(mesh) {\n    for (const primitive of mesh.primitives) {\n      const {attributes, indices, material} = primitive;\n      for (const attributeName in attributes) {\n        attributes[attributeName] = this._convertIdToIndex(attributes[attributeName], 'accessor');\n      }\n      if (indices) {\n        primitive.indices = this._convertIdToIndex(indices, 'accessor');\n      }\n      if (material) {\n        primitive.material = this._convertIdToIndex(material, 'material');\n      }\n    }\n  }\n\n  _convertNodeIds(node) {\n    if (node.children) {\n      node.children = node.children.map((child) => this._convertIdToIndex(child, 'node'));\n    }\n    if (node.meshes) {\n      node.meshes = node.meshes.map((mesh) => this._convertIdToIndex(mesh, 'mesh'));\n    }\n  }\n\n  _convertSceneIds(scene) {\n    if (scene.nodes) {\n      scene.nodes = scene.nodes.map((node) => this._convertIdToIndex(node, 'node'));\n    }\n  }\n\n  /** Go through all objects in a top-level array and replace ids with indices */\n  _convertIdsToIndices(json, topLevelArrayName) {\n    if (!json[topLevelArrayName]) {\n      console.warn(`gltf v1: json doesn't contain attribute ${topLevelArrayName}`); // eslint-disable-line no-console, no-undef\n      json[topLevelArrayName] = [];\n    }\n    for (const object of json[topLevelArrayName]) {\n      for (const key in object) {\n        const id = object[key];\n        const index = this._convertIdToIndex(id, key);\n        object[key] = index;\n      }\n    }\n  }\n\n  _convertIdToIndex(id, key) {\n    const arrayName = GLTF_KEYS[key];\n    if (arrayName in this.idToIndexMap) {\n      const index = this.idToIndexMap[arrayName][id];\n      if (!Number.isFinite(index)) {\n        throw new Error(`gltf v1: failed to resolve ${key} with id ${id}`);\n      }\n      return index;\n    }\n    return id;\n  }\n\n  /**\n   *\n   * @param {*} json\n   */\n  _updateObjects(json) {\n    for (const buffer of this.json.buffers) {\n      // - [x] Removed buffer.type, #786, #629\n      delete buffer.type;\n    }\n  }\n\n  /**\n   * Update material (set pbrMetallicRoughness)\n   * @param {*} json\n   */\n  _updateMaterial(json) {\n    for (const material of json.materials) {\n      material.pbrMetallicRoughness = {\n        baseColorFactor: [1, 1, 1, 1],\n        metallicFactor: 1,\n        roughnessFactor: 1\n      };\n\n      const textureId = material.values && material.values.tex;\n      const textureIndex = json.textures.findIndex((texture) => texture.id === textureId);\n      if (textureIndex !== -1) {\n        material.pbrMetallicRoughness.baseColorTexture = {index: textureIndex};\n      }\n    }\n  }\n}\n\nexport function normalizeGLTFV1(gltf, options = {}) {\n  return new GLTFV1Normalizer().normalize(gltf, options);\n}\n","// GLTF 1.0 EXTENSION: KHR_binary_glTF\n// https://github.com/KhronosGroup/glTF/tree/master/extensions/1.0/Khronos/KHR_binary_glTF\n\nimport type {GLTF} from '../types/gltf-types';\n\nimport GLTFScenegraph from '../api/gltf-scenegraph';\nimport {KHR_BINARY_GLTF} from '../gltf-utils/gltf-constants';\n\nexport function decode(gltfData: {json: GLTF}): void {\n  const gltfScenegraph = new GLTFScenegraph(gltfData);\n  const {json} = gltfScenegraph;\n\n  // Note: json.buffers.binary_glTF also needs to be replaced\n  // This is currently done during gltf normalization\n\n  // Image and shader nodes can have the extension\n  // https://github.com/KhronosGroup/glTF/blob/master/extensions/1.0/Khronos/KHR_binary_glTF/schema/image.KHR_binary_glTF.schema.json\n  for (const node of json.images || []) {\n    const extension = gltfScenegraph.removeObjectExtension(node, KHR_BINARY_GLTF);\n    // The data in the extension is valid as glTF 2.0 data inside the object, so just copy it in\n    if (extension) {\n      Object.assign(node, extension);\n    }\n  }\n\n  // TODO shaders\n  // https://github.com/KhronosGroup/glTF/blob/master/extensions/1.0/Khronos/KHR_binary_glTF/schema/shader.KHR_binary_glTF.schema.json\n\n  // glTF v1 one files have a partially formed URI field that is not expected in (and causes problems in) 2.0\n  if (json.buffers && json.buffers[0]) {\n    delete json.buffers[0].uri;\n  }\n\n  // Remove the top-level extension as it has now been removed from all nodes\n  gltfScenegraph.removeExtension(KHR_BINARY_GLTF);\n}\n\n// KHR_binary_gltf is a 1.0 extension that is supported natively by 2.0\nexport function encode() {\n  throw new Error(KHR_BINARY_GLTF);\n}\n","import type {Writer} from '@loaders.gl/loader-utils';\nimport {VERSION} from './lib/utils/version';\nimport {encodeGLTFSync} from './lib/encoders/encode-gltf';\n\nexport type GLTFWriterOptions = {\n  gltf?: {};\n  byteOffset?: number;\n};\n\n/**\n * GLTF exporter\n */\nexport const GLTFWriter = {\n  name: 'glTF',\n  id: 'gltf',\n  module: 'gltf',\n  version: VERSION,\n\n  extensions: ['glb'], // We only support encoding to binary GLB, not to JSON GLTF\n  mimeTypes: ['model/gltf-binary'], // 'model/gltf+json',\n  binary: true,\n\n  encodeSync,\n\n  options: {\n    gltf: {}\n  }\n};\n\nfunction encodeSync(gltf, options: GLTFWriterOptions = {}) {\n  const {byteOffset = 0} = options;\n\n  // Calculate length, then create arraybuffer and encode\n  const byteLength = encodeGLTFSync(gltf, null, byteOffset, options);\n  const arrayBuffer = new ArrayBuffer(byteLength);\n  const dataView = new DataView(arrayBuffer);\n  encodeGLTFSync(gltf, dataView, byteOffset, options);\n\n  return arrayBuffer;\n}\n\n// TYPE TESTS - TODO find a better way than exporting junk\nexport const _TypecheckGLBLoader: Writer = GLTFWriter;\n","import encodeGLBSync from './encode-glb';\n\n// Encode the full glTF file as a binary GLB file\n// Returns an ArrayBuffer that represents the complete GLB image that can be saved to file\n//\n// TODO - Does not support encoding to non-GLB versions of glTF format\n// - Encode as a textual JSON file with binary data in base64 data URLs.\n// - Encode as a JSON with all images (and buffers?) in separate binary files\n//\n// glb-file-format-specification\n// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#\n\nexport function encodeGLTFSync(gltf, arrayBuffer, byteOffset, options) {\n  convertBuffersToBase64(gltf);\n\n  // TODO: Copy buffers to binary\n\n  return encodeGLBSync(gltf, arrayBuffer, byteOffset, options);\n}\n\nfunction convertBuffersToBase64(gltf, {firstBuffer = 0} = {}) {\n  if (gltf.buffers && gltf.buffers.length > firstBuffer) {\n    throw new Error('encodeGLTF: multiple buffers not yet implemented');\n  }\n}\n","import type {LoaderWithParser, LoaderOptions} from '@loaders.gl/loader-utils';\nimport type {GLB} from './lib/types/glb-types';\nimport type {GLBParseOptions} from './lib/parsers/parse-glb';\nimport {VERSION} from './lib/utils/version';\nimport parseGLBSync from './lib/parsers/parse-glb';\n\nexport type GLBLoaderOptions = LoaderOptions & {\n  glb?: GLBParseOptions;\n  byteOffset?: number;\n};\n\n/**\n * GLB Loader -\n * GLB is the binary container format for GLTF\n */\nexport const GLBLoader: LoaderWithParser = {\n  name: 'GLB',\n  id: 'glb',\n  module: 'gltf',\n  version: VERSION,\n  extensions: ['glb'],\n  mimeTypes: ['model/gltf-binary'],\n  binary: true,\n  parse,\n  parseSync,\n  options: {\n    glb: {\n      strict: false // Enables deprecated XVIZ support (illegal CHUNK formats)\n    }\n  }\n};\n\nasync function parse(arrayBuffer: ArrayBuffer, options?: GLBLoaderOptions): Promise<GLB> {\n  return parseSync(arrayBuffer, options);\n}\n\nfunction parseSync(arrayBuffer: ArrayBuffer, options?: GLBLoaderOptions): GLB {\n  const {byteOffset = 0} = options || {};\n  const glb: GLB = {} as GLB;\n  parseGLBSync(glb, arrayBuffer, byteOffset, options?.glb);\n  return glb;\n}\n\n// TYPE TESTS - TODO find a better way than exporting junk\nexport const _TypecheckGLBLoader: LoaderWithParser = GLBLoader;\n","import type {Writer} from '@loaders.gl/loader-utils';\nimport {VERSION} from './lib/utils/version';\nimport encodeGLBSync from './lib/encoders/encode-glb';\n\n/**\n * GLB exporter\n * GLB is the binary container format for GLTF\n */\nexport const GLBWriter = {\n  name: 'GLB',\n  id: 'glb',\n  module: 'gltf',\n  version: VERSION,\n\n  extensions: ['glb'],\n  mimeTypes: ['model/gltf-binary'],\n  binary: true,\n\n  encodeSync,\n\n  options: {\n    glb: {}\n  }\n};\n\nfunction encodeSync(glb, options) {\n  const {byteOffset = 0} = options;\n\n  // Calculate length and allocate buffer\n  const byteLength = encodeGLBSync(glb, null, byteOffset, options);\n  const arrayBuffer = new ArrayBuffer(byteLength);\n\n  // Encode into buffer\n  const dataView = new DataView(arrayBuffer);\n  encodeGLBSync(glb, dataView, byteOffset, options);\n\n  return arrayBuffer;\n}\n\n// TYPE TESTS - TODO find a better way than exporting junk\nexport const _TypecheckGLBLoader: Writer = GLBWriter;\n","import getHiResTimestamp from '../utils/hi-res-timestamp';\nexport default class Stat {\n  constructor(name, type) {\n    this.name = name;\n    this.type = type;\n    this.sampleSize = 1;\n    this.reset();\n  }\n\n  setSampleSize(samples) {\n    this.sampleSize = samples;\n    return this;\n  }\n\n  incrementCount() {\n    this.addCount(1);\n    return this;\n  }\n\n  decrementCount() {\n    this.subtractCount(1);\n    return this;\n  }\n\n  addCount(value) {\n    this._count += value;\n    this._samples++;\n\n    this._checkSampling();\n\n    return this;\n  }\n\n  subtractCount(value) {\n    this._count -= value;\n    this._samples++;\n\n    this._checkSampling();\n\n    return this;\n  }\n\n  addTime(time) {\n    this._time += time;\n    this.lastTiming = time;\n    this._samples++;\n\n    this._checkSampling();\n\n    return this;\n  }\n\n  timeStart() {\n    this._startTime = getHiResTimestamp();\n    this._timerPending = true;\n    return this;\n  }\n\n  timeEnd() {\n    if (!this._timerPending) {\n      return this;\n    }\n\n    this.addTime(getHiResTimestamp() - this._startTime);\n    this._timerPending = false;\n\n    this._checkSampling();\n\n    return this;\n  }\n\n  getSampleAverageCount() {\n    return this.sampleSize > 0 ? this.lastSampleCount / this.sampleSize : 0;\n  }\n\n  getSampleAverageTime() {\n    return this.sampleSize > 0 ? this.lastSampleTime / this.sampleSize : 0;\n  }\n\n  getSampleHz() {\n    return this.lastSampleTime > 0 ? this.sampleSize / (this.lastSampleTime / 1000) : 0;\n  }\n\n  getAverageCount() {\n    return this.samples > 0 ? this.count / this.samples : 0;\n  }\n\n  getAverageTime() {\n    return this.samples > 0 ? this.time / this.samples : 0;\n  }\n\n  getHz() {\n    return this.time > 0 ? this.samples / (this.time / 1000) : 0;\n  }\n\n  reset() {\n    this.time = 0;\n    this.count = 0;\n    this.samples = 0;\n    this.lastTiming = 0;\n    this.lastSampleTime = 0;\n    this.lastSampleCount = 0;\n    this._count = 0;\n    this._time = 0;\n    this._samples = 0;\n    this._startTime = 0;\n    this._timerPending = false;\n    return this;\n  }\n\n  _checkSampling() {\n    if (this._samples === this.sampleSize) {\n      this.lastSampleTime = this._time;\n      this.lastSampleCount = this._count;\n      this.count += this._count;\n      this.time += this._time;\n      this.samples += this._samples;\n      this._time = 0;\n      this._count = 0;\n      this._samples = 0;\n    }\n  }\n\n}\n//# sourceMappingURL=stat.js.map","import Stat from './stat';\nexport default class Stats {\n  constructor({\n    id,\n    stats\n  }) {\n    this.id = id;\n    this.stats = {};\n\n    this._initializeStats(stats);\n\n    Object.seal(this);\n  }\n\n  get(name, type = 'count') {\n    return this._getOrCreate({\n      name,\n      type\n    });\n  }\n\n  get size() {\n    return Object.keys(this.stats).length;\n  }\n\n  reset() {\n    for (const key in this.stats) {\n      this.stats[key].reset();\n    }\n\n    return this;\n  }\n\n  forEach(fn) {\n    for (const key in this.stats) {\n      fn(this.stats[key]);\n    }\n  }\n\n  getTable() {\n    const table = {};\n    this.forEach(stat => {\n      table[stat.name] = {\n        time: stat.time || 0,\n        count: stat.count || 0,\n        average: stat.getAverageTime() || 0,\n        hz: stat.getHz() || 0\n      };\n    });\n    return table;\n  }\n\n  _initializeStats(stats = []) {\n    stats.forEach(stat => this._getOrCreate(stat));\n  }\n\n  _getOrCreate(stat) {\n    if (!stat || !stat.name) {\n      return null;\n    }\n\n    const {\n      name,\n      type\n    } = stat;\n\n    if (!this.stats[name]) {\n      if (stat instanceof Stat) {\n        this.stats[name] = stat;\n      } else {\n        this.stats[name] = new Stat(name, type);\n      }\n    }\n\n    return this.stats[name];\n  }\n\n}\n//# sourceMappingURL=stats.js.map"],"sourceRoot":""}