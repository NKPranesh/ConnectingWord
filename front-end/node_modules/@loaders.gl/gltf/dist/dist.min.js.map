{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap","webpack:///../worker-utils/src/lib/env-utils/globals.ts","webpack:///../images/src/lib/utils/globals.ts","webpack:///(webpack)/buildin/global.js","webpack:////Users/kbarron/github/mapping/loaders.gl/node_modules/process/browser.js","webpack:///./src/bundle.ts","webpack:///./src/lib/gltf-utils/gltf-constants.ts","webpack:///../images/src/lib/utils/assert.js","webpack:///../images/src/lib/category-api/image-type.ts","webpack:///../images/src/lib/category-api/parsed-image-api.ts","webpack:///../images/src/lib/parsers/svg-utils.ts","webpack:///../images/src/lib/parsers/parse-to-image.ts","webpack:///../images/src/lib/parsers/parse-to-image-bitmap.ts","webpack:///../images/src/lib/category-api/binary-image-api.ts","webpack:///../images/src/image-loader.ts","webpack:///../images/src/lib/utils/version.ts","webpack:///../images/src/lib/parsers/parse-image.ts","webpack:///../images/src/lib/parsers/parse-to-node-image.ts","webpack:///../loader-utils/src/lib/binary-utils/get-first-characters.ts","webpack:///../loader-utils/src/lib/parser-utils/parse-json.ts","webpack:///../loader-utils/src/lib/binary-utils/array-buffer-utils.ts","webpack:///./src/lib/utils/assert.js","webpack:///./src/lib/gltf-utils/resolve-url.ts","webpack:///./src/lib/gltf-utils/get-typed-array.ts","webpack:///../draco/src/lib/utils/version.ts","webpack:///../draco/src/draco-loader.ts","webpack:///../schema/src/lib/schema/impl/schema.ts","webpack:///../schema/src/lib/utils/assert.ts","webpack:///../schema/src/lib/schema/impl/enum.ts","webpack:///../schema/src/lib/schema/impl/type.ts","webpack:///../schema/src/lib/schema/impl/field.ts","webpack:///../draco/src/lib/utils/schema-attribute-utils.ts","webpack:///../schema/src/lib/schema-utils/type-utils.ts","webpack:///../draco/src/lib/draco-parser.ts","webpack:///../schema/src/category/mesh/mesh-utils.ts","webpack:///../worker-utils/src/lib/library-utils/library-utils.ts","webpack:///../worker-utils/src/lib/env-utils/assert.ts","webpack:///../draco/src/lib/draco-module-loader.ts","webpack:///../draco/src/index.ts","webpack:///../loader-utils/src/lib/env-utils/assert.ts","webpack:///../loader-utils/src/lib/binary-utils/memory-copy-utils.ts","webpack:///./src/lib/gltf-utils/gltf-utils.ts","webpack:///./src/lib/api/gltf-scenegraph.ts","webpack:///./src/lib/gltf-utils/gltf-attribute-utils.ts","webpack:///./src/lib/extensions/KHR_draco_mesh_compression.ts","webpack:///./src/lib/extensions/KHR_materials_unlit.ts","webpack:///./src/lib/extensions/KHR_lights_punctual.ts","webpack:///./src/lib/extensions/KHR_techniques_webgl.ts","webpack:///./src/lib/extensions/gltf-extensions.ts","webpack:///./src/lib/api/normalize-gltf-v1.js","webpack:///./src/lib/extensions/KHR_binary_gltf.ts","webpack:///./src/lib/api/post-process-gltf.js","webpack:///./src/lib/parsers/parse-glb.ts","webpack:///./src/lib/parsers/parse-gltf.ts","webpack:///./src/gltf-loader.ts","webpack:///./src/lib/utils/version.js","webpack:///../loader-utils/src/lib/binary-utils/binary-copy-utils.ts","webpack:///./src/lib/encoders/encode-glb.js","webpack:///./src/lib/encoders/encode-gltf.js","webpack:///./src/gltf-writer.ts","webpack:///./src/glb-loader.ts","webpack:///./src/glb-writer.ts"],"names":["root","factory","exports","module","define","amd","a","i","window","installedModules","__webpack_require__","moduleId","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","globals","self","global","document","global_","isBrowser","process","String","browser","isWorker","importScripts","matches","orientation","version","exec","parseFloat","g","this","Function","e","cachedSetTimeout","cachedClearTimeout","defaultSetTimout","Error","defaultClearTimeout","runTimeout","fun","setTimeout","clearTimeout","currentQueue","queue","draining","queueIndex","cleanUpNextTick","length","concat","drainQueue","timeout","len","run","marker","runClearTimeout","Item","array","noop","nextTick","args","Array","arguments","push","apply","title","env","argv","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","binding","cwd","chdir","dir","umask","moduleExports","require","_global","loaders","assign","KHR_DRACO_MESH_COMPRESSION","assert","condition","message","_parseImageNode","IMAGE_SUPPORTED","Image","IMAGE_BITMAP_SUPPORTED","ImageBitmap","NODE_IMAGE_SUPPORTED","Boolean","DATA_SUPPORTED","getImageType","image","format","getImageTypeOrNull","getImageData","canvas","createElement","context","getContext","width","height","drawImage","data","SVG_DATA_URL_PATTERN","SVG_URL_PATTERN","isSVG","url","test","getBlob","arrayBuffer","Blob","Uint8Array","async","parseToImage","options","blobOrDataUrl","xmlText","TextDecoder","decode","unescape","encodeURIComponent","error","btoa","getBlobOrSVGDataUrl","URL","webkitURL","objectUrl","createObjectURL","src","Promise","resolve","reject","onload","onerror","err","loadToImage","revokeObjectURL","EMPTY_OBJECT","imagebitmapOptionsSupported","parseToImageBitmap","blob","imagebitmapOptions","imagebitmap","isEmptyObject","createImageBitmap","console","warn","safeCreateImageBitmap","getBinaryImageMetadata","binaryData","dataView","toDataView","byteLength","getUint32","mimeType","getPngMetadata","getUint16","getUint8","tableMarkers","sofMarkers","Set","add","getJpegMarkers","has","getJpegMetadata","getGifMetadata","getBmpMetadata","DataView","ArrayBuffer","isView","buffer","ImageLoader","id","mimeTypes","extensions","parse","imageType","type","getDefaultImageType","isImageTypeSupported","getLoadableImageType","parseToNodeImage","tests","getMagicString","byteOffset","magic","fromCharCode","parseJSON","string","JSON","_","slice","getFirstCharacters","sliceArrayBuffer","subArray","undefined","subarray","resolveUrl","startsWith","baseUrl","baseUri","uri","substr","lastIndexOf","getTypedArrayForBufferView","json","buffers","bufferViewIndex","bufferView","bufferViews","binChunk","DracoLoader","worker","binary","draco","decoderType","WebAssembly","libraryPath","extraAttributes","attributeNameEntry","Schema","constructor","fields","metadata","isArray","usedNames","field","checkNames","Map","compareTo","other","select","columnNames","nameMap","selectedFields","filter","selectAt","columnIndices","map","index","schemaOrFields","otherSchema","mergeMaps","fieldMap","mergedFields","values","m1","m2","Type","DataType","x","typeId","Null","Int","Float","Binary","Utf8","Bool","Decimal","Date","Time","Timestamp","Interval","List","Struct","Union","FixedSizeBinary","FixedSizeList","Dictionary","NONE","isSigned","bitWidth","super","toString","Int8","Int16","Int32","Uint8","Uint16","Uint32","Precision","precision","Float32","Float64","listSize","child","children","valueType","Field","nullable","clone","getArrowFieldFromAttribute","attributeName","attribute","loaderData","metadataMap","makeMetadata","Int8Array","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","getArrowTypeFromTypedArray","size","set","stringify","DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP","POSITION","NORMAL","COLOR","TEX_COORD","DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP","1","2","3","4","5","6","9","DracoParser","decoder","Decoder","metadataQuerier","MetadataQuerier","destroy","parseSync","DecoderBuffer","Init","_disableAttributeTransforms","geometry_type","GetEncodedGeometryType","dracoGeometry","TRIANGULAR_MESH","Mesh","PointCloud","dracoStatus","DecodeBufferToMesh","POINT_CLOUD","DecodeBufferToPointCloud","ok","ptr","error_msg","_getDracoLoaderData","geometry","_getMeshData","boundingBox","attributes","minX","Infinity","minY","minZ","maxX","maxY","maxZ","positions","y","z","getMeshBoundingBox","schema","indices","namedLoaderDataAttributes","result","dracoAttribute","transformAttributesLoaderData","indicesField","makeSchemaFromAttributes","loader","header","vertexCount","num_points","_getTopLevelMetadata","_getDracoAttributes","num_attributes","num_faces","dracoAttributes","attributeId","GetAttribute","_getAttributeMetadata","unique_id","attribute_type","data_type","num_components","byte_offset","byte_stride","normalized","attribute_index","quantization","_getQuantizationTransform","quantization_transform","octahedron","_getOctahedronTransform","octahedron_transform","_getMeshAttributes","topology","_getTriangleStripIndices","_getTriangleListIndices","loaderAttribute","_deduceAttributeName","_getAttributeValues","byteStride","numIndices","_malloc","GetTrianglesUInt32Array","HEAPF32","_free","dracoArray","DracoInt32Array","GetTriangleStripsFromMesh","numValues","intArray","GetValue","getUint32Array","TypedArrayCtor","numComponents","BYTES_PER_ELEMENT","dataType","attributeType","DT_FLOAT32","DT_INT8","DT_INT16","DT_INT32","DT_UINT8","DT_UINT16","DT_UINT32","DT_INVALID","getDracoDataType","GetAttributeDataArrayForAllPoints","uniqueId","attributeUniqueId","entries","thisAttributeType","dracoAttributeConstant","entryName","dracoMetadata","GetMetadata","_getDracoMetadata","GetAttributeMetadata","numEntries","NumEntries","entryIndex","GetEntryName","_getDracoMetadataField","GetIntEntryArray","getInt32Array","int","GetIntEntry","GetStringEntry","double","GetDoubleEntry","quantizedAttributes","octahedronAttributes","skipAttributes","dracoAttributeName","SkipAttributeTransform","includes","transform","AttributeQuantizationTransform","InitFromAttribute","quantization_bits","range","min_values","min_value","loadLibraryPromises","loadLibrary","libraryUrl","moduleName","library","CDN","getLibraryUrl","endsWith","response","fetch","node","scriptSource","eval","script","appendChild","createTextNode","text","body","loadLibraryFromString","loadLibraryFromFile","loadDecoderPromise","loadDracoDecoderModule","draco3d","createDecoderModule","then","DracoDecoderModule","wasmBinary","all","globalThis","onModuleLoaded","initializeDracoDecoder","loadDracoDecoder","DracoWorkerLoader","dracoParser","padToNBytes","padding","copyToArray","source","target","targetOffset","sourceArray","srcByteOffset","srcByteLength","TYPES","ARRAY_CONSTRUCTOR_TO_WEBGL_CONSTANT","ARRAY_TO_COMPONENT_TYPE","ATTRIBUTE_TYPE_TO_COMPONENTS","SCALAR","VEC2","VEC3","VEC4","MAT2","MAT3","MAT4","ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE","5120","5121","5122","5123","5125","5126","ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY","getAccessorTypeFromSize","getComponentTypeFromArray","typedArray","componentType","getAccessorArrayTypeAndLength","accessor","ArrayType","components","bytesPerComponent","count","DEFAULT_GLTF_JSON","asset","generator","GLTFScenegraph","gltf","sourceBuffers","getApplicationData","getExtraData","extras","getExtension","extensionName","isExtension","getUsedExtensions","find","getRequiredExtension","getRequiredExtensions","extensionsRequired","extensionsUsed","getObjectExtension","getScene","getObject","getNode","getSkin","getMesh","getMaterial","getAccessor","getTexture","getSampler","getImage","getBufferView","getBuffer","bufferIndex","getTypedArrayForAccessor","getTypedArrayForImageData","addApplicationData","addExtraData","addObjectExtension","registerUsedExtension","setObjectExtension","removeObjectExtension","extension","addExtension","extensionData","addRequiredExtension","registerRequiredExtension","ext","removeExtension","_removeStringFromArray","setDefaultScene","sceneIndex","scene","addScene","nodeIndices","scenes","nodes","addNode","meshIndex","matrix","nodeData","mesh","addMesh","material","glTFMesh","primitives","_addAttributes","indicesAccessor","_addIndices","Number","isFinite","meshes","addPointCloud","addImage","imageData","mimeTypeOpt","glTFImage","addBufferView","images","glTFBufferView","addAccessor","glTFAccessor","max","min","accessors","addBinaryBuffer","sourceBuffer","minMax","_getAccessorMinMax","accessorDefaults","Math","round","addTexture","texture","imageIndex","glTFTexture","textures","addMaterial","pbrMaterialInfo","materials","createBinaryChunk","totalByteLength","targetArray","dstByteOffset","found","indexOf","splice","attributeKey","attributeData","attrName","_getGltfAttributeName","toLowerCase","initValues","componentIndex","getGLTFAccessor","convertTypedArrays","toTypedArray","getAccessorData","gltfData","decompressMeshes","scenegraph","Scenegraph","promises","primitive","makeMeshPrimitiveIterator","decompressPrimitive","encode","compressMesh","dracoExtension","bufferCopy","dracoOptions","decodedData","decodedAttributes","getGLTFAccessors","decodedAttribute","accessorIndex","keys","checkPrimitive","DracoWriter","compressedData","encodeSync","fauxAccessors","_addFauxAttributes","gltfScenegraph","KHR_materials_unlit","unlit","lights","nodeExtension","light","techniques","techniquesExtension","programs","shaders","textDecoder","forEach","shader","code","program","fragmentShader","vertexShader","technique","resolveTechniques","materialExtension","resolveValues","uniforms","uniform","EXTENSIONS","KHR_draco_mesh_compression","KHR_lights_punctual","KHR_techniques_webgl","GLTF_ARRAYS","animations","samplers","skins","GLTF_KEYS","sampler","skin","GLTFV1Normalizer","idToIndexMap","normalize","_addAsset","_convertTopLevelObjectsToArrays","KHR_binary_glTF","_convertObjectIdsToArrayIndices","_updateObjects","_updateMaterial","arrayName","_convertTopLevelObjectToArray","mapName","objectMap","_convertIdsToIndices","_convertIdToIndex","_convertTextureIds","_convertMeshIds","_convertNodeIds","_convertSceneIds","topLevelArrayName","pbrMetallicRoughness","baseColorFactor","metallicFactor","roughnessFactor","textureId","tex","textureIndex","findIndex","baseColorTexture","COMPONENTS","BYTES","GL_SAMPLER","TEXTURE_MAG_FILTER","TEXTURE_MIN_FILTER","TEXTURE_WRAP_S","TEXTURE_WRAP_T","REPEAT","LINEAR","NEAREST_MIPMAP_LINEAR","SAMPLER_PARAMETER_GLTF_TO_GL","magFilter","minFilter","wrapS","wrapT","DEFAULT_SAMPLER","TEXTURE_WRAP_","GLTFPostProcessor","postProcess","_resolveTree","bufView","_resolveBufferView","_resolveImage","_resolveSampler","_resolveTexture","_resolveAccessor","_resolveMaterial","_resolveMesh","_resolveNode","_resolveSkin","_resolveScene","_get","getCamera","reduce","accum","camera","inverseBindMatrices","normalTexture","occlusionTexture","occlustionTexture","emissiveTexture","emmisiveTexture","emissiveFactor","mr","metallicRoughnessTexture","bytesPerElement","cutBufffer","parameters","glEnum","_enumSamplerParameter","preloadedImage","_resolveCamera","perspective","orthographic","postProcessGLTF","MAGIC_glTF","isGLB","magic1","parseGLBSync","glb","hasBinChunk","binChunks","GLB_FILE_HEADER_SIZE","contentLength","contentFormat","parseJSONChunk","parseBINChunk","parseGLBV1","chunkLength","chunkFormat","strict","parseGLBChunksSync","parseGLBV2","jsonChunk","jsonText","parseGLTF","arrayBufferOrString","_glb","fill","parseGLTFContainerSync","normalizeGLTFV1","loadBuffers","loadImages","promise","loadImage","excludes","excludeExtensions","decodeExtensions","parsedImage","GLTFLoader","log","deprecatedOptions","fetchImages","createImages","decompress","copyPaddedArrayBufferToDataView","paddedLength","padLength","setUint8","encodeGLBSync","byteOffsetStart","setUint32","byteOffsetFileLength","byteOffsetJsonHeader","TextEncoder","copyPaddedStringToDataView","jsonByteLength","byteOffsetBinHeader","binByteLength","fileByteLength","encodeGLTFSync","firstBuffer","convertBuffersToBase64","GLTFWriter","GLBLoader","GLBWriter"],"mappings":"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","file":"dist.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 8);\n","// Purpose: include this in your module to avoids adding dependencies on\n// micro modules like 'global' and 'is-browser';\n\n/* eslint-disable no-restricted-globals */\nconst globals = {\n  self: typeof self !== 'undefined' && self,\n  window: typeof window !== 'undefined' && window,\n  global: typeof global !== 'undefined' && global,\n  document: typeof document !== 'undefined' && document\n};\n\nconst self_: {[key: string]: any} = globals.self || globals.window || globals.global || {};\nconst window_: {[key: string]: any} = globals.window || globals.self || globals.global || {};\nconst global_: {[key: string]: any} = globals.global || globals.self || globals.window || {};\nconst document_: {[key: string]: any} = globals.document || {};\n\nexport {self_ as self, window_ as window, global_ as global, document_ as document};\n\n/** true if running in the browser, false if running in Node.js */\nexport const isBrowser: boolean =\n  // @ts-ignore process.browser\n  typeof process !== 'object' || String(process) !== '[object process]' || process.browser;\n\n/** true if running on a worker thread */\nexport const isWorker: boolean = typeof importScripts === 'function';\n\n/** true if running on a mobile device */\nexport const isMobile: boolean =\n  typeof window !== 'undefined' && typeof window.orientation !== 'undefined';\n\n// Extract node major version\nconst matches =\n  typeof process !== 'undefined' && process.version && /v([0-9]*)/.exec(process.version);\n\n/** Version of Node.js if running under Node, otherwise 0 */\nexport const nodeVersion: number = (matches && parseFloat(matches[1])) || 0;\n","// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n// Purpose: include this in your module to avoids adding dependencies on\n// micro modules like 'global' and 'is-browser';\n\n/* eslint-disable no-restricted-globals */\nconst globals = {\n  self: typeof self !== 'undefined' && self,\n  window: typeof window !== 'undefined' && window,\n  global: typeof global !== 'undefined' && global,\n  document: typeof document !== 'undefined' && document\n};\n\nconst self_ = globals.self || globals.window || globals.global;\nconst window_ = globals.window || globals.self || globals.global;\nconst global_ = globals.global || globals.self || globals.window;\nconst document_ = globals.document || {};\n\nexport {self_ as self, window_ as window, global_ as global, document_ as document};\n\nexport const isBrowser =\n  // @ts-ignore\n  typeof process !== 'object' || String(process) !== '[object process]' || process.browser;\n\nexport const isWorker = typeof importScripts === 'function';\n\n// Extract node major version\nconst matches =\n  typeof process !== 'undefined' && process.version && /v([0-9]*)/.exec(process.version);\nexport const nodeVersion = (matches && parseFloat(matches[1])) || 0;\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","// @ts-nocheck\nconst moduleExports = require('./index');\nconst _global = typeof window === 'undefined' ? global : window;\n_global.loaders = _global.loaders || {};\nmodule.exports = Object.assign(_global.loaders, moduleExports);\n","// GLTF 1.0 extensions\nexport const KHR_BINARY_GLTF = 'KHR_binary_glTF';\n\n// GLTF 2.0 extensions\nexport const KHR_DRACO_MESH_COMPRESSION = 'KHR_draco_mesh_compression';\nexport const KHR_LIGHTS_PUNCTUAL = 'KHR_lights_punctual';\nexport const KHR_MATERIALS_UNLIT = 'KHR_materials_unlit';\nexport const KHR_TECHNIQUES_WEBGL = 'KHR_techniques_webgl';\n\n// External extensions\nexport const EXT_MESHOPT_COMPRESSION = 'EXT_meshopt_compression';\n\nconst COMPONENTS = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n};\n\nconst BYTES = {\n  5120: 1, // BYTE\n  5121: 1, // UNSIGNED_BYTE\n  5122: 2, // SHORT\n  5123: 2, // UNSIGNED_SHORT\n  5125: 4, // UNSIGNED_INT\n  5126: 4 // FLOAT\n};\n\n// ENUM LOOKUP\n\nexport function getBytesFromComponentType(componentType) {\n  return BYTES[componentType];\n}\n\nexport function getSizeFromAccessorType(type) {\n  return COMPONENTS[type];\n}\n\nexport function getGLEnumFromSamplerParameter(parameter) {\n  const GL_TEXTURE_MAG_FILTER = 0x2800;\n  const GL_TEXTURE_MIN_FILTER = 0x2801;\n  const GL_TEXTURE_WRAP_S = 0x2802;\n  const GL_TEXTURE_WRAP_T = 0x2803;\n\n  const PARAMETER_MAP = {\n    magFilter: GL_TEXTURE_MAG_FILTER,\n    minFilter: GL_TEXTURE_MIN_FILTER,\n    wrapS: GL_TEXTURE_WRAP_S,\n    wrapT: GL_TEXTURE_WRAP_T\n  };\n\n  return PARAMETER_MAP[parameter];\n}\n","export function assert(condition, message) {\n  if (!condition) {\n    throw new Error(message);\n  }\n}\n","import type {ImageTypeEnum} from '../../types';\nimport {global, isBrowser} from '../utils/globals';\n\n// @ts-ignore TS2339: Property does not exist on type\nconst {_parseImageNode} = global;\n\nconst IMAGE_SUPPORTED = typeof Image !== 'undefined'; // NOTE: \"false\" positives if jsdom is installed\nconst IMAGE_BITMAP_SUPPORTED = typeof ImageBitmap !== 'undefined';\nconst NODE_IMAGE_SUPPORTED = Boolean(_parseImageNode);\nconst DATA_SUPPORTED = isBrowser ? true : NODE_IMAGE_SUPPORTED;\n\n/**\n * Checks if a loaders.gl image type is supported\n * @param type image type string\n */\nexport function isImageTypeSupported(type: string): boolean {\n  switch (type) {\n    case 'auto':\n      // Should only ever be false in Node.js, if polyfills have not been installed...\n      return IMAGE_BITMAP_SUPPORTED || IMAGE_SUPPORTED || DATA_SUPPORTED;\n\n    case 'imagebitmap':\n      return IMAGE_BITMAP_SUPPORTED;\n    case 'image':\n      return IMAGE_SUPPORTED;\n    case 'data':\n      return DATA_SUPPORTED;\n\n    default:\n      throw new Error(`@loaders.gl/images: image ${type} not supported in this environment`);\n  }\n}\n\n/**\n * Returns the \"most performant\" supported image type on this platform\n * @returns image type string\n */\nexport function getDefaultImageType(): ImageTypeEnum {\n  if (IMAGE_BITMAP_SUPPORTED) {\n    return 'imagebitmap';\n  }\n  if (IMAGE_SUPPORTED) {\n    return 'image';\n  }\n  if (DATA_SUPPORTED) {\n    return 'data';\n  }\n\n  // This should only happen in Node.js\n  throw new Error('Install \\'@loaders.gl/polyfills\\' to parse images under Node.js');\n}\n","import type {ImageType, ImageTypeEnum, ImageDataType} from '../../types';\n\nexport function isImage(image: ImageType): boolean {\n  return Boolean(getImageTypeOrNull(image));\n}\n\nexport function deleteImage(image: ImageType): void {\n  switch (getImageType(image)) {\n    case 'imagebitmap':\n      (image as ImageBitmap).close();\n      break;\n    default:\n    // Nothing to do for images and image data objects\n  }\n}\n\nexport function getImageType(image: ImageType): ImageTypeEnum {\n  const format = getImageTypeOrNull(image);\n  if (!format) {\n    throw new Error('Not an image');\n  }\n  return format;\n}\n\nexport function getImageSize(image: ImageType): {width: number; height: number} {\n  return getImageData(image);\n}\n\nexport function getImageData(image: ImageType): ImageDataType | ImageData {\n  switch (getImageType(image)) {\n    case 'data':\n      return image as unknown as ImageData;\n\n    case 'image':\n    case 'imagebitmap':\n      // Extract the image data from the image via a canvas\n      const canvas = document.createElement('canvas');\n      // TODO - reuse the canvas?\n      const context = canvas.getContext('2d');\n      if (!context) {\n        throw new Error('getImageData');\n      }\n      // @ts-ignore\n      canvas.width = image.width;\n      // @ts-ignore\n      canvas.height = image.height;\n      // @ts-ignore\n      context.drawImage(image, 0, 0);\n      // @ts-ignore\n      return context.getImageData(0, 0, image.width, image.height);\n\n    default:\n      throw new Error('getImageData');\n  }\n}\n\n// PRIVATE\n\n// eslint-disable-next-line complexity\nfunction getImageTypeOrNull(image) {\n  if (typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {\n    return 'imagebitmap';\n  }\n  if (typeof Image !== 'undefined' && image instanceof Image) {\n    return 'image';\n  }\n  if (image && typeof image === 'object' && image.data && image.width && image.height) {\n    return 'data';\n  }\n  return null;\n}\n","// SVG parsing has limitations, e.g:\n// https://bugs.chromium.org/p/chromium/issues/detail?id=606319\n\nconst SVG_DATA_URL_PATTERN = /^data:image\\/svg\\+xml/;\nconst SVG_URL_PATTERN = /\\.svg((\\?|#).*)?$/;\n\nexport function isSVG(url) {\n  return url && (SVG_DATA_URL_PATTERN.test(url) || SVG_URL_PATTERN.test(url));\n}\n\nexport function getBlobOrSVGDataUrl(arrayBuffer, url) {\n  if (isSVG(url)) {\n    // Prepare a properly tagged data URL, and load using normal mechanism\n    const textDecoder = new TextDecoder();\n    let xmlText = textDecoder.decode(arrayBuffer);\n    // TODO Escape in browser to support e.g. Chinese characters\n    try {\n      if (typeof unescape === 'function' && typeof encodeURIComponent === 'function') {\n        xmlText = unescape(encodeURIComponent(xmlText));\n      }\n    } catch (error) {\n      throw new Error((error as Error).message);\n    }\n    // base64 encoding is safer. utf-8 fails in some browsers\n    const src = `data:image/svg+xml;base64,${btoa(xmlText)}`;\n    return src;\n  }\n  return getBlob(arrayBuffer, url);\n}\n\nexport function getBlob(arrayBuffer, url) {\n  if (isSVG(url)) {\n    // https://bugs.chromium.org/p/chromium/issues/detail?id=606319\n    // return new Blob([new Uint8Array(arrayBuffer)], {type: 'image/svg+xml'});\n    throw new Error('SVG cannot be parsed directly to imagebitmap');\n  }\n  // TODO - how to determine mime type? Param? Sniff here?\n  return new Blob([new Uint8Array(arrayBuffer)]); // MIME type not needed?\n}\n","import {getBlobOrSVGDataUrl} from './svg-utils';\n\n// Parses html image from array buffer\nexport default async function parseToImage(arrayBuffer, options, url) {\n  // Note: image parsing requires conversion to Blob (for createObjectURL).\n  // Potentially inefficient for not using `response.blob()` (and for File / Blob inputs)...\n  // But presumably not worth adding 'blob' flag to loader objects?\n\n  const blobOrDataUrl = getBlobOrSVGDataUrl(arrayBuffer, url);\n  const URL = self.URL || self.webkitURL;\n  const objectUrl = typeof blobOrDataUrl !== 'string' && URL.createObjectURL(blobOrDataUrl);\n  try {\n    return await loadToImage(objectUrl || blobOrDataUrl, options);\n  } finally {\n    if (objectUrl) {\n      URL.revokeObjectURL(objectUrl);\n    }\n  }\n}\n\nexport async function loadToImage(url, options) {\n  const image = new Image();\n  image.src = url;\n\n  // The `image.onload()` callback does not guarantee that the image has been decoded\n  // so a main thread \"freeze\" can be incurred when using the image for the first time.\n  // `Image.decode()` returns a promise that completes when image is decoded.\n\n  // https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/decode\n  // Note: When calling `img.decode()`, we do not need to wait for `img.onload()`\n  // Note: `HTMLImageElement.decode()` is not available in Edge and IE11\n  if (options.image && options.image.decode && image.decode) {\n    await image.decode();\n    return image;\n  }\n\n  // Create a promise that tracks onload/onerror callbacks\n  return await new Promise((resolve, reject) => {\n    try {\n      image.onload = () => resolve(image);\n      image.onerror = (err) => reject(new Error(`Could not load image ${url}: ${err}`));\n    } catch (error) {\n      reject(error);\n    }\n  });\n}\n","import {isSVG, getBlob} from './svg-utils';\nimport parseToImage from './parse-to-image';\n\nconst EMPTY_OBJECT = {};\n\nlet imagebitmapOptionsSupported = true;\n\n/**\n * Asynchronously parses an array buffer into an ImageBitmap - this contains the decoded data\n * ImageBitmaps are supported on worker threads, but not supported on Edge, IE11 and Safari\n * https://developer.mozilla.org/en-US/docs/Web/API/ImageBitmap#Browser_compatibility\n *\n * TODO - createImageBitmap supports source rect (5 param overload), pass through?\n */\nexport default async function parseToImageBitmap(arrayBuffer, options, url) {\n  let blob;\n\n  // Cannot parse SVG directly to ImageBitmap, parse to Image first\n  if (isSVG(url)) {\n    // Note: this only works on main thread\n    const image = await parseToImage(arrayBuffer, options, url);\n    blob = image;\n  } else {\n    // Create blob from the array buffer\n    blob = getBlob(arrayBuffer, url);\n  }\n\n  const imagebitmapOptions = options && options.imagebitmap;\n\n  return await safeCreateImageBitmap(blob, imagebitmapOptions);\n}\n\n/**\n * Safely creates an imageBitmap with options\n * *\n * Firefox crashes if imagebitmapOptions is supplied\n * Avoid supplying if not provided or supported, remember if not supported\n */\nasync function safeCreateImageBitmap(blob, imagebitmapOptions = null) {\n  if (isEmptyObject(imagebitmapOptions) || !imagebitmapOptionsSupported) {\n    imagebitmapOptions = null;\n  }\n\n  if (imagebitmapOptions) {\n    try {\n      // @ts-ignore Options\n      return await createImageBitmap(blob, imagebitmapOptions);\n    } catch (error) {\n      console.warn(error); // eslint-disable-line\n      imagebitmapOptionsSupported = false;\n    }\n  }\n\n  return await createImageBitmap(blob);\n}\n\nfunction isEmptyObject(object) {\n  // @ts-ignore\n  for (const key in object || EMPTY_OBJECT) {\n    return false;\n  }\n  return true;\n}\n","// Attributions\n// * Based on binary-gltf-utils under MIT license: Copyright (c) 2016-17 Karl Cheng\n\n// TODO: make these functions work for Node.js buffers?\n// Quarantine references to Buffer to prevent bundler from adding big polyfills\n// import {bufferToArrayBuffer} from '../node/buffer-to-array-buffer';\n// TODO - this should be handled in @loaders.gl/polyfills\n\n/** MIME type, width and height extracted from binary compressed image data */\nexport type BinaryImageMetadata = {\n  mimeType: string;\n  width: number;\n  height: number;\n};\n\nconst BIG_ENDIAN = false;\nconst LITTLE_ENDIAN = true;\n\n/**\n * Extracts `{mimeType, width and height}` from a memory buffer containing a known image format\n * Currently supports `image/png`, `image/jpeg`, `image/bmp` and `image/gif`.\n * @param binaryData image file memory to parse\n * @returns metadata or null if memory is not a valid image file format layout.\n */\nexport function getBinaryImageMetadata(\n  binaryData: DataView | ArrayBuffer\n): BinaryImageMetadata | null {\n  const dataView = toDataView(binaryData);\n  return (\n    getPngMetadata(dataView) ||\n    getJpegMetadata(dataView) ||\n    getGifMetadata(dataView) ||\n    getBmpMetadata(dataView)\n  );\n}\n\n// PNG\n\nfunction getPngMetadata(binaryData) {\n  const dataView = toDataView(binaryData);\n  // Check file contains the first 4 bytes of the PNG signature.\n  const isPng = dataView.byteLength >= 24 && dataView.getUint32(0, BIG_ENDIAN) === 0x89504e47;\n  if (!isPng) {\n    return null;\n  }\n\n  // Extract size from a binary PNG file\n  return {\n    mimeType: 'image/png',\n    width: dataView.getUint32(16, BIG_ENDIAN),\n    height: dataView.getUint32(20, BIG_ENDIAN)\n  };\n}\n\n// GIF\n\n// Extract size from a binary GIF file\n// TODO: GIF is not this simple\nfunction getGifMetadata(binaryData) {\n  const dataView = toDataView(binaryData);\n  // Check first 4 bytes of the GIF signature (\"GIF8\").\n  const isGif = dataView.byteLength >= 10 && dataView.getUint32(0, BIG_ENDIAN) === 0x47494638;\n  if (!isGif) {\n    return null;\n  }\n\n  // GIF is little endian.\n  return {\n    mimeType: 'image/gif',\n    width: dataView.getUint16(6, LITTLE_ENDIAN),\n    height: dataView.getUint16(8, LITTLE_ENDIAN)\n  };\n}\n\n// BMP\n\n// TODO: BMP is not this simple\nexport function getBmpMetadata(binaryData) {\n  const dataView = toDataView(binaryData);\n  // Check magic number is valid (first 2 characters should be \"BM\").\n  // The mandatory bitmap file header is 14 bytes long.\n  const isBmp =\n    dataView.byteLength >= 14 &&\n    dataView.getUint16(0, BIG_ENDIAN) === 0x424d &&\n    dataView.getUint32(2, LITTLE_ENDIAN) === dataView.byteLength;\n\n  if (!isBmp) {\n    return null;\n  }\n\n  // BMP is little endian.\n  return {\n    mimeType: 'image/bmp',\n    width: dataView.getUint32(18, LITTLE_ENDIAN),\n    height: dataView.getUint32(22, LITTLE_ENDIAN)\n  };\n}\n\n// JPEG\n\n// Extract width and height from a binary JPEG file\nfunction getJpegMetadata(binaryData) {\n  const dataView = toDataView(binaryData);\n  // Check file contains the JPEG \"start of image\" (SOI) marker\n  // followed by another marker.\n  const isJpeg =\n    dataView.byteLength >= 3 &&\n    dataView.getUint16(0, BIG_ENDIAN) === 0xffd8 &&\n    dataView.getUint8(2) === 0xff;\n\n  if (!isJpeg) {\n    return null;\n  }\n\n  const {tableMarkers, sofMarkers} = getJpegMarkers();\n\n  // Exclude the two byte SOI marker.\n  let i = 2;\n  while (i + 9 < dataView.byteLength) {\n    const marker = dataView.getUint16(i, BIG_ENDIAN);\n\n    // The frame that contains the width and height of the JPEG image.\n    if (sofMarkers.has(marker)) {\n      return {\n        mimeType: 'image/jpeg',\n        height: dataView.getUint16(i + 5, BIG_ENDIAN), // Number of lines\n        width: dataView.getUint16(i + 7, BIG_ENDIAN) // Number of pixels per line\n      };\n    }\n\n    // Miscellaneous tables/data preceding the frame header.\n    if (!tableMarkers.has(marker)) {\n      return null;\n    }\n\n    // Length includes size of length parameter but not the two byte header.\n    i += 2;\n    i += dataView.getUint16(i, BIG_ENDIAN);\n  }\n\n  return null;\n}\n\nfunction getJpegMarkers() {\n  // Tables/misc header markers.\n  // DQT, DHT, DAC, DRI, COM, APP_n\n  const tableMarkers = new Set([0xffdb, 0xffc4, 0xffcc, 0xffdd, 0xfffe]);\n  for (let i = 0xffe0; i < 0xfff0; ++i) {\n    tableMarkers.add(i);\n  }\n\n  // SOF markers and DHP marker.\n  // These markers are after tables/misc data.\n  const sofMarkers = new Set([\n    0xffc0, 0xffc1, 0xffc2, 0xffc3, 0xffc5, 0xffc6, 0xffc7, 0xffc9, 0xffca, 0xffcb, 0xffcd, 0xffce,\n    0xffcf, 0xffde\n  ]);\n\n  return {tableMarkers, sofMarkers};\n}\n\n// TODO - move into image module?\nfunction toDataView(data) {\n  if (data instanceof DataView) {\n    return data;\n  }\n  if (ArrayBuffer.isView(data)) {\n    return new DataView(data.buffer);\n  }\n\n  // TODO: make these functions work for Node.js buffers?\n  // if (bufferToArrayBuffer) {\n  //   data = bufferToArrayBuffer(data);\n  // }\n\n  // Careful - Node Buffers will look like ArrayBuffers (keep after isBuffer)\n  if (data instanceof ArrayBuffer) {\n    return new DataView(data);\n  }\n  throw new Error('toDataView');\n}\n","import type {LoaderWithParser} from '@loaders.gl/loader-utils';\nimport {VERSION} from './lib/utils/version';\nimport parseImage from './lib/parsers/parse-image';\nimport {getBinaryImageMetadata} from './lib/category-api/binary-image-api';\n\nconst EXTENSIONS = ['png', 'jpg', 'jpeg', 'gif', 'webp', 'bmp', 'ico', 'svg'];\nconst MIME_TYPES = [\n  'image/png',\n  'image/jpeg',\n  'image/gif',\n  'image/webp',\n  'image/bmp',\n  'image/vnd.microsoft.icon',\n  'image/svg+xml'\n];\n\n/**\n * Loads a platform-specific image type\n * Note: This type can be used as input data to WebGL texture creation\n */\nexport const ImageLoader = {\n  id: 'image',\n  module: 'images',\n  name: 'Images',\n  version: VERSION,\n  mimeTypes: MIME_TYPES,\n  extensions: EXTENSIONS,\n  parse: parseImage,\n  // TODO: byteOffset, byteLength;\n  tests: [(arrayBuffer) => Boolean(getBinaryImageMetadata(new DataView(arrayBuffer)))],\n  options: {\n    image: {\n      type: 'auto',\n      decode: true // if format is HTML\n    }\n    // imagebitmap: {} - passes (platform dependent) parameters to ImageBitmap constructor\n  }\n};\n\nexport const _typecheckImageLoader: LoaderWithParser = ImageLoader;\n","// Version constant cannot be imported, it needs to correspond to the build version of **this** module.\n// __VERSION__ is injected by babel-plugin-version-inline\n// @ts-ignore TS2304: Cannot find name '__VERSION__'.\nexport const VERSION = typeof __VERSION__ !== 'undefined' ? __VERSION__ : 'latest';\n","import {assert} from '../utils/assert';\nimport {isImageTypeSupported, getDefaultImageType} from '../category-api/image-type';\nimport {getImageData} from '../category-api/parsed-image-api';\nimport parseToImage from './parse-to-image';\nimport parseToImageBitmap from './parse-to-image-bitmap';\nimport parseToNodeImage from './parse-to-node-image';\n\n// Parse to platform defined image type (data on node, ImageBitmap or HTMLImage on browser)\n// eslint-disable-next-line complexity\nexport default async function parseImage(arrayBuffer, options, context) {\n  options = options || {};\n  const imageOptions = options.image || {};\n\n  // The user can request a specific output format via `options.image.type`\n  const imageType = imageOptions.type || 'auto';\n\n  const {url} = context || {};\n\n  // Note: For options.image.type === `data`, we may still need to load as `image` or `imagebitmap`\n  const loadType = getLoadableImageType(imageType);\n\n  let image;\n  switch (loadType) {\n    case 'imagebitmap':\n      image = await parseToImageBitmap(arrayBuffer, options, url);\n      break;\n    case 'image':\n      image = await parseToImage(arrayBuffer, options, url);\n      break;\n    case 'data':\n      // Node.js loads imagedata directly\n      image = await parseToNodeImage(arrayBuffer, options);\n      break;\n    default:\n      assert(false);\n  }\n\n  // Browser: if options.image.type === 'data', we can now extract data from the loaded image\n  if (imageType === 'data') {\n    image = getImageData(image);\n  }\n\n  return image;\n}\n\n// Get a loadable image type from image type\nfunction getLoadableImageType(type) {\n  switch (type) {\n    case 'auto':\n    case 'data':\n      // Browser: For image data we need still need to load using an image format\n      // Node: the default image type is `data`.\n      return getDefaultImageType();\n    default:\n      // Throw an error if not supported\n      isImageTypeSupported(type);\n      return type;\n  }\n}\n","import {global} from '../utils/globals';\nimport {assert} from '../utils/assert';\nimport {getBinaryImageMetadata} from '../category-api/binary-image-api';\n\n// Use polyfills if installed to p[arsed image using get-pixels\nexport default function parseToNodeImage(arrayBuffer, options) {\n  const {mimeType} = getBinaryImageMetadata(arrayBuffer) || {};\n\n  // @ts-ignore\n  const {_parseImageNode} = global;\n  assert(_parseImageNode); // '@loaders.gl/polyfills not installed'\n\n  return _parseImageNode(arrayBuffer, mimeType, options);\n}\n","export function getFirstCharacters(data, length = 5): string {\n  if (typeof data === 'string') {\n    return data.slice(0, length);\n  } else if (ArrayBuffer.isView(data)) {\n    // Typed Arrays can have offsets into underlying buffer\n    return getMagicString(data.buffer, data.byteOffset, length);\n  } else if (data instanceof ArrayBuffer) {\n    const byteOffset = 0;\n    return getMagicString(data, byteOffset, length);\n  }\n  return '';\n}\n\nexport function getMagicString(\n  arrayBuffer: ArrayBuffer,\n  byteOffset: number,\n  length: number\n): string {\n  if (arrayBuffer.byteLength <= byteOffset + length) {\n    return '';\n  }\n  const dataView = new DataView(arrayBuffer);\n  let magic = '';\n  for (let i = 0; i < length; i++) {\n    magic += String.fromCharCode(dataView.getUint8(byteOffset + i));\n  }\n  return magic;\n}\n","import {getFirstCharacters} from '../binary-utils/get-first-characters';\n\n/**\n * Minimal JSON parser that throws more meaningful error messages\n */\nexport function parseJSON(string: string): any {\n  try {\n    return JSON.parse(string);\n  } catch (_) {\n    throw new Error(`Failed to parse JSON from data starting with \"${getFirstCharacters(string)}\"`);\n  }\n}\n","import {TypedArray} from '../../types';\nimport * as node from './buffer-utils';\n\n/**\n * Convert an object to an array buffer\n */\nexport function toArrayBuffer(data: any): ArrayBuffer {\n  // Note: Should be called first, Buffers can trigger other detections below\n  if (node.isBuffer(data)) {\n    // TODO - per docs we should just be able to call buffer.buffer, but there are issues\n    data = node.bufferToArrayBuffer(data);\n  }\n\n  if (data instanceof ArrayBuffer) {\n    return data;\n  }\n\n  // Careful - Node Buffers look like Uint8Arrays (keep after isBuffer)\n  if (ArrayBuffer.isView(data)) {\n    if (data.byteOffset === 0 && data.byteLength === data.buffer.byteLength) {\n      return data.buffer;\n    }\n    return data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength);\n  }\n\n  if (typeof data === 'string') {\n    const text = data;\n    const uint8Array = new TextEncoder().encode(text);\n    return uint8Array.buffer;\n  }\n\n  // HACK to support Blob polyfill\n  if (data && typeof data === 'object' && data._toArrayBuffer) {\n    return data._toArrayBuffer();\n  }\n\n  throw new Error('toArrayBuffer');\n}\n\n/**\n * compare two binary arrays for equality\n * @param {ArrayBuffer} a\n * @param {ArrayBuffer} b\n * @param {number} byteLength\n */\nexport function compareArrayBuffers(\n  arrayBuffer1: ArrayBuffer,\n  arrayBuffer2: ArrayBuffer,\n  byteLength?: number\n): boolean {\n  byteLength = byteLength || arrayBuffer1.byteLength;\n  if (arrayBuffer1.byteLength < byteLength || arrayBuffer2.byteLength < byteLength) {\n    return false;\n  }\n  const array1 = new Uint8Array(arrayBuffer1);\n  const array2 = new Uint8Array(arrayBuffer2);\n  for (let i = 0; i < array1.length; ++i) {\n    if (array1[i] !== array2[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Concatenate a sequence of ArrayBuffers\n * @return A concatenated ArrayBuffer\n */\nexport function concatenateArrayBuffers(...sources: (ArrayBuffer | Uint8Array)[]): ArrayBuffer {\n  // Make sure all inputs are wrapped in typed arrays\n  const sourceArrays = sources.map((source2) =>\n    source2 instanceof ArrayBuffer ? new Uint8Array(source2) : source2\n  );\n\n  // Get length of all inputs\n  const byteLength = sourceArrays.reduce((length, typedArray) => length + typedArray.byteLength, 0);\n\n  // Allocate array with space for all inputs\n  const result = new Uint8Array(byteLength);\n\n  // Copy the subarrays\n  let offset = 0;\n  for (const sourceArray of sourceArrays) {\n    result.set(sourceArray, offset);\n    offset += sourceArray.byteLength;\n  }\n\n  // We work with ArrayBuffers, discard the typed array wrapper\n  return result.buffer;\n}\n\n/**\n * Concatenate arbitrary count of typed arrays\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Typed_arrays\n * @param {...*} arrays - list of arrays. All arrays should be the same type\n * @return A concatenated TypedArray\n */\nexport function concatenateTypedArrays<T>(...typedArrays: T[]): T {\n  // @ts-ignore\n  const arrays = typedArrays as TypedArray[];\n  // @ts-ignore\n  const TypedArrayConstructor = (arrays && arrays.length > 1 && arrays[0].constructor) || null;\n  if (!TypedArrayConstructor) {\n    throw new Error(\n      '\"concatenateTypedArrays\" - incorrect quantity of arguments or arguments have incompatible data types'\n    );\n  }\n\n  const sumLength = arrays.reduce((acc, value) => acc + value.length, 0);\n  // @ts-ignore typescript does not like dynamic constructors\n  const result = new TypedArrayConstructor(sumLength);\n  let offset = 0;\n  for (const array of arrays) {\n    result.set(array, offset);\n    offset += array.length;\n  }\n  return result;\n}\n\n/**\n * Copy a view of an ArrayBuffer into new ArrayBuffer with byteOffset = 0\n * @param arrayBuffer\n * @param byteOffset\n * @param byteLength\n */\nexport function sliceArrayBuffer(\n  arrayBuffer: ArrayBuffer,\n  byteOffset: number,\n  byteLength?: number\n): ArrayBuffer {\n  const subArray =\n    byteLength !== undefined\n      ? new Uint8Array(arrayBuffer).subarray(byteOffset, byteOffset + byteLength)\n      : new Uint8Array(arrayBuffer).subarray(byteOffset);\n  const arrayCopy = new Uint8Array(subArray);\n  return arrayCopy.buffer;\n}\n","// Replacement for the external assert method to reduce bundle size\n// Note: We don't use the second \"message\" argument in calling code,\n// so no need to support it here\nexport function assert(condition, message) {\n  if (!condition) {\n    throw new Error(message || 'assert failed: gltf');\n  }\n}\n","// Resolves a relative url against a baseUrl\n// If url is absolute, return it unchanged\nexport function resolveUrl(url, options) {\n  // TODO: Use better logic to handle all protocols plus not delay on data\n  const absolute = url.startsWith('data:') || url.startsWith('http:') || url.startsWith('https:');\n  if (absolute) {\n    return url;\n  }\n  const baseUrl = options.baseUri || options.uri;\n  if (!baseUrl) {\n    throw new Error(`'baseUri' must be provided to resolve relative url ${url}`);\n  }\n  return baseUrl.substr(0, baseUrl.lastIndexOf('/') + 1) + url;\n}\n","// TODO - GLTFScenegraph should use these\nimport {assert} from '../utils/assert';\n\n// accepts buffer view index or buffer view object\n// returns a `Uint8Array`\nexport function getTypedArrayForBufferView(json, buffers, bufferViewIndex) {\n  const bufferView = json.bufferViews[bufferViewIndex];\n  assert(bufferView);\n\n  // Get hold of the arrayBuffer\n  const bufferIndex = bufferView.buffer;\n  const binChunk = buffers[bufferIndex];\n  assert(binChunk);\n\n  const byteOffset = (bufferView.byteOffset || 0) + binChunk.byteOffset;\n  return new Uint8Array(binChunk.arrayBuffer, byteOffset, bufferView.byteLength);\n}\n\n// accepts accessor index or accessor object\n// returns a `Uint8Array`\nexport function getTypedArrayForImageData(json, buffers, imageIndex) {\n  const image = json.images[imageIndex];\n  const bufferViewIndex = json.bufferViews[image.bufferView];\n  return getTypedArrayForBufferView(json, buffers, bufferViewIndex);\n}\n\n/*\n// accepts accessor index or accessor object\n// returns a typed array with type that matches the types\nexport function getTypedArrayForAccessor(accessor) {\n  accessor = this.getAccessor(accessor);\n  const bufferView = this.getBufferView(accessor.bufferView);\n  const buffer = this.getBuffer(bufferView.buffer);\n  const arrayBuffer = buffer.data;\n\n  // Create a new typed array as a view into the combined buffer\n  const {ArrayType, length} = getAccessorArrayTypeAndLength(accessor, bufferView);\n  const byteOffset = bufferView.byteOffset + accessor.byteOffset;\n  return new ArrayType(arrayBuffer, byteOffset, length);\n}\n*/\n","// Version constant cannot be imported, it needs to correspond to the build version of **this** module.\n// __VERSION__ is injected by babel-plugin-version-inline\n// @ts-ignore TS2304: Cannot find name '__VERSION__'.\nexport const VERSION = typeof __VERSION__ !== 'undefined' ? __VERSION__ : 'latest';\n","import type {Loader, LoaderOptions} from '@loaders.gl/loader-utils';\nimport type {DracoParseOptions} from './lib/draco-parser';\n// import type {DracoMeshData} from './types';\nimport {VERSION} from './lib/utils/version';\n\nexport type DracoLoaderOptions = LoaderOptions & {\n  draco?: DracoParseOptions & {\n    decoderType?: 'wasm' | 'js';\n    libraryPath?: string;\n    extraAttributes?;\n    attributeNameEntry?: string;\n  };\n};\n\nconst DEFAULT_DRACO_OPTIONS: DracoLoaderOptions = {\n  draco: {\n    decoderType: typeof WebAssembly === 'object' ? 'wasm' : 'js', // 'js' for IE11\n    libraryPath: 'libs/',\n    extraAttributes: {},\n    attributeNameEntry: undefined\n  }\n};\n\n/**\n * Worker loader for Draco3D compressed geometries\n */\nexport const DracoLoader = {\n  name: 'Draco',\n  id: 'draco',\n  module: 'draco',\n  version: VERSION,\n  worker: true,\n  extensions: ['drc'],\n  mimeTypes: ['application/octet-stream'],\n  binary: true,\n  tests: ['DRACO'],\n  options: DEFAULT_DRACO_OPTIONS\n};\n\nexport const _TypecheckDracoLoader: Loader = DracoLoader;\n","import {assert} from '../../utils/assert';\nimport Field from './field';\n\nexport type SchemaMetadata = Map<string, any>;\n\n/**\n * ArrowJS `Schema` API-compatible class for row-based tables (returned from `DataTable`)\n * https://loaders.gl/arrowjs/docs/api-reference/schema\n */\nexport default class Schema {\n  fields: Field[];\n  // TODO - Arrow just allows Map<string, string>\n  metadata: SchemaMetadata;\n\n  constructor(fields: Field[], metadata?: SchemaMetadata) {\n    assert(Array.isArray(fields));\n    checkNames(fields);\n    // For kepler fields, create arrow compatible `Fields` that have kepler fields as `metadata`\n    this.fields = fields;\n    this.metadata = metadata || new Map();\n  }\n\n  // TODO - arrow only seems to compare fields, not metadata\n  compareTo(other: Schema): boolean {\n    if (this.metadata !== other.metadata) {\n      return false;\n    }\n    if (this.fields.length !== other.fields.length) {\n      return false;\n    }\n    for (let i = 0; i < this.fields.length; ++i) {\n      if (!this.fields[i].compareTo(other.fields[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  select(...columnNames: string[]): Schema {\n    // Ensure column names reference valid fields\n    const nameMap = Object.create(null);\n    for (const name of columnNames) {\n      nameMap[name] = true;\n    }\n    const selectedFields = this.fields.filter((field) => nameMap[field.name]);\n    return new Schema(selectedFields, this.metadata);\n  }\n\n  selectAt(...columnIndices: number[]): Schema {\n    // Ensure column indices reference valid fields\n    const selectedFields = columnIndices.map((index) => this.fields[index]).filter(Boolean);\n    return new Schema(selectedFields, this.metadata);\n  }\n\n  assign(schemaOrFields: Schema | Field[]): Schema {\n    let fields: Field[];\n    let metadata: SchemaMetadata = this.metadata;\n\n    if (schemaOrFields instanceof Schema) {\n      const otherSchema = schemaOrFields;\n      fields = otherSchema.fields;\n      metadata = mergeMaps(mergeMaps(new Map(), this.metadata), otherSchema.metadata);\n    } else {\n      fields = schemaOrFields;\n    }\n\n    // Create a merged list of fields, overwrite fields in place, new fields at end\n    const fieldMap: {[key: string]: Field} = Object.create(null);\n\n    for (const field of this.fields) {\n      fieldMap[field.name] = field;\n    }\n\n    for (const field of fields) {\n      fieldMap[field.name] = field;\n    }\n\n    const mergedFields = Object.values(fieldMap);\n\n    return new Schema(mergedFields, metadata);\n  }\n}\n\n// Warn if any duplicated field names\nfunction checkNames(fields) {\n  const usedNames = {};\n  for (const field of fields) {\n    if (usedNames[field.name]) {\n      // eslint-disable-next-line\n      console.warn('Schema: duplicated field name', field.name, field);\n    }\n    usedNames[field.name] = true;\n  }\n}\n\nfunction mergeMaps<T>(m1: T, m2: T): T {\n  // @ts-ignore\n  return new Map([...(m1 || new Map()), ...(m2 || new Map())]);\n}\n","// Replacement for the external assert method to reduce bundle size\n// Note: We don't use the second \"message\" argument in calling code,\n// so no need to support it here\nexport function assert(condition: boolean, message?: string) {\n  if (!condition) {\n    throw new Error(message || 'loader assertion failed.');\n  }\n}\n","// This code is adapted from ArrowJS https://github.com/apache/arrow\n// under Apache license http://www.apache.org/licenses/LICENSE-2.0\n\n/**\n * Main data type enumeration.\n *\n * Data types in this library are all *logical*. They can be expressed as\n * either a primitive physical type (bytes or bits of some fixed size), a\n * nested type consisting of other data types, or another data type (e.g. a\n * timestamp encoded as an int64).\n *\n * **Note**: Only enum values 0-17 (NONE through Map) are written to an Arrow\n * IPC payload.\n *\n * The rest of the values are specified here so TypeScript can narrow the type\n * signatures further beyond the base Arrow Types. The Arrow DataTypes include\n * metadata like `bitWidth` that impact the type signatures of the values we\n * accept and return.\n *\n * For example, the `Int8Vector` reads 1-byte numbers from an `Int8Array`, an\n * `Int32Vector` reads a 4-byte number from an `Int32Array`, and an `Int64Vector`\n * reads a pair of 4-byte lo, hi 32-bit integers as a zero-copy slice from the\n * underlying `Int32Array`.\n *\n * Library consumers benefit by knowing the narrowest type, since we can ensure\n * the types across all public methods are propagated, and never bail to `any`.\n * These values are _never_ used at runtime, and they will _never_ be written\n * to the flatbuffers metadata of serialized Arrow IPC payloads.\n */\nexport enum Type {\n  /** The default placeholder type */\n  NONE = 0,\n  /** A NULL type having no physical storage */\n  Null = 1,\n  /** Signed or unsigned 8, 16, 32, or 64-bit little-endian integer */\n  Int = 2,\n  /** 2, 4, or 8-byte floating point value */\n  Float = 3,\n  /** Variable-length bytes (no guarantee of UTF8-ness) */\n  Binary = 4,\n  /** UTF8 variable-length string as List<Char> */\n  Utf8 = 5,\n  /** Boolean as 1 bit, LSB bit-packed ordering */\n  Bool = 6,\n  /** Precision-and-scale-based decimal type. Storage type depends on the parameters. */\n  Decimal = 7,\n  /** int32_t days or int64_t milliseconds since the UNIX epoch */\n  Date = 8,\n  /** Time as signed 32 or 64-bit integer, representing either seconds, milliseconds, microseconds, or nanoseconds since midnight since midnight */\n  Time = 9,\n  /** Exact timestamp encoded with int64 since UNIX epoch (Default unit millisecond) */\n  Timestamp = 10,\n  /** YEAR_MONTH or DAY_TIME interval in SQL style */\n  Interval = 11,\n  /** A list of some logical data type */\n  List = 12,\n  /** Struct of logical types */\n  Struct = 13,\n  /** Union of logical types */\n  Union = 14,\n  /** Fixed-size binary. Each value occupies the same number of bytes */\n  FixedSizeBinary = 15,\n  /** Fixed-size list. Each value occupies the same number of bytes */\n  FixedSizeList = 16,\n  /** Map of named logical types */\n  Map = 17,\n\n  /** Dictionary aka Category type */\n  Dictionary = -1,\n  Int8 = -2,\n  Int16 = -3,\n  Int32 = -4,\n  Int64 = -5,\n  Uint8 = -6,\n  Uint16 = -7,\n  Uint32 = -8,\n  Uint64 = -9,\n  Float16 = -10,\n  Float32 = -11,\n  Float64 = -12,\n  DateDay = -13,\n  DateMillisecond = -14,\n  TimestampSecond = -15,\n  TimestampMillisecond = -16,\n  TimestampMicrosecond = -17,\n  TimestampNanosecond = -18,\n  TimeSecond = -19,\n  TimeMillisecond = -20,\n  TimeMicrosecond = -21,\n  TimeNanosecond = -22,\n  DenseUnion = -23,\n  SparseUnion = -24,\n  IntervalDayTime = -25,\n  IntervalYearMonth = -26\n}\n","// This code is adapted from ArrowJS https://github.com/apache/arrow\n// under Apache license http://www.apache.org/licenses/LICENSE-2.0\n\nimport {Type} from './enum';\n\nimport Field from './field';\n\nexport {Type} from './enum';\n\nexport type TypedIntArray =\n  | Int8Array\n  | Uint8Array\n  | Int16Array\n  | Uint16Array\n  | Int32Array\n  | Uint32Array\n  | Int32Array\n  | Uint32Array\n  | Uint8ClampedArray;\n\nexport type TypedFloatArray = Float32Array | Float64Array;\n\nexport type TypedArray = TypedIntArray | TypedFloatArray;\n\nexport type AnyArrayType = Array<any> | TypedIntArray | TypedFloatArray;\n\nexport class DataType {\n  static isNull(x: any): boolean {\n    return x && x.typeId === Type.Null;\n  }\n  static isInt(x: any): boolean {\n    return x && x.typeId === Type.Int;\n  }\n  static isFloat(x: any): boolean {\n    return x && x.typeId === Type.Float;\n  }\n  static isBinary(x: any): boolean {\n    return x && x.typeId === Type.Binary;\n  }\n  static isUtf8(x: any): boolean {\n    return x && x.typeId === Type.Utf8;\n  }\n  static isBool(x: any): boolean {\n    return x && x.typeId === Type.Bool;\n  }\n  static isDecimal(x: any): boolean {\n    return x && x.typeId === Type.Decimal;\n  }\n  static isDate(x: any): boolean {\n    return x && x.typeId === Type.Date;\n  }\n  static isTime(x: any): boolean {\n    return x && x.typeId === Type.Time;\n  }\n  static isTimestamp(x: any): boolean {\n    return x && x.typeId === Type.Timestamp;\n  }\n  static isInterval(x: any): boolean {\n    return x && x.typeId === Type.Interval;\n  }\n  static isList(x: any): boolean {\n    return x && x.typeId === Type.List;\n  }\n  static isStruct(x: any): boolean {\n    return x && x.typeId === Type.Struct;\n  }\n  static isUnion(x: any): boolean {\n    return x && x.typeId === Type.Union;\n  }\n  static isFixedSizeBinary(x: any): boolean {\n    return x && x.typeId === Type.FixedSizeBinary;\n  }\n  static isFixedSizeList(x: any): boolean {\n    return x && x.typeId === Type.FixedSizeList;\n  }\n  static isMap(x: any): boolean {\n    return x && x.typeId === Type.Map;\n  }\n  static isDictionary(x: any): boolean {\n    return x && x.typeId === Type.Dictionary;\n  }\n\n  get typeId(): Type {\n    return Type.NONE;\n  }\n\n  // get ArrayType(): AnyArrayType {\n  //   return Int8Array;\n  // }\n\n  // get ArrayType() { return Array; }\n  compareTo(other: DataType): boolean {\n    // TODO\n    return this === other; // comparer.visit(this, other);\n  }\n}\n\n// NULL\n\nexport class Null extends DataType {\n  get typeId(): Type {\n    return Type.Null;\n  }\n  get [Symbol.toStringTag](): string {\n    return 'Null';\n  }\n  toString(): string {\n    return 'Null';\n  }\n}\n\n// BOOLEANS\n\nexport class Bool extends DataType {\n  get typeId(): Type {\n    return Type.Bool;\n  }\n  // get ArrayType() {\n  //   return Uint8Array;\n  // }\n  get [Symbol.toStringTag](): string {\n    return 'Bool';\n  }\n  toString(): string {\n    return 'Bool';\n  }\n}\n\n// INTS\n\nexport class Int extends DataType {\n  readonly isSigned: boolean;\n  readonly bitWidth: number;\n  constructor(isSigned, bitWidth) {\n    super();\n    this.isSigned = isSigned;\n    this.bitWidth = bitWidth;\n  }\n  get typeId(): Type {\n    return Type.Int;\n  }\n  // get ArrayType() {\n  //   switch (this.bitWidth) {\n  //     case 8:\n  //       return this.isSigned ? Int8Array : Uint8Array;\n  //     case 16:\n  //       return this.isSigned ? Int16Array : Uint16Array;\n  //     case 32:\n  //       return this.isSigned ? Int32Array : Uint32Array;\n  //     case 64:\n  //       return this.isSigned ? Int32Array : Uint32Array;\n  //     default:\n  //       throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`);\n  //   }\n  // }\n  get [Symbol.toStringTag](): string {\n    return 'Int';\n  }\n  toString(): string {\n    return `${this.isSigned ? 'I' : 'Ui'}nt${this.bitWidth}`;\n  }\n}\n\nexport class Int8 extends Int {\n  constructor() {\n    super(true, 8);\n  }\n}\nexport class Int16 extends Int {\n  constructor() {\n    super(true, 16);\n  }\n}\nexport class Int32 extends Int {\n  constructor() {\n    super(true, 32);\n  }\n}\nexport class Int64 extends Int {\n  constructor() {\n    super(true, 64);\n  }\n}\nexport class Uint8 extends Int {\n  constructor() {\n    super(false, 8);\n  }\n}\nexport class Uint16 extends Int {\n  constructor() {\n    super(false, 16);\n  }\n}\nexport class Uint32 extends Int {\n  constructor() {\n    super(false, 32);\n  }\n}\nexport class Uint64 extends Int {\n  constructor() {\n    super(false, 64);\n  }\n}\n\n// FLOATS\n\nconst Precision = {\n  HALF: 16,\n  SINGLE: 32,\n  DOUBLE: 64\n};\n\nexport class Float extends DataType {\n  readonly precision: number;\n  constructor(precision) {\n    super();\n    this.precision = precision;\n  }\n  get typeId(): Type {\n    return Type.Float;\n  }\n  // get ArrayType() {\n  //   switch (this.precision) {\n  //     case Precision.HALF:\n  //       return Uint16Array;\n  //     case Precision.SINGLE:\n  //       return Float32Array;\n  //     case Precision.DOUBLE:\n  //       return Float64Array;\n  //     default:\n  //       throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`);\n  //   }\n  // }\n  get [Symbol.toStringTag](): string {\n    return 'Float';\n  }\n  toString(): string {\n    return `Float${this.precision}`;\n  }\n}\n\nexport class Float16 extends Float {\n  constructor() {\n    super(Precision.HALF);\n  }\n}\nexport class Float32 extends Float {\n  constructor() {\n    super(Precision.SINGLE);\n  }\n}\nexport class Float64 extends Float {\n  constructor() {\n    super(Precision.DOUBLE);\n  }\n}\n\nexport class Binary extends DataType {\n  constructor() {\n    super();\n  }\n  get typeId() {\n    return Type.Binary;\n  }\n  toString() {\n    return 'Binary';\n  }\n  get [Symbol.toStringTag]() {\n    return 'Binary';\n  }\n}\n\n// STRINGS\n\nexport class Utf8 extends DataType {\n  get typeId(): Type {\n    return Type.Utf8;\n  }\n  // get ArrayType() {\n  //   return Uint8Array;\n  // }\n  get [Symbol.toStringTag](): string {\n    return 'Utf8';\n  }\n  toString(): string {\n    return 'Utf8';\n  }\n}\n\n// DATES, TIMES AND INTERVALS\n\nconst DateUnit = {\n  DAY: 0,\n  MILLISECOND: 1\n};\n\nexport class Date extends DataType {\n  readonly unit: number;\n  constructor(unit) {\n    super();\n    this.unit = unit;\n  }\n  get typeId(): Type {\n    return Type.Date;\n  }\n  // get ArrayType() {\n  //   return Int32Array;\n  // }\n  get [Symbol.toStringTag](): string {\n    return 'Date';\n  }\n  toString(): string {\n    return `Date${(this.unit + 1) * 32}<${DateUnit[this.unit]}>`;\n  }\n}\n\nexport class DateDay extends Date {\n  constructor() {\n    super(DateUnit.DAY);\n  }\n}\nexport class DateMillisecond extends Date {\n  constructor() {\n    super(DateUnit.MILLISECOND);\n  }\n}\n\nconst TimeUnit = {\n  SECOND: 1,\n  MILLISECOND: 1e3,\n  MICROSECOND: 1e6,\n  NANOSECOND: 1e9\n};\n\nexport class Time extends DataType {\n  readonly unit: number;\n  readonly bitWidth: number;\n\n  constructor(unit, bitWidth) {\n    super();\n    this.unit = unit;\n    this.bitWidth = bitWidth;\n  }\n  get typeId(): Type {\n    return Type.Time;\n  }\n  toString(): string {\n    return `Time${this.bitWidth}<${TimeUnit[this.unit]}>`;\n  }\n  get [Symbol.toStringTag](): string {\n    return 'Time';\n  }\n  // get ArrayType() {\n  //   return Int32Array;\n  // }\n}\n\nexport class TimeSecond extends Time {\n  constructor() {\n    super(TimeUnit.SECOND, 32);\n  }\n}\nexport class TimeMillisecond extends Time {\n  constructor() {\n    super(TimeUnit.MILLISECOND, 32);\n  }\n}\n// export class TimeMicrosecond extends Time { constructor() { super(TimeUnit.MICROSECOND, 64); } }\n// export class TimeNanosecond extends Time { constructor() { super(TimeUnit.NANOSECOND, 64); } }\n\nexport class Timestamp extends DataType {\n  readonly unit: any;\n  readonly timezone: any;\n\n  constructor(unit: any, timezone = null) {\n    super();\n    this.unit = unit;\n    this.timezone = timezone;\n  }\n  get typeId(): Type {\n    return Type.Timestamp;\n  }\n  // get ArrayType() {\n  //   return Int32Array;\n  // }\n  get [Symbol.toStringTag](): string {\n    return 'Timestamp';\n  }\n  toString(): string {\n    return `Timestamp<${TimeUnit[this.unit]}${this.timezone ? `, ${this.timezone}` : ''}>`;\n  }\n}\n\nexport class TimestampSecond extends Timestamp {\n  constructor(timezone = null) {\n    super(TimeUnit.SECOND, timezone);\n  }\n}\nexport class TimestampMillisecond extends Timestamp {\n  constructor(timezone = null) {\n    super(TimeUnit.MILLISECOND, timezone);\n  }\n}\nexport class TimestampMicrosecond extends Timestamp {\n  constructor(timezone = null) {\n    super(TimeUnit.MICROSECOND, timezone);\n  }\n}\nexport class TimestampNanosecond extends Timestamp {\n  constructor(timezone = null) {\n    super(TimeUnit.NANOSECOND, timezone);\n  }\n}\n\nconst IntervalUnit = {\n  DAY_TIME: 0,\n  YEAR_MONTH: 1\n};\n\nexport class Interval extends DataType {\n  readonly unit: number;\n  constructor(unit: number) {\n    super();\n    this.unit = unit;\n  }\n  get typeId(): Type {\n    return Type.Interval;\n  }\n  // get ArrayType() {\n  //   return Int32Array;\n  // }\n  get [Symbol.toStringTag](): string {\n    return 'Interval';\n  }\n  toString(): string {\n    return `Interval<${IntervalUnit[this.unit]}>`;\n  }\n}\n\nexport class IntervalDayTime extends Interval {\n  constructor() {\n    super(IntervalUnit.DAY_TIME);\n  }\n}\nexport class IntervalYearMonth extends Interval {\n  constructor() {\n    super(IntervalUnit.YEAR_MONTH);\n  }\n}\n\nexport class FixedSizeList extends DataType {\n  readonly listSize: number;\n  readonly children: Field[];\n\n  constructor(listSize: number, child: Field) {\n    super();\n    this.listSize = listSize;\n    this.children = [child];\n  }\n  get typeId(): Type {\n    return Type.FixedSizeList;\n  }\n  get valueType() {\n    return this.children[0].type;\n  }\n  get valueField() {\n    return this.children[0];\n  }\n  // get ArrayType() {\n  //   return this.valueType.ArrayType;\n  // }\n  get [Symbol.toStringTag](): string {\n    return 'FixedSizeList';\n  }\n  toString(): string {\n    return `FixedSizeList[${this.listSize}]<${this.valueType}>`;\n  }\n}\n","import {DataType} from './type';\n\n/**\n * ArrowJS `Field` API-compatible class for row-based tables\n * https://loaders.gl/arrowjs/docs/api-reference/field\n * A field holds name, nullable, and metadata information about a table \"column\"\n * A Schema is essentially a list of fields\n */\nexport default class Field {\n  name: string;\n  type: DataType;\n  nullable: boolean;\n  metadata: Map<string, string>;\n\n  constructor(\n    name: string,\n    type: DataType,\n    nullable = false,\n    metadata: Map<string, string> = new Map()\n  ) {\n    this.name = name;\n    this.type = type;\n    this.nullable = nullable;\n    this.metadata = metadata;\n  }\n\n  get typeId(): number {\n    return this.type && this.type.typeId;\n  }\n\n  clone(): Field {\n    return new Field(this.name, this.type, this.nullable, this.metadata);\n  }\n\n  compareTo(other: this): boolean {\n    return (\n      this.name === other.name &&\n      this.type === other.type &&\n      this.nullable === other.nullable &&\n      this.metadata === other.metadata\n    );\n  }\n\n  toString(): string {\n    return `${this.type}${this.nullable ? ', nullable' : ''}${\n      this.metadata ? `, metadata: ${this.metadata}` : ''\n    }`;\n  }\n}\n","import {Schema, Field, FixedSizeList, getArrowTypeFromTypedArray} from '@loaders.gl/schema';\n\nimport {MeshAttribute, DracoAttribute, DracoLoaderData, DracoMetadataEntry} from '../draco-types';\n\nexport function makeSchemaFromAttributes(\n  attributes: {[attributeName: string]: MeshAttribute},\n  loaderData: DracoLoaderData,\n  indices?: MeshAttribute\n): Schema {\n  const metadataMap = makeMetadata(loaderData.metadata);\n  const fields: Field[] = [];\n  const namedLoaderDataAttributes = transformAttributesLoaderData(loaderData.attributes);\n  for (const attributeName in attributes) {\n    const attribute = attributes[attributeName];\n    const field = getArrowFieldFromAttribute(\n      attributeName,\n      attribute,\n      namedLoaderDataAttributes[attributeName]\n    );\n    fields.push(field);\n  }\n  if (indices) {\n    const indicesField = getArrowFieldFromAttribute('indices', indices);\n    fields.push(indicesField);\n  }\n  return new Schema(fields, metadataMap);\n}\n\nfunction transformAttributesLoaderData(loaderData: {[key: number]: DracoAttribute}): {\n  [attributeName: string]: DracoAttribute;\n} {\n  const result: {[attributeName: string]: DracoAttribute} = {};\n  for (const key in loaderData) {\n    const dracoAttribute = loaderData[key];\n    result[dracoAttribute.name || 'undefined'] = dracoAttribute;\n  }\n  return result;\n}\n\nfunction getArrowFieldFromAttribute(\n  attributeName: string,\n  attribute: MeshAttribute,\n  loaderData?: DracoAttribute\n): Field {\n  const metadataMap = loaderData ? makeMetadata(loaderData.metadata) : undefined;\n  const type = getArrowTypeFromTypedArray(attribute.value);\n  return new Field(\n    attributeName,\n    new FixedSizeList(attribute.size, new Field('value', type)),\n    false,\n    metadataMap\n  );\n}\n\nfunction makeMetadata(metadata: {[key: string]: DracoMetadataEntry}): Map<string, string> {\n  const metadataMap = new Map();\n  for (const key in metadata) {\n    metadataMap.set(`${key}.string`, JSON.stringify(metadata[key]));\n  }\n\n  return metadataMap;\n}\n","import type {TypedArray} from '../../types';\nimport {DataType, Float32, Float64, Int16, Int32, Int8, Uint16, Uint32, Uint8} from '../schema';\n\nexport function getArrowTypeFromTypedArray(array: TypedArray): DataType {\n  switch (array.constructor) {\n    case Int8Array:\n      return new Int8();\n    case Uint8Array:\n      return new Uint8();\n    case Int16Array:\n      return new Int16();\n    case Uint16Array:\n      return new Uint16();\n    case Int32Array:\n      return new Int32();\n    case Uint32Array:\n      return new Uint32();\n    case Float32Array:\n      return new Float32();\n    case Float64Array:\n      return new Float64();\n    default:\n      throw new Error('array type not supported');\n  }\n}\n","/* eslint-disable camelcase */\n\n// Draco types (input)\nimport type {\n  Draco3D,\n  Decoder,\n  Mesh,\n  PointCloud,\n  PointAttribute,\n  Metadata,\n  MetadataQuerier,\n  DracoInt32Array,\n  draco_DataType\n} from '../draco3d/draco3d-types';\n\n// Parsed data types (output)\nimport type {\n  TypedArray,\n  // standard mesh output data\n  MeshData,\n  MeshAttribute,\n  // standard mesh with draco metadata\n  DracoMeshData,\n  DracoLoaderData,\n  DracoAttribute,\n  DracoMetadataEntry,\n  DracoQuantizationTransform,\n  DracoOctahedronTransform\n} from './draco-types';\n\nimport {getMeshBoundingBox} from '@loaders.gl/schema';\nimport {makeSchemaFromAttributes} from './utils/schema-attribute-utils';\n\n/**\n * @param topology - How triangle indices should be generated (mesh only)\n * @param attributeNameEntry\n * @param extraAttributes\n * @param quantizedAttributes\n * @param octahedronAttributes\n */\nexport type DracoParseOptions = {\n  topology?: 'triangle-list' | 'triangle-strip';\n  attributeNameEntry?: string;\n  extraAttributes?: {[uniqueId: string]: number};\n  quantizedAttributes?: ('POSITION' | 'NORMAL' | 'COLOR' | 'TEX_COORD' | 'GENERIC')[];\n  octahedronAttributes?: ('POSITION' | 'NORMAL' | 'COLOR' | 'TEX_COORD' | 'GENERIC')[];\n};\n\n// @ts-ignore\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst GEOMETRY_TYPE = {\n  TRIANGULAR_MESH: 0,\n  POINT_CLOUD: 1\n};\n\n// Native Draco attribute names to GLTF attribute names.\nconst DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP = {\n  POSITION: 'POSITION',\n  NORMAL: 'NORMAL',\n  COLOR: 'COLOR_0',\n  TEX_COORD: 'TEXCOORD_0'\n};\n\nconst DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP = {\n  1: Int8Array,\n  2: Uint8Array,\n  3: Int16Array,\n  4: Uint16Array,\n  5: Int32Array,\n  6: Uint32Array,\n  9: Float32Array\n};\n\nconst INDEX_ITEM_SIZE = 4;\n\nexport default class DracoParser {\n  draco: Draco3D;\n  decoder: Decoder;\n  metadataQuerier: MetadataQuerier;\n\n  // draco - the draco decoder, either import `draco3d` or load dynamically\n  constructor(draco: Draco3D) {\n    this.draco = draco;\n    this.decoder = new this.draco.Decoder();\n    this.metadataQuerier = new this.draco.MetadataQuerier();\n  }\n\n  /**\n   * Destroy draco resources\n   */\n  destroy(): void {\n    this.draco.destroy(this.decoder);\n    this.draco.destroy(this.metadataQuerier);\n  }\n\n  /**\n   * NOTE: caller must call `destroyGeometry` on the return value after using it\n   * @param arrayBuffer\n   * @param options\n   */\n  parseSync(arrayBuffer: ArrayBuffer, options: DracoParseOptions = {}): DracoMeshData {\n    const buffer = new this.draco.DecoderBuffer();\n    buffer.Init(new Int8Array(arrayBuffer), arrayBuffer.byteLength);\n\n    this._disableAttributeTransforms(options);\n\n    const geometry_type = this.decoder.GetEncodedGeometryType(buffer);\n    const dracoGeometry =\n      geometry_type === this.draco.TRIANGULAR_MESH\n        ? new this.draco.Mesh()\n        : new this.draco.PointCloud();\n\n    try {\n      let dracoStatus;\n      switch (geometry_type) {\n        case this.draco.TRIANGULAR_MESH:\n          dracoStatus = this.decoder.DecodeBufferToMesh(buffer, dracoGeometry as Mesh);\n          break;\n\n        case this.draco.POINT_CLOUD:\n          dracoStatus = this.decoder.DecodeBufferToPointCloud(buffer, dracoGeometry);\n          break;\n\n        default:\n          throw new Error('DRACO: Unknown geometry type.');\n      }\n\n      if (!dracoStatus.ok() || !dracoGeometry.ptr) {\n        const message = `DRACO decompression failed: ${dracoStatus.error_msg()}`;\n        // console.error(message);\n        throw new Error(message);\n      }\n\n      const loaderData = this._getDracoLoaderData(dracoGeometry, geometry_type, options);\n\n      const geometry = this._getMeshData(dracoGeometry, loaderData, options);\n\n      const boundingBox = getMeshBoundingBox(geometry.attributes);\n\n      const schema = makeSchemaFromAttributes(geometry.attributes, loaderData, geometry.indices);\n\n      const data: DracoMeshData = {\n        loader: 'draco',\n        loaderData,\n        header: {\n          vertexCount: dracoGeometry.num_points(),\n          boundingBox\n        },\n        ...geometry,\n        schema\n      };\n      return data;\n    } finally {\n      this.draco.destroy(buffer);\n      if (dracoGeometry) {\n        this.draco.destroy(dracoGeometry);\n      }\n    }\n  }\n\n  // Draco specific \"loader data\"\n\n  /**\n   * Extract\n   * @param dracoGeometry\n   * @param geometry_type\n   * @param options\n   * @returns\n   */\n  _getDracoLoaderData(\n    dracoGeometry: Mesh | PointCloud,\n    geometry_type,\n    options: DracoParseOptions\n  ): DracoLoaderData {\n    const metadata = this._getTopLevelMetadata(dracoGeometry);\n    const attributes = this._getDracoAttributes(dracoGeometry, options);\n\n    return {\n      geometry_type,\n      num_attributes: dracoGeometry.num_attributes(),\n      num_points: dracoGeometry.num_points(),\n      num_faces: dracoGeometry instanceof this.draco.Mesh ? dracoGeometry.num_faces() : 0,\n      metadata,\n      attributes\n    };\n  }\n\n  /**\n   * Extract all draco provided information and metadata for each attribute\n   * @param dracoGeometry\n   * @param options\n   * @returns\n   */\n  _getDracoAttributes(\n    dracoGeometry: Mesh | PointCloud,\n    options: DracoParseOptions\n  ): {[unique_id: number]: DracoAttribute} {\n    const dracoAttributes: {[unique_id: number]: DracoAttribute} = {};\n\n    for (let attributeId = 0; attributeId < dracoGeometry.num_attributes(); attributeId++) {\n      // Note: Draco docs do not seem clear on `GetAttribute` ids just being a zero-based index,\n      // but it does seems to work this way\n      const dracoAttribute = this.decoder.GetAttribute(dracoGeometry, attributeId);\n\n      const metadata = this._getAttributeMetadata(dracoGeometry, attributeId);\n\n      dracoAttributes[dracoAttribute.unique_id()] = {\n        unique_id: dracoAttribute.unique_id(),\n        attribute_type: dracoAttribute.attribute_type(),\n        data_type: dracoAttribute.data_type(),\n        num_components: dracoAttribute.num_components(),\n\n        byte_offset: dracoAttribute.byte_offset(),\n        byte_stride: dracoAttribute.byte_stride(),\n        normalized: dracoAttribute.normalized(),\n        attribute_index: attributeId,\n\n        metadata\n      };\n\n      // Add transformation parameters for any attributes app wants untransformed\n      const quantization = this._getQuantizationTransform(dracoAttribute, options);\n      if (quantization) {\n        dracoAttributes[dracoAttribute.unique_id()].quantization_transform = quantization;\n      }\n\n      const octahedron = this._getOctahedronTransform(dracoAttribute, options);\n      if (octahedron) {\n        dracoAttributes[dracoAttribute.unique_id()].octahedron_transform = octahedron;\n      }\n    }\n\n    return dracoAttributes;\n  }\n\n  /**\n   * Get standard loaders.gl mesh category data\n   * Extracts the geometry from draco\n   * @param dracoGeometry\n   * @param options\n   */\n  _getMeshData(\n    dracoGeometry: Mesh | PointCloud,\n    loaderData: DracoLoaderData,\n    options: DracoParseOptions\n  ): MeshData {\n    const attributes = this._getMeshAttributes(loaderData, dracoGeometry, options);\n\n    const positionAttribute = attributes.POSITION;\n    if (!positionAttribute) {\n      throw new Error('DRACO: No position attribute found.');\n    }\n\n    // For meshes, we need indices to define the faces.\n    if (dracoGeometry instanceof this.draco.Mesh) {\n      switch (options.topology) {\n        case 'triangle-strip':\n          return {\n            topology: 'triangle-strip',\n            mode: 4, // GL.TRIANGLES\n            attributes,\n            indices: {\n              value: this._getTriangleStripIndices(dracoGeometry),\n              size: 1\n            }\n          };\n        case 'triangle-list':\n        default:\n          return {\n            topology: 'triangle-list',\n            mode: 5, // GL.TRIANGLE_STRIP\n            attributes,\n            indices: {\n              value: this._getTriangleListIndices(dracoGeometry),\n              size: 1\n            }\n          };\n      }\n    }\n\n    // PointCloud - must come last as Mesh inherits from PointCloud\n    return {\n      topology: 'point-list',\n      mode: 0, // GL.POINTS\n      attributes\n    };\n  }\n\n  _getMeshAttributes(\n    loaderData: DracoLoaderData,\n    dracoGeometry: Mesh | PointCloud,\n    options: DracoParseOptions\n  ): {[attributeName: string]: MeshAttribute} {\n    const attributes: {[key: string]: MeshAttribute} = {};\n\n    for (const loaderAttribute of Object.values(loaderData.attributes)) {\n      const attributeName = this._deduceAttributeName(loaderAttribute, options);\n      loaderAttribute.name = attributeName;\n      const {value, size} = this._getAttributeValues(dracoGeometry, loaderAttribute);\n      attributes[attributeName] = {\n        value,\n        size,\n        byteOffset: loaderAttribute.byte_offset,\n        byteStride: loaderAttribute.byte_stride,\n        normalized: loaderAttribute.normalized\n      };\n    }\n\n    return attributes;\n  }\n\n  // MESH INDICES EXTRACTION\n\n  /**\n   * For meshes, we need indices to define the faces.\n   * @param dracoGeometry\n   */\n  _getTriangleListIndices(dracoGeometry: Mesh) {\n    // Example on how to retrieve mesh and attributes.\n    const numFaces = dracoGeometry.num_faces();\n    const numIndices = numFaces * 3;\n    const byteLength = numIndices * INDEX_ITEM_SIZE;\n\n    const ptr = this.draco._malloc(byteLength);\n    try {\n      this.decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr);\n      return new Uint32Array(this.draco.HEAPF32.buffer, ptr, numIndices).slice();\n    } finally {\n      this.draco._free(ptr);\n    }\n  }\n\n  /**\n   * For meshes, we need indices to define the faces.\n   * @param dracoGeometry\n   */\n  _getTriangleStripIndices(dracoGeometry: Mesh) {\n    const dracoArray = new this.draco.DracoInt32Array();\n    try {\n      /* const numStrips = */ this.decoder.GetTriangleStripsFromMesh(dracoGeometry, dracoArray);\n      return getUint32Array(dracoArray);\n    } finally {\n      this.draco.destroy(dracoArray);\n    }\n  }\n\n  /**\n   *\n   * @param dracoGeometry\n   * @param dracoAttribute\n   * @param attributeName\n   */\n  _getAttributeValues(\n    dracoGeometry: Mesh | PointCloud,\n    attribute: DracoAttribute\n  ): {value: TypedArray; size: number} {\n    const TypedArrayCtor = DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP[attribute.data_type];\n    const numComponents = attribute.num_components;\n    const numPoints = dracoGeometry.num_points();\n    const numValues = numPoints * numComponents;\n\n    const byteLength = numValues * TypedArrayCtor.BYTES_PER_ELEMENT;\n    const dataType = getDracoDataType(this.draco, TypedArrayCtor);\n\n    let value: TypedArray;\n\n    const ptr = this.draco._malloc(byteLength);\n    try {\n      const dracoAttribute = this.decoder.GetAttribute(dracoGeometry, attribute.attribute_index);\n      this.decoder.GetAttributeDataArrayForAllPoints(\n        dracoGeometry,\n        dracoAttribute,\n        dataType,\n        byteLength,\n        ptr\n      );\n      value = new TypedArrayCtor(this.draco.HEAPF32.buffer, ptr, numValues).slice();\n    } finally {\n      this.draco._free(ptr);\n    }\n\n    return {value, size: numComponents};\n  }\n\n  // Attribute names\n\n  /** \n   * DRACO does not store attribute names - We need to deduce an attribute name\n   * for each attribute\n  _getAttributeNames(\n    dracoGeometry: Mesh | PointCloud,\n    options: DracoParseOptions\n  ): {[unique_id: number]: string} {\n    const attributeNames: {[unique_id: number]: string} = {};\n    for (let attributeId = 0; attributeId < dracoGeometry.num_attributes(); attributeId++) {\n      const dracoAttribute = this.decoder.GetAttribute(dracoGeometry, attributeId);\n      const attributeName = this._deduceAttributeName(dracoAttribute, options);\n      attributeNames[attributeName] = attributeName;\n    }\n    return attributeNames;\n  }\n   */\n\n  /**\n   * Deduce an attribute name.\n   * @note DRACO does not save attribute names, just general type (POSITION, COLOR)\n   * to help optimize compression. We generate GLTF compatible names for the Draco-recognized\n   * types\n   * @param attributeData\n   */\n  _deduceAttributeName(attribute: DracoAttribute, options: DracoParseOptions): string {\n    // Deduce name based on application provided map\n    const uniqueId = attribute.unique_id;\n    for (const [attributeName, attributeUniqueId] of Object.entries(\n      options.extraAttributes || {}\n    )) {\n      if (attributeUniqueId === uniqueId) {\n        return attributeName;\n      }\n    }\n\n    // Deduce name based on attribute type\n    const thisAttributeType = attribute.attribute_type;\n    for (const dracoAttributeConstant in DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP) {\n      const attributeType = this.draco[dracoAttributeConstant];\n      if (attributeType === thisAttributeType) {\n        // TODO - Return unique names if there multiple attributes per type\n        // (e.g. multiple TEX_COORDS or COLORS)\n        return DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP[dracoAttributeConstant];\n      }\n    }\n\n    // Look up in metadata\n    // TODO - shouldn't this have priority?\n    const entryName = options.attributeNameEntry || 'name';\n    if (attribute.metadata[entryName]) {\n      return attribute.metadata[entryName].string;\n    }\n\n    // Attribute of \"GENERIC\" type, we need to assign some name\n    return `CUSTOM_ATTRIBUTE_${uniqueId}`;\n  }\n\n  // METADATA EXTRACTION\n\n  /** Get top level metadata */\n  _getTopLevelMetadata(dracoGeometry: Mesh | PointCloud) {\n    const dracoMetadata = this.decoder.GetMetadata(dracoGeometry);\n    return this._getDracoMetadata(dracoMetadata);\n  }\n\n  /** Get per attribute metadata */\n  _getAttributeMetadata(dracoGeometry: Mesh | PointCloud, attributeId: number) {\n    const dracoMetadata = this.decoder.GetAttributeMetadata(dracoGeometry, attributeId);\n    return this._getDracoMetadata(dracoMetadata);\n  }\n\n  /**\n   * Extract metadata field values\n   * @param dracoMetadata\n   * @returns\n   */\n  _getDracoMetadata(dracoMetadata: Metadata): {[entry: string]: DracoMetadataEntry} {\n    // The not so wonderful world of undocumented Draco APIs :(\n    if (!dracoMetadata || !dracoMetadata.ptr) {\n      return {};\n    }\n    const result = {};\n    const numEntries = this.metadataQuerier.NumEntries(dracoMetadata);\n    for (let entryIndex = 0; entryIndex < numEntries; entryIndex++) {\n      const entryName = this.metadataQuerier.GetEntryName(dracoMetadata, entryIndex);\n      result[entryName] = this._getDracoMetadataField(dracoMetadata, entryName);\n    }\n    return result;\n  }\n\n  /**\n   * Extracts possible values for one metadata entry by name\n   * @param dracoMetadata\n   * @param entryName\n   */\n  _getDracoMetadataField(dracoMetadata: Metadata, entryName: string): DracoMetadataEntry {\n    const dracoArray = new this.draco.DracoInt32Array();\n    try {\n      // Draco metadata fields can hold int32 arrays\n      this.metadataQuerier.GetIntEntryArray(dracoMetadata, entryName, dracoArray);\n      const intArray = getInt32Array(dracoArray);\n      return {\n        int: this.metadataQuerier.GetIntEntry(dracoMetadata, entryName),\n        string: this.metadataQuerier.GetStringEntry(dracoMetadata, entryName),\n        double: this.metadataQuerier.GetDoubleEntry(dracoMetadata, entryName),\n        intArray\n      };\n    } finally {\n      this.draco.destroy(dracoArray);\n    }\n  }\n\n  // QUANTIZED ATTRIBUTE SUPPORT (NO DECOMPRESSION)\n\n  /** Skip transforms for specific attribute types */\n  _disableAttributeTransforms(options: DracoParseOptions) {\n    const {quantizedAttributes = [], octahedronAttributes = []} = options;\n    const skipAttributes = [...quantizedAttributes, ...octahedronAttributes];\n    for (const dracoAttributeName of skipAttributes) {\n      this.decoder.SkipAttributeTransform(this.draco[dracoAttributeName]);\n    }\n  }\n\n  /**\n   * Extract (and apply?) Position Transform\n   * @todo not used\n   */\n  _getQuantizationTransform(\n    dracoAttribute: PointAttribute,\n    options: DracoParseOptions\n  ): DracoQuantizationTransform | null {\n    const {quantizedAttributes = []} = options;\n    const attribute_type = dracoAttribute.attribute_type();\n    const skip = quantizedAttributes.map((type) => this.decoder[type]).includes(attribute_type);\n    if (skip) {\n      const transform = new this.draco.AttributeQuantizationTransform();\n      try {\n        if (transform.InitFromAttribute(dracoAttribute)) {\n          return {\n            quantization_bits: transform.quantization_bits(),\n            range: transform.range(),\n            min_values: new Float32Array([1, 2, 3]).map((i) => transform.min_value(i))\n          };\n        }\n      } finally {\n        this.draco.destroy(transform);\n      }\n    }\n    return null;\n  }\n\n  _getOctahedronTransform(\n    dracoAttribute: PointAttribute,\n    options: DracoParseOptions\n  ): DracoOctahedronTransform | null {\n    const {octahedronAttributes = []} = options;\n    const attribute_type = dracoAttribute.attribute_type();\n    const octahedron = octahedronAttributes\n      .map((type) => this.decoder[type])\n      .includes(attribute_type);\n    if (octahedron) {\n      const transform = new this.draco.AttributeQuantizationTransform();\n      try {\n        if (transform.InitFromAttribute(dracoAttribute)) {\n          return {\n            quantization_bits: transform.quantization_bits()\n          };\n        }\n      } finally {\n        this.draco.destroy(transform);\n      }\n    }\n    return null;\n  }\n\n  // HELPERS\n}\n\n/**\n * Get draco specific data type by TypedArray constructor type\n * @param attributeType\n * @returns draco specific data type\n */\nfunction getDracoDataType(draco: Draco3D, attributeType: any): draco_DataType {\n  switch (attributeType) {\n    case Float32Array:\n      return draco.DT_FLOAT32;\n    case Int8Array:\n      return draco.DT_INT8;\n    case Int16Array:\n      return draco.DT_INT16;\n    case Int32Array:\n      return draco.DT_INT32;\n    case Uint8Array:\n      return draco.DT_UINT8;\n    case Uint16Array:\n      return draco.DT_UINT16;\n    case Uint32Array:\n      return draco.DT_UINT32;\n    default:\n      return draco.DT_INVALID;\n  }\n}\n\n/**\n * Copy a Draco int32 array into a JS typed array\n */\nfunction getInt32Array(dracoArray: DracoInt32Array): Int32Array {\n  const numValues = dracoArray.size();\n  const intArray = new Int32Array(numValues);\n  for (let i = 0; i < numValues; i++) {\n    intArray[i] = dracoArray.GetValue(i);\n  }\n  return intArray;\n}\n\n/**\n * Copy a Draco int32 array into a JS typed array\n */\nfunction getUint32Array(dracoArray: DracoInt32Array): Int32Array {\n  const numValues = dracoArray.size();\n  const intArray = new Int32Array(numValues);\n  for (let i = 0; i < numValues; i++) {\n    intArray[i] = dracoArray.GetValue(i);\n  }\n  return intArray;\n}\n","// Mesh category utilities\n// TODO - move to mesh category module, or to math.gl/geometry module\nimport {TypedArray} from '../../types';\n\ntype Attribute = {\n  size?: number;\n  type?: number;\n  normalized?: boolean;\n  value: TypedArray;\n};\n\ntype TypedArrays = {[key: string]: TypedArray};\nexport type Attributes = {[key: string]: Attribute};\n\n/**\n * Holds an axis aligned bounding box\n * TODO - make sure AxisAlignedBoundingBox in math.gl/culling understands this format (or change this format)\n */\ntype BoundingBox = [[number, number, number], [number, number, number]];\n\n/**\n * Get number of vertices in mesh\n * @param attributes\n */\nexport function getMeshSize(attributes: TypedArrays): number {\n  let size = 0;\n  for (const attributeName in attributes) {\n    const attribute = attributes[attributeName];\n    if (ArrayBuffer.isView(attribute)) {\n      // @ts-ignore DataView doesn't have BYTES_PER_ELEMENT\n      size += attribute.byteLength * attribute.BYTES_PER_ELEMENT;\n    }\n  }\n  return size;\n}\n\n/**\n * Get the (axis aligned) bounding box of a mesh\n * @param attributes\n * @returns array of two vectors representing the axis aligned bounding box\n */\n// eslint-disable-next-line complexity\nexport function getMeshBoundingBox(attributes: Attributes): BoundingBox {\n  let minX = Infinity;\n  let minY = Infinity;\n  let minZ = Infinity;\n  let maxX = -Infinity;\n  let maxY = -Infinity;\n  let maxZ = -Infinity;\n\n  const positions = attributes.POSITION ? attributes.POSITION.value : [];\n  const len = positions && positions.length;\n\n  for (let i = 0; i < len; i += 3) {\n    const x = positions[i];\n    const y = positions[i + 1];\n    const z = positions[i + 2];\n\n    minX = x < minX ? x : minX;\n    minY = y < minY ? y : minY;\n    minZ = z < minZ ? z : minZ;\n\n    maxX = x > maxX ? x : maxX;\n    maxY = y > maxY ? y : maxY;\n    maxZ = z > maxZ ? z : maxZ;\n  }\n  return [\n    [minX, minY, minZ],\n    [maxX, maxY, maxZ]\n  ];\n}\n","/* global importScripts */\nimport {global, isBrowser, isWorker} from '../env-utils/globals';\nimport * as node from '../node/require-utils.node';\nimport {assert} from '../env-utils/assert';\nimport {VERSION as __VERSION__} from '../env-utils/version';\n\n// TODO - unpkg.com doesn't seem to have a `latest` specifier for alpha releases...\nconst LATEST = 'beta';\nconst VERSION = typeof __VERSION__ !== 'undefined' ? __VERSION__ : LATEST;\n\nconst loadLibraryPromises = {}; // promises\n\n/**\n * Dynamically loads a library (\"module\")\n *\n * - wasm library: Array buffer is returned\n * - js library: Parse JS is returned\n *\n * Method depends on environment\n * - browser - script element is created and installed on document\n * - worker - eval is called on global context\n * - node - file is required\n *\n * @param libraryUrl\n * @param moduleName\n * @param options\n */\nexport async function loadLibrary(\n  libraryUrl: string,\n  moduleName: string | null = null,\n  options: object = {}\n): Promise<any> {\n  if (moduleName) {\n    libraryUrl = getLibraryUrl(libraryUrl, moduleName, options);\n  }\n\n  // Ensure libraries are only loaded once\n  loadLibraryPromises[libraryUrl] =\n    loadLibraryPromises[libraryUrl] || loadLibraryFromFile(libraryUrl);\n  return await loadLibraryPromises[libraryUrl];\n}\n\n// TODO - sort out how to resolve paths for main/worker and dev/prod\nexport function getLibraryUrl(library, moduleName?: string, options?): string {\n  // Check if already a URL\n  if (library.startsWith('http')) {\n    return library;\n  }\n\n  // Allow application to import and supply libraries through `options.modules`\n  const modules = options.modules || {};\n  if (modules[library]) {\n    return modules[library];\n  }\n\n  // Load from local files, not from CDN scripts in Node.js\n  // TODO - needs to locate the modules directory when installed!\n  if (!isBrowser) {\n    return `modules/${moduleName}/dist/libs/${library}`;\n  }\n\n  // In browser, load from external scripts\n  if (options.CDN) {\n    assert(options.CDN.startsWith('http'));\n    return `${options.CDN}/${moduleName}@${VERSION}/dist/libs/${library}`;\n  }\n\n  // TODO - loading inside workers requires paths relative to worker script location...\n  if (isWorker) {\n    return `../src/libs/${library}`;\n  }\n\n  return `modules/${moduleName}/src/libs/${library}`;\n}\n\nasync function loadLibraryFromFile(libraryUrl) {\n  if (libraryUrl.endsWith('wasm')) {\n    const response = await fetch(libraryUrl);\n    return await response.arrayBuffer();\n  }\n\n  if (!isBrowser) {\n    return node.requireFromFile && (await node.requireFromFile(libraryUrl));\n  }\n  if (isWorker) {\n    return importScripts(libraryUrl);\n  }\n  // TODO - fix - should be more secure than string parsing since observes CORS\n  // if (isBrowser) {\n  //   return await loadScriptFromFile(libraryUrl);\n  // }\n\n  const response = await fetch(libraryUrl);\n  const scriptSource = await response.text();\n  return loadLibraryFromString(scriptSource, libraryUrl);\n}\n\n/*\nasync function loadScriptFromFile(libraryUrl) {\n  const script = document.createElement('script');\n  script.src = libraryUrl;\n  return await new Promise((resolve, reject) => {\n    script.onload = data => {\n      resolve(data);\n    };\n    script.onerror = reject;\n  });\n}\n*/\n\n// TODO - Needs security audit...\n//  - Raw eval call\n//  - Potentially bypasses CORS\n// Upside is that this separates fetching and parsing\n// we could create a`LibraryLoader` or`ModuleLoader`\nfunction loadLibraryFromString(scriptSource, id) {\n  if (!isBrowser) {\n    return node.requireFromString && node.requireFromString(scriptSource, id);\n  }\n\n  if (isWorker) {\n    // Use lvalue trick to make eval run in global scope\n    eval.call(global, scriptSource); // eslint-disable-line no-eval\n    // https://stackoverflow.com/questions/9107240/1-evalthis-vs-evalthis-in-javascript\n    // http://perfectionkills.com/global-eval-what-are-the-options/\n    return null;\n  }\n\n  const script = document.createElement('script');\n  script.id = id;\n  // most browsers like a separate text node but some throw an error. The second method covers those.\n  try {\n    script.appendChild(document.createTextNode(scriptSource));\n  } catch (e) {\n    script.text = scriptSource;\n  }\n  document.body.appendChild(script);\n  return null;\n}\n\n// TODO - technique for module injection into worker, from THREE.DracoLoader...\n/*\nfunction combineWorkerWithLibrary(worker, jsContent) {\n  var fn = wWorker.toString();\n  var body = [\n    '// injected',\n    jsContent,\n    '',\n    '// worker',\n    fn.substring(fn.indexOf('{') + 1, fn.lastIndexOf('}'))\n  ].join('\\n');\n  this.workerSourceURL = URL.createObjectURL(new Blob([body]));\n}\n*/\n","// Replacement for the external assert method to reduce bundle size\n// Note: We don't use the second \"message\" argument in calling code,\n// so no need to support it here\n\n/** Throws an `Error` with the optional `message` if `condition` is falsy */\nexport function assert(condition: any, message?: string): void {\n  if (!condition) {\n    throw new Error(message || 'loaders.gl assertion failed.');\n  }\n}\n","// Dynamic DRACO module loading inspired by THREE.DRACOLoader\n// https://github.com/mrdoob/three.js/blob/398c4f39ebdb8b23eefd4a7a5ec49ec0c96c7462/examples/jsm/loaders/DRACOLoader.js\n// by Don McCurdy / https://www.donmccurdy.com / MIT license\n\nimport {loadLibrary} from '@loaders.gl/worker-utils';\n\nconst DRACO_VERSION = '1.4.1';\nconst DRACO_JS_DECODER_URL = `https://www.gstatic.com/draco/versioned/decoders/${DRACO_VERSION}/draco_decoder.js`;\nconst DRACO_WASM_WRAPPER_URL = `https://www.gstatic.com/draco/versioned/decoders/${DRACO_VERSION}/draco_wasm_wrapper.js`;\nconst DRACO_WASM_DECODER_URL = `https://www.gstatic.com/draco/versioned/decoders/${DRACO_VERSION}/draco_decoder.wasm`;\n\nconst DRACO_ENCODER_URL = `https://raw.githubusercontent.com/google/draco/${DRACO_VERSION}/javascript/draco_encoder.js`;\n\nlet loadDecoderPromise;\nlet loadEncoderPromise;\n\nexport async function loadDracoDecoderModule(options) {\n  const modules = options.modules || {};\n\n  // Check if a bundled draco3d library has been supplied by application\n  if (modules.draco3d) {\n    loadDecoderPromise =\n      loadDecoderPromise ||\n      modules.draco3d.createDecoderModule({}).then((draco) => {\n        return {draco};\n      });\n  } else {\n    // If not, dynamically load the WASM script from our CDN\n    loadDecoderPromise = loadDecoderPromise || loadDracoDecoder(options);\n  }\n  return await loadDecoderPromise;\n}\n\nexport async function loadDracoEncoderModule(options) {\n  const modules = options.modules || {};\n\n  // Check if a bundled draco3d library has been supplied by application\n  if (modules.draco3d) {\n    loadEncoderPromise =\n      loadEncoderPromise ||\n      modules.draco3d.createEncoderModule({}).then((draco) => {\n        return {draco};\n      });\n  } else {\n    // If not, dynamically load the WASM script from our CDN\n    loadEncoderPromise = loadEncoderPromise || loadDracoEncoder(options);\n  }\n  return await loadEncoderPromise;\n}\n\n// DRACO DECODER LOADING\n\nasync function loadDracoDecoder(options) {\n  let DracoDecoderModule;\n  let wasmBinary;\n  switch (options.draco && options.draco.decoderType) {\n    case 'js':\n      DracoDecoderModule = await loadLibrary(DRACO_JS_DECODER_URL, 'draco', options);\n      break;\n\n    case 'wasm':\n    default:\n      [DracoDecoderModule, wasmBinary] = await Promise.all([\n        await loadLibrary(DRACO_WASM_WRAPPER_URL, 'draco', options),\n        await loadLibrary(DRACO_WASM_DECODER_URL, 'draco', options)\n      ]);\n  }\n  // Depends on how import happened...\n  // @ts-ignore\n  DracoDecoderModule = DracoDecoderModule || globalThis.DracoDecoderModule;\n  return await initializeDracoDecoder(DracoDecoderModule, wasmBinary);\n}\n\nfunction initializeDracoDecoder(DracoDecoderModule, wasmBinary) {\n  const options: {wasmBinary?: any} = {};\n  if (wasmBinary) {\n    options.wasmBinary = wasmBinary;\n  }\n\n  return new Promise((resolve) => {\n    DracoDecoderModule({\n      ...options,\n      onModuleLoaded: (draco) => resolve({draco}) // Module is Promise-like. Wrap in object to avoid loop.\n    });\n  });\n}\n\n// ENCODER\n\nasync function loadDracoEncoder(options) {\n  let DracoEncoderModule = await loadLibrary(DRACO_ENCODER_URL, 'draco', options);\n  // @ts-ignore\n  DracoEncoderModule = DracoEncoderModule || globalThis.DracoEncoderModule;\n\n  return new Promise((resolve) => {\n    DracoEncoderModule({\n      onModuleLoaded: (draco) => resolve({draco}) // Module is Promise-like. Wrap in object to avoid loop.\n    });\n  });\n}\n","import type {LoaderWithParser} from '@loaders.gl/loader-utils';\nimport type {DracoMeshData, DracoLoaderData} from './lib/draco-types';\nimport type {DracoLoaderOptions} from './draco-loader';\nimport {DracoLoader as DracoWorkerLoader} from './draco-loader';\nimport DracoParser from './lib/draco-parser';\nimport {loadDracoDecoderModule} from './lib/draco-module-loader';\n\n// Draco data types\n\nexport type {DracoMeshData, DracoLoaderData};\n\n// Draco Writer\n\nexport type {DracoWriterOptions} from './draco-writer';\nexport {DracoWriter} from './draco-writer';\n\n// Draco Loader\n\nexport type {DracoLoaderOptions};\nexport {DracoWorkerLoader};\n\n/**\n * Loader for Draco3D compressed geometries\n */\nexport const DracoLoader = {\n  ...DracoWorkerLoader,\n  parse\n};\n\nasync function parse(\n  arrayBuffer: ArrayBuffer,\n  options?: DracoLoaderOptions\n): Promise<DracoMeshData> {\n  const {draco} = await loadDracoDecoderModule(options);\n  const dracoParser = new DracoParser(draco);\n  try {\n    return dracoParser.parseSync(arrayBuffer, options?.draco);\n  } finally {\n    dracoParser.destroy();\n  }\n}\n\n// TYPE TESTS - TODO find a better way than exporting junk\nexport const _TypecheckDracoLoader: LoaderWithParser = DracoLoader;\n","/**\n * Throws an `Error` with the optional `message` if `condition` is falsy\n * @note Replacement for the external assert method to reduce bundle size\n */\nexport function assert(condition: any, message?: string): void {\n  if (!condition) {\n    throw new Error(message || 'loader assertion failed.');\n  }\n}\n","import {assert} from '../env-utils/assert';\n\n/**\n * Calculate new size of an arrayBuffer to be aligned to an n-byte boundary\n * This function increases `byteLength` by the minimum delta,\n * allowing the total length to be divided by `padding`\n * @param byteLength\n * @param padding\n */\nexport function padToNBytes(byteLength: number, padding: number): number {\n  assert(byteLength >= 0); // `Incorrect 'byteLength' value: ${byteLength}`\n  assert(padding > 0); // `Incorrect 'padding' value: ${padding}`\n  return (byteLength + (padding - 1)) & ~(padding - 1);\n}\n\n/**\n * Creates a new Uint8Array based on two different ArrayBuffers\n * @param targetBuffer The first buffer.\n * @param sourceBuffer The second buffer.\n * @return The new ArrayBuffer created out of the two.\n */\nexport function copyArrayBuffer(\n  targetBuffer: ArrayBuffer,\n  sourceBuffer: ArrayBuffer,\n  byteOffset: number,\n  byteLength: number = sourceBuffer.byteLength\n): ArrayBuffer {\n  const targetArray = new Uint8Array(targetBuffer, byteOffset, byteLength);\n  const sourceArray = new Uint8Array(sourceBuffer);\n  targetArray.set(sourceArray);\n  return targetBuffer;\n}\n\n/**\n * Copy from source to target at the targetOffset\n *\n * @param source - The data to copy\n * @param target - The destination to copy data into\n * @param targetOffset - The start offset into target to place the copied data\n * @returns the new offset taking into account proper padding\n */\nexport function copyToArray(source: ArrayBuffer | any, target: any, targetOffset: number): number {\n  let sourceArray;\n\n  if (source instanceof ArrayBuffer) {\n    sourceArray = new Uint8Array(source);\n  } else {\n    // Pack buffer onto the big target array\n    //\n    // 'source.data.buffer' could be a view onto a larger buffer.\n    // We MUST use this constructor to ensure the byteOffset and byteLength is\n    // set to correct values from 'source.data' and not the underlying\n    // buffer for target.set() to work properly.\n    const srcByteOffset = source.byteOffset;\n    const srcByteLength = source.byteLength;\n    // In gltf parser it is set as \"arrayBuffer\" instead of \"buffer\"\n    // https://github.com/visgl/loaders.gl/blob/1e3a82a0a65d7b6a67b1e60633453e5edda2960a/modules/gltf/src/lib/parse-gltf.js#L85\n    sourceArray = new Uint8Array(source.buffer || source.arrayBuffer, srcByteOffset, srcByteLength);\n  }\n\n  // Pack buffer onto the big target array\n  target.set(sourceArray, targetOffset);\n\n  return targetOffset + padToNBytes(sourceArray.byteLength, 4);\n}\n","import {assert} from '../utils/assert';\n\nconst TYPES = ['SCALAR', 'VEC2', 'VEC3', 'VEC4'];\n\ntype TypedArrayConstructor =\n  | Int8ArrayConstructor\n  | Uint8ArrayConstructor\n  | Int16ArrayConstructor\n  | Uint16ArrayConstructor\n  | Int32ArrayConstructor\n  | Uint32ArrayConstructor\n  | Int32ArrayConstructor\n  | Uint32ArrayConstructor\n  | Float32ArrayConstructor\n  | Float64ArrayConstructor;\n\nconst ARRAY_CONSTRUCTOR_TO_WEBGL_CONSTANT: [TypedArrayConstructor, number][] = [\n  [Int8Array, 5120],\n  [Uint8Array, 5121],\n  [Int16Array, 5122],\n  [Uint16Array, 5123],\n  [Uint32Array, 5125],\n  [Float32Array, 5126],\n  [Float64Array, 5130]\n];\nconst ARRAY_TO_COMPONENT_TYPE = new Map<TypedArrayConstructor, number>(\n  ARRAY_CONSTRUCTOR_TO_WEBGL_CONSTANT\n);\n\nconst ATTRIBUTE_TYPE_TO_COMPONENTS = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n};\n\nconst ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE = {\n  5120: 1,\n  5121: 1,\n  5122: 2,\n  5123: 2,\n  5125: 4,\n  5126: 4\n};\n\nconst ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY = {\n  5120: Int8Array,\n  5121: Uint8Array,\n  5122: Int16Array,\n  5123: Uint16Array,\n  5125: Uint32Array,\n  5126: Float32Array\n};\n\nexport function getAccessorTypeFromSize(size) {\n  const type = TYPES[size - 1];\n  return type || TYPES[0];\n}\n\nexport function getComponentTypeFromArray(typedArray) {\n  const componentType = ARRAY_TO_COMPONENT_TYPE.get(typedArray.constructor);\n  if (!componentType) {\n    throw new Error('Illegal typed array');\n  }\n  return componentType;\n}\n\nexport function getAccessorArrayTypeAndLength(accessor, bufferView) {\n  const ArrayType = ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY[accessor.componentType];\n  const components = ATTRIBUTE_TYPE_TO_COMPONENTS[accessor.type];\n  const bytesPerComponent = ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE[accessor.componentType];\n  const length = accessor.count * components;\n  const byteLength = accessor.count * components * bytesPerComponent;\n  assert(byteLength >= 0 && byteLength <= bufferView.byteLength);\n  return {ArrayType, length, byteLength};\n}\n","import type {\n  GLTF,\n  GLTFScene,\n  GLTFNode,\n  GLTFMesh,\n  GLTFSkin,\n  GLTFMaterial,\n  GLTFAccessor,\n  GLTFSampler,\n  GLTFTexture,\n  GLTFImage,\n  GLTFBuffer,\n  GLTFBufferView\n} from '../types/gltf-types';\n\nimport {getBinaryImageMetadata} from '@loaders.gl/images';\nimport {padToNBytes, copyToArray} from '@loaders.gl/loader-utils';\nimport {assert} from '../utils/assert';\nimport {\n  getAccessorArrayTypeAndLength,\n  getAccessorTypeFromSize,\n  getComponentTypeFromArray\n} from '../gltf-utils/gltf-utils';\n\ntype GLTFWithBuffers = {\n  json: GLTF;\n  buffers: any[];\n  binary?: ArrayBuffer;\n};\n\nconst DEFAULT_GLTF_JSON: GLTF = {\n  asset: {\n    version: '2.0',\n    generator: 'loaders.gl'\n  },\n  buffers: []\n};\n\n/**\n * Class for structured access to GLTF data\n */\nexport default class GLTFScenegraph {\n  // internal\n  gltf: GLTFWithBuffers;\n  sourceBuffers: any[];\n  byteLength: number;\n\n  constructor(gltf?: {json: GLTF; buffers?: any[]}) {\n    // @ts-ignore\n    this.gltf = gltf || {\n      json: {...DEFAULT_GLTF_JSON},\n      buffers: []\n    };\n    this.sourceBuffers = [];\n    this.byteLength = 0;\n\n    // Initialize buffers\n    if (this.gltf.buffers && this.gltf.buffers[0]) {\n      this.byteLength = this.gltf.buffers[0].byteLength;\n      this.sourceBuffers = [this.gltf.buffers[0]];\n    }\n  }\n\n  // Accessors\n\n  get json(): GLTF {\n    return this.gltf.json;\n  }\n\n  getApplicationData(key: string): {[key: string]: any} {\n    // TODO - Data is already unpacked by GLBParser\n    const data = this.json[key];\n    return data;\n  }\n\n  getExtraData(key: string): {[key: string]: any} {\n    // TODO - Data is already unpacked by GLBParser\n    const extras = this.json.extras || {};\n    return extras[key];\n  }\n\n  getExtension(extensionName: string): {[key: string]: any} | null {\n    const isExtension = this.getUsedExtensions().find((name) => name === extensionName);\n    const extensions = this.json.extensions || {};\n    return isExtension ? extensions[extensionName] || true : null;\n  }\n\n  getRequiredExtension(extensionName: string): {[key: string]: any} | null {\n    const isRequired = this.getRequiredExtensions().find((name) => name === extensionName);\n    return isRequired ? this.getExtension(extensionName) : null;\n  }\n\n  getRequiredExtensions(): string[] {\n    return this.json.extensionsRequired || [];\n  }\n\n  getUsedExtensions(): string[] {\n    return this.json.extensionsUsed || [];\n  }\n\n  getObjectExtension(\n    object: {[key: string]: any},\n    extensionName: string\n  ): {[key: string]: any} | null {\n    const extensions = object.extensions || {};\n    return extensions[extensionName];\n  }\n\n  getScene(index: number): GLTFScene {\n    return this.getObject('scenes', index) as GLTFScene;\n  }\n\n  getNode(index: number): GLTFNode {\n    return this.getObject('nodes', index) as GLTFNode;\n  }\n\n  getSkin(index: number): GLTFSkin {\n    return this.getObject('skins', index) as GLTFSkin;\n  }\n\n  getMesh(index: number): GLTFMesh {\n    return this.getObject('meshes', index) as GLTFMesh;\n  }\n\n  getMaterial(index: number): GLTFMaterial {\n    return this.getObject('materials', index) as GLTFMaterial;\n  }\n\n  getAccessor(index: number): GLTFAccessor {\n    return this.getObject('accessors', index) as GLTFAccessor;\n  }\n\n  // getCamera(index: number): object | null {\n  //   return null; // TODO: fix thi: object  as null;\n  // }\n\n  getTexture(index: number): GLTFTexture {\n    return this.getObject('textures', index) as GLTFTexture;\n  }\n\n  getSampler(index: number): GLTFSampler {\n    return this.getObject('samplers', index) as GLTFSampler;\n  }\n\n  getImage(index: number): GLTFImage {\n    return this.getObject('images', index) as GLTFImage;\n  }\n\n  getBufferView(index: number | object): GLTFBufferView {\n    return this.getObject('bufferViews', index) as GLTFBufferView;\n  }\n\n  getBuffer(index: number): GLTFBuffer {\n    return this.getObject('buffers', index) as GLTFBuffer;\n  }\n\n  getObject(array: string, index: number | object): object {\n    // check if already resolved\n    if (typeof index === 'object') {\n      return index;\n    }\n    const object = this.json[array] && this.json[array][index];\n    if (!object) {\n      throw new Error(`glTF file error: Could not find ${array}[${index}]`); // eslint-disable-line\n    }\n    return object;\n  }\n\n  /**\n   * Accepts buffer view index or buffer view object\n   * @returns a `Uint8Array`\n   */\n  getTypedArrayForBufferView(bufferView: number | object): Uint8Array {\n    bufferView = this.getBufferView(bufferView);\n    // @ts-ignore\n    const bufferIndex = bufferView.buffer;\n\n    // Get hold of the arrayBuffer\n    // const buffer = this.getBuffer(bufferIndex);\n    const binChunk = this.gltf.buffers[bufferIndex];\n    assert(binChunk);\n\n    // @ts-ignore\n    const byteOffset = (bufferView.byteOffset || 0) + binChunk.byteOffset;\n    // @ts-ignore\n    return new Uint8Array(binChunk.arrayBuffer, byteOffset, bufferView.byteLength);\n  }\n\n  /** Accepts accessor index or accessor object\n   * @returns a typed array with type that matches the types\n   */\n  getTypedArrayForAccessor(accessor: number | object): any {\n    // @ts-ignore\n    accessor = this.getAccessor(accessor);\n    // @ts-ignore\n    const bufferView = this.getBufferView(accessor.bufferView);\n    const buffer = this.getBuffer(bufferView.buffer);\n    // @ts-ignore\n    const arrayBuffer = buffer.data;\n\n    // Create a new typed array as a view into the combined buffer\n    const {ArrayType, length} = getAccessorArrayTypeAndLength(accessor, bufferView);\n    // @ts-ignore\n    const byteOffset = bufferView.byteOffset + accessor.byteOffset;\n    return new ArrayType(arrayBuffer, byteOffset, length);\n  }\n\n  /** accepts accessor index or accessor object\n   * returns a `Uint8Array`\n   */\n  getTypedArrayForImageData(image: number | object): Uint8Array {\n    // @ts-ignore\n    image = this.getAccessor(image);\n    // @ts-ignore\n    const bufferView = this.getBufferView(image.bufferView);\n    const buffer = this.getBuffer(bufferView.buffer);\n    // @ts-ignore\n    const arrayBuffer = buffer.data;\n\n    const byteOffset = bufferView.byteOffset || 0;\n    return new Uint8Array(arrayBuffer, byteOffset, bufferView.byteLength);\n  }\n\n  // MODIFERS\n\n  /**\n   * Add an extra application-defined key to the top-level data structure\n   */\n  addApplicationData(key: string, data: object): GLTFScenegraph {\n    this.json[key] = data;\n    return this;\n  }\n\n  /**\n   * `extras` - Standard GLTF field for storing application specific data\n   */\n  addExtraData(key: string, data: object): GLTFScenegraph {\n    this.json.extras = this.json.extras || {};\n    this.json.extras[key] = data;\n    return this;\n  }\n\n  addObjectExtension(object: object, extensionName: string, data: object): GLTFScenegraph {\n    // @ts-ignore\n    object.extensions = object.extensions || {};\n    // TODO - clobber or merge?\n    // @ts-ignore\n    object.extensions[extensionName] = data;\n    this.registerUsedExtension(extensionName);\n    return this;\n  }\n\n  setObjectExtension(object: object, extensionName: string, data: object): void {\n    // @ts-ignore\n    const extensions = object.extensions || {};\n    extensions[extensionName] = data;\n    // TODO - add to usedExtensions...\n  }\n\n  removeObjectExtension(object: object, extensionName: string): object {\n    // @ts-ignore\n    const extensions = object.extensions || {};\n    const extension = extensions[extensionName];\n    delete extensions[extensionName];\n    return extension;\n  }\n\n  /**\n   * Add to standard GLTF top level extension object, mark as used\n   */\n  addExtension(extensionName: string, extensionData: object = {}): object {\n    assert(extensionData);\n    this.json.extensions = this.json.extensions || {};\n    this.json.extensions[extensionName] = extensionData;\n    this.registerUsedExtension(extensionName);\n    return extensionData;\n  }\n\n  /**\n   * Standard GLTF top level extension object, mark as used and required\n   */\n  addRequiredExtension(extensionName, extensionData: object = {}): object {\n    assert(extensionData);\n    this.addExtension(extensionName, extensionData);\n    this.registerRequiredExtension(extensionName);\n    return extensionData;\n  }\n\n  /**\n   * Add extensionName to list of used extensions\n   */\n  registerUsedExtension(extensionName: string): void {\n    this.json.extensionsUsed = this.json.extensionsUsed || [];\n    if (!this.json.extensionsUsed.find((ext) => ext === extensionName)) {\n      this.json.extensionsUsed.push(extensionName);\n    }\n  }\n\n  /**\n   * Add extensionName to list of required extensions\n   */\n  registerRequiredExtension(extensionName: string): void {\n    this.registerUsedExtension(extensionName);\n    this.json.extensionsRequired = this.json.extensionsRequired || [];\n    if (!this.json.extensionsRequired.find((ext) => ext === extensionName)) {\n      this.json.extensionsRequired.push(extensionName);\n    }\n  }\n\n  /**\n   * Removes an extension from the top-level list\n   */\n  removeExtension(extensionName: string): void {\n    if (this.json.extensionsRequired) {\n      this._removeStringFromArray(this.json.extensionsRequired, extensionName);\n    }\n    if (this.json.extensionsUsed) {\n      this._removeStringFromArray(this.json.extensionsUsed, extensionName);\n    }\n    if (this.json.extensions) {\n      delete this.json.extensions[extensionName];\n    }\n  }\n\n  /**\n   *  Set default scene which is to be displayed at load time\n   */\n  setDefaultScene(sceneIndex: number): void {\n    this.json.scene = sceneIndex;\n  }\n\n  /**\n   * @todo: add more properties for scene initialization:\n   *   name`, `extensions`, `extras`\n   *   https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#reference-scene\n   */\n  addScene(scene: {nodeIndices: number[]}): number {\n    const {nodeIndices} = scene;\n    this.json.scenes = this.json.scenes || [];\n    this.json.scenes.push({nodes: nodeIndices});\n    return this.json.scenes.length - 1;\n  }\n\n  /**\n   * @todo: add more properties for node initialization:\n   *   `name`, `extensions`, `extras`, `camera`, `children`, `skin`, `rotation`, `scale`, `translation`, `weights`\n   *   https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#node\n   */\n  addNode(node: {meshIndex: number; matrix: number[]}): number {\n    const {meshIndex, matrix} = node;\n    this.json.nodes = this.json.nodes || [];\n    const nodeData = {mesh: meshIndex};\n    if (matrix) {\n      // @ts-ignore\n      nodeData.matrix = matrix;\n    }\n    this.json.nodes.push(nodeData);\n    return this.json.nodes.length - 1;\n  }\n\n  /** Adds a mesh to the json part */\n  addMesh(mesh: {attributes: object; indices: object; material: number; mode: number}): number {\n    const {attributes, indices, material, mode = 4} = mesh;\n    const accessors = this._addAttributes(attributes);\n\n    const glTFMesh = {\n      primitives: [\n        {\n          attributes: accessors,\n          mode\n        }\n      ]\n    };\n\n    if (indices) {\n      const indicesAccessor = this._addIndices(indices);\n      // @ts-ignore\n      glTFMesh.primitives[0].indices = indicesAccessor;\n    }\n\n    if (Number.isFinite(material)) {\n      // @ts-ignore\n      glTFMesh.primitives[0].material = material;\n    }\n\n    this.json.meshes = this.json.meshes || [];\n    this.json.meshes.push(glTFMesh);\n    return this.json.meshes.length - 1;\n  }\n\n  addPointCloud(attributes: object): number {\n    // @ts-ignore\n    const accessorIndices = this._addAttributes(attributes);\n\n    const glTFMesh = {\n      primitives: [\n        {\n          attributes: accessorIndices,\n          mode: 0 // GL.POINTS\n        }\n      ]\n    };\n\n    this.json.meshes = this.json.meshes || [];\n    this.json.meshes.push(glTFMesh);\n    return this.json.meshes.length - 1;\n  }\n\n  /**\n   * Adds a binary image. Builds glTF \"JSON metadata\" and saves buffer reference\n   * Buffer will be copied into BIN chunk during \"pack\"\n   * Currently encodes as glTF image\n   * @param imageData\n   * @param mimeType\n   */\n  addImage(imageData: any, mimeTypeOpt?: string): number {\n    // If image is referencing a bufferView instead of URI, mimeType must be defined:\n    //   https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#images\n    //   \"a reference to a bufferView; in that case mimeType must be defined.\"\n    const metadata = getBinaryImageMetadata(imageData);\n    const mimeType = mimeTypeOpt || metadata?.mimeType;\n\n    const bufferViewIndex = this.addBufferView(imageData);\n\n    const glTFImage = {\n      bufferView: bufferViewIndex,\n      mimeType\n    };\n\n    this.json.images = this.json.images || [];\n    this.json.images.push(glTFImage);\n    return this.json.images.length - 1;\n  }\n\n  /**\n   * Add one untyped source buffer, create a matching glTF `bufferView`, and return its index\n   * @param buffer\n   */\n  addBufferView(buffer: any): number {\n    const byteLength = buffer.byteLength;\n    assert(Number.isFinite(byteLength));\n\n    // Add this buffer to the list of buffers to be written to the body.\n    this.sourceBuffers = this.sourceBuffers || [];\n    this.sourceBuffers.push(buffer);\n\n    const glTFBufferView = {\n      buffer: 0,\n      // Write offset from the start of the binary body\n      byteOffset: this.byteLength,\n      byteLength\n    };\n\n    // We've now added the contents to the body, so update the total length\n    // Every sub-chunk needs to be 4-byte align ed\n    this.byteLength += padToNBytes(byteLength, 4);\n\n    // Add a bufferView indicating start and length of this binary sub-chunk\n    this.json.bufferViews = this.json.bufferViews || [];\n    this.json.bufferViews.push(glTFBufferView);\n    return this.json.bufferViews.length - 1;\n  }\n\n  /**\n   * Adds an accessor to a bufferView\n   * @param bufferViewIndex\n   * @param accessor\n   */\n  addAccessor(bufferViewIndex: number, accessor: object): number {\n    const glTFAccessor = {\n      bufferView: bufferViewIndex,\n      // @ts-ignore\n      type: getAccessorTypeFromSize(accessor.size),\n      // @ts-ignore\n      componentType: accessor.componentType,\n      // @ts-ignore\n      count: accessor.count,\n      // @ts-ignore\n      max: accessor.max,\n      // @ts-ignore\n      min: accessor.min\n    };\n\n    this.json.accessors = this.json.accessors || [];\n    this.json.accessors.push(glTFAccessor);\n    return this.json.accessors.length - 1;\n  }\n\n  /**\n   * Add a binary buffer. Builds glTF \"JSON metadata\" and saves buffer reference\n   * Buffer will be copied into BIN chunk during \"pack\"\n   * Currently encodes buffers as glTF accessors, but this could be optimized\n   * @param sourceBuffer\n   * @param accessor\n   */\n  addBinaryBuffer(sourceBuffer: any, accessor: object = {size: 3}): number {\n    const bufferViewIndex = this.addBufferView(sourceBuffer);\n    // @ts-ignore\n    let minMax = {min: accessor.min, max: accessor.max};\n    if (!minMax.min || !minMax.max) {\n      // @ts-ignore\n      minMax = this._getAccessorMinMax(sourceBuffer, accessor.size);\n    }\n\n    const accessorDefaults = {\n      // @ts-ignore\n      size: accessor.size,\n      componentType: getComponentTypeFromArray(sourceBuffer),\n      // @ts-ignore\n      count: Math.round(sourceBuffer.length / accessor.size),\n      min: minMax.min,\n      max: minMax.max\n    };\n\n    return this.addAccessor(bufferViewIndex, Object.assign(accessorDefaults, accessor));\n  }\n\n  /**\n   * Adds a texture to the json part\n   * @todo: add more properties for texture initialization\n   * `sampler`, `name`, `extensions`, `extras`\n   * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#texture\n   */\n  addTexture(texture: {imageIndex: number}): number {\n    const {imageIndex} = texture;\n    const glTFTexture = {\n      source: imageIndex\n    };\n\n    this.json.textures = this.json.textures || [];\n    this.json.textures.push(glTFTexture);\n    return this.json.textures.length - 1;\n  }\n\n  /** Adds a material to the json part */\n  addMaterial(pbrMaterialInfo: Object): number {\n    this.json.materials = this.json.materials || [];\n    this.json.materials.push(pbrMaterialInfo);\n    return this.json.materials.length - 1;\n  }\n\n  /** Pack the binary chunk */\n  createBinaryChunk(): void {\n    // Encoder expects this array undefined or empty\n    this.gltf.buffers = [];\n\n    // Allocate total array\n    const totalByteLength = this.byteLength;\n    const arrayBuffer = new ArrayBuffer(totalByteLength);\n    const targetArray = new Uint8Array(arrayBuffer);\n\n    // Copy each array into\n    let dstByteOffset = 0;\n    for (const sourceBuffer of this.sourceBuffers || []) {\n      dstByteOffset = copyToArray(sourceBuffer, targetArray, dstByteOffset);\n    }\n\n    // Update the glTF BIN CHUNK byte length\n    if (this.json?.buffers?.[0]) {\n      this.json.buffers[0].byteLength = totalByteLength;\n    } else {\n      this.json.buffers = [{byteLength: totalByteLength}];\n    }\n\n    // Save generated arrayBuffer\n    this.gltf.binary = arrayBuffer;\n\n    // Put arrayBuffer to sourceBuffers for possible additional writing data in the chunk\n    this.sourceBuffers = [arrayBuffer];\n  }\n\n  // PRIVATE\n\n  _removeStringFromArray(array, string) {\n    let found = true;\n    while (found) {\n      const index = array.indexOf(string);\n      if (index > -1) {\n        array.splice(index, 1);\n      } else {\n        found = false;\n      }\n    }\n  }\n\n  /**\n   * Add attributes to buffers and create `attributes` object which is part of `mesh`\n   */\n  _addAttributes(attributes = {}) {\n    const result = {};\n    for (const attributeKey in attributes) {\n      const attributeData = attributes[attributeKey];\n      const attrName = this._getGltfAttributeName(attributeKey);\n      const accessor = this.addBinaryBuffer(attributeData.value, attributeData);\n      result[attrName] = accessor;\n    }\n    return result;\n  }\n\n  /**\n   * Add indices to buffers\n   */\n  _addIndices(indices) {\n    return this.addBinaryBuffer(indices, {size: 1});\n  }\n\n  /**\n   * Deduce gltf specific attribue name from input attribute name\n   */\n  _getGltfAttributeName(attributeName) {\n    switch (attributeName.toLowerCase()) {\n      case 'position':\n      case 'positions':\n      case 'vertices':\n        return 'POSITION';\n      case 'normal':\n      case 'normals':\n        return 'NORMAL';\n      case 'color':\n      case 'colors':\n        return 'COLOR_0';\n      case 'texcoord':\n      case 'texcoords':\n        return 'TEXCOORD_0';\n      default:\n        return attributeName;\n    }\n  }\n\n  /**\n   * Calculate `min` and `max` arrays of accessor according to spec:\n   * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#reference-accessor\n   */\n  _getAccessorMinMax(buffer, size) {\n    const result = {min: null, max: null};\n    if (buffer.length < size) {\n      return result;\n    }\n    // @ts-ignore\n    result.min = [];\n    // @ts-ignore\n    result.max = [];\n    const initValues = buffer.subarray(0, size);\n    for (const value of initValues) {\n      // @ts-ignore\n      result.min.push(value);\n      // @ts-ignore\n      result.max.push(value);\n    }\n\n    for (let index = size; index < buffer.length; index += size) {\n      for (let componentIndex = 0; componentIndex < size; componentIndex++) {\n        // @ts-ignore\n        result.min[0 + componentIndex] = Math.min(\n          // @ts-ignore\n          result.min[0 + componentIndex],\n          buffer[index + componentIndex]\n        );\n        // @ts-ignore\n        result.max[0 + componentIndex] = Math.max(\n          // @ts-ignore\n          result.max[0 + componentIndex],\n          buffer[index + componentIndex]\n        );\n      }\n    }\n    return result;\n  }\n}\n","// import type {TypedArray} from '../types/loader-utils';\nimport type {GLTFAccessor} from '../types/gltf-types';\n// TODO - remove\nimport {getAccessorTypeFromSize, getComponentTypeFromArray} from './gltf-utils';\n\n// Returns a fresh attributes object with glTF-standardized attributes names\n// Attributes that cannot be identified will not be included\n// Removes `indices` if present, as it should be stored separately from the attributes\nexport function getGLTFAccessors(attributes): {[key: string]: GLTFAccessor} {\n  const accessors = {};\n  for (const name in attributes) {\n    const attribute = attributes[name];\n    if (name !== 'indices') {\n      const glTFAccessor = getGLTFAccessor(attribute);\n      accessors[name] = glTFAccessor;\n    }\n  }\n  return accessors;\n}\n\n// Fix up a single accessor.\n// Input: typed array or a partial accessor object\n// Return: accessor object\nexport function getGLTFAccessor(attribute) {\n  const {buffer, size, count} = getAccessorData(attribute);\n\n  const glTFAccessor: GLTFAccessor = {\n    // glTF Accessor values\n    // TODO: Instead of a bufferView index we could have an actual buffer (typed array)\n    // bufferView: null,\n    // TODO: Deprecate `value` in favor of bufferView?\n    // @ts-ignore\n    value: buffer,\n    size, // Decoded `type` (e.g. SCALAR)\n\n    byteOffset: 0,\n    count,\n    type: getAccessorTypeFromSize(size),\n    componentType: getComponentTypeFromArray(buffer)\n  };\n\n  return glTFAccessor;\n}\n\n// export function getGLTFAttribute(data, gltfAttributeName): GLTFAccessor {\n//   return data.attributes[data.glTFAttributeMap[gltfAttributeName]];\n// }\n\nfunction getAccessorData(attribute) {\n  let buffer = attribute;\n  let size = 1;\n  let count = 0;\n\n  if (attribute && attribute.value) {\n    buffer = attribute.value;\n    size = attribute.size || 1;\n  }\n\n  if (buffer) {\n    if (!ArrayBuffer.isView(buffer)) {\n      buffer = toTypedArray(buffer, Float32Array);\n    }\n    count = buffer.length / size;\n  }\n\n  return {buffer, size, count};\n}\n\n// Convert non-typed arrays to arrays of specified format\nfunction toTypedArray(array, ArrayType, convertTypedArrays = false) {\n  if (!array) {\n    return null;\n  }\n  if (Array.isArray(array)) {\n    return new ArrayType(array);\n  }\n  if (convertTypedArrays && !(array instanceof ArrayType)) {\n    return new ArrayType(array);\n  }\n  return array;\n}\n","// https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression\n// Only TRIANGLES: 0x0004 and TRIANGLE_STRIP: 0x0005 are supported\n\n/* eslint-disable camelcase */\nimport type {GLTF, GLTFAccessor, GLTFMeshPrimitive} from '../types/gltf-types';\nimport type {GLTFLoaderOptions} from '../../gltf-loader';\n\nimport type {LoaderContext} from '@loaders.gl/loader-utils';\nimport {DracoLoader} from '@loaders.gl/draco';\nimport {DracoLoaderOptions, DracoMeshData} from '@loaders.gl/draco';\nimport {sliceArrayBuffer} from '@loaders.gl/loader-utils';\nimport {default as Scenegraph} from '../api/gltf-scenegraph';\nimport {KHR_DRACO_MESH_COMPRESSION} from '../gltf-utils/gltf-constants';\nimport {getGLTFAccessors, getGLTFAccessor} from '../gltf-utils/gltf-attribute-utils';\n\n// Note: We have a \"soft dependency\" on DracoWriter to avoid bundling it when not needed\nexport async function decode(\n  gltfData: {json: GLTF},\n  options: GLTFLoaderOptions,\n  context: LoaderContext\n): Promise<void> {\n  if (!options?.gltf?.decompressMeshes) {\n    return;\n  }\n\n  const scenegraph = new Scenegraph(gltfData);\n  const promises: Promise<void>[] = [];\n  for (const primitive of makeMeshPrimitiveIterator(scenegraph)) {\n    if (scenegraph.getObjectExtension(primitive, KHR_DRACO_MESH_COMPRESSION)) {\n      promises.push(decompressPrimitive(scenegraph, primitive, options, context));\n    }\n  }\n\n  // Decompress meshes in parallel\n  await Promise.all(promises);\n\n  // We have now decompressed all primitives, so remove the top-level extensions\n  scenegraph.removeExtension(KHR_DRACO_MESH_COMPRESSION);\n}\n\nexport function encode(gltfData, options: GLTFLoaderOptions = {}): void {\n  const scenegraph = new Scenegraph(gltfData);\n\n  for (const mesh of scenegraph.json.meshes || []) {\n    // eslint-disable-next-line camelcase\n    // @ts-ignore\n    compressMesh(mesh, options);\n    // NOTE: Only add the extension if something was actually compressed\n    scenegraph.addRequiredExtension(KHR_DRACO_MESH_COMPRESSION);\n  }\n}\n\n// DECODE\n\n// Unpacks one mesh primitive and removes the extension from the primitive\n// DracoDecoder needs to be imported and registered by app\n// Returns: Promise that resolves when all pending draco decoder jobs for this mesh complete\n\n// TODO - Implement fallback behavior per KHR_DRACO_MESH_COMPRESSION spec\n\nasync function decompressPrimitive(\n  scenegraph: Scenegraph,\n  primitive: GLTFMeshPrimitive,\n  options: GLTFLoaderOptions,\n  context: LoaderContext\n): Promise<void> {\n  const dracoExtension = scenegraph.getObjectExtension(primitive, KHR_DRACO_MESH_COMPRESSION);\n  if (!dracoExtension) {\n    return;\n  }\n\n  const buffer = scenegraph.getTypedArrayForBufferView(dracoExtension.bufferView);\n  // TODO - parse does not yet deal well with byte offsets embedded in typed arrays. Copy buffer\n  // TODO - remove when `parse` is fixed to handle `byteOffset`s\n  const bufferCopy = sliceArrayBuffer(buffer.buffer, buffer.byteOffset); // , buffer.byteLength);\n\n  const {parse} = context;\n  const dracoOptions: DracoLoaderOptions = {...options};\n\n  // TODO - remove hack: The entire tileset might be included, too expensive to serialize\n  delete dracoOptions['3d-tiles'];\n  const decodedData = (await parse(\n    bufferCopy,\n    DracoLoader,\n    dracoOptions,\n    context\n  )) as DracoMeshData;\n\n  const decodedAttributes: {[key: string]: GLTFAccessor} = getGLTFAccessors(decodedData.attributes);\n\n  // Restore min/max values\n  for (const [attributeName, decodedAttribute] of Object.entries(decodedAttributes)) {\n    if (attributeName in primitive.attributes) {\n      const accessorIndex: number = primitive.attributes[attributeName];\n      const accessor = scenegraph.getAccessor(accessorIndex);\n      if (accessor?.min && accessor?.max) {\n        decodedAttribute.min = accessor.min;\n        decodedAttribute.max = accessor.max;\n      }\n    }\n  }\n\n  // @ts-ignore\n  primitive.attributes = decodedAttributes;\n  if (decodedData.indices) {\n    // @ts-ignore\n    primitive.indices = getGLTFAccessor(decodedData.indices);\n  }\n\n  // Extension has been processed, delete it\n  // delete primitive.extensions[KHR_DRACO_MESH_COMPRESSION];\n\n  checkPrimitive(primitive);\n}\n\n// ENCODE\n\n// eslint-disable-next-line max-len\n// Only TRIANGLES: 0x0004 and TRIANGLE_STRIP: 0x0005 are supported\nfunction compressMesh(attributes, indices, mode: number = 4, options, context: LoaderContext) {\n  if (!options.DracoWriter) {\n    throw new Error('options.gltf.DracoWriter not provided');\n  }\n\n  // TODO - use DracoWriter using encode w/ registered DracoWriter...\n  const compressedData = options.DracoWriter.encodeSync({attributes});\n\n  // Draco compression may change the order and number of vertices in a mesh.\n  // To satisfy the requirement that accessors properties be correct for both\n  // compressed and uncompressed data, generators should create uncompressed\n  // attributes and indices using data that has been decompressed from the Draco buffer,\n  // rather than the original source data.\n  // @ts-ignore TODO this needs to be fixed\n  const decodedData = context?.parseSync?.({attributes});\n  const fauxAccessors = options._addFauxAttributes(decodedData.attributes);\n\n  const bufferViewIndex = options.addBufferView(compressedData);\n\n  const glTFMesh = {\n    primitives: [\n      {\n        attributes: fauxAccessors, // TODO - verify with spec\n        mode, // GL.POINTS\n        extensions: {\n          [KHR_DRACO_MESH_COMPRESSION]: {\n            bufferView: bufferViewIndex,\n            attributes: fauxAccessors // TODO - verify with spec\n          }\n        }\n      }\n    ]\n  };\n\n  return glTFMesh;\n}\n\n// UTILS\n\nfunction checkPrimitive(primitive: GLTFMeshPrimitive) {\n  if (!primitive.attributes && Object.keys(primitive.attributes).length > 0) {\n    throw new Error('glTF: Empty primitive detected: Draco decompression failure?');\n  }\n}\n\nfunction* makeMeshPrimitiveIterator(scenegraph) {\n  for (const mesh of scenegraph.json.meshes || []) {\n    for (const primitive of mesh.primitives) {\n      yield primitive;\n    }\n  }\n}\n","// GLTF EXTENSION: KHR_materials_unlit\n// https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit\n\nimport type {GLTF} from '../types/gltf-types';\n\nimport GLTFScenegraph from '../api/gltf-scenegraph';\nimport {KHR_MATERIALS_UNLIT} from '../gltf-utils/gltf-constants';\n\nexport async function decode(gltfData: {json: GLTF}): Promise<void> {\n  const gltfScenegraph = new GLTFScenegraph(gltfData);\n  const {json} = gltfScenegraph;\n\n  // Remove the top-level extension\n  gltfScenegraph.removeExtension(KHR_MATERIALS_UNLIT);\n\n  // Any nodes that have the extension, add lights field pointing to light object\n  // and remove the extension\n  for (const material of json.materials || []) {\n    const extension = material.extensions && material.extensions.KHR_materials_unlit;\n    if (extension) {\n      // @ts-ignore TODO\n      material.unlit = true;\n    }\n    gltfScenegraph.removeObjectExtension(material, KHR_MATERIALS_UNLIT);\n  }\n}\n\nexport function encode(gltfData) {\n  const gltfScenegraph = new GLTFScenegraph(gltfData);\n  const {json} = gltfScenegraph;\n\n  // Any nodes that have lights field pointing to light object\n  // add the extension\n  // @ts-ignore\n  if (gltfScenegraph.materials) {\n    for (const material of json.materials || []) {\n      // @ts-ignore\n      if (material.unlit) {\n        // @ts-ignore\n        delete material.unlit;\n        gltfScenegraph.addObjectExtension(material, KHR_MATERIALS_UNLIT, {});\n        gltfScenegraph.addExtension(KHR_MATERIALS_UNLIT);\n      }\n    }\n  }\n}\n","// GLTF EXTENSION: KHR_lights_punctual\n// https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual\n\nimport type {GLTF} from '../types/gltf-types';\n\nimport {assert} from '../utils/assert';\nimport GLTFScenegraph from '../api/gltf-scenegraph';\nimport {KHR_LIGHTS_PUNCTUAL} from '../gltf-utils/gltf-constants';\n\nexport async function decode(gltfData: {json: GLTF}): Promise<void> {\n  const gltfScenegraph = new GLTFScenegraph(gltfData);\n  const {json} = gltfScenegraph;\n\n  // Move the light array out of the extension and remove the extension\n  const extension = gltfScenegraph.getExtension(KHR_LIGHTS_PUNCTUAL);\n  if (extension) {\n    // @ts-ignore\n    gltfScenegraph.json.lights = extension.lights;\n    gltfScenegraph.removeExtension(KHR_LIGHTS_PUNCTUAL);\n  }\n\n  // Any nodes that have the extension, add lights field pointing to light object\n  // and remove the extension\n  for (const node of json.nodes || []) {\n    const nodeExtension = gltfScenegraph.getObjectExtension(node, KHR_LIGHTS_PUNCTUAL);\n    if (nodeExtension) {\n      // @ts-ignore\n      node.light = nodeExtension.light;\n    }\n    gltfScenegraph.removeObjectExtension(node, KHR_LIGHTS_PUNCTUAL);\n  }\n}\n\n// Move the light ar ray out of the extension and remove the extension\nexport async function encode(gltfData): Promise<void> {\n  const gltfScenegraph = new GLTFScenegraph(gltfData);\n  const {json} = gltfScenegraph;\n\n  // @ts-ignore\n  if (json.lights) {\n    const extension = gltfScenegraph.addExtension(KHR_LIGHTS_PUNCTUAL);\n    // @ts-ignore\n    assert(!extension.lights);\n    // @ts-ignore\n    extension.lights = json.lights;\n    // @ts-ignore\n    delete json.lights;\n  }\n\n  // Any nodes that have lights field pointing to light object\n  // add the extension\n  // @ts-ignore\n  if (gltfScenegraph.json.lights) {\n    // @ts-ignore\n    for (const light of gltfScenegraph.json.lights) {\n      const node = light.node;\n      gltfScenegraph.addObjectExtension(node, KHR_LIGHTS_PUNCTUAL, light);\n    }\n    // @ts-ignore\n    delete gltfScenegraph.json.lights;\n  }\n}\n","// GLTF EXTENSION: KHR_techniques_webgl\n// https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_techniques_webgl\n\nimport type {GLTF} from '../types/gltf-types';\n\nimport GLTFScenegraph from '../api/gltf-scenegraph';\nimport {KHR_TECHNIQUES_WEBGL} from '../gltf-utils/gltf-constants';\n\nexport async function decode(gltfData: {json: GLTF}): Promise<void> {\n  const gltfScenegraph = new GLTFScenegraph(gltfData);\n  const {json} = gltfScenegraph;\n\n  const extension = gltfScenegraph.getExtension(KHR_TECHNIQUES_WEBGL);\n  if (extension) {\n    const techniques = resolveTechniques(extension, gltfScenegraph);\n\n    for (const material of json.materials || []) {\n      const materialExtension = gltfScenegraph.getObjectExtension(material, KHR_TECHNIQUES_WEBGL);\n      if (materialExtension) {\n        // @ts-ignore TODO\n        material.technique = Object.assign(\n          {},\n          materialExtension,\n          // @ts-ignore\n          techniques[materialExtension.technique]\n        );\n        // @ts-ignore TODO\n        material.technique.values = resolveValues(material.technique, gltfScenegraph);\n      }\n      gltfScenegraph.removeObjectExtension(material, KHR_TECHNIQUES_WEBGL);\n    }\n\n    gltfScenegraph.removeExtension(KHR_TECHNIQUES_WEBGL);\n  }\n}\n// eslint-disable-next-line\nexport async function encode(gltfData, options): Promise<void> {\n  // TODO\n}\n\nfunction resolveTechniques(\n  techniquesExtension: {[key: string]: any},\n  // programs: {[key: string]: any}[],\n  // shaders: {[key: string]: any}[],\n  // techniques: {[key: string]: any}[]\n  gltfScenegraph\n) {\n  const {programs = [], shaders = [], techniques = []} = techniquesExtension;\n  const textDecoder = new TextDecoder();\n\n  shaders.forEach((shader) => {\n    if (Number.isFinite(shader.bufferView)) {\n      shader.code = textDecoder.decode(\n        gltfScenegraph.getTypedArrayForBufferView(shader.bufferView)\n      );\n    } else {\n      // TODO: handle URI shader\n      throw new Error('KHR_techniques_webgl: no shader code');\n    }\n  });\n\n  programs.forEach((program) => {\n    program.fragmentShader = shaders[program.fragmentShader];\n    program.vertexShader = shaders[program.vertexShader];\n  });\n\n  techniques.forEach((technique) => {\n    technique.program = programs[technique.program];\n  });\n\n  return techniques;\n}\n\nfunction resolveValues(technique, gltfScenegraph) {\n  const values = Object.assign({}, technique.values);\n\n  // merge values from uniforms\n  Object.keys(technique.uniforms || {}).forEach((uniform) => {\n    if (technique.uniforms[uniform].value && !(uniform in values)) {\n      values[uniform] = technique.uniforms[uniform].value;\n    }\n  });\n\n  // resolve textures\n  Object.keys(values).forEach((uniform) => {\n    if (typeof values[uniform] === 'object' && values[uniform].index !== undefined) {\n      // Assume this is a texture\n      // TODO: find if there are any other types that can be referenced\n      values[uniform].texture = gltfScenegraph.getTexture(values[uniform].index);\n    }\n  });\n\n  return values;\n}\n","/* eslint-disable camelcase */\nimport {GLTF} from '../types/gltf-types';\nimport type {GLTFLoaderOptions} from '../../gltf-loader';\n\n// GLTF 1.0 extensions (read only)\n// import * as KHR_binary_gltf from './KHR_draco_mesh_compression';\n\n// GLTF 2.0 extensions (read/write)\nimport * as KHR_draco_mesh_compression from './KHR_draco_mesh_compression';\nimport * as KHR_materials_unlit from './KHR_materials_unlit';\nimport * as KHR_lights_punctual from './KHR_lights_punctual';\nimport * as KHR_techniques_webgl from './KHR_techniques_webgl';\n\ntype GLTFExtensionPlugin = {\n  decode: (gltfData: {json: GLTF}, options: GLTFLoaderOptions, context) => Promise<void>;\n\n  encode: (gltfData: {json: GLTF}, options: GLTFLoaderOptions) => void;\n};\n\n/**\n * List of extensions processed by the GLTFLoader\n * Note that may extensions can only be handled on the rendering stage and are left out here\n * These are just extensions that can be handled fully or partially during loading.\n */\nexport const EXTENSIONS: {[extensionName: string]: GLTFExtensionPlugin} = {\n  // 1.0\n  // KHR_binary_gltf is handled separately - must be processed before other parsing starts\n  // KHR_binary_gltf,\n\n  // 2.0\n  KHR_draco_mesh_compression,\n  KHR_materials_unlit,\n  KHR_lights_punctual,\n  KHR_techniques_webgl\n};\n\nexport async function decodeExtensions(gltf, options: GLTFLoaderOptions = {}, context?) {\n  for (const extensionName in EXTENSIONS) {\n    const excludes = options?.gltf?.excludeExtensions || {};\n    const exclude = extensionName in excludes && !excludes[extensionName];\n    if (!exclude) {\n      const extension = EXTENSIONS[extensionName];\n      // Note: We decode async extensions sequentially, this might not be necessary\n      // Currently we only have Draco, but when we add Basis we may revisit\n      await extension.decode(gltf, options, context);\n    }\n  }\n}\n","/* eslint-disable camelcase */\nimport * as KHR_binary_glTF from '../extensions/KHR_binary_gltf';\n\n// Binary format changes (mainly implemented by GLBLoader)\n// https://github.com/KhronosGroup/glTF/tree/master/extensions/1.0/Khronos/KHR_binary_glTF\n\n// JSON format changes:\n// https://github.com/khronosgroup/gltf/issues/605\n\n// - [x] Top-level JSON objects are arrays now\n// - [ ] Removed indirection from animation: sampler now refers directly to accessors, #712\n// - [ ] material.parameter.value and technique.parameter.value must be an array, #690\n// - [ ] Node can have only one mesh #821\n// - [ ] Added reqs on JSON encoding\n// - [ ] Added reqs on binary data alignment #802 (comment)\n\n// Additions:\n// - [ ] Added accessor.normalized, #691, #706\n// - [ ] Added glExtensionsUsed property and 5125 (UNSIGNED_INT) accessor.componentType value, #619\n// - [ ] Added extensionsRequired property, #720, #721\n// - [ ] Added \"STEP\" as valid animation.sampler.interpolation value, #712\n\n// Removals:\n// - [x] Removed buffer.type, #786, #629\n// - [ ] Removed revision number from profile.version, #709\n// - [ ] Removed technique.functions.scissor and removed 3089 (SCISSOR_TEST) as a valid value for technique.states.enable, #681\n// - [ ] Techniques, programs, and shaders were moved out to KHR_technique_webgl extension.\n\n// Other edits:\n// - [x] asset is now required, #642\n// - [ ] buffer.byteLength and bufferView.byteLength are now required, #560.\n// - [ ] accessor.min and accessor.max are now required, #593, and clarified that the JSON value and binary data must be the same, #628.\n// - [ ] Clarified animation.sampler and animation.channel restrictions, #712\n// - [ ] skin.inverseBindMatrices is now optional, #461.\n// - [ ] Attribute parameters can't have a value defined in the technique or parameter, #563 (comment).\n// - [ ] Only TEXCOORD and COLOR attribute semantics can be written in the form [semantic]_[set_index], #563 (comment).\n// - [ ] TEXCOORD and COLOR attribute semantics must be written in the form [semantic]_[set_index], e.g., just TEXCOORD should be TEXCOORD_0, and just COLOR should be COLOR_0, #649\n// - [ ] camera.perspective.aspectRatio and camera.perspective.yfov must now be > 0, not >= 0, #563 (comment).\n// - [ ] Application-specific parameter semantics must start with an underscore, e.g., _TEMPERATURE and _SIMULATION_TIME, #563 (comment).\n// - [ ] Properties in technique.parameters must be defined in technique.uniforms or technique.attributes,\n\n// #563 (comment).\n// - [ ] technique.parameter.count can only be defined when the semantic is JOINTMATRIX or an application-specific semantic is used. It can never be defined for attribute parameters; only uniforms, d2f6945\n// - [ ] technique.parameter.semantic is required when the parameter is an attribute, 28e113d\n// - [ ] Mesh-only models are allowed, e.g., without materials, #642\n// - [ ] Skeleton hierarchies (nodes containing jointName) must be separated from non-skeleton hierarchies., #647\n// - [ ] technique.states.functions.blendColor and technique.states.functions.depthRange parameters now must match WebGL function min/max, #707\n\nconst GLTF_ARRAYS = {\n  accessors: 'accessor',\n  animations: 'animation',\n  buffers: 'buffer',\n  bufferViews: 'bufferView',\n  images: 'image',\n  materials: 'material',\n  meshes: 'mesh',\n  nodes: 'node',\n  samplers: 'sampler',\n  scenes: 'scene',\n  skins: 'skin',\n  textures: 'texture'\n};\n\nconst GLTF_KEYS = {\n  accessor: 'accessors',\n  animations: 'animation',\n  buffer: 'buffers',\n  bufferView: 'bufferViews',\n  image: 'images',\n  material: 'materials',\n  mesh: 'meshes',\n  node: 'nodes',\n  sampler: 'samplers',\n  scene: 'scenes',\n  skin: 'skins',\n  texture: 'textures'\n};\n\n/**\n * Converts (normalizes) glTF v1 to v2\n */\nclass GLTFV1Normalizer {\n  constructor(gltf) {\n    this.idToIndexMap = {\n      animations: {},\n      accessors: {},\n      buffers: {},\n      bufferViews: {},\n      images: {},\n      materials: {},\n      meshes: {},\n      nodes: {},\n      samplers: {},\n      scenes: {},\n      skins: {},\n      textures: {}\n    };\n  }\n\n  /**\n   * Convert (normalize) glTF < 2.0 to glTF 2.0\n   * @param gltf - object with json and binChunks\n   * @param options\n   * @param options normalize Whether to actually normalize\n   */\n  normalize(gltf, options) {\n    this.json = gltf.json;\n    const json = gltf.json;\n\n    // Check version\n    switch (json.asset && json.asset.version) {\n      // We are converting to v2 format. Return if there is nothing to do\n      case '2.0':\n        return;\n\n      // This class is written to convert 1.0\n      case undefined:\n      case '1.0':\n        break;\n\n      default:\n        // eslint-disable-next-line no-undef, no-console\n        console.warn(`glTF: Unknown version ${json.asset.version}`);\n        return;\n    }\n\n    if (!options.normalize) {\n      // We are still missing a few conversion tricks, remove once addressed\n      throw new Error('glTF v1 is not supported.');\n    }\n\n    // eslint-disable-next-line no-undef, no-console\n    console.warn('Converting glTF v1 to glTF v2 format. This is experimental and may fail.');\n\n    this._addAsset(json);\n\n    // In glTF2 top-level fields are Arrays not Object maps\n    this._convertTopLevelObjectsToArrays(json);\n\n    // Extract bufferView indices for images\n    // (this extension needs to be invoked early in the normalization process)\n    KHR_binary_glTF.decode(gltf);\n\n    // Convert object references from ids to indices\n    this._convertObjectIdsToArrayIndices(json);\n\n    this._updateObjects(json);\n\n    this._updateMaterial(json);\n  }\n\n  // asset is now required, #642 https://github.com/KhronosGroup/glTF/issues/639\n  _addAsset(json) {\n    json.asset = json.asset || {};\n    // We are normalizing to glTF v2, so change version to \"2.0\"\n    json.asset.version = '2.0';\n    json.asset.generator = json.asset.generator || 'Normalized to glTF 2.0 by loaders.gl';\n  }\n\n  _convertTopLevelObjectsToArrays(json) {\n    // TODO check that all arrays are covered\n    for (const arrayName in GLTF_ARRAYS) {\n      this._convertTopLevelObjectToArray(json, arrayName);\n    }\n  }\n\n  /** Convert one top level object to array */\n  _convertTopLevelObjectToArray(json, mapName) {\n    const objectMap = json[mapName];\n    if (!objectMap || Array.isArray(objectMap)) {\n      return;\n    }\n\n    // Rewrite the top-level field as an array\n    json[mapName] = [];\n    // Copy the map key into object.id\n    for (const id in objectMap) {\n      const object = objectMap[id];\n      object.id = object.id || id; // Mutates the loaded object\n      const index = json[mapName].length;\n      json[mapName].push(object);\n      this.idToIndexMap[mapName][id] = index;\n    }\n  }\n\n  /** Go through all objects in all top-level arrays and replace ids with indices */\n  _convertObjectIdsToArrayIndices(json) {\n    for (const arrayName in GLTF_ARRAYS) {\n      this._convertIdsToIndices(json, arrayName);\n    }\n    if ('scene' in json) {\n      json.scene = this._convertIdToIndex(json.scene, 'scene');\n    }\n\n    // Convert any index references that are not using array names\n\n    // texture.source (image)\n    for (const texture of json.textures) {\n      this._convertTextureIds(texture);\n    }\n    for (const mesh of json.meshes) {\n      this._convertMeshIds(mesh);\n    }\n    for (const node of json.nodes) {\n      this._convertNodeIds(node);\n    }\n    for (const node of json.scenes) {\n      this._convertSceneIds(node);\n    }\n  }\n\n  _convertTextureIds(texture) {\n    if (texture.source) {\n      texture.source = this._convertIdToIndex(texture.source, 'image');\n    }\n  }\n\n  _convertMeshIds(mesh) {\n    for (const primitive of mesh.primitives) {\n      const {attributes, indices, material} = primitive;\n      for (const attributeName in attributes) {\n        attributes[attributeName] = this._convertIdToIndex(attributes[attributeName], 'accessor');\n      }\n      if (indices) {\n        primitive.indices = this._convertIdToIndex(indices, 'accessor');\n      }\n      if (material) {\n        primitive.material = this._convertIdToIndex(material, 'material');\n      }\n    }\n  }\n\n  _convertNodeIds(node) {\n    if (node.children) {\n      node.children = node.children.map((child) => this._convertIdToIndex(child, 'node'));\n    }\n    if (node.meshes) {\n      node.meshes = node.meshes.map((mesh) => this._convertIdToIndex(mesh, 'mesh'));\n    }\n  }\n\n  _convertSceneIds(scene) {\n    if (scene.nodes) {\n      scene.nodes = scene.nodes.map((node) => this._convertIdToIndex(node, 'node'));\n    }\n  }\n\n  /** Go through all objects in a top-level array and replace ids with indices */\n  _convertIdsToIndices(json, topLevelArrayName) {\n    if (!json[topLevelArrayName]) {\n      console.warn(`gltf v1: json doesn't contain attribute ${topLevelArrayName}`); // eslint-disable-line no-console, no-undef\n      json[topLevelArrayName] = [];\n    }\n    for (const object of json[topLevelArrayName]) {\n      for (const key in object) {\n        const id = object[key];\n        const index = this._convertIdToIndex(id, key);\n        object[key] = index;\n      }\n    }\n  }\n\n  _convertIdToIndex(id, key) {\n    const arrayName = GLTF_KEYS[key];\n    if (arrayName in this.idToIndexMap) {\n      const index = this.idToIndexMap[arrayName][id];\n      if (!Number.isFinite(index)) {\n        throw new Error(`gltf v1: failed to resolve ${key} with id ${id}`);\n      }\n      return index;\n    }\n    return id;\n  }\n\n  /**\n   *\n   * @param {*} json\n   */\n  _updateObjects(json) {\n    for (const buffer of this.json.buffers) {\n      // - [x] Removed buffer.type, #786, #629\n      delete buffer.type;\n    }\n  }\n\n  /**\n   * Update material (set pbrMetallicRoughness)\n   * @param {*} json\n   */\n  _updateMaterial(json) {\n    for (const material of json.materials) {\n      material.pbrMetallicRoughness = {\n        baseColorFactor: [1, 1, 1, 1],\n        metallicFactor: 1,\n        roughnessFactor: 1\n      };\n\n      const textureId = material.values && material.values.tex;\n      const textureIndex = json.textures.findIndex((texture) => texture.id === textureId);\n      if (textureIndex !== -1) {\n        material.pbrMetallicRoughness.baseColorTexture = {index: textureIndex};\n      }\n    }\n  }\n}\n\nexport function normalizeGLTFV1(gltf, options = {}) {\n  return new GLTFV1Normalizer().normalize(gltf, options);\n}\n","// GLTF 1.0 EXTENSION: KHR_binary_glTF\n// https://github.com/KhronosGroup/glTF/tree/master/extensions/1.0/Khronos/KHR_binary_glTF\n\nimport type {GLTF} from '../types/gltf-types';\n\nimport GLTFScenegraph from '../api/gltf-scenegraph';\nimport {KHR_BINARY_GLTF} from '../gltf-utils/gltf-constants';\n\nexport function decode(gltfData: {json: GLTF}): void {\n  const gltfScenegraph = new GLTFScenegraph(gltfData);\n  const {json} = gltfScenegraph;\n\n  // Note: json.buffers.binary_glTF also needs to be replaced\n  // This is currently done during gltf normalization\n\n  // Image and shader nodes can have the extension\n  // https://github.com/KhronosGroup/glTF/blob/master/extensions/1.0/Khronos/KHR_binary_glTF/schema/image.KHR_binary_glTF.schema.json\n  for (const node of json.images || []) {\n    const extension = gltfScenegraph.removeObjectExtension(node, KHR_BINARY_GLTF);\n    // The data in the extension is valid as glTF 2.0 data inside the object, so just copy it in\n    if (extension) {\n      Object.assign(node, extension);\n    }\n  }\n\n  // TODO shaders\n  // https://github.com/KhronosGroup/glTF/blob/master/extensions/1.0/Khronos/KHR_binary_glTF/schema/shader.KHR_binary_glTF.schema.json\n\n  // glTF v1 one files have a partially formed URI field that is not expected in (and causes problems in) 2.0\n  if (json.buffers && json.buffers[0]) {\n    delete json.buffers[0].uri;\n  }\n\n  // Remove the top-level extension as it has now been removed from all nodes\n  gltfScenegraph.removeExtension(KHR_BINARY_GLTF);\n}\n\n// KHR_binary_gltf is a 1.0 extension that is supported natively by 2.0\nexport function encode() {\n  throw new Error(KHR_BINARY_GLTF);\n}\n","import {assert} from '../utils/assert';\nimport {getAccessorArrayTypeAndLength} from '../gltf-utils/gltf-utils';\n\n// This is a post processor for loaded glTF files\n// The goal is to make the loaded data easier to use in WebGL applications\n//\n// Functions:\n// * Resolve indexed arrays structure of glTF into a linked tree.\n// * Translate stringified enum keys and values into WebGL constants.\n// * Load images (optional)\n\n// ENUM LOOKUP\n\nconst COMPONENTS = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n};\n\nconst BYTES = {\n  5120: 1, // BYTE\n  5121: 1, // UNSIGNED_BYTE\n  5122: 2, // SHORT\n  5123: 2, // UNSIGNED_SHORT\n  5125: 4, // UNSIGNED_INT\n  5126: 4 // FLOAT\n};\n\nconst GL_SAMPLER = {\n  // Sampler parameters\n  TEXTURE_MAG_FILTER: 0x2800,\n  TEXTURE_MIN_FILTER: 0x2801,\n  TEXTURE_WRAP_S: 0x2802,\n  TEXTURE_WRAP_T: 0x2803,\n\n  // Sampler default values\n  REPEAT: 0x2901,\n  LINEAR: 0x2601,\n  NEAREST_MIPMAP_LINEAR: 0x2702\n};\n\nconst SAMPLER_PARAMETER_GLTF_TO_GL = {\n  magFilter: GL_SAMPLER.TEXTURE_MAG_FILTER,\n  minFilter: GL_SAMPLER.TEXTURE_MIN_FILTER,\n  wrapS: GL_SAMPLER.TEXTURE_WRAP_S,\n  wrapT: GL_SAMPLER.TEXTURE_WRAP_T\n};\n\n// When undefined, a sampler with repeat wrapping and auto filtering should be used.\n// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#texture\nconst DEFAULT_SAMPLER = {\n  [GL_SAMPLER.TEXTURE_MAG_FILTER]: GL_SAMPLER.LINEAR,\n  [GL_SAMPLER.TEXTURE_MIN_FILTER]: GL_SAMPLER.NEAREST_MIPMAP_LINEAR,\n  [GL_SAMPLER.TEXTURE_WRAP_S]: GL_SAMPLER.REPEAT,\n  [GL_SAMPLER.TEXTURE_WRAP_]: GL_SAMPLER.REPEAT\n};\n\nfunction getBytesFromComponentType(componentType) {\n  return BYTES[componentType];\n}\n\nfunction getSizeFromAccessorType(type) {\n  return COMPONENTS[type];\n}\n\nclass GLTFPostProcessor {\n  postProcess(gltf, options = {}) {\n    const {json, buffers = [], images = [], baseUri = ''} = gltf;\n    assert(json);\n\n    this.baseUri = baseUri;\n    this.json = json;\n    this.buffers = buffers;\n    this.images = images;\n\n    this._resolveTree(this.json, options);\n\n    return this.json;\n  }\n\n  // Convert indexed glTF structure into tree structure\n  // cross-link index resolution, enum lookup, convenience calculations\n  // eslint-disable-next-line complexity\n  _resolveTree(json, options = {}) {\n    if (json.bufferViews) {\n      json.bufferViews = json.bufferViews.map((bufView, i) => this._resolveBufferView(bufView, i));\n    }\n    if (json.images) {\n      json.images = json.images.map((image, i) => this._resolveImage(image, i));\n    }\n    if (json.samplers) {\n      json.samplers = json.samplers.map((sampler, i) => this._resolveSampler(sampler, i));\n    }\n    if (json.textures) {\n      json.textures = json.textures.map((texture, i) => this._resolveTexture(texture, i));\n    }\n    if (json.accessors) {\n      json.accessors = json.accessors.map((accessor, i) => this._resolveAccessor(accessor, i));\n    }\n    if (json.materials) {\n      json.materials = json.materials.map((material, i) => this._resolveMaterial(material, i));\n    }\n    if (json.meshes) {\n      json.meshes = json.meshes.map((mesh, i) => this._resolveMesh(mesh, i));\n    }\n    if (json.nodes) {\n      json.nodes = json.nodes.map((node, i) => this._resolveNode(node, i));\n    }\n    if (json.skins) {\n      json.skins = json.skins.map((skin, i) => this._resolveSkin(skin, i));\n    }\n    if (json.scenes) {\n      json.scenes = json.scenes.map((scene, i) => this._resolveScene(scene, i));\n    }\n    if (json.scene !== undefined) {\n      json.scene = json.scenes[this.json.scene];\n    }\n  }\n\n  getScene(index) {\n    return this._get('scenes', index);\n  }\n\n  getNode(index) {\n    return this._get('nodes', index);\n  }\n\n  getSkin(index) {\n    return this._get('skins', index);\n  }\n\n  getMesh(index) {\n    return this._get('meshes', index);\n  }\n\n  getMaterial(index) {\n    return this._get('materials', index);\n  }\n\n  getAccessor(index) {\n    return this._get('accessors', index);\n  }\n\n  getCamera(index) {\n    return null; // TODO: fix this\n  }\n\n  getTexture(index) {\n    return this._get('textures', index);\n  }\n\n  getSampler(index) {\n    return this._get('samplers', index);\n  }\n\n  getImage(index) {\n    return this._get('images', index);\n  }\n\n  getBufferView(index) {\n    return this._get('bufferViews', index);\n  }\n\n  getBuffer(index) {\n    return this._get('buffers', index);\n  }\n\n  _get(array, index) {\n    // check if already resolved\n    if (typeof index === 'object') {\n      return index;\n    }\n    const object = this.json[array] && this.json[array][index];\n    if (!object) {\n      console.warn(`glTF file error: Could not find ${array}[${index}]`); // eslint-disable-line\n    }\n    return object;\n  }\n\n  // PARSING HELPERS\n\n  _resolveScene(scene, index) {\n    // scene = {...scene};\n    scene.id = scene.id || `scene-${index}`;\n    scene.nodes = (scene.nodes || []).map((node) => this.getNode(node));\n    return scene;\n  }\n\n  _resolveNode(node, index) {\n    // node = {...node};\n    node.id = node.id || `node-${index}`;\n    if (node.children) {\n      node.children = node.children.map((child) => this.getNode(child));\n    }\n    if (node.mesh !== undefined) {\n      node.mesh = this.getMesh(node.mesh);\n    } else if (node.meshes !== undefined && node.meshes.length) {\n      node.mesh = node.meshes.reduce(\n        (accum, meshIndex) => {\n          const mesh = this.getMesh(meshIndex);\n          accum.id = mesh.id;\n          accum.primitives = accum.primitives.concat(mesh.primitives);\n          return accum;\n        },\n        {primitives: []}\n      );\n    }\n    if (node.camera !== undefined) {\n      node.camera = this.getCamera(node.camera);\n    }\n    if (node.skin !== undefined) {\n      node.skin = this.getSkin(node.skin);\n    }\n    return node;\n  }\n\n  _resolveSkin(skin, index) {\n    // skin = {...skin};\n    skin.id = skin.id || `skin-${index}`;\n    skin.inverseBindMatrices = this.getAccessor(skin.inverseBindMatrices);\n    return skin;\n  }\n\n  _resolveMesh(mesh, index) {\n    // mesh = {...mesh};\n    mesh.id = mesh.id || `mesh-${index}`;\n    if (mesh.primitives) {\n      mesh.primitives = mesh.primitives.map((primitive) => {\n        primitive = {...primitive};\n        const attributes = primitive.attributes;\n        primitive.attributes = {};\n        for (const attribute in attributes) {\n          primitive.attributes[attribute] = this.getAccessor(attributes[attribute]);\n        }\n        if (primitive.indices !== undefined) {\n          primitive.indices = this.getAccessor(primitive.indices);\n        }\n        if (primitive.material !== undefined) {\n          primitive.material = this.getMaterial(primitive.material);\n        }\n        return primitive;\n      });\n    }\n    return mesh;\n  }\n\n  _resolveMaterial(material, index) {\n    // material = {...material};\n    material.id = material.id || `material-${index}`;\n    if (material.normalTexture) {\n      material.normalTexture = {...material.normalTexture};\n      material.normalTexture.texture = this.getTexture(material.normalTexture.index);\n    }\n    if (material.occlusionTexture) {\n      material.occlustionTexture = {...material.occlustionTexture};\n      material.occlusionTexture.texture = this.getTexture(material.occlusionTexture.index);\n    }\n    if (material.emissiveTexture) {\n      material.emmisiveTexture = {...material.emmisiveTexture};\n      material.emissiveTexture.texture = this.getTexture(material.emissiveTexture.index);\n    }\n    if (!material.emissiveFactor) {\n      material.emissiveFactor = material.emmisiveTexture ? [1, 1, 1] : [0, 0, 0];\n    }\n\n    if (material.pbrMetallicRoughness) {\n      material.pbrMetallicRoughness = {...material.pbrMetallicRoughness};\n      const mr = material.pbrMetallicRoughness;\n      if (mr.baseColorTexture) {\n        mr.baseColorTexture = {...mr.baseColorTexture};\n        mr.baseColorTexture.texture = this.getTexture(mr.baseColorTexture.index);\n      }\n      if (mr.metallicRoughnessTexture) {\n        mr.metallicRoughnessTexture = {...mr.metallicRoughnessTexture};\n        mr.metallicRoughnessTexture.texture = this.getTexture(mr.metallicRoughnessTexture.index);\n      }\n    }\n    return material;\n  }\n\n  _resolveAccessor(accessor, index) {\n    // accessor = {...accessor};\n    accessor.id = accessor.id || `accessor-${index}`;\n    if (accessor.bufferView !== undefined) {\n      // Draco encoded meshes don't have bufferView\n      accessor.bufferView = this.getBufferView(accessor.bufferView);\n    }\n\n    // Look up enums\n    accessor.bytesPerComponent = getBytesFromComponentType(accessor.componentType);\n    accessor.components = getSizeFromAccessorType(accessor.type);\n    accessor.bytesPerElement = accessor.bytesPerComponent * accessor.components;\n\n    // Create TypedArray for the accessor\n    // Note: The canonical way to instantiate is to ignore this array and create\n    // WebGLBuffer's using the bufferViews.\n    if (accessor.bufferView) {\n      const buffer = accessor.bufferView.buffer;\n      const {ArrayType, byteLength} = getAccessorArrayTypeAndLength(accessor, accessor.bufferView);\n      const byteOffset =\n        (accessor.bufferView.byteOffset || 0) + (accessor.byteOffset || 0) + buffer.byteOffset;\n      const cutBufffer = buffer.arrayBuffer.slice(byteOffset, byteOffset + byteLength);\n      accessor.value = new ArrayType(cutBufffer);\n    }\n\n    return accessor;\n  }\n\n  _resolveTexture(texture, index) {\n    // texture = {...texture};\n    texture.id = texture.id || `texture-${index}`;\n    texture.sampler = 'sampler' in texture ? this.getSampler(texture.sampler) : DEFAULT_SAMPLER;\n    texture.source = this.getImage(texture.source);\n    return texture;\n  }\n\n  _resolveSampler(sampler, index) {\n    // sampler = {...sampler};\n    sampler.id = sampler.id || `sampler-${index}`;\n    // Map textual parameters to GL parameter values\n    sampler.parameters = {};\n    for (const key in sampler) {\n      const glEnum = this._enumSamplerParameter(key);\n      if (glEnum !== undefined) {\n        sampler.parameters[glEnum] = sampler[key];\n      }\n    }\n    return sampler;\n  }\n\n  _enumSamplerParameter(key) {\n    return SAMPLER_PARAMETER_GLTF_TO_GL[key];\n  }\n\n  _resolveImage(image, index) {\n    // image = {...image};\n    image.id = image.id || `image-${index}`;\n    if (image.bufferView !== undefined) {\n      image.bufferView = this.getBufferView(image.bufferView);\n    }\n\n    // Check if image has been preloaded by the GLTFLoader\n    // If so, link it into the JSON and drop the URI\n    const preloadedImage = this.images[index];\n    if (preloadedImage) {\n      image.image = preloadedImage;\n    }\n\n    return image;\n  }\n\n  _resolveBufferView(bufferView, index) {\n    // bufferView = {...bufferView};\n    bufferView.id = bufferView.id || `bufferView-${index}`;\n    const bufferIndex = bufferView.buffer;\n    bufferView.buffer = this.buffers[bufferIndex];\n\n    const arrayBuffer = this.buffers[bufferIndex].arrayBuffer;\n    let byteOffset = this.buffers[bufferIndex].byteOffset || 0;\n\n    if ('byteOffset' in bufferView) {\n      byteOffset += bufferView.byteOffset;\n    }\n\n    bufferView.data = new Uint8Array(arrayBuffer, byteOffset, bufferView.byteLength);\n    return bufferView;\n  }\n\n  _resolveCamera(camera, index) {\n    camera.id = camera.id || `camera-${index}`;\n    // TODO - create 4x4 matrices\n    if (camera.perspective) {\n      // camera.matrix = createPerspectiveMatrix(camera.perspective);\n    }\n    if (camera.orthographic) {\n      // camera.matrix = createOrthographicMatrix(camera.orthographic);\n    }\n    return camera;\n  }\n}\n\nexport function postProcessGLTF(gltf, options) {\n  return new GLTFPostProcessor().postProcess(gltf, options);\n}\n","/* eslint-disable camelcase, max-statements */\n// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#glb-file-format-specification\n// https://github.com/KhronosGroup/glTF/tree/master/extensions/1.0/Khronos/KHR_binary_glTF\nimport type {GLB} from '../types/glb-types';\nimport {padToNBytes, assert} from '@loaders.gl/loader-utils';\n\nexport type GLBParseOptions = {\n  magic?: number;\n  strict?: boolean;\n};\n\nconst MAGIC_glTF = 0x676c5446; // glTF in Big-Endian ASCII\n\nconst GLB_FILE_HEADER_SIZE = 12;\nconst GLB_CHUNK_HEADER_SIZE = 8;\n\nconst GLB_CHUNK_TYPE_JSON = 0x4e4f534a;\nconst GLB_CHUNK_TYPE_BIN = 0x004e4942;\nconst GLB_CHUNK_TYPE_JSON_XVIZ_DEPRECATED = 0; // DEPRECATED - Backward compatibility for old xviz files\nconst GLB_CHUNK_TYPE_BIX_XVIZ_DEPRECATED = 1; // DEPRECATED - Backward compatibility for old xviz files\n\nconst GLB_V1_CONTENT_FORMAT_JSON = 0x0;\n\nconst LE = true; // Binary GLTF is little endian.\n\nfunction getMagicString(dataView, byteOffset = 0) {\n  return `\\\n${String.fromCharCode(dataView.getUint8(byteOffset + 0))}\\\n${String.fromCharCode(dataView.getUint8(byteOffset + 1))}\\\n${String.fromCharCode(dataView.getUint8(byteOffset + 2))}\\\n${String.fromCharCode(dataView.getUint8(byteOffset + 3))}`;\n}\n\n// Check if a data view is a GLB\nexport function isGLB(\n  arrayBuffer: ArrayBuffer,\n  byteOffset: number = 0,\n  options: GLBParseOptions = {}\n): boolean {\n  const dataView = new DataView(arrayBuffer);\n  // Check that GLB Header starts with the magic number\n  const {magic = MAGIC_glTF} = options;\n  const magic1 = dataView.getUint32(byteOffset, false);\n  return magic1 === magic || magic1 === MAGIC_glTF;\n}\n\nexport default function parseGLBSync(\n  glb: GLB,\n  arrayBuffer: ArrayBuffer,\n  byteOffset: number = 0,\n  options: GLBParseOptions = {}\n) {\n  // Check that GLB Header starts with the magic number\n  const dataView = new DataView(arrayBuffer);\n\n  // Compare format with GLBLoader documentation\n  const type = getMagicString(dataView, byteOffset + 0);\n  const version = dataView.getUint32(byteOffset + 4, LE); // Version 2 of binary glTF container format\n  const byteLength = dataView.getUint32(byteOffset + 8, LE); // Total byte length of binary file\n\n  Object.assign(glb, {\n    // Put less important stuff in a header, to avoid clutter\n    header: {\n      byteOffset, // Byte offset into the initial arrayBuffer\n      byteLength,\n      hasBinChunk: false\n    },\n\n    type,\n    version,\n\n    json: {},\n    binChunks: []\n  } as GLB);\n\n  byteOffset += GLB_FILE_HEADER_SIZE;\n\n  switch (glb.version) {\n    case 1:\n      // eslint-disable-next-line\n      return parseGLBV1(glb, dataView, byteOffset);\n    case 2:\n      // eslint-disable-next-line\n      return parseGLBV2(glb, dataView, byteOffset, (options = {}));\n    default:\n      throw new Error(`Invalid GLB version ${glb.version}. Only supports v1 and v2.`);\n  }\n}\n\nfunction parseGLBV1(glb: GLB, dataView: DataView, byteOffset: number): number {\n  // Sanity: ensure file is big enough to hold at least the headers\n  assert(glb.header.byteLength > GLB_FILE_HEADER_SIZE + GLB_CHUNK_HEADER_SIZE);\n\n  // Explanation of GLB structure:\n  // https://cloud.githubusercontent.com/assets/3479527/22600725/36b87122-ea55-11e6-9d40-6fd42819fcab.png\n  const contentLength = dataView.getUint32(byteOffset + 0, LE); // Byte length of chunk\n  const contentFormat = dataView.getUint32(byteOffset + 4, LE); // Chunk format as uint32\n  byteOffset += GLB_CHUNK_HEADER_SIZE;\n\n  // GLB v1 only supports a single chunk type\n  assert(contentFormat === GLB_V1_CONTENT_FORMAT_JSON);\n\n  parseJSONChunk(glb, dataView, byteOffset, contentLength);\n  // No need to call the function padToBytes() from parseJSONChunk()\n  byteOffset += contentLength;\n  byteOffset += parseBINChunk(glb, dataView, byteOffset, glb.header.byteLength);\n\n  return byteOffset;\n}\n\nfunction parseGLBV2(\n  glb: GLB,\n  dataView: DataView,\n  byteOffset: number,\n  options: GLBParseOptions\n): number {\n  // Sanity: ensure file is big enough to hold at least the first chunk header\n  assert(glb.header.byteLength > GLB_FILE_HEADER_SIZE + GLB_CHUNK_HEADER_SIZE);\n\n  parseGLBChunksSync(glb, dataView, byteOffset, options);\n\n  return byteOffset + glb.header.byteLength;\n}\n\nfunction parseGLBChunksSync(\n  glb: GLB,\n  dataView: DataView,\n  byteOffset: number,\n  options: GLBParseOptions\n) {\n  // Per spec we must iterate over chunks, ignoring all except JSON and BIN\n  // Iterate as long as there is space left for another chunk header\n  while (byteOffset + 8 <= glb.header.byteLength) {\n    const chunkLength = dataView.getUint32(byteOffset + 0, LE); // Byte length of chunk\n    const chunkFormat = dataView.getUint32(byteOffset + 4, LE); // Chunk format as uint32\n    byteOffset += GLB_CHUNK_HEADER_SIZE;\n\n    // Per spec we must iterate over chunks, ignoring all except JSON and BIN\n    switch (chunkFormat) {\n      case GLB_CHUNK_TYPE_JSON:\n        parseJSONChunk(glb, dataView, byteOffset, chunkLength);\n        break;\n      case GLB_CHUNK_TYPE_BIN:\n        parseBINChunk(glb, dataView, byteOffset, chunkLength);\n        break;\n\n      // Backward compatibility for very old xviz files\n      case GLB_CHUNK_TYPE_JSON_XVIZ_DEPRECATED:\n        if (!options.strict) {\n          parseJSONChunk(glb, dataView, byteOffset, chunkLength);\n        }\n        break;\n      case GLB_CHUNK_TYPE_BIX_XVIZ_DEPRECATED:\n        if (!options.strict) {\n          parseBINChunk(glb, dataView, byteOffset, chunkLength);\n        }\n        break;\n\n      default:\n        // Ignore, per spec\n        // console.warn(`Unknown GLB chunk type`); // eslint-disable-line\n        break;\n    }\n\n    byteOffset += padToNBytes(chunkLength, 4);\n  }\n\n  return byteOffset;\n}\n\n// Parse a GLB JSON chunk\nfunction parseJSONChunk(glb: GLB, dataView: DataView, byteOffset: number, chunkLength: number) {\n  // 1. Create a \"view\" of the binary encoded JSON data inside the GLB\n  const jsonChunk = new Uint8Array(dataView.buffer, byteOffset, chunkLength);\n\n  // 2. Decode the JSON binary array into clear text\n  const textDecoder = new TextDecoder('utf8');\n  const jsonText = textDecoder.decode(jsonChunk);\n\n  // 3. Parse the JSON text into a JavaScript data structure\n  glb.json = JSON.parse(jsonText);\n\n  return padToNBytes(chunkLength, 4);\n}\n\n// Parse a GLB BIN chunk\nfunction parseBINChunk(glb: GLB, dataView, byteOffset, chunkLength) {\n  // Note: BIN chunk can be optional\n  glb.header.hasBinChunk = true;\n  glb.binChunks.push({\n    byteOffset,\n    byteLength: chunkLength,\n    arrayBuffer: dataView.buffer\n    // TODO - copy, or create typed array view?\n  });\n\n  return padToNBytes(chunkLength, 4);\n}\n","/* eslint-disable camelcase, max-statements, no-restricted-globals */\nimport type {LoaderContext} from '@loaders.gl/loader-utils';\nimport type {GLB} from '../types/glb-types';\nimport type {GLBParseOptions} from './parse-glb';\n\nimport {ImageLoader} from '@loaders.gl/images';\nimport {parseJSON, sliceArrayBuffer} from '@loaders.gl/loader-utils';\nimport {assert} from '../utils/assert';\nimport {resolveUrl} from '../gltf-utils/resolve-url';\nimport {getTypedArrayForBufferView} from '../gltf-utils/get-typed-array';\nimport {decodeExtensions} from '../extensions/gltf-extensions';\nimport {normalizeGLTFV1} from '../api/normalize-gltf-v1';\nimport {postProcessGLTF} from '../api/post-process-gltf';\nimport parseGLBSync, {isGLB} from './parse-glb';\n\nexport type GLTFParseOptions = {\n  excludeExtensions?: string[];\n  decompressMeshes?: boolean;\n  normalize?: boolean;\n  loadBuffers?: boolean;\n  loadImages?: boolean;\n  postProcess?: boolean;\n};\n\n// export type GLTFOptions = {\n//   gltf?: GLTFParseOptions;\n// };\n\nexport function isGLTF(arrayBuffer, options?): boolean {\n  const byteOffset = 0;\n  return isGLB(arrayBuffer, byteOffset, options);\n}\n\nexport async function parseGLTF(\n  gltf,\n  arrayBufferOrString,\n  byteOffset = 0,\n  options: {\n    gltf?: GLTFParseOptions;\n    glb?: GLBParseOptions;\n  },\n  context: LoaderContext\n) {\n  parseGLTFContainerSync(gltf, arrayBufferOrString, byteOffset, options);\n\n  normalizeGLTFV1(gltf, {normalize: options?.gltf?.normalize});\n\n  const promises: Promise<any>[] = [];\n\n  // Load linked buffers asynchronously and decodes base64 buffers in parallel\n  if (options?.gltf?.loadBuffers && gltf.json.buffers) {\n    await loadBuffers(gltf, options, context);\n  }\n\n  if (options?.gltf?.loadImages) {\n    const promise = loadImages(gltf, options, context);\n    promises.push(promise);\n  }\n\n  const promise = decodeExtensions(gltf, options, context);\n  promises.push(promise);\n\n  // Parallelize image loading and buffer loading/extension decoding\n  await Promise.all(promises);\n\n  // Post processing resolves indices to objects, buffers\n  return options?.gltf?.postProcess ? postProcessGLTF(gltf, options) : gltf;\n}\n\n// `data` - can be ArrayBuffer (GLB), ArrayBuffer (Binary JSON), String (JSON), or Object (parsed JSON)\nfunction parseGLTFContainerSync(gltf, data, byteOffset, options) {\n  // Initialize gltf container\n  if (options.uri) {\n    gltf.baseUri = options.uri;\n  }\n\n  // If data is binary and starting with magic bytes, assume binary JSON text, convert to string\n  if (data instanceof ArrayBuffer && !isGLB(data, byteOffset, options)) {\n    const textDecoder = new TextDecoder();\n    data = textDecoder.decode(data);\n  }\n\n  if (typeof data === 'string') {\n    // If string, try to parse as JSON\n    gltf.json = parseJSON(data);\n  } else if (data instanceof ArrayBuffer) {\n    // If still ArrayBuffer, parse as GLB container\n    const glb: GLB = {} as GLB;\n    byteOffset = parseGLBSync(glb, data, byteOffset, options.glb);\n\n    assert(glb.type === 'glTF', `Invalid GLB magic string ${glb.type}`);\n\n    gltf._glb = glb;\n    gltf.json = glb.json;\n  } else {\n    assert(false, 'GLTF: must be ArrayBuffer or string');\n  }\n\n  // Populate buffers\n  // Create an external buffers array to hold binary data\n  const buffers = gltf.json.buffers || [];\n  gltf.buffers = new Array(buffers.length).fill(null);\n\n  // Populates JSON and some bin chunk info\n  if (gltf._glb && gltf._glb.header.hasBinChunk) {\n    const {binChunks} = gltf._glb;\n    gltf.buffers[0] = {\n      arrayBuffer: binChunks[0].arrayBuffer,\n      byteOffset: binChunks[0].byteOffset,\n      byteLength: binChunks[0].byteLength\n    };\n\n    // TODO - this modifies JSON and is a post processing thing\n    // gltf.json.buffers[0].data = gltf.buffers[0].arrayBuffer;\n    // gltf.json.buffers[0].byteOffset = gltf.buffers[0].byteOffset;\n  }\n\n  // Populate images\n  const images = gltf.json.images || [];\n  gltf.images = new Array(images.length).fill({});\n}\n\n// Asynchronously fetch and parse buffers, store in buffers array outside of json\nasync function loadBuffers(gltf, options, context: LoaderContext) {\n  for (let i = 0; i < gltf.json.buffers.length; ++i) {\n    const buffer = gltf.json.buffers[i];\n    if (buffer.uri) {\n      const {fetch} = context;\n      assert(fetch);\n\n      const uri = resolveUrl(buffer.uri, options);\n      const response = await context?.fetch?.(uri);\n      const arrayBuffer = await response?.arrayBuffer?.();\n\n      gltf.buffers[i] = {\n        arrayBuffer,\n        byteOffset: 0,\n        byteLength: arrayBuffer.byteLength\n      };\n\n      delete buffer.uri;\n    }\n  }\n}\n\nasync function loadImages(gltf, options, context: LoaderContext) {\n  const images = gltf.json.images || [];\n\n  const promises: Promise<any>[] = [];\n  for (let i = 0; i < images.length; ++i) {\n    promises.push(loadImage(gltf, images[i], i, options, context));\n  }\n\n  return await Promise.all(promises);\n}\n\n// Asynchronously fetches and parses one image, store in images array outside of json\nasync function loadImage(gltf, image, index: number, options, context: LoaderContext) {\n  const {fetch, parse} = context;\n\n  let arrayBuffer;\n\n  if (image.uri) {\n    const uri = resolveUrl(image.uri, options);\n    const response = await fetch(uri);\n    arrayBuffer = await response.arrayBuffer();\n  }\n\n  if (Number.isFinite(image.bufferView)) {\n    const array = getTypedArrayForBufferView(gltf.json, gltf.buffers, image.bufferView);\n    arrayBuffer = sliceArrayBuffer(array.buffer, array.byteOffset, array.byteLength);\n  }\n\n  assert(arrayBuffer, 'glTF image has no data');\n\n  // Call `parse`\n  const parsedImage = await parse(arrayBuffer, ImageLoader, {}, context);\n  // TODO making sure ImageLoader is overridable by using array of loaders\n  // const parsedImage = await parse(arrayBuffer, [ImageLoader]);\n\n  gltf.images[index] = parsedImage;\n}\n","import type {LoaderWithParser, LoaderOptions} from '@loaders.gl/loader-utils';\nimport type {DracoLoaderOptions} from '@loaders.gl/draco';\n// import type {ImageLoaderOptions} from '@loaders.gl/images';\n// import type {TextureLoaderOptions} from '@loaders.gl/textures';\nimport type {GLTFParseOptions} from './lib/parsers/parse-gltf';\nimport {VERSION} from './lib/utils/version';\nimport {parseGLTF} from './lib/parsers/parse-gltf';\nimport {GLBLoaderOptions} from './glb-loader';\n\n/**\n * GLTF loader options\n */\nexport type GLTFLoaderOptions = LoaderOptions &\n  GLBLoaderOptions &\n  DracoLoaderOptions & {\n    gltf?: GLTFParseOptions;\n  };\n\n/**\n * GLTF loader\n */\nexport const GLTFLoader: LoaderWithParser = {\n  name: 'glTF',\n  id: 'gltf',\n  module: 'gltf',\n  version: VERSION,\n  extensions: ['gltf', 'glb'],\n  mimeTypes: ['model/gltf+json', 'model/gltf-binary'],\n\n  text: true,\n  binary: true,\n  tests: ['glTF'],\n  parse,\n\n  options: {\n    gltf: {\n      normalize: true, // Normalize glTF v1 to glTF v2 format (not yet stable)\n      loadBuffers: true, // Fetch any linked .BIN buffers, decode base64\n      loadImages: true, // Create image objects\n      decompressMeshes: true, // Decompress Draco encoded meshes\n      postProcess: true // Postprocess glTF and return json structure directly\n    },\n\n    // common?\n    log: console // eslint-disable-line\n  },\n  deprecatedOptions: {\n    fetchImages: 'gltf.loadImages',\n    createImages: 'gltf.loadImages',\n    decompress: 'gltf.decompressMeshes',\n    postProcess: 'gltf.postProcess',\n    gltf: {\n      decompress: 'gltf.decompressMeshes'\n    }\n  }\n};\n\nexport async function parse(arrayBuffer, options: GLTFLoaderOptions = {}, context) {\n  // Apps can call the parse method directly, we so apply default options here\n  options = {...GLTFLoader.options, ...options};\n  // @ts-ignore\n  options.gltf = {...GLTFLoader.options.gltf, ...options.gltf};\n\n  const {byteOffset = 0} = options;\n  const gltf = {};\n  return await parseGLTF(gltf, arrayBuffer, byteOffset, options, context);\n}\n","// Version constant cannot be imported, it needs to correspond to the build version of **this** module.\n// __VERSION__ is injected by babel-plugin-version-inline\n// @ts-ignore TS2304: Cannot find name '__VERSION__'.\nexport const VERSION = typeof __VERSION__ !== 'undefined' ? __VERSION__ : 'latest';\n","import {TypedArray} from '../../types';\nimport {padToNBytes} from './memory-copy-utils';\n\n/**\n * Copy sourceBuffer to dataView with some padding\n *\n * @param {DataView | null} dataView - destination data container. If null - only new offset is calculated\n * @param {number} byteOffset - destination byte offset to copy to\n * @param {Array | TypedArray} sourceBuffer - source data buffer\n * @param {number} padding - pad the resulting array to multiple of \"padding\" bytes. Additional bytes are filled with 0x20 (ASCII space)\n *\n * @return new byteOffset of resulting dataView\n */\nexport function copyPaddedArrayBufferToDataView(\n  dataView: DataView | null,\n  byteOffset: number,\n  sourceBuffer: TypedArray,\n  padding: number\n) {\n  const paddedLength = padToNBytes(sourceBuffer.byteLength, padding);\n  const padLength = paddedLength - sourceBuffer.byteLength;\n\n  if (dataView) {\n    // Copy array\n    const targetArray = new Uint8Array(\n      dataView.buffer,\n      dataView.byteOffset + byteOffset,\n      sourceBuffer.byteLength\n    );\n    const sourceArray = new Uint8Array(sourceBuffer);\n    targetArray.set(sourceArray);\n\n    // Add PADDING\n    for (let i = 0; i < padLength; ++i) {\n      // json chunk is padded with spaces (ASCII 0x20)\n      dataView.setUint8(byteOffset + sourceBuffer.byteLength + i, 0x20);\n    }\n  }\n  byteOffset += paddedLength;\n  return byteOffset;\n}\n\n/**\n * Copy string to dataView with some padding\n *\n * @param {DataView | null} dataView - destination data container. If null - only new offset is calculated\n * @param {number} byteOffset - destination byte offset to copy to\n * @param {string} string - source string\n * @param {number} padding - pad the resulting array to multiple of \"padding\" bytes. Additional bytes are filled with 0x20 (ASCII space)\n *\n * @return new byteOffset of resulting dataView\n */\nexport function copyPaddedStringToDataView(\n  dataView: DataView | null,\n  byteOffset: number,\n  string: string,\n  padding: number\n): number {\n  const textEncoder = new TextEncoder();\n  // PERFORMANCE IDEA: We encode twice, once to get size and once to store\n  // PERFORMANCE IDEA: Use TextEncoder.encodeInto() to avoid temporary copy\n  const stringBuffer = textEncoder.encode(string);\n\n  byteOffset = copyPaddedArrayBufferToDataView(dataView, byteOffset, stringBuffer, padding);\n\n  return byteOffset;\n}\n","/* eslint-disable camelcase, max-statements */\nimport {\n  copyPaddedStringToDataView,\n  copyPaddedArrayBufferToDataView\n} from '@loaders.gl/loader-utils';\n\nconst MAGIC_glTF = 0x46546c67; // glTF in ASCII\nconst MAGIC_JSON = 0x4e4f534a; // JSON in ASCII\nconst MAGIC_BIN = 0x004e4942; // BIN\\0 in ASCII\n\nconst LE = true; // Binary GLTF is little endian.\n\n// Encode the full GLB buffer with header etc\n// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#\n// glb-file-format-specification\nexport default function encodeGLBSync(glb, dataView, byteOffset = 0, options = {}) {\n  const {magic = MAGIC_glTF, version = 2, json = {}, binary} = glb;\n\n  const byteOffsetStart = byteOffset;\n\n  // Write GLB Header\n  if (dataView) {\n    dataView.setUint32(byteOffset + 0, magic, LE); // Magic number (the ASCII string 'glTF').\n    dataView.setUint32(byteOffset + 4, version, LE); // Version 2 of binary glTF container format uint32\n    dataView.setUint32(byteOffset + 8, 0, LE); // Total byte length of generated file (uint32), will be set last\n  }\n  const byteOffsetFileLength = byteOffset + 8;\n  byteOffset += 12; // GLB_FILE_HEADER_SIZE\n\n  // Write the JSON chunk header\n  const byteOffsetJsonHeader = byteOffset;\n  if (dataView) {\n    dataView.setUint32(byteOffset + 0, 0, LE); // Byte length of json chunk (will be written later)\n    dataView.setUint32(byteOffset + 4, MAGIC_JSON, LE); // Chunk type\n  }\n  byteOffset += 8; // GLB_CHUNK_HEADER_SIZE\n\n  // Write the JSON chunk\n  const jsonString = JSON.stringify(json);\n  byteOffset = copyPaddedStringToDataView(dataView, byteOffset, jsonString, 4);\n\n  // Now we know the JSON chunk length so we can write it.\n  if (dataView) {\n    const jsonByteLength = byteOffset - byteOffsetJsonHeader - 8; // GLB_CHUNK_HEADER_SIZE\n    dataView.setUint32(byteOffsetJsonHeader + 0, jsonByteLength, LE); // Byte length of json chunk (uint32)\n  }\n\n  // Write the BIN chunk if present. The BIN chunk is optional.\n  if (binary) {\n    const byteOffsetBinHeader = byteOffset;\n\n    // Write the BIN chunk header\n    if (dataView) {\n      dataView.setUint32(byteOffset + 0, 0, LE); // Byte length BIN (uint32)\n      dataView.setUint32(byteOffset + 4, MAGIC_BIN, LE); // Chunk type\n    }\n    byteOffset += 8; // GLB_CHUNK_HEADER_SIZE\n\n    byteOffset = copyPaddedArrayBufferToDataView(dataView, byteOffset, binary, 4);\n\n    // Now we know the BIN chunk length so we can write it.\n    if (dataView) {\n      const binByteLength = byteOffset - byteOffsetBinHeader - 8; // GLB_CHUNK_HEADER_SIZE\n      dataView.setUint32(byteOffsetBinHeader + 0, binByteLength, LE); // Byte length BIN (uint32)\n    }\n  }\n\n  // Now we know the glb file length so we can write it.\n  if (dataView) {\n    const fileByteLength = byteOffset - byteOffsetStart;\n    dataView.setUint32(byteOffsetFileLength, fileByteLength, LE); // Total byte length of generated file (uint32)\n  }\n\n  return byteOffset;\n}\n","import encodeGLBSync from './encode-glb';\n\n// Encode the full glTF file as a binary GLB file\n// Returns an ArrayBuffer that represents the complete GLB image that can be saved to file\n//\n// TODO - Does not support encoding to non-GLB versions of glTF format\n// - Encode as a textual JSON file with binary data in base64 data URLs.\n// - Encode as a JSON with all images (and buffers?) in separate binary files\n//\n// glb-file-format-specification\n// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#\n\nexport function encodeGLTFSync(gltf, arrayBuffer, byteOffset, options) {\n  convertBuffersToBase64(gltf);\n\n  // TODO: Copy buffers to binary\n\n  return encodeGLBSync(gltf, arrayBuffer, byteOffset, options);\n}\n\nfunction convertBuffersToBase64(gltf, {firstBuffer = 0} = {}) {\n  if (gltf.buffers && gltf.buffers.length > firstBuffer) {\n    throw new Error('encodeGLTF: multiple buffers not yet implemented');\n  }\n}\n","import type {Writer} from '@loaders.gl/loader-utils';\nimport {VERSION} from './lib/utils/version';\nimport {encodeGLTFSync} from './lib/encoders/encode-gltf';\n\nexport type GLTFWriterOptions = {\n  gltf?: {};\n  byteOffset?: number;\n};\n\n/**\n * GLTF exporter\n */\nexport const GLTFWriter = {\n  name: 'glTF',\n  id: 'gltf',\n  module: 'gltf',\n  version: VERSION,\n\n  extensions: ['glb'], // We only support encoding to binary GLB, not to JSON GLTF\n  mimeTypes: ['model/gltf-binary'], // 'model/gltf+json',\n  binary: true,\n\n  encodeSync,\n\n  options: {\n    gltf: {}\n  }\n};\n\nfunction encodeSync(gltf, options: GLTFWriterOptions = {}) {\n  const {byteOffset = 0} = options;\n\n  // Calculate length, then create arraybuffer and encode\n  const byteLength = encodeGLTFSync(gltf, null, byteOffset, options);\n  const arrayBuffer = new ArrayBuffer(byteLength);\n  const dataView = new DataView(arrayBuffer);\n  encodeGLTFSync(gltf, dataView, byteOffset, options);\n\n  return arrayBuffer;\n}\n\n// TYPE TESTS - TODO find a better way than exporting junk\nexport const _TypecheckGLBLoader: Writer = GLTFWriter;\n","import type {LoaderWithParser, LoaderOptions} from '@loaders.gl/loader-utils';\nimport type {GLB} from './lib/types/glb-types';\nimport type {GLBParseOptions} from './lib/parsers/parse-glb';\nimport {VERSION} from './lib/utils/version';\nimport parseGLBSync from './lib/parsers/parse-glb';\n\nexport type GLBLoaderOptions = LoaderOptions & {\n  glb?: GLBParseOptions;\n  byteOffset?: number;\n};\n\n/**\n * GLB Loader -\n * GLB is the binary container format for GLTF\n */\nexport const GLBLoader: LoaderWithParser = {\n  name: 'GLB',\n  id: 'glb',\n  module: 'gltf',\n  version: VERSION,\n  extensions: ['glb'],\n  mimeTypes: ['model/gltf-binary'],\n  binary: true,\n  parse,\n  parseSync,\n  options: {\n    glb: {\n      strict: false // Enables deprecated XVIZ support (illegal CHUNK formats)\n    }\n  }\n};\n\nasync function parse(arrayBuffer: ArrayBuffer, options?: GLBLoaderOptions): Promise<GLB> {\n  return parseSync(arrayBuffer, options);\n}\n\nfunction parseSync(arrayBuffer: ArrayBuffer, options?: GLBLoaderOptions): GLB {\n  const {byteOffset = 0} = options || {};\n  const glb: GLB = {} as GLB;\n  parseGLBSync(glb, arrayBuffer, byteOffset, options?.glb);\n  return glb;\n}\n\n// TYPE TESTS - TODO find a better way than exporting junk\nexport const _TypecheckGLBLoader: LoaderWithParser = GLBLoader;\n","import type {Writer} from '@loaders.gl/loader-utils';\nimport {VERSION} from './lib/utils/version';\nimport encodeGLBSync from './lib/encoders/encode-glb';\n\n/**\n * GLB exporter\n * GLB is the binary container format for GLTF\n */\nexport const GLBWriter = {\n  name: 'GLB',\n  id: 'glb',\n  module: 'gltf',\n  version: VERSION,\n\n  extensions: ['glb'],\n  mimeTypes: ['model/gltf-binary'],\n  binary: true,\n\n  encodeSync,\n\n  options: {\n    glb: {}\n  }\n};\n\nfunction encodeSync(glb, options) {\n  const {byteOffset = 0} = options;\n\n  // Calculate length and allocate buffer\n  const byteLength = encodeGLBSync(glb, null, byteOffset, options);\n  const arrayBuffer = new ArrayBuffer(byteLength);\n\n  // Encode into buffer\n  const dataView = new DataView(arrayBuffer);\n  encodeGLBSync(glb, dataView, byteOffset, options);\n\n  return arrayBuffer;\n}\n\n// TYPE TESTS - TODO find a better way than exporting junk\nexport const _TypecheckGLBLoader: Writer = GLBWriter;\n"],"sourceRoot":""}