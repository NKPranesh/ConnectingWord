{"version":3,"sources":["../../../../src/lib/extensions/KHR_techniques_webgl.ts"],"names":["decode","gltfData","gltfScenegraph","GLTFScenegraph","json","extension","getExtension","KHR_TECHNIQUES_WEBGL","techniques","resolveTechniques","material","materials","materialExtension","getObjectExtension","technique","Object","assign","values","resolveValues","removeObjectExtension","removeExtension","encode","options","techniquesExtension","programs","shaders","textDecoder","TextDecoder","forEach","shader","Number","isFinite","bufferView","code","getTypedArrayForBufferView","Error","program","fragmentShader","vertexShader","keys","uniforms","uniform","value","index","undefined","texture","getTexture"],"mappings":"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","sourcesContent":["// GLTF EXTENSION: KHR_techniques_webgl\n// https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_techniques_webgl\n\nimport type {GLTF} from '../types/gltf-types';\n\nimport GLTFScenegraph from '../api/gltf-scenegraph';\nimport {KHR_TECHNIQUES_WEBGL} from '../gltf-utils/gltf-constants';\n\nexport async function decode(gltfData: {json: GLTF}): Promise<void> {\n  const gltfScenegraph = new GLTFScenegraph(gltfData);\n  const {json} = gltfScenegraph;\n\n  const extension = gltfScenegraph.getExtension(KHR_TECHNIQUES_WEBGL);\n  if (extension) {\n    const techniques = resolveTechniques(extension, gltfScenegraph);\n\n    for (const material of json.materials || []) {\n      const materialExtension = gltfScenegraph.getObjectExtension(material, KHR_TECHNIQUES_WEBGL);\n      if (materialExtension) {\n        // @ts-ignore TODO\n        material.technique = Object.assign(\n          {},\n          materialExtension,\n          // @ts-ignore\n          techniques[materialExtension.technique]\n        );\n        // @ts-ignore TODO\n        material.technique.values = resolveValues(material.technique, gltfScenegraph);\n      }\n      gltfScenegraph.removeObjectExtension(material, KHR_TECHNIQUES_WEBGL);\n    }\n\n    gltfScenegraph.removeExtension(KHR_TECHNIQUES_WEBGL);\n  }\n}\n// eslint-disable-next-line\nexport async function encode(gltfData, options): Promise<void> {\n  // TODO\n}\n\nfunction resolveTechniques(\n  techniquesExtension: {[key: string]: any},\n  // programs: {[key: string]: any}[],\n  // shaders: {[key: string]: any}[],\n  // techniques: {[key: string]: any}[]\n  gltfScenegraph\n) {\n  const {programs = [], shaders = [], techniques = []} = techniquesExtension;\n  const textDecoder = new TextDecoder();\n\n  shaders.forEach((shader) => {\n    if (Number.isFinite(shader.bufferView)) {\n      shader.code = textDecoder.decode(\n        gltfScenegraph.getTypedArrayForBufferView(shader.bufferView)\n      );\n    } else {\n      // TODO: handle URI shader\n      throw new Error('KHR_techniques_webgl: no shader code');\n    }\n  });\n\n  programs.forEach((program) => {\n    program.fragmentShader = shaders[program.fragmentShader];\n    program.vertexShader = shaders[program.vertexShader];\n  });\n\n  techniques.forEach((technique) => {\n    technique.program = programs[technique.program];\n  });\n\n  return techniques;\n}\n\nfunction resolveValues(technique, gltfScenegraph) {\n  const values = Object.assign({}, technique.values);\n\n  // merge values from uniforms\n  Object.keys(technique.uniforms || {}).forEach((uniform) => {\n    if (technique.uniforms[uniform].value && !(uniform in values)) {\n      values[uniform] = technique.uniforms[uniform].value;\n    }\n  });\n\n  // resolve textures\n  Object.keys(values).forEach((uniform) => {\n    if (typeof values[uniform] === 'object' && values[uniform].index !== undefined) {\n      // Assume this is a texture\n      // TODO: find if there are any other types that can be referenced\n      values[uniform].texture = gltfScenegraph.getTexture(values[uniform].index);\n    }\n  });\n\n  return values;\n}\n"],"file":"KHR_techniques_webgl.js"}