"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.decode = decode;

var _gltfScenegraph = _interopRequireDefault(require("../api/gltf-scenegraph"));

var _gltfConstants = require("../gltf-utils/gltf-constants");

var _meshoptDecoder = require("../../meshopt/meshopt-decoder");

const DEFAULT_MESHOPT_OPTIONS = {
  byteOffset: 0,
  filter: 'NONE'
};

async function decode(gltfData, options) {
  var _options$gltf;

  if (!(options !== null && options !== void 0 && (_options$gltf = options.gltf) !== null && _options$gltf !== void 0 && _options$gltf.decompressMeshes) || !(0, _meshoptDecoder.isMeshoptSupported)()) {
    return;
  }

  const promises = [];

  for (const bufferViewIndex of gltfData.json.bufferViews || []) {
    promises.push(decodeMeshoptBufferView(gltfData.json, bufferViewIndex));
  }

  await Promise.all(promises);
  const scenegraph = new _gltfScenegraph.default(gltfData);
  scenegraph.removeExtension(_gltfConstants.EXT_MESHOPT_COMPRESSION);
}

async function decodeMeshoptBufferView(json, index) {
  const bufferView = json.bufferViews[index];
  const meshoptExtension = bufferView.extensions && bufferView.extensions[_gltfConstants.EXT_MESHOPT_COMPRESSION];

  if (meshoptExtension) {
    const buffer = json.buffers[meshoptExtension.buffer];
    const {
      byteOffset = 0,
      byteLength = 0,
      byteStride,
      count,
      mode,
      filter = 'NONE'
    } = meshoptExtension;
    const source = new Uint8Array(buffer, byteOffset, byteLength);
    const result = new ArrayBuffer(count * byteStride);
    await (0, _meshoptDecoder.meshoptDecodeGltfBuffer)(new Uint8Array(result), count, byteStride, source, mode, filter);
    return result;
  }

  return null;
}
//# sourceMappingURL=EXT_meshopt_compression.js.map