"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getFrameState = getFrameState;

var _core = require("@math.gl/core");

var _culling = require("@math.gl/culling");

var _geospatial = require("@math.gl/geospatial");

const scratchVector = new _core.Vector3();
const scratchPosition = new _core.Vector3();
const cullingVolume = new _culling.CullingVolume([new _culling.Plane(), new _culling.Plane(), new _culling.Plane(), new _culling.Plane(), new _culling.Plane(), new _culling.Plane()]);

function getFrameState(viewport, frameNumber) {
  const {
    cameraDirection,
    cameraUp,
    height
  } = viewport;
  const {
    metersPerUnit
  } = viewport.distanceScales;
  const viewportCenterCartographic = [viewport.longitude, viewport.latitude, 0];

  const viewportCenterCartesian = _geospatial.Ellipsoid.WGS84.cartographicToCartesian(viewportCenterCartographic, new _core.Vector3());

  const enuToFixedTransform = _geospatial.Ellipsoid.WGS84.eastNorthUpToFixedFrame(viewportCenterCartesian);

  const cameraPositionCartographic = viewport.unprojectPosition(viewport.cameraPosition);

  const cameraPositionCartesian = _geospatial.Ellipsoid.WGS84.cartographicToCartesian(cameraPositionCartographic, new _core.Vector3());

  const cameraDirectionCartesian = new _core.Vector3(enuToFixedTransform.transformAsVector(new _core.Vector3(cameraDirection).scale(metersPerUnit))).normalize();
  const cameraUpCartesian = new _core.Vector3(enuToFixedTransform.transformAsVector(new _core.Vector3(cameraUp).scale(metersPerUnit))).normalize();
  commonSpacePlanesToWGS84(viewport, viewportCenterCartesian);
  return {
    camera: {
      position: cameraPositionCartesian,
      direction: cameraDirectionCartesian,
      up: cameraUpCartesian
    },
    viewport,
    height,
    cullingVolume,
    frameNumber,
    sseDenominator: 1.15
  };
}

function commonSpacePlanesToWGS84(viewport, viewportCenterCartesian) {
  const frustumPlanes = viewport.getFrustumPlanes();
  let i = 0;

  for (const dir in frustumPlanes) {
    const plane = frustumPlanes[dir];
    const distanceToCenter = plane.normal.dot(viewport.center);
    scratchPosition.copy(plane.normal).scale(plane.distance - distanceToCenter).add(viewport.center);
    const cartographicPos = viewport.unprojectPosition(scratchPosition);

    const cartesianPos = _geospatial.Ellipsoid.WGS84.cartographicToCartesian(cartographicPos, new _core.Vector3());

    cullingVolume.planes[i++].fromPointNormal(cartesianPos, scratchVector.copy(viewportCenterCartesian).subtract(cartesianPos));
  }
}
//# sourceMappingURL=frame-state.js.map