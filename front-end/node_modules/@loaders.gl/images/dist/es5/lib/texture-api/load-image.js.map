{"version":3,"sources":["../../../../src/lib/texture-api/load-image.ts"],"names":["loadImage","getUrl","options","imageUrls","getImageUrls","parseImage","urlOptions","mipLevels","image","getMipmappedImageUrls","urls","url","lod","width","height","getMipLevels","push","mipLevel","length","Math","floor","log2","max"],"mappings":";;;;;;;;;;;AAAA;;AACA;;AACA;;AACA;;AACA;;AAEO,eAAeA,SAAf,CAAyBC,MAAzB,EAAiCC,OAAO,GAAG,EAA3C,EAA+C;AACpD,QAAMC,SAAS,GAAG,MAAMC,YAAY,CAACH,MAAD,EAASC,OAAT,CAApC;AACA,SAAO,MAAM,wBAASC,SAAT,EAAoBE,mBAApB,EAAgCH,OAAhC,CAAb;AACD;;AAEM,eAAeE,YAAf,CAA4BH,MAA5B,EAAoCC,OAApC,EAA6CI,UAAU,GAAG,EAA1D,EAA8D;AACnE,QAAMC,SAAS,GAAIL,OAAO,IAAIA,OAAO,CAACM,KAAnB,IAA4BN,OAAO,CAACM,KAAR,CAAcD,SAA3C,IAAyD,CAA3E;AACA,SAAOA,SAAS,KAAK,CAAd,GACH,MAAME,qBAAqB,CAACR,MAAD,EAASM,SAAT,EAAoBL,OAApB,EAA6BI,UAA7B,CADxB,GAEH,8BAAYL,MAAZ,EAAoBC,OAApB,EAA6BI,UAA7B,CAFJ;AAGD;;AAED,eAAeG,qBAAf,CAAqCR,MAArC,EAA6CM,SAA7C,EAAwDL,OAAxD,EAAiEI,UAAjE,EAA6E;AAC3E,QAAMI,IAAc,GAAG,EAAvB;;AAGA,MAAIH,SAAS,KAAK,MAAlB,EAA0B;AACxB,UAAMI,GAAG,GAAG,8BAAYV,MAAZ,EAAoBC,OAApB,EAA6B,EAAC,GAAGI,UAAJ;AAAgBM,MAAAA,GAAG,EAAE;AAArB,KAA7B,CAAZ;AACA,UAAMJ,KAAK,GAAG,MAAM,2BAAYG,GAAZ,EAAiBN,mBAAjB,EAA6BH,OAA7B,CAApB;AAEA,UAAM;AAACW,MAAAA,KAAD;AAAQC,MAAAA;AAAR,QAAkB,kCAAaN,KAAb,CAAxB;AACAD,IAAAA,SAAS,GAAGQ,YAAY,CAAC;AAACF,MAAAA,KAAD;AAAQC,MAAAA;AAAR,KAAD,CAAxB;AAGAJ,IAAAA,IAAI,CAACM,IAAL,CAAUL,GAAV;AACD;;AAGD,sBAAOJ,SAAS,GAAG,CAAnB;;AAEA,OAAK,IAAIU,QAAQ,GAAGP,IAAI,CAACQ,MAAzB,EAAiCD,QAAQ,GAAGV,SAA5C,EAAuD,EAAEU,QAAzD,EAAmE;AACjE,UAAMN,GAAG,GAAG,8BAAYV,MAAZ,EAAoBC,OAApB,EAA6B,EAAC,GAAGI,UAAJ;AAAgBM,MAAAA,GAAG,EAAEK;AAArB,KAA7B,CAAZ;AACAP,IAAAA,IAAI,CAACM,IAAL,CAAUL,GAAV;AACD;;AAED,SAAOD,IAAP;AACD;;AAGM,SAASK,YAAT,CAAsB;AAACF,EAAAA,KAAD;AAAQC,EAAAA;AAAR,CAAtB,EAAuC;AAC5C,SAAO,IAAIK,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,IAAL,CAAUF,IAAI,CAACG,GAAL,CAAST,KAAT,EAAgBC,MAAhB,CAAV,CAAX,CAAX;AACD","sourcesContent":["import {assert} from '../utils/assert';\nimport parseImage from '../parsers/parse-image';\nimport {getImageSize} from '../category-api/parsed-image-api';\nimport {generateUrl} from './generate-url';\nimport {deepLoad, shallowLoad} from './deep-load';\n\nexport async function loadImage(getUrl, options = {}) {\n  const imageUrls = await getImageUrls(getUrl, options);\n  return await deepLoad(imageUrls, parseImage, options);\n}\n\nexport async function getImageUrls(getUrl, options, urlOptions = {}) {\n  const mipLevels = (options && options.image && options.image.mipLevels) || 0;\n  return mipLevels !== 0\n    ? await getMipmappedImageUrls(getUrl, mipLevels, options, urlOptions)\n    : generateUrl(getUrl, options, urlOptions);\n}\n\nasync function getMipmappedImageUrls(getUrl, mipLevels, options, urlOptions) {\n  const urls: string[] = [];\n\n  // If no mip levels supplied, we need to load the level 0 image and calculate based on size\n  if (mipLevels === 'auto') {\n    const url = generateUrl(getUrl, options, {...urlOptions, lod: 0});\n    const image = await shallowLoad(url, parseImage, options);\n\n    const {width, height} = getImageSize(image);\n    mipLevels = getMipLevels({width, height});\n\n    // TODO - push image and make `deepLoad` pass through non-url values, avoid loading twice?\n    urls.push(url);\n  }\n\n  // We now know how many mipLevels we need, remaining image urls can now be constructed\n  assert(mipLevels > 0);\n\n  for (let mipLevel = urls.length; mipLevel < mipLevels; ++mipLevel) {\n    const url = generateUrl(getUrl, options, {...urlOptions, lod: mipLevel});\n    urls.push(url);\n  }\n\n  return urls;\n}\n\n// Calculates number of mipmaps based on texture size (log2)\nexport function getMipLevels({width, height}) {\n  return 1 + Math.floor(Math.log2(Math.max(width, height)));\n}\n"],"file":"load-image.js"}