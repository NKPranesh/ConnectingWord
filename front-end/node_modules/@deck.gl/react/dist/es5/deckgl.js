"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = require("react");

var _propTypes = _interopRequireDefault(require("prop-types"));

var _core = require("@deck.gl/core");

var _useIsomorphicLayoutEffect = _interopRequireDefault(require("./utils/use-isomorphic-layout-effect"));

var _extractJsxLayers = _interopRequireDefault(require("./utils/extract-jsx-layers"));

var _positionChildrenUnderViews = _interopRequireDefault(require("./utils/position-children-under-views"));

var _extractStyles = _interopRequireDefault(require("./utils/extract-styles"));

function getRefHandles(thisRef) {
  const handles = {
    pickObject: opts => thisRef.deck.pickObject(opts),
    pickMultipleObjects: opts => thisRef.deck.pickMultipleObjects(opts),
    pickObjects: opts => thisRef.deck.pickObjects(opts)
  };
  Object.defineProperty(handles, 'deck', {
    get: () => thisRef.deck
  });
  return handles;
}

function redrawDeck(thisRef) {
  if (thisRef.redrawReason) {
    thisRef.deck._drawLayers(thisRef.redrawReason);

    thisRef.redrawReason = null;
  }
}

function createDeckInstance(thisRef, props) {
  const DeckClass = props.Deck || _core.Deck;
  const deck = new DeckClass({ ...props,
    style: null,
    width: '100%',
    height: '100%',
    _customRender: redrawReason => {
      thisRef.redrawReason = redrawReason;
      const viewports = deck.viewManager.getViewports();

      if (thisRef.lastRenderedViewports !== viewports) {
        thisRef.forceUpdate(v => v + 1);
      } else {
        redrawDeck(thisRef);
      }
    }
  });
  return deck;
}

const DeckGL = (0, _react.forwardRef)((props, ref) => {
  const _thisRef = (0, _react.useRef)({});

  const thisRef = _thisRef.current;
  const [version, setVersion] = (0, _react.useState)(0);
  thisRef.forceUpdate = setVersion;
  const containerRef = (0, _react.useRef)(null);
  const canvasRef = (0, _react.useRef)(null);
  const jsxProps = (0, _react.useMemo)(() => (0, _extractJsxLayers.default)(props), [props.layers, props.views, props.children]);
  let inRender = true;

  const handleViewStateChange = params => {
    if (inRender && props.viewState) {
      thisRef.viewStateUpdateRequested = params;
      return null;
    }

    thisRef.viewStateUpdateRequested = null;
    return props.onViewStateChange(params);
  };

  const handleInteractionStateChange = params => {
    if (inRender) {
      thisRef.interactionStateUpdateRequested = params;
    } else {
      thisRef.interactionStateUpdateRequested = null;
      props.onInteractionStateChange(params);
    }
  };

  const deckProps = (0, _react.useMemo)(() => {
    const forwardProps = { ...props,
      style: null,
      width: '100%',
      height: '100%',
      layers: jsxProps.layers,
      views: jsxProps.views,
      onViewStateChange: handleViewStateChange,
      onInteractionStateChange: handleInteractionStateChange
    };

    if (thisRef.deck) {
      thisRef.deck.setProps(forwardProps);
    }

    return forwardProps;
  }, [props]);
  (0, _react.useEffect)(() => {
    thisRef.deck = createDeckInstance(thisRef, { ...deckProps,
      parent: containerRef.current,
      canvas: canvasRef.current
    });
    return () => thisRef.deck.finalize();
  }, []);
  (0, _useIsomorphicLayoutEffect.default)(() => {
    redrawDeck(thisRef);
    const {
      viewStateUpdateRequested,
      interactionStateUpdateRequested
    } = thisRef;

    if (viewStateUpdateRequested) {
      handleViewStateChange(viewStateUpdateRequested);
    }

    if (interactionStateUpdateRequested) {
      handleInteractionStateChange(interactionStateUpdateRequested);
    }
  });
  (0, _react.useImperativeHandle)(ref, () => getRefHandles(thisRef), []);
  const {
    viewManager
  } = thisRef.deck || {};
  const currentViewports = viewManager && viewManager.getViewports();
  const {
    ContextProvider,
    width,
    height,
    id,
    style
  } = props;
  const {
    containerStyle,
    canvasStyle
  } = (0, _react.useMemo)(() => (0, _extractStyles.default)({
    width,
    height,
    style
  }), [width, height, style]);

  if (!thisRef.viewStateUpdateRequested && thisRef.lastRenderedViewports === currentViewports || thisRef.version !== version) {
      thisRef.lastRenderedViewports = currentViewports;
      thisRef.version = version;
      const childrenUnderViews = (0, _positionChildrenUnderViews.default)({
        children: jsxProps.children,
        deck: thisRef.deck,
        ContextProvider
      });
      const canvas = (0, _react.createElement)('canvas', {
        key: 'canvas',
        id: id || 'deckgl-overlay',
        ref: canvasRef,
        style: canvasStyle
      });
      thisRef.control = (0, _react.createElement)('div', {
        id: "".concat(id || 'deckgl', "-wrapper"),
        ref: containerRef,
        style: containerStyle
      }, [canvas, childrenUnderViews]);
    }

  inRender = false;
  return thisRef.control;
});
DeckGL.propTypes = _core.Deck.getPropTypes(_propTypes.default);
DeckGL.defaultProps = _core.Deck.defaultProps;
var _default = DeckGL;
exports.default = _default;
//# sourceMappingURL=deckgl.js.map