"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _core = require("@deck.gl/core");

var _core2 = require("@luma.gl/core");

var _shadertools = require("@luma.gl/shadertools");

var _experimental = require("@luma.gl/experimental");

var _gltf = require("@loaders.gl/gltf");

var _gltfUtils = require("./gltf-utils");

var _matrix = require("../utils/matrix");

var _scenegraphLayerVertex = _interopRequireDefault(require("./scenegraph-layer-vertex.glsl"));

var _scenegraphLayerFragment = _interopRequireDefault(require("./scenegraph-layer-fragment.glsl"));

const DEFAULT_COLOR = [255, 255, 255, 255];
const defaultProps = {
  scenegraph: {
    type: 'object',
    value: null,
    async: true
  },
  getScene: gltf => {
    if (gltf && gltf.scenes) {
      return typeof gltf.scene === 'object' ? gltf.scene : gltf.scenes[gltf.scene || 0];
    }

    return gltf;
  },
  getAnimator: scenegraph => scenegraph && scenegraph.animator,
  _animations: null,
  sizeScale: {
    type: 'number',
    value: 1,
    min: 0
  },
  sizeMinPixels: {
    type: 'number',
    min: 0,
    value: 0
  },
  sizeMaxPixels: {
    type: 'number',
    min: 0,
    value: Number.MAX_SAFE_INTEGER
  },
  getPosition: {
    type: 'accessor',
    value: x => x.position
  },
  getColor: {
    type: 'accessor',
    value: DEFAULT_COLOR
  },
  _lighting: 'flat',
  _imageBasedLightingEnvironment: null,
  getOrientation: {
    type: 'accessor',
    value: [0, 0, 0]
  },
  getScale: {
    type: 'accessor',
    value: [1, 1, 1]
  },
  getTranslation: {
    type: 'accessor',
    value: [0, 0, 0]
  },
  getTransformMatrix: {
    type: 'accessor',
    value: []
  },
  loaders: [_gltf.GLTFLoader]
};

class ScenegraphLayer extends _core.Layer {
  getShaders() {
    const modules = [_core.project32, _core.picking];

    if (this.props._lighting === 'pbr') {
      modules.push(_shadertools.pbr);
    }

    return {
      vs: _scenegraphLayerVertex.default,
      fs: _scenegraphLayerFragment.default,
      modules
    };
  }

  initializeState() {
    const attributeManager = this.getAttributeManager();
    attributeManager.addInstanced({
      instancePositions: {
        size: 3,
        type: 5130,
        fp64: this.use64bitPositions(),
        accessor: 'getPosition',
        transition: true
      },
      instanceColors: {
        type: 5121,
        size: this.props.colorFormat.length,
        accessor: 'getColor',
        normalized: true,
        defaultValue: DEFAULT_COLOR,
        transition: true
      },
      instanceModelMatrix: _matrix.MATRIX_ATTRIBUTES
    });
  }

  updateState(params) {
    super.updateState(params);
    const {
      props,
      oldProps
    } = params;

    if (props.scenegraph !== oldProps.scenegraph) {
      this._updateScenegraph(props);
    } else if (props._animations !== oldProps._animations) {
      this._applyAnimationsProp(this.state.scenegraph, this.state.animator, props._animations);
    }
  }

  finalizeState() {
    super.finalizeState();

    this._deleteScenegraph();
  }

  _updateScenegraph(props) {
    const {
      gl
    } = this.context;
    let scenegraphData = null;

    if (props.scenegraph instanceof _experimental.ScenegraphNode) {
      scenegraphData = {
        scenes: [props.scenegraph]
      };
    } else if (props.scenegraph && !props.scenegraph.gltf) {
      const gltf = props.scenegraph;
      const gltfObjects = (0, _experimental.createGLTFObjects)(gl, gltf, this._getModelOptions());
      scenegraphData = {
        gltf,
        ...gltfObjects
      };
      (0, _gltfUtils.waitForGLTFAssets)(gltfObjects).then(() => this.setNeedsRedraw());
    } else if (props.scenegraph) {
      _core.log.deprecated('ScenegraphLayer.props.scenegraph', 'Use GLTFLoader instead of GLTFScenegraphLoader')();

      scenegraphData = props.scenegraph;
    }

    const options = {
      layer: this,
      gl
    };
    const scenegraph = props.getScene(scenegraphData, options);
    const animator = props.getAnimator(scenegraphData, options);

    if (scenegraph instanceof _experimental.ScenegraphNode) {
      this._deleteScenegraph();

      this._applyAllAttributes(scenegraph);

      this._applyAnimationsProp(scenegraph, animator, props._animations);

      this.setState({
        scenegraph,
        animator
      });
    } else if (scenegraph !== null) {
      _core.log.warn('invalid scenegraph:', scenegraph)();
    }
  }

  _applyAllAttributes(scenegraph) {
    if (this.state.attributesAvailable) {
      const allAttributes = this.getAttributeManager().getAttributes();
      scenegraph.traverse(model => {
        this._setModelAttributes(model.model, allAttributes);
      });
    }
  }

  _applyAnimationsProp(scenegraph, animator, animationsProp) {
    if (!scenegraph || !animator || !animationsProp) {
      return;
    }

    const animations = animator.getAnimations();
    Object.keys(animationsProp).sort().forEach(key => {
      const value = animationsProp[key];

      if (key === '*') {
        animations.forEach(animation => {
          Object.assign(animation, value);
        });
      } else if (Number.isFinite(Number(key))) {
        const number = Number(key);

        if (number >= 0 && number < animations.length) {
          Object.assign(animations[number], value);
        } else {
          _core.log.warn("animation ".concat(key, " not found"))();
        }
      } else {
        const findResult = animations.find(({
          name
        }) => name === key);

        if (findResult) {
          Object.assign(findResult, value);
        } else {
          _core.log.warn("animation ".concat(key, " not found"))();
        }
      }
    });
  }

  _deleteScenegraph() {
    const {
      scenegraph
    } = this.state;

    if (scenegraph instanceof _experimental.ScenegraphNode) {
      scenegraph.delete();
    }
  }

  _getModelOptions() {
    const {
      _imageBasedLightingEnvironment
    } = this.props;
    let env = null;

    if (_imageBasedLightingEnvironment) {
      if (typeof _imageBasedLightingEnvironment === 'function') {
        env = _imageBasedLightingEnvironment({
          gl: this.context.gl,
          layer: this
        });
      } else {
        env = _imageBasedLightingEnvironment;
      }
    }

    return {
      gl: this.context.gl,
      waitForFullLoad: true,
      imageBasedLightingEnvironment: env,
      modelOptions: {
        isInstanced: true,
        transpileToGLSL100: !(0, _core2.isWebGL2)(this.context.gl),
        ...this.getShaders()
      },
      useTangents: false
    };
  }

  updateAttributes(changedAttributes) {
    this.setState({
      attributesAvailable: true
    });
    if (!this.state.scenegraph) return;
    this.state.scenegraph.traverse(model => {
      this._setModelAttributes(model.model, changedAttributes);
    });
  }

  draw({
    moduleParameters = null,
    parameters = {},
    context
  }) {
    if (!this.state.scenegraph) return;

    if (this.props._animations && this.state.animator) {
      this.state.animator.animate(context.timeline.getTime());
      this.setNeedsRedraw();
    }

    const {
      viewport
    } = this.context;
    const {
      sizeScale,
      sizeMinPixels,
      sizeMaxPixels,
      opacity,
      coordinateSystem
    } = this.props;
    const numInstances = this.getNumInstances();
    this.state.scenegraph.traverse((model, {
      worldMatrix
    }) => {
      model.model.setInstanceCount(numInstances);
      model.updateModuleSettings(moduleParameters);
      model.draw({
        parameters,
        uniforms: {
          sizeScale,
          opacity,
          sizeMinPixels,
          sizeMaxPixels,
          composeModelMatrix: (0, _matrix.shouldComposeModelMatrix)(viewport, coordinateSystem),
          sceneModelMatrix: worldMatrix,
          u_Camera: model.model.getUniforms().project_uCameraPosition
        }
      });
    });
  }

}

exports.default = ScenegraphLayer;
ScenegraphLayer.layerName = 'ScenegraphLayer';
ScenegraphLayer.defaultProps = defaultProps;
//# sourceMappingURL=scenegraph-layer.js.map