{"version":3,"sources":["../../../../src/utils/gpu-grid-aggregation/gpu-grid-aggregator.js"],"names":["BUFFER_NAMES","ARRAY_BUFFER_MAP","maxData","minData","maxMinData","REQUIRED_FEATURES","FEATURES","WEBGL2","COLOR_ATTACHMENT_RGBA32F","BLEND_EQUATION_MINMAX","FLOAT_BLEND","TEXTURE_FLOAT","GPUGridAggregator","getAggregationData","aggregationData","pixelIndex","index","PIXEL_SIZE","results","cellCount","cellWeight","maxCellWieght","minCellWeight","totalCount","getCellData","countsData","size","numCells","length","cellWeights","Float32Array","cellCounts","Uint32Array","i","sizeIndex","isSupported","gl","constructor","opts","id","state","weightAttributes","textures","meanTextures","buffers","framebuffers","maxMinFramebuffers","minFramebuffers","maxFramebuffers","equations","resources","_hasGPUSupport","_setupModels","delete","gridAggregationModel","allAggregationModel","meanTransform","deleteResources","run","setState","aggregationParams","_normalizeAggregationParams","log","_runAggregation","getData","weightId","data","aggregationBuffer","arrayName","bufferName","updateShaders","shaderOptions","modelDirty","DEFAULT_RUN_PARAMS","weights","normalizeWeightParams","updateObject","Object","assign","_getAggregateData","needMin","needMax","combineMaxMin","aggregationTexture","target","sourceType","maxMinBuffer","maxMinTexture","minBuffer","minTexture","maxBuffer","maxTexture","_trackGPUResultBuffers","_renderAggregateData","cellSize","projectPoints","attributes","moduleSettings","numCol","numRow","translation","scaling","gridSize","parameters","blend","depthTest","blendFunc","uniforms","_renderToWeightsTexture","_renderToMaxMinTexture","blendEquation","MAX_MIN_BLEND_EQUATION","minOrMaxFb","clearParams","clearColor","MAX_32_BIT_FLOAT","MIN_BLEND_EQUATION","MAX_BLEND_EQUATION","framebuffer","viewport","clear","draw","uSampler","texture","operation","AGGREGATION_OPERATION","MIN","MEAN","transformOptions","_sourceTextures","aggregationValues","_targetTexture","elementCount","width","height","update","getMeanTransform","attach","_updateModels","_setupFramebuffers","framebufferSize","resize","EQUATION_MAP","SUM","_getMinMaxTexture","name","getAggregationModel","instanceCount","getAllAggregationModel","_setupWeightAttributes","vertexCount","setVertexCount","setAttributes","setInstanceCount","result","DEFAULT_WEIGHT_PARAMS","Array","isArray","forEach","obj","shaders","vs","AGGREGATE_TO_GRID_VS","fs","AGGREGATE_TO_GRID_FS","modules","fp64arithmetic","project32","Model","drawMode","AGGREGATE_ALL_VS","AGGREGATE_ALL_FS","isInstanced","position","Transform","TRANSFORM_MEAN_VS","_targetTextureVarying"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2018 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport GL from '@luma.gl/constants';\nimport {\n  Model,\n  Transform,\n  FEATURES,\n  hasFeatures,\n  isWebGL2,\n  readPixelsToBuffer,\n  withParameters\n} from '@luma.gl/core';\nimport {fp64arithmetic} from '@luma.gl/shadertools';\nimport {log, project32, _mergeShaders as mergeShaders} from '@deck.gl/core';\n\nimport {\n  DEFAULT_RUN_PARAMS,\n  MAX_32_BIT_FLOAT,\n  MIN_BLEND_EQUATION,\n  MAX_BLEND_EQUATION,\n  MAX_MIN_BLEND_EQUATION,\n  EQUATION_MAP,\n  DEFAULT_WEIGHT_PARAMS,\n  PIXEL_SIZE\n} from './gpu-grid-aggregator-constants';\nimport {AGGREGATION_OPERATION} from '../aggregation-operation-utils';\n\nimport AGGREGATE_TO_GRID_VS from './aggregate-to-grid-vs.glsl';\nimport AGGREGATE_TO_GRID_FS from './aggregate-to-grid-fs.glsl';\nimport AGGREGATE_ALL_VS from './aggregate-all-vs.glsl';\nimport AGGREGATE_ALL_FS from './aggregate-all-fs.glsl';\nimport TRANSFORM_MEAN_VS from './transform-mean-vs.glsl';\nimport {getFloatTexture, getFramebuffer} from './../resource-utils.js';\n\nconst BUFFER_NAMES = ['aggregationBuffer', 'maxMinBuffer', 'minBuffer', 'maxBuffer'];\nconst ARRAY_BUFFER_MAP = {\n  maxData: 'maxBuffer',\n  minData: 'minBuffer',\n  maxMinData: 'maxMinBuffer'\n};\n\nconst REQUIRED_FEATURES = [\n  FEATURES.WEBGL2, // TODO: Remove after trannsform refactor\n  FEATURES.COLOR_ATTACHMENT_RGBA32F,\n  FEATURES.BLEND_EQUATION_MINMAX,\n  FEATURES.FLOAT_BLEND,\n  FEATURES.TEXTURE_FLOAT\n];\n\nexport default class GPUGridAggregator {\n  // Decode and return aggregation data of given pixel.\n  static getAggregationData({aggregationData, maxData, minData, maxMinData, pixelIndex}) {\n    const index = pixelIndex * PIXEL_SIZE;\n    const results = {};\n    if (aggregationData) {\n      results.cellCount = aggregationData[index + 3];\n      results.cellWeight = aggregationData[index];\n    }\n    if (maxMinData) {\n      results.maxCellWieght = maxMinData[0];\n      results.minCellWeight = maxMinData[3];\n    } else {\n      if (maxData) {\n        results.maxCellWieght = maxData[0];\n        results.totalCount = maxData[3];\n      }\n      if (minData) {\n        results.minCellWeight = minData[0];\n        results.totalCount = maxData[3];\n      }\n    }\n    return results;\n  }\n\n  // Decodes and retuns counts and weights of all cells\n  static getCellData({countsData, size = 1}) {\n    const numCells = countsData.length / 4;\n    const cellWeights = new Float32Array(numCells * size);\n    const cellCounts = new Uint32Array(numCells);\n    for (let i = 0; i < numCells; i++) {\n      // weights in RGB channels\n      for (let sizeIndex = 0; sizeIndex < size; sizeIndex++) {\n        cellWeights[i * size + sizeIndex] = countsData[i * 4 + sizeIndex];\n      }\n      // count in Alpha channel\n      cellCounts[i] = countsData[i * 4 + 3];\n    }\n    return {cellCounts, cellWeights};\n  }\n\n  static isSupported(gl) {\n    return hasFeatures(gl, REQUIRED_FEATURES);\n  }\n\n  // DEBUG ONLY\n  // static logData({aggregationBuffer, minBuffer, maxBuffer, maxMinBuffer, limit = 10}) {\n  //   if (aggregationBuffer) {\n  //     console.log('Aggregation Data:');\n  //     const agrData = aggregationBuffer.getData();\n  //     for (let index = 0; index < agrData.length && limit > 0; index += 4) {\n  //       if (agrData[index + 3] > 0) {\n  //         console.log(\n  //           `index: ${index} weights: ${agrData[index]} ${agrData[index + 1]} ${\n  //             agrData[index + 2]\n  //           } count: ${agrData[index + 3]}`\n  //         );\n  //         limit--;\n  //       }\n  //     }\n  //   }\n  //   const obj = {minBuffer, maxBuffer, maxMinBuffer};\n  //   for (const key in obj) {\n  //     if (obj[key]) {\n  //       const data = obj[key].getData();\n  //       console.log(`${key} data : R: ${data[0]} G: ${data[1]} B: ${data[2]} A: ${data[3]}`);\n  //     }\n  //   }\n  // }\n\n  constructor(gl, opts = {}) {\n    this.id = opts.id || 'gpu-grid-aggregator';\n    this.gl = gl;\n    this.state = {\n      // per weight GPU resources\n      weightAttributes: {},\n      textures: {},\n      meanTextures: {},\n      buffers: {},\n      framebuffers: {},\n      maxMinFramebuffers: {},\n      minFramebuffers: {},\n      maxFramebuffers: {},\n      equations: {},\n\n      // common resources to be deleted\n      resources: {},\n\n      // results\n      results: {}\n    };\n    this._hasGPUSupport =\n      isWebGL2(gl) && // gl_InstanceID usage in min/max calculation shaders\n      hasFeatures(\n        this.gl,\n        FEATURES.BLEND_EQUATION_MINMAX, // set min/max blend modes\n        FEATURES.COLOR_ATTACHMENT_RGBA32F, // render to float texture\n        FEATURES.TEXTURE_FLOAT // sample from a float texture\n      );\n    if (this._hasGPUSupport) {\n      this._setupModels();\n    }\n  }\n\n  // Delete owned resources.\n  delete() {\n    const {gridAggregationModel, allAggregationModel, meanTransform} = this;\n    const {\n      textures,\n      framebuffers,\n      maxMinFramebuffers,\n      minFramebuffers,\n      maxFramebuffers,\n      meanTextures,\n      resources\n    } = this.state;\n\n    gridAggregationModel?.delete();\n    allAggregationModel?.delete();\n    meanTransform?.delete();\n\n    deleteResources([\n      framebuffers,\n      textures,\n      maxMinFramebuffers,\n      minFramebuffers,\n      maxFramebuffers,\n      meanTextures,\n      resources\n    ]);\n  }\n\n  // Perform aggregation and retun the results\n  run(opts = {}) {\n    // reset results\n    this.setState({results: {}});\n    const aggregationParams = this._normalizeAggregationParams(opts);\n    if (!this._hasGPUSupport) {\n      log.log(1, 'GPUGridAggregator: not supported')();\n    }\n    return this._runAggregation(aggregationParams);\n  }\n\n  // Reads aggregation data into JS Array object\n  // For WebGL1, data is available in JS Array objects already.\n  // For WebGL2, data is read from Buffer objects and cached for subsequent queries.\n  getData(weightId) {\n    const data = {};\n    const results = this.state.results;\n    if (!results[weightId].aggregationData) {\n      // cache the results if reading from the buffer (WebGL2 path)\n      results[weightId].aggregationData = results[weightId].aggregationBuffer.getData();\n    }\n    data.aggregationData = results[weightId].aggregationData;\n\n    // Check for optional results\n    for (const arrayName in ARRAY_BUFFER_MAP) {\n      const bufferName = ARRAY_BUFFER_MAP[arrayName];\n\n      if (results[weightId][arrayName] || results[weightId][bufferName]) {\n        // cache the result\n        results[weightId][arrayName] =\n          results[weightId][arrayName] || results[weightId][bufferName].getData();\n        data[arrayName] = results[weightId][arrayName];\n      }\n    }\n    return data;\n  }\n\n  updateShaders(shaderOptions = {}) {\n    this.setState({shaderOptions, modelDirty: true});\n  }\n\n  // PRIVATE\n\n  _normalizeAggregationParams(opts) {\n    const aggregationParams = {...DEFAULT_RUN_PARAMS, ...opts};\n    const {weights} = aggregationParams;\n    if (weights) {\n      aggregationParams.weights = normalizeWeightParams(weights);\n    }\n    return aggregationParams;\n  }\n\n  // Update priveate state\n  setState(updateObject) {\n    Object.assign(this.state, updateObject);\n  }\n\n  // GPU Aggregation methods\n\n  _getAggregateData(opts) {\n    const results = {};\n    const {\n      textures,\n      framebuffers,\n      maxMinFramebuffers,\n      minFramebuffers,\n      maxFramebuffers,\n      resources\n    } = this.state;\n    const {weights} = opts;\n\n    for (const id in weights) {\n      results[id] = {};\n      const {needMin, needMax, combineMaxMin} = weights[id];\n      results[id].aggregationTexture = textures[id];\n      results[id].aggregationBuffer = readPixelsToBuffer(framebuffers[id], {\n        target: weights[id].aggregationBuffer, // update if a buffer is provided\n        sourceType: GL.FLOAT\n      });\n      if (needMin && needMax && combineMaxMin) {\n        results[id].maxMinBuffer = readPixelsToBuffer(maxMinFramebuffers[id], {\n          target: weights[id].maxMinBuffer, // update if a buffer is provided\n          sourceType: GL.FLOAT\n        });\n        results[id].maxMinTexture = resources[`${id}-maxMinTexture`];\n      } else {\n        if (needMin) {\n          results[id].minBuffer = readPixelsToBuffer(minFramebuffers[id], {\n            target: weights[id].minBuffer, // update if a buffer is provided\n            sourceType: GL.FLOAT\n          });\n          results[id].minTexture = resources[`${id}-minTexture`];\n        }\n        if (needMax) {\n          results[id].maxBuffer = readPixelsToBuffer(maxFramebuffers[id], {\n            target: weights[id].maxBuffer, // update if a buffer is provided\n            sourceType: GL.FLOAT\n          });\n          results[id].maxTexture = resources[`${id}-maxTexture`];\n        }\n      }\n    }\n    this._trackGPUResultBuffers(results, weights);\n    return results;\n  }\n\n  _renderAggregateData(opts) {\n    const {\n      cellSize,\n      projectPoints,\n      attributes,\n      moduleSettings,\n      numCol,\n      numRow,\n      weights,\n      translation,\n      scaling\n    } = opts;\n    const {maxMinFramebuffers, minFramebuffers, maxFramebuffers} = this.state;\n\n    const gridSize = [numCol, numRow];\n    const parameters = {\n      blend: true,\n      depthTest: false,\n      blendFunc: [GL.ONE, GL.ONE]\n    };\n    const uniforms = {\n      cellSize,\n      gridSize,\n      projectPoints,\n      translation,\n      scaling\n    };\n\n    for (const id in weights) {\n      const {needMin, needMax} = weights[id];\n      const combineMaxMin = needMin && needMax && weights[id].combineMaxMin;\n      this._renderToWeightsTexture({\n        id,\n        parameters,\n        moduleSettings,\n        uniforms,\n        gridSize,\n        attributes,\n        weights\n      });\n      if (combineMaxMin) {\n        this._renderToMaxMinTexture({\n          id,\n          parameters: {...parameters, blendEquation: MAX_MIN_BLEND_EQUATION},\n          gridSize,\n          minOrMaxFb: maxMinFramebuffers[id],\n          clearParams: {clearColor: [0, 0, 0, MAX_32_BIT_FLOAT]},\n          combineMaxMin\n        });\n      } else {\n        if (needMin) {\n          this._renderToMaxMinTexture({\n            id,\n            parameters: {...parameters, blendEquation: MIN_BLEND_EQUATION},\n            gridSize,\n            minOrMaxFb: minFramebuffers[id],\n            clearParams: {clearColor: [MAX_32_BIT_FLOAT, MAX_32_BIT_FLOAT, MAX_32_BIT_FLOAT, 0]},\n            combineMaxMin\n          });\n        }\n        if (needMax) {\n          this._renderToMaxMinTexture({\n            id,\n            parameters: {...parameters, blendEquation: MAX_BLEND_EQUATION},\n            gridSize,\n            minOrMaxFb: maxFramebuffers[id],\n            clearParams: {clearColor: [0, 0, 0, 0]},\n            combineMaxMin\n          });\n        }\n      }\n    }\n  }\n\n  // render all aggregated grid-cells to generate Min, Max or MaxMin data texture\n  _renderToMaxMinTexture(opts) {\n    const {id, parameters, gridSize, minOrMaxFb, combineMaxMin, clearParams = {}} = opts;\n    const {framebuffers} = this.state;\n    const {gl, allAggregationModel} = this;\n\n    withParameters(\n      gl,\n      {\n        ...clearParams,\n        framebuffer: minOrMaxFb,\n        viewport: [0, 0, gridSize[0], gridSize[1]]\n      },\n      () => {\n        gl.clear(gl.COLOR_BUFFER_BIT);\n\n        allAggregationModel.draw({\n          parameters,\n          uniforms: {\n            uSampler: framebuffers[id].texture,\n            gridSize,\n            combineMaxMin\n          }\n        });\n      }\n    );\n  }\n\n  // render all data points to aggregate weights\n  _renderToWeightsTexture(opts) {\n    const {id, parameters, moduleSettings, uniforms, gridSize, weights} = opts;\n    const {framebuffers, equations, weightAttributes} = this.state;\n    const {gl, gridAggregationModel} = this;\n    const {operation} = weights[id];\n\n    const clearColor =\n      operation === AGGREGATION_OPERATION.MIN\n        ? [MAX_32_BIT_FLOAT, MAX_32_BIT_FLOAT, MAX_32_BIT_FLOAT, 0]\n        : [0, 0, 0, 0];\n    withParameters(\n      gl,\n      {\n        framebuffer: framebuffers[id],\n        viewport: [0, 0, gridSize[0], gridSize[1]],\n        clearColor\n      },\n      () => {\n        gl.clear(gl.COLOR_BUFFER_BIT);\n\n        const attributes = {weights: weightAttributes[id]};\n        gridAggregationModel.draw({\n          parameters: {...parameters, blendEquation: equations[id]},\n          moduleSettings,\n          uniforms,\n          attributes\n        });\n      }\n    );\n\n    if (operation === AGGREGATION_OPERATION.MEAN) {\n      const {meanTextures, textures} = this.state;\n      const transformOptions = {\n        _sourceTextures: {aggregationValues: meanTextures[id]}, // contains aggregated data\n        _targetTexture: textures[id], // store mean values,\n        elementCount: textures[id].width * textures[id].height\n      };\n      if (this.meanTransform) {\n        this.meanTransform.update(transformOptions);\n      } else {\n        this.meanTransform = getMeanTransform(gl, transformOptions);\n      }\n      this.meanTransform.run({\n        parameters: {\n          blend: false,\n          depthTest: false\n        }\n      });\n\n      // update framebuffer with mean results so readPixelsToBuffer returns mean values\n      framebuffers[id].attach({[GL.COLOR_ATTACHMENT0]: textures[id]});\n    }\n  }\n\n  _runAggregation(opts) {\n    this._updateModels(opts);\n    this._setupFramebuffers(opts);\n    this._renderAggregateData(opts);\n    const results = this._getAggregateData(opts);\n    this.setState({results});\n    return results;\n  }\n\n  // set up framebuffer for each weight\n  /* eslint-disable complexity, max-depth, max-statements*/\n  _setupFramebuffers(opts) {\n    const {\n      textures,\n      framebuffers,\n      maxMinFramebuffers,\n      minFramebuffers,\n      maxFramebuffers,\n      meanTextures,\n      equations\n    } = this.state;\n    const {weights} = opts;\n    const {numCol, numRow} = opts;\n    const framebufferSize = {width: numCol, height: numRow};\n    for (const id in weights) {\n      const {needMin, needMax, combineMaxMin, operation} = weights[id];\n      textures[id] =\n        weights[id].aggregationTexture ||\n        textures[id] ||\n        getFloatTexture(this.gl, {id: `${id}-texture`, width: numCol, height: numRow});\n      textures[id].resize(framebufferSize);\n      let texture = textures[id];\n      if (operation === AGGREGATION_OPERATION.MEAN) {\n        // For MEAN, we first aggregatet into a temp texture\n        meanTextures[id] =\n          meanTextures[id] ||\n          getFloatTexture(this.gl, {id: `${id}-mean-texture`, width: numCol, height: numRow});\n        meanTextures[id].resize(framebufferSize);\n        texture = meanTextures[id];\n      }\n      if (framebuffers[id]) {\n        framebuffers[id].attach({[GL.COLOR_ATTACHMENT0]: texture});\n      } else {\n        framebuffers[id] = getFramebuffer(this.gl, {\n          id: `${id}-fb`,\n          width: numCol,\n          height: numRow,\n          texture\n        });\n      }\n      framebuffers[id].resize(framebufferSize);\n      equations[id] = EQUATION_MAP[operation] || EQUATION_MAP.SUM;\n      // For min/max framebuffers will use default size 1X1\n      if (needMin || needMax) {\n        if (needMin && needMax && combineMaxMin) {\n          if (!maxMinFramebuffers[id]) {\n            texture = weights[id].maxMinTexture || this._getMinMaxTexture(`${id}-maxMinTexture`);\n            maxMinFramebuffers[id] = getFramebuffer(this.gl, {id: `${id}-maxMinFb`, texture});\n          }\n        } else {\n          if (needMin) {\n            if (!minFramebuffers[id]) {\n              texture = weights[id].minTexture || this._getMinMaxTexture(`${id}-minTexture`);\n              minFramebuffers[id] = getFramebuffer(this.gl, {\n                id: `${id}-minFb`,\n                texture\n              });\n            }\n          }\n          if (needMax) {\n            if (!maxFramebuffers[id]) {\n              texture = weights[id].maxTexture || this._getMinMaxTexture(`${id}-maxTexture`);\n              maxFramebuffers[id] = getFramebuffer(this.gl, {\n                id: `${id}-maxFb`,\n                texture\n              });\n            }\n          }\n        }\n      }\n    }\n  }\n  /* eslint-enable complexity, max-depth, max-statements */\n\n  _getMinMaxTexture(name) {\n    const {resources} = this.state;\n    if (!resources[name]) {\n      resources[name] = getFloatTexture(this.gl, {id: `resourceName`});\n    }\n    return resources[name];\n  }\n\n  _setupModels({numCol = 0, numRow = 0} = {}) {\n    const {gl} = this;\n    const {shaderOptions} = this.state;\n    this.gridAggregationModel?.delete();\n    this.gridAggregationModel = getAggregationModel(gl, shaderOptions);\n    if (!this.allAggregationModel) {\n      const instanceCount = numCol * numRow;\n      this.allAggregationModel = getAllAggregationModel(gl, instanceCount);\n    }\n  }\n\n  // set up buffers for all weights\n  _setupWeightAttributes(opts) {\n    const {weightAttributes} = this.state;\n    const {weights} = opts;\n    for (const id in weights) {\n      weightAttributes[id] = opts.attributes[id];\n    }\n  }\n\n  // GPU Aggregation results are provided in Buffers, if new Buffer objects are created track them for later deletion.\n  /* eslint-disable max-depth */\n  _trackGPUResultBuffers(results, weights) {\n    const {resources} = this.state;\n    for (const id in results) {\n      if (results[id]) {\n        for (const bufferName of BUFFER_NAMES) {\n          if (results[id][bufferName] && weights[id][bufferName] !== results[id][bufferName]) {\n            // No result buffer is provided in weights object, `readPixelsToBuffer` has created a new Buffer object\n            // collect the new buffer for garabge collection\n            const name = `gpu-result-${id}-${bufferName}`;\n            if (resources[name]) {\n              resources[name].delete();\n            }\n            resources[name] = results[id][bufferName];\n          }\n        }\n      }\n    }\n  }\n  /* eslint-enable max-depth */\n\n  _updateModels(opts) {\n    const {vertexCount, attributes, numCol, numRow} = opts;\n    const {modelDirty} = this.state;\n\n    if (modelDirty) {\n      this._setupModels(opts);\n      this.setState({modelDirty: false});\n    }\n\n    // this maps color/elevation to weight name.\n    this._setupWeightAttributes(opts);\n\n    this.gridAggregationModel.setVertexCount(vertexCount);\n    this.gridAggregationModel.setAttributes(attributes);\n\n    this.allAggregationModel.setInstanceCount(numCol * numRow);\n  }\n}\n\n// HELPER METHODS\n\nfunction normalizeWeightParams(weights) {\n  const result = {};\n  for (const id in weights) {\n    result[id] = {...DEFAULT_WEIGHT_PARAMS, ...weights[id]};\n  }\n  return result;\n}\n\nfunction deleteResources(resources) {\n  resources = Array.isArray(resources) ? resources : [resources];\n  resources.forEach(obj => {\n    for (const name in obj) {\n      obj[name].delete();\n    }\n  });\n}\n\nfunction getAggregationModel(gl, shaderOptions) {\n  const shaders = mergeShaders(\n    {\n      vs: AGGREGATE_TO_GRID_VS,\n      fs: AGGREGATE_TO_GRID_FS,\n      modules: [fp64arithmetic, project32]\n    },\n    shaderOptions\n  );\n\n  return new Model(gl, {\n    id: 'Gird-Aggregation-Model',\n    vertexCount: 1,\n    drawMode: GL.POINTS,\n    ...shaders\n  });\n}\n\nfunction getAllAggregationModel(gl, instanceCount) {\n  return new Model(gl, {\n    id: 'All-Aggregation-Model',\n    vs: AGGREGATE_ALL_VS,\n    fs: AGGREGATE_ALL_FS,\n    modules: [fp64arithmetic],\n    vertexCount: 1,\n    drawMode: GL.POINTS,\n    isInstanced: true,\n    instanceCount,\n    attributes: {\n      position: [0, 0]\n    }\n  });\n}\n\nfunction getMeanTransform(gl, opts) {\n  return new Transform(gl, {\n    vs: TRANSFORM_MEAN_VS,\n    _targetTextureVarying: 'meanValues',\n    ...opts\n  });\n}\n"],"file":"gpu-grid-aggregator.js"}