"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _core = require("@deck.gl/core");

var _shaders = require("./shaders.glsl");

var _vec = require("gl-matrix/vec3");

const defaultProps = {
  getDashArray: {
    type: 'accessor',
    value: [0, 0]
  },
  getOffset: {
    type: 'accessor',
    value: 0
  },
  dashJustified: false,
  dashGapPickable: false
};

class PathStyleExtension extends _core.LayerExtension {
  constructor({
    dash = false,
    offset = false,
    highPrecisionDash = false
  } = {}) {
    super({
      dash: dash || highPrecisionDash,
      offset,
      highPrecisionDash
    });
  }

  isEnabled(layer) {
    return layer.state.pathTesselator;
  }

  getShaders(extension) {
    if (!extension.isEnabled(this)) {
      return null;
    }

    let result = {};

    if (extension.opts.dash) {
      result = (0, _core._mergeShaders)(result, _shaders.dashShaders);
    }

    if (extension.opts.offset) {
      result = (0, _core._mergeShaders)(result, _shaders.offsetShaders);
    }

    return result;
  }

  initializeState(context, extension) {
    const attributeManager = this.getAttributeManager();

    if (!attributeManager || !extension.isEnabled(this)) {
      return;
    }

    extension.enabled = true;

    if (extension.opts.dash) {
      attributeManager.addInstanced({
        instanceDashArrays: {
          size: 2,
          accessor: 'getDashArray'
        }
      });
    }

    if (extension.opts.highPrecisionDash) {
      attributeManager.addInstanced({
        instanceDashOffsets: {
          size: 1,
          accessor: 'getPath',
          transform: extension.getDashOffsets.bind(this)
        }
      });
    }

    if (extension.opts.offset) {
      attributeManager.addInstanced({
        instanceOffsets: {
          size: 1,
          accessor: 'getOffset'
        }
      });
    }
  }

  updateState(params, extension) {
    if (!extension.isEnabled(this)) {
      return;
    }

    const uniforms = {};

    if (extension.opts.dash) {
      uniforms.dashAlignMode = this.props.dashJustified ? 1 : 0;
      uniforms.dashGapPickable = Boolean(this.props.dashGapPickable);
    }

    this.state.model.setUniforms(uniforms);
  }

  getDashOffsets(path) {
    const result = [0];
    const positionSize = this.props.positionFormat === 'XY' ? 2 : 3;
    const isNested = Array.isArray(path[0]);
    const geometrySize = isNested ? path.length : path.length / positionSize;
    let p;
    let prevP;

    for (let i = 0; i < geometrySize - 1; i++) {
      p = isNested ? path[i] : path.slice(i * positionSize, i * positionSize + positionSize);
      p = this.projectPosition(p);

      if (i > 0) {
        result[i] = result[i - 1] + (0, _vec.dist)(prevP, p);
      }

      prevP = p;
    }

    return result;
  }

}

exports.default = PathStyleExtension;
PathStyleExtension.extensionName = 'PathStyleExtension';
PathStyleExtension.defaultProps = defaultProps;
//# sourceMappingURL=path-style.js.map