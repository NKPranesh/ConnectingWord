"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _core = require("@deck.gl/core");

var _geoLayers = require("@deck.gl/geo-layers");

var _layers = require("@deck.gl/layers");

var _api = require("../api");

var _mapsApiCommon = require("../api/maps-api-common");

var _config = require("../config");

const defaultProps = {
  data: null,
  type: null,
  onDataLoad: {
    type: 'function',
    value: data => {},
    compare: false
  },
  onDataError: {
    type: 'function',
    value: null,
    compare: false,
    optional: true
  },
  credentials: null,
  connection: null,
  geoColumn: null,
  columns: {
    type: 'array',
    value: null
  }
};

class CartoLayer extends _core.CompositeLayer {
  initializeState() {
    this.state = {
      data: null,
      apiVersion: null
    };
  }

  get isLoaded() {
    return this.getSubLayers().length > 0 && super.isLoaded;
  }

  _checkProps(props) {
    const {
      type,
      credentials,
      connection,
      geoColumn,
      columns
    } = props;
    const localCreds = { ...(0, _config.getDefaultCredentials)(),
      ...credentials
    };
    const {
      apiVersion
    } = localCreds;

    _core.log.assert(Object.values(_api.API_VERSIONS).includes(apiVersion), "Invalid apiVersion ".concat(apiVersion, ". Use API_VERSIONS enum."));

    if (apiVersion === _api.API_VERSIONS.V1 || apiVersion === _api.API_VERSIONS.V2) {
      _core.log.assert(type === _mapsApiCommon.MAP_TYPES.QUERY || type === _mapsApiCommon.MAP_TYPES.TILESET, "Invalid type ".concat(type, ". Use type MAP_TYPES.QUERY or MAP_TYPES.TILESET for apiVersion ").concat(apiVersion));

      _core.log.assert(!connection, "Connection prop is not supported for apiVersion ".concat(apiVersion));

      _core.log.assert(!geoColumn, "geoColumn prop is not supported for apiVersion ".concat(apiVersion));

      _core.log.assert(!columns, "columns prop is not supported for apiVersion ".concat(apiVersion));
    } else if (apiVersion === _api.API_VERSIONS.V3) {
      _core.log.assert(connection, 'Missing mandatory connection parameter');

      _core.log.assert(Object.values(_mapsApiCommon.MAP_TYPES).includes(type), "Invalid type ".concat(type, ". Use MAP_TYPES enum."));

      if (type !== _mapsApiCommon.MAP_TYPES.TABLE) {
        _core.log.assert(!geoColumn, "geoColumn prop is only supported for type ".concat(_mapsApiCommon.MAP_TYPES.TABLE));

        _core.log.assert(!columns, "columns prop is only supported for type ".concat(_mapsApiCommon.MAP_TYPES.TABLE));
      }

      if (columns) {
        _core.log.assert(Array.isArray(columns), 'columns prop must be an Array');
      }
    }
  }

  updateState({
    props,
    oldProps,
    changeFlags
  }) {
    this._checkProps(props);

    const shouldUpdateData = changeFlags.dataChanged || props.connection !== oldProps.connection || props.geoColumn !== oldProps.geoColumn || JSON.stringify(props.columns) !== JSON.stringify(oldProps.columns) || props.type !== oldProps.type || JSON.stringify(props.credentials) !== JSON.stringify(oldProps.credentials);

    if (shouldUpdateData) {
      this.setState({
        data: null,
        apiVersion: null
      });

      this._updateData();
    }
  }

  async _updateData() {
    try {
      const {
        type,
        data: source,
        connection,
        credentials,
        geoColumn,
        columns
      } = this.props;
      const localConfig = { ...(0, _config.getDefaultCredentials)(),
        ...credentials
      };
      const {
        apiVersion
      } = localConfig;
      let data;

      if (apiVersion === _api.API_VERSIONS.V3) {
        data = await (0, _api.getData)({
          type,
          source,
          connection,
          credentials,
          geoColumn,
          columns
        });
      } else if (apiVersion === _api.API_VERSIONS.V1 || apiVersion === _api.API_VERSIONS.V2) {
        data = await (0, _api.getDataV2)({
          type,
          source,
          credentials
        });
      } else {
        _core.log.assert("Unknow apiVersion ".concat(apiVersion, ". Use API_VERSIONS enum."));
      }

      this.setState({
        data,
        apiVersion
      });
      this.props.onDataLoad(data);
    } catch (err) {
      if (this.props.onDataError) {
        this.props.onDataError(err);
      } else {
        throw err;
      }
    }
  }

  renderLayers() {
    const {
      data,
      apiVersion
    } = this.state;
    const {
      type
    } = this.props;
    if (!data) return null;
    const {
      updateTriggers
    } = this.props;
    let layer;

    if (apiVersion === _api.API_VERSIONS.V1 || apiVersion === _api.API_VERSIONS.V2 || type === _mapsApiCommon.MAP_TYPES.TILESET) {
      layer = _geoLayers.MVTLayer;
    } else {
      layer = _layers.GeoJsonLayer;
    }

    const props = { ...this.props
    };
    delete props.data;
    return new layer(props, this.getSubLayerProps({
      id: "carto-".concat(layer.layerName),
      data,
      updateTriggers
    }));
  }

}

exports.default = CartoLayer;
CartoLayer.layerName = 'CartoLayer';
CartoLayer.defaultProps = defaultProps;
//# sourceMappingURL=carto-layer.js.map