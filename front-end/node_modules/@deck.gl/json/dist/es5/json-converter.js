"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _assert = _interopRequireDefault(require("./utils/assert"));

var _jsonConfiguration = _interopRequireDefault(require("./json-configuration"));

var _instantiateClass = require("./helpers/instantiate-class");

var _syntacticSugar = require("./syntactic-sugar");

var _parseJson = _interopRequireDefault(require("./helpers/parse-json"));

const isObject = value => value && typeof value === 'object';

class JSONConverter {
  constructor(props) {
    this.log = console;
    this.configuration = {};

    this.onJSONChange = () => {};

    this.json = null;
    this.convertedJson = null;
    this.setProps(props);
  }

  finalize() {}

  setProps(props) {
    if ('configuration' in props) {
      this.configuration = props.configuration instanceof _jsonConfiguration.default ? props.configuration : new _jsonConfiguration.default(props.configuration);
    }

    if ('onJSONChange' in props) {
      this.onJSONChange = props.onJSONChange;
    }
  }

  mergeConfiguration(config) {
    this.configuration.merge(config);
  }

  convert(json) {
    if (!json || json === this.json) {
      return this.convertedJson;
    }

    this.json = json;
    const parsedJSON = (0, _parseJson.default)(json);
    let convertedJson = convertJSON(parsedJSON, this.configuration);
    convertedJson = this.configuration.postProcessConvertedJson(convertedJson);
    this.convertedJson = convertedJson;
    return convertedJson;
  }

  convertJson(json) {
    return this.convert(json);
  }

}

exports.default = JSONConverter;

function convertJSON(json, configuration) {
  configuration = new _jsonConfiguration.default(configuration);
  return convertJSONRecursively(json, '', configuration);
}

function convertJSONRecursively(json, key, configuration) {
  if (Array.isArray(json)) {
    return json.map((element, i) => convertJSONRecursively(element, String(i), configuration));
  }

  if (isClassInstance(json, configuration)) {
    return convertClassInstance(json, configuration);
  }

  if (isObject(json)) {
    if (_syntacticSugar.FUNCTION_KEY in json) {
      return convertFunctionObject(json, configuration);
    }

    return convertPlainObject(json, configuration);
  }

  if (typeof json === 'string') {
    return convertString(json, key, configuration);
  }

  return json;
}

function isClassInstance(json, configuration) {
  const {
    typeKey
  } = configuration;
  const isClass = isObject(json) && Boolean(json[typeKey]);
  return isClass;
}

function convertClassInstance(json, configuration) {
  const {
    typeKey
  } = configuration;
  const type = json[typeKey];
  let props = { ...json
  };
  delete props[typeKey];
  props = convertPlainObject(props, configuration);
  return (0, _instantiateClass.instantiateClass)(type, props, configuration);
}

function convertFunctionObject(json, configuration) {
  const {
    functionKey
  } = configuration;
  let props = { ...json
  };
  delete props[functionKey];
  props = convertPlainObject(props, configuration);
  const targetFunction = json[functionKey];
  const availableFunctions = configuration.functions;
  const matchedFn = availableFunctions[targetFunction];
  (0, _assert.default)(matchedFn, "Function ".concat(targetFunction, " not found."));
  return matchedFn(props);
}

function convertPlainObject(json, configuration) {
  (0, _assert.default)(isObject(json));
  const result = {};

  for (const key in json) {
    const value = json[key];
    result[key] = convertJSONRecursively(value, key, configuration);
  }

  return result;
}

function convertString(string, key, configuration) {
  if (string.startsWith(_syntacticSugar.FUNCTION_IDENTIFIER) && configuration.convertFunction) {
    string = string.replace(_syntacticSugar.FUNCTION_IDENTIFIER, '');
    return configuration.convertFunction(string, configuration);
  }

  if (string.startsWith(_syntacticSugar.CONSTANT_IDENTIFIER)) {
    string = string.replace(_syntacticSugar.CONSTANT_IDENTIFIER, '');

    if (configuration.constants[string]) {
      return configuration.constants[string];
    }

    const [enumVarName, enumValName] = string.split('.');
    return configuration.enumerations[enumVarName][enumValName];
  }

  return string;
}
//# sourceMappingURL=json-converter.js.map