{"version":3,"sources":["../../../../src/lib/attribute/attribute-manager.js"],"names":["TRACE_INVALIDATE","TRACE_UPDATE_START","TRACE_UPDATE_END","TRACE_ATTRIBUTE_UPDATE_START","TRACE_ATTRIBUTE_ALLOCATE","TRACE_ATTRIBUTE_UPDATE_END","AttributeManager","constructor","gl","id","stats","timeline","attributes","updateTriggers","accessors","needsRedraw","userData","attributeTransitionManager","AttributeTransitionManager","Object","seal","finalize","attributeName","delete","getNeedsRedraw","opts","clearRedrawFlags","redraw","setNeedsRedraw","add","updaters","_add","addInstanced","instanced","remove","attributeNameArray","i","length","name","undefined","invalidate","triggerName","dataRange","invalidatedAttributes","_invalidateTrigger","invalidateAll","setNeedsUpdate","update","data","numInstances","startIndices","transitions","props","buffers","context","updated","get","timeStart","attribute","accessorName","settings","accessor","log","removed","setExternalBuffer","setBinaryValue","setConstantValue","needsUpdate","_updateAttribute","timeEnd","updateTransition","transitionUpdated","run","getAttributes","getChangedAttributes","clearChangedFlags","changedAttributes","hasAttribute","getShaderAttributes","excludeAttributes","shaderAttributes","assign","getAccessors","extraProps","warn","_createAttribute","_mapUpdateTriggersToAttributes","isIndexed","elements","constant","size","value","divisor","Attribute","triggers","getUpdateTriggers","forEach","push","allocate","updateBuffer"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/* eslint-disable guard-for-in */\nimport Attribute from './attribute';\nimport log from '../../utils/log';\nimport debug from '../../debug';\n\nimport AttributeTransitionManager from './attribute-transition-manager';\n\nconst TRACE_INVALIDATE = 'attributeManager.invalidate';\nconst TRACE_UPDATE_START = 'attributeManager.updateStart';\nconst TRACE_UPDATE_END = 'attributeManager.updateEnd';\nconst TRACE_ATTRIBUTE_UPDATE_START = 'attribute.updateStart';\nconst TRACE_ATTRIBUTE_ALLOCATE = 'attribute.allocate';\nconst TRACE_ATTRIBUTE_UPDATE_END = 'attribute.updateEnd';\n\nexport default class AttributeManager {\n  /**\n   * @classdesc\n   * Automated attribute generation and management. Suitable when a set of\n   * vertex shader attributes are generated by iteration over a data array,\n   * and updates to these attributes are needed either when the data itself\n   * changes, or when other data relevant to the calculations change.\n   *\n   * - First the application registers descriptions of its dynamic vertex\n   *   attributes using AttributeManager.add().\n   * - Then, when any change that affects attributes is detected by the\n   *   application, the app will call AttributeManager.invalidate().\n   * - Finally before it renders, it calls AttributeManager.update() to\n   *   ensure that attributes are automatically rebuilt if anything has been\n   *   invalidated.\n   *\n   * The application provided update functions describe how attributes\n   * should be updated from a data array and are expected to traverse\n   * that data array (or iterable) and fill in the attribute's typed array.\n   *\n   * Note that the attribute manager intentionally does not do advanced\n   * change detection, but instead makes it easy to build such detection\n   * by offering the ability to \"invalidate\" each attribute separately.\n   */\n  constructor(gl, {id = 'attribute-manager', stats, timeline} = {}) {\n    this.id = id;\n    this.gl = gl;\n\n    this.attributes = {};\n\n    this.updateTriggers = {};\n    this.accessors = {};\n    this.needsRedraw = true;\n\n    this.userData = {};\n    this.stats = stats;\n\n    this.attributeTransitionManager = new AttributeTransitionManager(gl, {\n      id: `${id}-transitions`,\n      timeline\n    });\n\n    // For debugging sanity, prevent uninitialized members\n    Object.seal(this);\n  }\n\n  finalize() {\n    for (const attributeName in this.attributes) {\n      this.attributes[attributeName].delete();\n    }\n    this.attributeTransitionManager.finalize();\n  }\n\n  // Returns the redraw flag, optionally clearing it.\n  // Redraw flag will be set if any attributes attributes changed since\n  // flag was last cleared.\n  //\n  // @param {String} [clearRedrawFlags=false] - whether to clear the flag\n  // @return {false|String} - reason a redraw is needed.\n  getNeedsRedraw(opts = {clearRedrawFlags: false}) {\n    const redraw = this.needsRedraw;\n    this.needsRedraw = this.needsRedraw && !opts.clearRedrawFlags;\n    return redraw && this.id;\n  }\n\n  // Sets the redraw flag.\n  // @param {Boolean} redraw=true\n  // @return {AttributeManager} - for chaining\n  setNeedsRedraw(redraw = true) {\n    this.needsRedraw = true;\n    return this;\n  }\n\n  // Adds attributes\n  add(attributes, updaters) {\n    this._add(attributes, updaters);\n  }\n\n  // Adds attributes\n  addInstanced(attributes, updaters) {\n    this._add(attributes, updaters, {instanced: 1});\n  }\n\n  /**\n   * Removes attributes\n   * Takes an array of attribute names and delete them from\n   * the attribute map if they exists\n   *\n   * @example\n   * attributeManager.remove(['position']);\n   *\n   * @param {Object} attributeNameArray - attribute name array (see above)\n   */\n  remove(attributeNameArray) {\n    for (let i = 0; i < attributeNameArray.length; i++) {\n      const name = attributeNameArray[i];\n      if (this.attributes[name] !== undefined) {\n        this.attributes[name].delete();\n        delete this.attributes[name];\n      }\n    }\n  }\n\n  // Marks an attribute for update\n  invalidate(triggerName, dataRange) {\n    const invalidatedAttributes = this._invalidateTrigger(triggerName, dataRange);\n    // For performance tuning\n    debug(TRACE_INVALIDATE, this, triggerName, invalidatedAttributes);\n  }\n\n  invalidateAll(dataRange) {\n    for (const attributeName in this.attributes) {\n      this.attributes[attributeName].setNeedsUpdate(attributeName, dataRange);\n    }\n    // For performance tuning\n    debug(TRACE_INVALIDATE, this, 'all');\n  }\n\n  // Ensure all attribute buffers are updated from props or data.\n  update({\n    data,\n    numInstances,\n    startIndices = null,\n    transitions,\n    props = {},\n    buffers = {},\n    context = {}\n  } = {}) {\n    // keep track of whether some attributes are updated\n    let updated = false;\n\n    debug(TRACE_UPDATE_START, this);\n    if (this.stats) {\n      this.stats.get('Update Attributes').timeStart();\n    }\n\n    for (const attributeName in this.attributes) {\n      const attribute = this.attributes[attributeName];\n      const accessorName = attribute.settings.accessor;\n      attribute.startIndices = startIndices;\n\n      if (props[attributeName]) {\n        log.removed(`props.${attributeName}`, `data.attributes.${attributeName}`)();\n      }\n\n      if (attribute.setExternalBuffer(buffers[attributeName])) {\n        // Step 1: try update attribute directly from external buffers\n      } else if (attribute.setBinaryValue(buffers[accessorName], data.startIndices)) {\n        // Step 2: try set packed value from external typed array\n      } else if (!buffers[accessorName] && attribute.setConstantValue(props[accessorName])) {\n        // Step 3: try set constant value from props\n        // Note: if buffers[accessorName] is supplied, ignore props[accessorName]\n        // This may happen when setBinaryValue falls through to use the auto updater\n      } else if (attribute.needsUpdate()) {\n        // Step 4: update via updater callback\n        updated = true;\n        this._updateAttribute({\n          attribute,\n          numInstances,\n          data,\n          props,\n          context\n        });\n      }\n\n      this.needsRedraw |= attribute.needsRedraw();\n    }\n\n    if (updated) {\n      // Only initiate alloc/update (and logging) if actually needed\n      debug(TRACE_UPDATE_END, this, numInstances);\n    }\n\n    if (this.stats) {\n      this.stats.get('Update Attributes').timeEnd();\n    }\n\n    this.attributeTransitionManager.update({\n      attributes: this.attributes,\n      numInstances,\n      transitions\n    });\n  }\n\n  // Update attribute transition to the current timestamp\n  // Returns `true` if any transition is in progress\n  updateTransition() {\n    const {attributeTransitionManager} = this;\n    const transitionUpdated = attributeTransitionManager.run();\n    this.needsRedraw = this.needsRedraw || transitionUpdated;\n    return transitionUpdated;\n  }\n\n  /**\n   * Returns all attribute descriptors\n   * Note: Format matches luma.gl Model/Program.setAttributes()\n   * @return {Object} attributes - descriptors\n   */\n  getAttributes() {\n    return this.attributes;\n  }\n\n  /**\n   * Returns changed attribute descriptors\n   * This indicates which WebGLBuffers need to be updated\n   * @return {Object} attributes - descriptors\n   */\n  getChangedAttributes(opts = {clearChangedFlags: false}) {\n    const {attributes, attributeTransitionManager} = this;\n\n    const changedAttributes = {...attributeTransitionManager.getAttributes()};\n\n    for (const attributeName in attributes) {\n      const attribute = attributes[attributeName];\n      if (attribute.needsRedraw(opts) && !attributeTransitionManager.hasAttribute(attributeName)) {\n        changedAttributes[attributeName] = attribute;\n      }\n    }\n\n    return changedAttributes;\n  }\n\n  // Returns shader attributes\n  getShaderAttributes(attributes, excludeAttributes = {}) {\n    if (!attributes) {\n      attributes = this.getAttributes();\n    }\n    const shaderAttributes = {};\n    for (const attributeName in attributes) {\n      if (!excludeAttributes[attributeName]) {\n        Object.assign(shaderAttributes, attributes[attributeName].getShaderAttributes());\n      }\n    }\n    return shaderAttributes;\n  }\n\n  // PROTECTED METHODS - Only to be used by collaborating classes, not by apps\n\n  // Returns object containing all accessors as keys, with non-null values\n  // @return {Object} - accessors object\n  getAccessors() {\n    return this.updateTriggers;\n  }\n\n  // PRIVATE METHODS\n\n  // Used to register an attribute\n  _add(attributes, updaters, extraProps = {}) {\n    if (updaters) {\n      log.warn('AttributeManager.add({updaters}) - updater map no longer supported')();\n    }\n\n    for (const attributeName in attributes) {\n      const attribute = attributes[attributeName];\n\n      // Initialize the attribute descriptor, with WebGL and metadata fields\n      this.attributes[attributeName] = this._createAttribute(attributeName, attribute, extraProps);\n    }\n\n    this._mapUpdateTriggersToAttributes();\n  }\n  /* eslint-enable max-statements */\n\n  _createAttribute(name, attribute, extraProps) {\n    // For expected default values see:\n    // https://github.com/visgl/luma.gl/blob/1affe21352e289eeaccee2a876865138858a765c/modules/webgl/src/classes/accessor.js#L5-L13\n    // and https://deck.gl/docs/api-reference/core/attribute-manager#add\n    const props = {\n      ...attribute,\n      id: name,\n      isIndexed: attribute.isIndexed || attribute.elements || false,\n      // Luma fields\n      constant: attribute.constant || false,\n      size: (attribute.elements && 1) || attribute.size || 1,\n      value: attribute.value || null,\n      divisor: attribute.instanced || extraProps.instanced ? 1 : attribute.divisor || 0\n    };\n\n    return new Attribute(this.gl, props);\n  }\n\n  // build updateTrigger name to attribute name mapping\n  _mapUpdateTriggersToAttributes() {\n    const triggers = {};\n\n    for (const attributeName in this.attributes) {\n      const attribute = this.attributes[attributeName];\n      attribute.getUpdateTriggers().forEach(triggerName => {\n        if (!triggers[triggerName]) {\n          triggers[triggerName] = [];\n        }\n        triggers[triggerName].push(attributeName);\n      });\n    }\n\n    this.updateTriggers = triggers;\n  }\n\n  _invalidateTrigger(triggerName, dataRange) {\n    const {attributes, updateTriggers} = this;\n    const invalidatedAttributes = updateTriggers[triggerName];\n\n    if (invalidatedAttributes) {\n      invalidatedAttributes.forEach(name => {\n        const attribute = attributes[name];\n        if (attribute) {\n          attribute.setNeedsUpdate(attribute.id, dataRange);\n        }\n      });\n    }\n    return invalidatedAttributes;\n  }\n\n  _updateAttribute(opts) {\n    const {attribute, numInstances} = opts;\n    debug(TRACE_ATTRIBUTE_UPDATE_START, attribute);\n\n    if (attribute.constant) {\n      // The attribute is flagged as constant outside of an update cycle\n      // Skip allocation and updater call\n      attribute.setConstantValue(attribute.value);\n      return;\n    }\n\n    if (attribute.allocate(numInstances)) {\n      debug(TRACE_ATTRIBUTE_ALLOCATE, attribute, numInstances);\n    }\n\n    // Calls update on any buffers that need update\n    const updated = attribute.updateBuffer(opts);\n    if (updated) {\n      this.needsRedraw = true;\n      debug(TRACE_ATTRIBUTE_UPDATE_END, attribute, numInstances);\n    }\n  }\n}\n"],"file":"attribute-manager.js"}