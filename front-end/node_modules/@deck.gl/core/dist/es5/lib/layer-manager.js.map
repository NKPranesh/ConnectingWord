{"version":3,"sources":["../../../src/lib/layer-manager.js"],"names":["TRACE_SET_LAYERS","TRACE_ACTIVATE_VIEWPORT","INITIAL_CONTEXT","Object","seal","layerManager","resourceManager","deck","gl","stats","shaderCache","pickingFBO","mousePosition","userData","LayerManager","constructor","viewport","timeline","lastRenderedLayers","layers","ResourceManager","protocol","context","programManager","Stats","id","Viewport","Timeline","_nextLayers","_needsRedraw","_needsUpdate","_debug","activateViewport","bind","finalize","layer","_finalizeLayer","needsRedraw","opts","clearRedrawFlags","redraw","layerNeedsRedraw","getNeedsRedraw","needsUpdate","setNeedsRedraw","reason","setNeedsUpdate","getLayers","layerIds","filter","find","layerId","indexOf","setProps","props","debug","onError","setLayers","newLayers","Boolean","_updateLayers","updateLayers","_handleError","stage","error","raiseError","oldLayers","oldLayerMap","oldLayer","log","warn","generatedLayers","_updateSublayersRecursively","_finalizeOldLayers","hasUniformTransition","newLayer","sublayers","validateProps","_initializeLayer","_transferLayerState","_updateLayer","push","isComposite","getSubLayers","err","_initialize","lifecycle","LIFECYCLE","INITIALIZED","_transferState","MATCHED","AWAITING_GC","_update","AWAITING_FINALIZATION","_finalize","FINALIZED"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {Timeline} from '@luma.gl/core';\nimport {LIFECYCLE} from '../lifecycle/constants';\nimport log from '../utils/log';\nimport debug from '../debug';\nimport {flatten} from '../utils/flatten';\nimport {Stats} from 'probe.gl';\nimport ResourceManager from './resource/resource-manager';\n\nimport Viewport from '../viewports/viewport';\nimport {createProgramManager} from '../shaderlib';\n\nconst TRACE_SET_LAYERS = 'layerManager.setLayers';\nconst TRACE_ACTIVATE_VIEWPORT = 'layerManager.activateViewport';\n\n// CONTEXT IS EXPOSED TO LAYERS\nconst INITIAL_CONTEXT = Object.seal({\n  layerManager: null,\n  resourceManager: null,\n  deck: null,\n  gl: null,\n\n  // General resources\n  stats: null, // for tracking lifecycle performance\n\n  // GL Resources\n  shaderCache: null,\n  pickingFBO: null, // Screen-size framebuffer that layers can reuse\n\n  mousePosition: null,\n\n  userData: {} // Place for any custom app `context`\n});\n\nexport default class LayerManager {\n  // eslint-disable-next-line\n  constructor(gl, {deck, stats, viewport, timeline} = {}) {\n    // Currently deck.gl expects the DeckGL.layers array to be different\n    // whenever React rerenders. If the same layers array is used, the\n    // LayerManager's diffing algorithm will generate a fatal error and\n    // break the rendering.\n\n    // `this.lastRenderedLayers` stores the UNFILTERED layers sent\n    // down to LayerManager, so that `layers` reference can be compared.\n    // If it's the same across two React render calls, the diffing logic\n    // will be skipped.\n    this.lastRenderedLayers = [];\n    this.layers = [];\n    this.resourceManager = new ResourceManager({gl, protocol: 'deck://'});\n\n    this.context = {\n      ...INITIAL_CONTEXT,\n      layerManager: this,\n      gl,\n      deck,\n      // Enabling luma.gl Program caching using private API (_cachePrograms)\n      programManager: gl && createProgramManager(gl),\n      stats: stats || new Stats({id: 'deck.gl'}),\n      // Make sure context.viewport is not empty on the first layer initialization\n      viewport: viewport || new Viewport({id: 'DEFAULT-INITIAL-VIEWPORT'}), // Current viewport, exposed to layers for project* function\n      timeline: timeline || new Timeline(),\n      resourceManager: this.resourceManager\n    };\n\n    this._nextLayers = null;\n    this._needsRedraw = 'Initial render';\n    this._needsUpdate = false;\n    this._debug = false;\n\n    this.activateViewport = this.activateViewport.bind(this);\n\n    Object.seal(this);\n  }\n\n  // Method to call when the layer manager is not needed anymore.\n  finalize() {\n    this.resourceManager.finalize();\n    // Finalize all layers\n    for (const layer of this.layers) {\n      this._finalizeLayer(layer);\n    }\n  }\n\n  // Check if a redraw is needed\n  needsRedraw(opts = {clearRedrawFlags: false}) {\n    let redraw = this._needsRedraw;\n    if (opts.clearRedrawFlags) {\n      this._needsRedraw = false;\n    }\n\n    // This layers list doesn't include sublayers, relying on composite layers\n    for (const layer of this.layers) {\n      // Call every layer to clear their flags\n      const layerNeedsRedraw = layer.getNeedsRedraw(opts);\n      redraw = redraw || layerNeedsRedraw;\n    }\n\n    return redraw;\n  }\n\n  // Check if a deep update of all layers is needed\n  needsUpdate() {\n    if (this._nextLayers && this._nextLayers !== this.lastRenderedLayers) {\n      // New layers array may be the same as the old one if `setProps` is called by React\n      return 'layers changed';\n    }\n    return this._needsUpdate;\n  }\n\n  // Layers will be redrawn (in next animation frame)\n  setNeedsRedraw(reason) {\n    this._needsRedraw = this._needsRedraw || reason;\n  }\n\n  // Layers will be updated deeply (in next animation frame)\n  // Potentially regenerating attributes and sub layers\n  setNeedsUpdate(reason) {\n    this._needsUpdate = this._needsUpdate || reason;\n  }\n\n  // Gets an (optionally) filtered list of layers\n  getLayers({layerIds = null} = {}) {\n    // Filtering by layerId compares beginning of strings, so that sublayers will be included\n    // Dependes on the convention of adding suffixes to the parent's layer name\n    return layerIds\n      ? this.layers.filter(layer => layerIds.find(layerId => layer.id.indexOf(layerId) === 0))\n      : this.layers;\n  }\n\n  // Set props needed for layer rendering and picking.\n  setProps(props) {\n    if ('debug' in props) {\n      this._debug = props.debug;\n    }\n\n    // A way for apps to add data to context that can be accessed in layers\n    if ('userData' in props) {\n      this.context.userData = props.userData;\n    }\n\n    // New layers will be processed in `updateLayers` in the next update cycle\n    if ('layers' in props) {\n      this._nextLayers = props.layers;\n    }\n\n    if ('onError' in props) {\n      this.context.onError = props.onError;\n    }\n  }\n\n  // Supply a new layer list, initiating sublayer generation and layer matching\n  setLayers(newLayers, reason) {\n    debug(TRACE_SET_LAYERS, this, reason, newLayers);\n\n    this.lastRenderedLayers = newLayers;\n\n    newLayers = flatten(newLayers, Boolean);\n\n    for (const layer of newLayers) {\n      layer.context = this.context;\n    }\n\n    this._updateLayers(this.layers, newLayers);\n\n    return this;\n  }\n\n  // Update layers from last cycle if `setNeedsUpdate()` has been called\n  updateLayers() {\n    // NOTE: For now, even if only some layer has changed, we update all layers\n    // to ensure that layer id maps etc remain consistent even if different\n    // sublayers are rendered\n    const reason = this.needsUpdate();\n    if (reason) {\n      this.setNeedsRedraw(`updating layers: ${reason}`);\n      // Force a full update\n      this.setLayers(this._nextLayers || this.lastRenderedLayers, reason);\n    }\n    // Updated, clear the backlog\n    this._nextLayers = null;\n  }\n\n  //\n  // PRIVATE METHODS\n  //\n\n  // Make a viewport \"current\" in layer context, updating viewportChanged flags\n  activateViewport(viewport) {\n    debug(TRACE_ACTIVATE_VIEWPORT, this, viewport);\n    if (viewport) {\n      this.context.viewport = viewport;\n    }\n    return this;\n  }\n\n  _handleError(stage, error, layer) {\n    layer.raiseError(error, `${stage} of ${layer}`);\n  }\n\n  // Match all layers, checking for caught errors\n  // To avoid having an exception in one layer disrupt other layers\n  // TODO - mark layers with exceptions as bad and remove from rendering cycle?\n  _updateLayers(oldLayers, newLayers) {\n    // Create old layer map\n    const oldLayerMap = {};\n    for (const oldLayer of oldLayers) {\n      if (oldLayerMap[oldLayer.id]) {\n        log.warn(`Multiple old layers with same id ${oldLayer.id}`)();\n      } else {\n        oldLayerMap[oldLayer.id] = oldLayer;\n      }\n    }\n\n    // Allocate array for generated layers\n    const generatedLayers = [];\n\n    // Match sublayers\n    this._updateSublayersRecursively(newLayers, oldLayerMap, generatedLayers);\n\n    // Finalize unmatched layers\n    this._finalizeOldLayers(oldLayerMap);\n\n    let needsUpdate = false;\n    for (const layer of generatedLayers) {\n      if (layer.hasUniformTransition()) {\n        needsUpdate = true;\n        break;\n      }\n    }\n\n    this._needsUpdate = needsUpdate;\n    this.layers = generatedLayers;\n  }\n\n  /* eslint-disable complexity,max-statements */\n  // Note: adds generated layers to `generatedLayers` array parameter\n  _updateSublayersRecursively(newLayers, oldLayerMap, generatedLayers) {\n    for (const newLayer of newLayers) {\n      newLayer.context = this.context;\n\n      // Given a new coming layer, find its matching old layer (if any)\n      const oldLayer = oldLayerMap[newLayer.id];\n      if (oldLayer === null) {\n        // null, rather than undefined, means this id was originally there\n        log.warn(`Multiple new layers with same id ${newLayer.id}`)();\n      }\n      // Remove the old layer from candidates, as it has been matched with this layer\n      oldLayerMap[newLayer.id] = null;\n\n      let sublayers = null;\n\n      // We must not generate exceptions until after layer matching is complete\n      try {\n        if (this._debug && oldLayer !== newLayer) {\n          newLayer.validateProps();\n        }\n\n        if (!oldLayer) {\n          this._initializeLayer(newLayer);\n        } else {\n          this._transferLayerState(oldLayer, newLayer);\n          this._updateLayer(newLayer);\n        }\n        generatedLayers.push(newLayer);\n\n        // Call layer lifecycle method: render sublayers\n        sublayers = newLayer.isComposite && newLayer.getSubLayers();\n        // End layer lifecycle method: render sublayers\n      } catch (err) {\n        this._handleError('matching', err, newLayer); // Record first exception\n      }\n\n      if (sublayers) {\n        this._updateSublayersRecursively(sublayers, oldLayerMap, generatedLayers);\n      }\n    }\n  }\n  /* eslint-enable complexity,max-statements */\n\n  // Finalize any old layers that were not matched\n  _finalizeOldLayers(oldLayerMap) {\n    for (const layerId in oldLayerMap) {\n      const layer = oldLayerMap[layerId];\n      if (layer) {\n        this._finalizeLayer(layer);\n      }\n    }\n  }\n\n  // EXCEPTION SAFE LAYER ACCESS\n\n  // Initializes a single layer, calling layer methods\n  _initializeLayer(layer) {\n    try {\n      layer._initialize();\n      layer.lifecycle = LIFECYCLE.INITIALIZED;\n    } catch (err) {\n      this._handleError('initialization', err, layer);\n      // TODO - what should the lifecycle state be here? LIFECYCLE.INITIALIZATION_FAILED?\n    }\n  }\n\n  _transferLayerState(oldLayer, newLayer) {\n    newLayer._transferState(oldLayer);\n    newLayer.lifecycle = LIFECYCLE.MATCHED;\n\n    if (newLayer !== oldLayer) {\n      oldLayer.lifecycle = LIFECYCLE.AWAITING_GC;\n    }\n  }\n\n  // Updates a single layer, cleaning all flags\n  _updateLayer(layer) {\n    try {\n      layer._update();\n    } catch (err) {\n      this._handleError('update', err, layer);\n    }\n  }\n\n  // Finalizes a single layer\n  _finalizeLayer(layer) {\n    this._needsRedraw = this._needsRedraw || `finalized ${layer}`;\n\n    layer.lifecycle = LIFECYCLE.AWAITING_FINALIZATION;\n\n    try {\n      layer._finalize();\n      layer.lifecycle = LIFECYCLE.FINALIZED;\n    } catch (err) {\n      this._handleError('finalization', err, layer);\n    }\n  }\n}\n"],"file":"layer-manager.js"}