"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _math = require("math.gl");

var _controller = _interopRequireDefault(require("./controller"));

var _orbitController = require("./orbit-controller");

class OrthographicState extends _orbitController.OrbitState {
  constructor(props) {
    super(props);
    this.zoomAxis = props.zoomAxis || 'all';
  }

  _applyConstraints(props) {
    const {
      maxZoom,
      minZoom,
      zoom
    } = props;
    props.zoom = Array.isArray(zoom) ? [(0, _math.clamp)(zoom[0], minZoom, maxZoom), (0, _math.clamp)(zoom[1], minZoom, maxZoom)] : (0, _math.clamp)(zoom, minZoom, maxZoom);
    return props;
  }

  _calculateNewZoom({
    scale,
    startZoom
  }) {
    const {
      maxZoom,
      minZoom
    } = this._viewportProps;

    if (!startZoom && startZoom !== 0) {
      startZoom = this._viewportProps.zoom;
    }

    let deltaZoom = Math.log2(scale);

    if (Array.isArray(startZoom)) {
      let [newZoomX, newZoomY] = startZoom;

      switch (this.zoomAxis) {
        case 'X':
          newZoomX = (0, _math.clamp)(newZoomX + deltaZoom, minZoom, maxZoom);
          break;

        case 'Y':
          newZoomY = (0, _math.clamp)(newZoomY + deltaZoom, minZoom, maxZoom);
          break;

        default:
          let z = Math.min(newZoomX + deltaZoom, newZoomY + deltaZoom);

          if (z < minZoom) {
            deltaZoom += minZoom - z;
          }

          z = Math.max(newZoomX + deltaZoom, newZoomY + deltaZoom);

          if (z > maxZoom) {
            deltaZoom += maxZoom - z;
          }

          newZoomX += deltaZoom;
          newZoomY += deltaZoom;
      }

      return [newZoomX, newZoomY];
    }

    return (0, _math.clamp)(startZoom + deltaZoom, minZoom, maxZoom);
  }

}

class OrthographicController extends _controller.default {
  constructor(props) {
    props.dragMode = props.dragMode || 'pan';
    super(OrthographicState, props);
  }

  _onPanRotate(event) {
    return false;
  }

  get linearTransitionProps() {
    return ['target', 'zoom'];
  }

}

exports.default = OrthographicController;
//# sourceMappingURL=orthographic-controller.js.map