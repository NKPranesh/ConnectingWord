import LayersPass from './layers-pass';
import { withParameters } from '@luma.gl/core';
import log from '../utils/log';
const PICKING_PARAMETERS = {
  blendFunc: [1, 0, 32771, 0],
  blendEquation: 32774
};
export default class PickLayersPass extends LayersPass {
  render(props) {
    if (props.pickingFBO) {
      return this._drawPickingBuffer(props);
    }

    return super.render(props);
  }

  _drawPickingBuffer({
    layers,
    layerFilter,
    views,
    viewports,
    onViewportActive,
    pickingFBO,
    deviceRect: {
      x,
      y,
      width,
      height
    },
    pass = 'picking',
    redrawReason,
    pickZ
  }) {
    const gl = this.gl;
    this.pickZ = pickZ;
    const encodedColors = !pickZ && {
      byLayer: new Map(),
      byAlpha: []
    };
    this._colors = encodedColors;
    const renderStatus = withParameters(gl, {
      scissorTest: true,
      scissor: [x, y, width, height],
      clearColor: [0, 0, 0, 0],
      depthMask: true,
      depthTest: true,
      depthRange: [0, 1],
      colorMask: [true, true, true, true],
      ...PICKING_PARAMETERS,
      blend: !pickZ
    }, () => super.render({
      target: pickingFBO,
      layers,
      layerFilter,
      views,
      viewports,
      onViewportActive,
      pass,
      redrawReason
    }));
    this._colors = null;
    const decodePickingColor = encodedColors && decodeColor.bind(null, encodedColors);
    return {
      decodePickingColor,
      stats: renderStatus
    };
  }

  shouldDrawLayer(layer) {
    return layer.props.pickable;
  }

  getModuleParameters() {
    return {
      pickingActive: 1,
      pickingAttribute: this.pickZ,
      lightSources: {}
    };
  }

  getLayerParameters(layer, layerIndex, viewport) {
    const pickParameters = { ...layer.props.parameters
    };

    if (this.pickZ) {
      pickParameters.blend = false;
    } else {
      Object.assign(pickParameters, PICKING_PARAMETERS);
      pickParameters.blend = true;
      pickParameters.blendColor = encodeColor(this._colors, layer, viewport);
    }

    return pickParameters;
  }

}

function encodeColor(encoded, layer, viewport) {
  const {
    byLayer,
    byAlpha
  } = encoded;
  let a;

  if (byLayer.has(layer)) {
    const entry = byLayer.get(layer);
    entry.viewports.push(viewport);
    a = entry.a;
  } else {
    a = byLayer.size + 1;

    if (a <= 255) {
      const entry = {
        a,
        layer,
        viewports: [viewport]
      };
      byLayer.set(layer, entry);
      byAlpha[a] = entry;
    } else {
      log.warn('Too many pickable layers, only picking the first 255')();
      a = 0;
    }
  }

  return [0, 0, 0, a / 255];
}

function decodeColor(encoded, pickedColor) {
  const entry = encoded.byAlpha[pickedColor[3]];
  return entry && {
    pickedLayer: entry.layer,
    pickedViewports: entry.viewports,
    pickedObjectIndex: entry.layer.decodePickingColor(pickedColor)
  };
}
//# sourceMappingURL=pick-layers-pass.js.map