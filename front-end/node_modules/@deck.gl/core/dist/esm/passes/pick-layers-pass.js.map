{"version":3,"sources":["../../../src/passes/pick-layers-pass.js"],"names":["LayersPass","withParameters","log","PICKING_PARAMETERS","blendFunc","blendEquation","PickLayersPass","render","props","pickingFBO","_drawPickingBuffer","layers","layerFilter","views","viewports","onViewportActive","deviceRect","x","y","width","height","pass","redrawReason","pickZ","gl","encodedColors","byLayer","Map","byAlpha","_colors","renderStatus","scissorTest","scissor","clearColor","depthMask","depthTest","depthRange","colorMask","blend","target","decodePickingColor","decodeColor","bind","stats","shouldDrawLayer","layer","pickable","getModuleParameters","pickingActive","pickingAttribute","lightSources","getLayerParameters","layerIndex","viewport","pickParameters","parameters","Object","assign","blendColor","encodeColor","encoded","a","has","entry","get","push","size","set","warn","pickedColor","pickedLayer","pickedViewports","pickedObjectIndex"],"mappings":"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","sourcesContent":["import LayersPass from './layers-pass';\nimport {withParameters} from '@luma.gl/core';\nimport GL from '@luma.gl/constants';\nimport log from '../utils/log';\n\nconst PICKING_PARAMETERS = {\n  blendFunc: [GL.ONE, GL.ZERO, GL.CONSTANT_ALPHA, GL.ZERO],\n  blendEquation: GL.FUNC_ADD\n};\n\nexport default class PickLayersPass extends LayersPass {\n  render(props) {\n    if (props.pickingFBO) {\n      // When drawing into an off-screen buffer, use the alpha channel to encode layer index\n      return this._drawPickingBuffer(props);\n    }\n    // When drawing to screen (debug mode), do not use the alpha channel so that result is always visible\n    return super.render(props);\n  }\n\n  // Private\n  // Draws list of layers and viewports into the picking buffer\n  // Note: does not sample the buffer, that has to be done by the caller\n  _drawPickingBuffer({\n    layers,\n    layerFilter,\n    views,\n    viewports,\n    onViewportActive,\n    pickingFBO,\n    deviceRect: {x, y, width, height},\n    pass = 'picking',\n    redrawReason,\n    pickZ\n  }) {\n    const gl = this.gl;\n    this.pickZ = pickZ;\n\n    // Track encoded layer indices\n    const encodedColors = !pickZ && {\n      byLayer: new Map(),\n      byAlpha: []\n    };\n    // Temporarily store it on the instance so that it can be accessed by this.getLayerParameters\n    this._colors = encodedColors;\n\n    // Make sure we clear scissor test and fbo bindings in case of exceptions\n    // We are only interested in one pixel, no need to render anything else\n    // Note that the callback here is called synchronously.\n    // Set blend mode for picking\n    // always overwrite existing pixel with [r,g,b,layerIndex]\n    const renderStatus = withParameters(\n      gl,\n      {\n        scissorTest: true,\n        scissor: [x, y, width, height],\n        clearColor: [0, 0, 0, 0],\n        // When used as Mapbox custom layer, the context state may be dirty\n        // TODO - Remove when mapbox fixes this issue\n        // https://github.com/mapbox/mapbox-gl-js/issues/7801\n        depthMask: true,\n        depthTest: true,\n        depthRange: [0, 1],\n        colorMask: [true, true, true, true],\n        // Blending\n        ...PICKING_PARAMETERS,\n        blend: !pickZ\n      },\n      () =>\n        super.render({\n          target: pickingFBO,\n          layers,\n          layerFilter,\n          views,\n          viewports,\n          onViewportActive,\n          pass,\n          redrawReason\n        })\n    );\n\n    // Clear the temp field\n    this._colors = null;\n    const decodePickingColor = encodedColors && decodeColor.bind(null, encodedColors);\n    return {decodePickingColor, stats: renderStatus};\n  }\n\n  // PRIVATE\n  shouldDrawLayer(layer) {\n    return layer.props.pickable;\n  }\n\n  getModuleParameters() {\n    return {\n      pickingActive: 1,\n      pickingAttribute: this.pickZ,\n      // turn off lighting by adding empty light source object\n      // lights shader module relies on the `lightSources` to turn on/off lighting\n      lightSources: {}\n    };\n  }\n\n  getLayerParameters(layer, layerIndex, viewport) {\n    const pickParameters = {...layer.props.parameters};\n\n    if (this.pickZ) {\n      pickParameters.blend = false;\n    } else {\n      Object.assign(pickParameters, PICKING_PARAMETERS);\n      pickParameters.blend = true;\n      pickParameters.blendColor = encodeColor(this._colors, layer, viewport);\n    }\n\n    return pickParameters;\n  }\n}\n\n// Assign an unique alpha value for each pickable layer and track the encoding in the cache object\n// Returns normalized blend color\nfunction encodeColor(encoded, layer, viewport) {\n  const {byLayer, byAlpha} = encoded;\n  let a;\n\n  // Encode layerIndex in the alpha channel\n  // TODO - combine small layers to better utilize the picking color space\n  if (byLayer.has(layer)) {\n    const entry = byLayer.get(layer);\n    entry.viewports.push(viewport);\n    a = entry.a;\n  } else {\n    a = byLayer.size + 1;\n    if (a <= 255) {\n      const entry = {a, layer, viewports: [viewport]};\n      byLayer.set(layer, entry);\n      byAlpha[a] = entry;\n    } else {\n      log.warn('Too many pickable layers, only picking the first 255')();\n      a = 0;\n    }\n  }\n  return [0, 0, 0, a / 255];\n}\n\n// Given a picked color, retrieve the corresponding layer and viewports from cache\nfunction decodeColor(encoded, pickedColor) {\n  const entry = encoded.byAlpha[pickedColor[3]];\n  return (\n    entry && {\n      pickedLayer: entry.layer,\n      pickedViewports: entry.viewports,\n      pickedObjectIndex: entry.layer.decodePickingColor(pickedColor)\n    }\n  );\n}\n"],"file":"pick-layers-pass.js"}