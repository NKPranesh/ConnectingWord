{"version":3,"sources":["../../../src/h3-layers/h3-hexagon-layer.js"],"names":["UPDATE_THRESHOLD_KM","normalizeLongitudes","vertices","refLng","undefined","pt","deltaLng","scalePolygon","hexId","factor","lat","lng","actualCount","length","vertexCount","i","getHexagonCentroid","getHexagon","object","objectInfo","hexagonId","h3ToPolygon","coverage","flatten","positions","Float64Array","mergeTriggers","trigger","defaultProps","PolygonLayer","highPrecision","type","min","max","value","centerHexagon","x","hexagon","extruded","getLineDashArray","H3HexagonLayer","CompositeLayer","shouldUpdateState","changeFlags","_shouldUseHighPrecision","propsOrDataChanged","somethingChanged","updateState","props","oldProps","dataChanged","updateTriggers","dataProps","_calculateH3DataProps","setState","_updateVertices","context","viewport","resolution","hasPentagon","hasMultipleRes","iterable","data","index","hexResolution","edgeLengthKM","UNITS","km","state","centerHex","hex","latitude","longitude","distance","unitsPerMeter","distanceScales","centerLat","centerLng","centerX","centerY","projectFlat","map","p","worldPosition","renderLayers","_renderPolygonLayer","_renderColumnLayer","_getForwardProps","elevationScale","material","wireframe","stroked","filled","lineWidthUnits","lineWidthScale","lineWidthMinPixels","lineWidthMaxPixels","getFillColor","getElevation","getLineColor","getLineWidth","transitions","SubLayerClass","getSubLayerClass","forwardProps","getPolygon","getSubLayerProps","id","_normalize","_windingOrder","positionFormat","ColumnLayer","getPosition","diskResolution","radius","bind","layerName"],"mappings":"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","sourcesContent":["import {\n  h3ToGeoBoundary,\n  h3GetResolution,\n  h3ToGeo,\n  geoToH3,\n  h3IsPentagon,\n  h3Distance,\n  edgeLength,\n  UNITS\n} from 'h3-js';\nimport {lerp} from 'math.gl';\nimport {CompositeLayer, createIterable} from '@deck.gl/core';\nimport {ColumnLayer, PolygonLayer} from '@deck.gl/layers';\n\n// There is a cost to updating the instanced geometries when using highPrecision: false\n// This constant defines the distance between two hexagons that leads to \"significant\n// distortion.\" Smaller value makes the column layer more sensitive to viewport change.\nconst UPDATE_THRESHOLD_KM = 10;\n\n// normalize longitudes w.r.t center (refLng), when not provided first vertex\nexport function normalizeLongitudes(vertices, refLng) {\n  refLng = refLng === undefined ? vertices[0][0] : refLng;\n  for (const pt of vertices) {\n    const deltaLng = pt[0] - refLng;\n    if (deltaLng > 180) {\n      pt[0] -= 360;\n    } else if (deltaLng < -180) {\n      pt[0] += 360;\n    }\n  }\n}\n\n// scale polygon vertices w.r.t center (hexId)\nexport function scalePolygon(hexId, vertices, factor) {\n  const [lat, lng] = h3ToGeo(hexId);\n  const actualCount = vertices.length;\n\n  // normalize with respect to center\n  normalizeLongitudes(vertices, lng);\n\n  // `h3ToGeoBoundary` returns same array object for first and last vertex (closed polygon),\n  // if so skip scaling the last vertex\n  const vertexCount = vertices[0] === vertices[actualCount - 1] ? actualCount - 1 : actualCount;\n  for (let i = 0; i < vertexCount; i++) {\n    vertices[i][0] = lerp(lng, vertices[i][0], factor);\n    vertices[i][1] = lerp(lat, vertices[i][1], factor);\n  }\n}\n\nfunction getHexagonCentroid(getHexagon, object, objectInfo) {\n  const hexagonId = getHexagon(object, objectInfo);\n  const [lat, lng] = h3ToGeo(hexagonId);\n  return [lng, lat];\n}\n\nfunction h3ToPolygon(hexId, coverage = 1, flatten) {\n  const vertices = h3ToGeoBoundary(hexId, true);\n\n  if (coverage !== 1) {\n    // scale and normalize vertices w.r.t to center\n    scalePolygon(hexId, vertices, coverage);\n  } else {\n    // normalize w.r.t to start vertex\n    normalizeLongitudes(vertices);\n  }\n\n  if (flatten) {\n    const positions = new Float64Array(vertices.length * 2);\n    let i = 0;\n    for (const pt of vertices) {\n      positions[i++] = pt[0];\n      positions[i++] = pt[1];\n    }\n    return positions;\n  }\n\n  return vertices;\n}\n\nfunction mergeTriggers(getHexagon, coverage) {\n  let trigger;\n  if (getHexagon === undefined || getHexagon === null) {\n    trigger = coverage;\n  } else if (typeof getHexagon === 'object') {\n    trigger = {...getHexagon, coverage};\n  } else {\n    trigger = {getHexagon, coverage};\n  }\n  return trigger;\n}\n\nconst defaultProps = {\n  ...PolygonLayer.defaultProps,\n  highPrecision: 'auto',\n  coverage: {type: 'number', min: 0, max: 1, value: 1},\n  centerHexagon: null,\n  getHexagon: {type: 'accessor', value: x => x.hexagon},\n  extruded: true\n};\n\n// not supported\ndelete defaultProps.getLineDashArray;\n\n/**\n * A subclass of HexagonLayer that uses H3 hexagonIds in data objects\n * rather than centroid lat/longs. The shape of each hexagon is determined\n * based on a single \"center\" hexagon, which can be selected by passing in\n * a center lat/lon pair. If not provided, the map center will be used.\n *\n * Also sets the `hexagonId` field in the onHover/onClick callback's info\n * objects. Since this is calculated using math, hexagonId will be present\n * even when no corresponding hexagon is in the data set. You can check\n * index !== -1 to see if picking matches an actual object.\n */\nexport default class H3HexagonLayer extends CompositeLayer {\n  shouldUpdateState({changeFlags}) {\n    return this._shouldUseHighPrecision()\n      ? changeFlags.propsOrDataChanged\n      : changeFlags.somethingChanged;\n  }\n\n  updateState({props, oldProps, changeFlags}) {\n    if (\n      props.highPrecision !== true &&\n      (changeFlags.dataChanged ||\n        (changeFlags.updateTriggers && changeFlags.updateTriggers.getHexagon))\n    ) {\n      const dataProps = this._calculateH3DataProps(props);\n      this.setState(dataProps);\n    }\n\n    this._updateVertices(this.context.viewport);\n  }\n\n  _calculateH3DataProps(props) {\n    let resolution = -1;\n    let hasPentagon = false;\n    let hasMultipleRes = false;\n\n    const {iterable, objectInfo} = createIterable(props.data);\n    for (const object of iterable) {\n      objectInfo.index++;\n      const hexId = props.getHexagon(object, objectInfo);\n      // Take the resolution of the first hex\n      const hexResolution = h3GetResolution(hexId);\n      if (resolution < 0) {\n        resolution = hexResolution;\n        if (!props.highPrecision) break;\n      } else if (resolution !== hexResolution) {\n        hasMultipleRes = true;\n        break;\n      }\n      if (h3IsPentagon(hexId)) {\n        hasPentagon = true;\n        break;\n      }\n    }\n\n    return {\n      resolution,\n      edgeLengthKM: resolution >= 0 ? edgeLength(resolution, UNITS.km) : 0,\n      hasMultipleRes,\n      hasPentagon\n    };\n  }\n\n  _shouldUseHighPrecision() {\n    if (this.props.highPrecision === 'auto') {\n      const {resolution, hasPentagon, hasMultipleRes} = this.state;\n      const {viewport} = this.context;\n      return (\n        viewport.resolution || hasMultipleRes || hasPentagon || (resolution >= 0 && resolution <= 5)\n      );\n    }\n\n    return this.props.highPrecision;\n  }\n\n  _updateVertices(viewport) {\n    if (this._shouldUseHighPrecision()) {\n      return;\n    }\n    const {resolution, edgeLengthKM, centerHex} = this.state;\n    if (resolution < 0) {\n      return;\n    }\n    const hex =\n      this.props.centerHexagon || geoToH3(viewport.latitude, viewport.longitude, resolution);\n    if (centerHex === hex) {\n      return;\n    }\n    if (centerHex) {\n      const distance = h3Distance(centerHex, hex);\n      // h3Distance returns a negative number if the distance could not be computed\n      // due to the two indexes very far apart or on opposite sides of a pentagon.\n      if (distance >= 0 && distance * edgeLengthKM < UPDATE_THRESHOLD_KM) {\n        return;\n      }\n    }\n\n    const {unitsPerMeter} = viewport.distanceScales;\n\n    let vertices = h3ToPolygon(hex);\n    const [centerLat, centerLng] = h3ToGeo(hex);\n\n    const [centerX, centerY] = viewport.projectFlat([centerLng, centerLat]);\n    vertices = vertices.map(p => {\n      const worldPosition = viewport.projectFlat(p);\n      return [\n        (worldPosition[0] - centerX) / unitsPerMeter[0],\n        (worldPosition[1] - centerY) / unitsPerMeter[1]\n      ];\n    });\n\n    this.setState({centerHex: hex, vertices});\n  }\n\n  renderLayers() {\n    return this._shouldUseHighPrecision() ? this._renderPolygonLayer() : this._renderColumnLayer();\n  }\n\n  _getForwardProps() {\n    const {\n      elevationScale,\n      material,\n      coverage,\n      extruded,\n      wireframe,\n      stroked,\n      filled,\n      lineWidthUnits,\n      lineWidthScale,\n      lineWidthMinPixels,\n      lineWidthMaxPixels,\n      getFillColor,\n      getElevation,\n      getLineColor,\n      getLineWidth,\n      transitions,\n      updateTriggers\n    } = this.props;\n\n    return {\n      elevationScale,\n      extruded,\n      coverage,\n      wireframe,\n      stroked,\n      filled,\n      lineWidthUnits,\n      lineWidthScale,\n      lineWidthMinPixels,\n      lineWidthMaxPixels,\n      material,\n      getElevation,\n      getFillColor,\n      getLineColor,\n      getLineWidth,\n      transitions,\n      updateTriggers: {\n        getFillColor: updateTriggers.getFillColor,\n        getElevation: updateTriggers.getElevation,\n        getLineColor: updateTriggers.getLineColor,\n        getLineWidth: updateTriggers.getLineWidth\n      }\n    };\n  }\n\n  _renderPolygonLayer() {\n    const {data, getHexagon, updateTriggers, coverage} = this.props;\n\n    const SubLayerClass = this.getSubLayerClass('hexagon-cell-hifi', PolygonLayer);\n    const forwardProps = this._getForwardProps();\n\n    forwardProps.updateTriggers.getPolygon = mergeTriggers(updateTriggers.getHexagon, coverage);\n\n    return new SubLayerClass(\n      forwardProps,\n      this.getSubLayerProps({\n        id: 'hexagon-cell-hifi',\n        updateTriggers: forwardProps.updateTriggers\n      }),\n      {\n        data,\n        _normalize: false,\n        _windingOrder: 'CCW',\n        positionFormat: 'XY',\n        getPolygon: (object, objectInfo) => {\n          const hexagonId = getHexagon(object, objectInfo);\n          return h3ToPolygon(hexagonId, coverage, true);\n        }\n      }\n    );\n  }\n\n  _renderColumnLayer() {\n    const {data, getHexagon, updateTriggers} = this.props;\n\n    const SubLayerClass = this.getSubLayerClass('hexagon-cell', ColumnLayer);\n    const forwardProps = this._getForwardProps();\n    forwardProps.updateTriggers.getPosition = updateTriggers.getHexagon;\n\n    return new SubLayerClass(\n      forwardProps,\n      this.getSubLayerProps({\n        id: 'hexagon-cell',\n        updateTriggers: forwardProps.updateTriggers\n      }),\n      {\n        data,\n        diskResolution: 6, // generate an extruded hexagon as the base geometry\n        radius: 1,\n        vertices: this.state.vertices,\n        getPosition: getHexagonCentroid.bind(null, getHexagon)\n      }\n    );\n  }\n}\n\nH3HexagonLayer.defaultProps = defaultProps;\nH3HexagonLayer.layerName = 'H3HexagonLayer';\n"],"file":"h3-hexagon-layer.js"}