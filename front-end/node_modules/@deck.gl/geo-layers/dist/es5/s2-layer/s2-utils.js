"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getS2QuadKey = getS2QuadKey;
exports.getS2Polygon = getS2Polygon;

var _s2Geometry = require("./s2-geometry");

var _long = _interopRequireDefault(require("long"));

function getIdFromToken(token) {
  const paddedToken = token.padEnd(16, '0');
  return _long.default.fromString(paddedToken, 16);
}

const MAX_RESOLUTION = 100;

function getGeoBounds({
  face,
  ij,
  level
}) {
  const offsets = [[0, 0], [0, 1], [1, 1], [1, 0], [0, 0]];
  const resolution = Math.max(1, Math.ceil(MAX_RESOLUTION * Math.pow(2, -level)));
  const result = new Float64Array(4 * resolution * 2 + 2);
  let ptIndex = 0;
  let prevLng = 0;

  for (let i = 0; i < 4; i++) {
    const offset = offsets[i].slice(0);
    const nextOffset = offsets[i + 1];
    const stepI = (nextOffset[0] - offset[0]) / resolution;
    const stepJ = (nextOffset[1] - offset[1]) / resolution;

    for (let j = 0; j < resolution; j++) {
      offset[0] += stepI;
      offset[1] += stepJ;
      const st = (0, _s2Geometry.IJToST)(ij, level, offset);
      const uv = (0, _s2Geometry.STToUV)(st);
      const xyz = (0, _s2Geometry.FaceUVToXYZ)(face, uv);
      const lngLat = (0, _s2Geometry.XYZToLngLat)(xyz);

      if (Math.abs(lngLat[1]) > 89.999) {
        lngLat[0] = prevLng;
      }

      const deltaLng = lngLat[0] - prevLng;
      lngLat[0] += deltaLng > 180 ? -360 : deltaLng < -180 ? 360 : 0;
      result[ptIndex++] = lngLat[0];
      result[ptIndex++] = lngLat[1];
      prevLng = lngLat[0];
    }
  }

  result[ptIndex++] = result[0];
  result[ptIndex++] = result[1];
  return result;
}

function getS2QuadKey(token) {
  if (typeof token === 'string') {
    if (token.indexOf('/') > 0) {
      return token;
    }

    token = getIdFromToken(token);
  }

  return (0, _s2Geometry.toHilbertQuadkey)(token.toString());
}

function getS2Polygon(token) {
  const key = getS2QuadKey(token);
  const s2cell = (0, _s2Geometry.FromHilbertQuadKey)(key);
  return getGeoBounds(s2cell);
}
//# sourceMappingURL=s2-utils.js.map