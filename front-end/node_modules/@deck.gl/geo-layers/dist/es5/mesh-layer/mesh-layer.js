"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _experimental = require("@luma.gl/experimental");

var _core = require("@luma.gl/core");

var _meshLayers = require("@deck.gl/mesh-layers");

var _meshLayerVertex = _interopRequireDefault(require("./mesh-layer-vertex.glsl"));

var _meshLayerFragment = _interopRequireDefault(require("./mesh-layer-fragment.glsl"));

function validateGeometryAttributes(attributes) {
  const hasColorAttribute = attributes.COLOR_0 || attributes.colors;

  if (!hasColorAttribute) {
    attributes.colors = {
      constant: true,
      value: new Float32Array([1, 1, 1])
    };
  }

  if (!attributes.uvRegions) {
    attributes.uvRegions = {
      constant: true,
      value: new Float32Array([0, 0, 1, 1])
    };
  }
}

const defaultProps = {
  pbrMaterial: {
    type: 'object',
    value: null
  },
  featureIds: {
    type: 'array',
    value: null,
    optional: true
  }
};

class _MeshLayer extends _meshLayers.SimpleMeshLayer {
  getShaders() {
    const shaders = super.getShaders();
    const modules = shaders.modules;
    modules.push(_core.pbr);
    return { ...shaders,
      vs: _meshLayerVertex.default,
      fs: _meshLayerFragment.default
    };
  }

  initializeState() {
    const {
      featureIds
    } = this.props;
    super.initializeState();

    if (featureIds) {
      this.state.attributeManager.add({
        featureIdsPickingColors: {
          type: 5121,
          size: 3,
          noAlloc: true,
          update: this.calculateFeatureIdsPickingColors
        }
      });
    }
  }

  updateState({
    props,
    oldProps,
    changeFlags
  }) {
    super.updateState({
      props,
      oldProps,
      changeFlags
    });

    if (props.pbrMaterial !== oldProps.pbrMaterial) {
      this.updatePbrMaterialUniforms(props.pbrMaterial);
    }
  }

  draw(opts) {
    const {
      featureIds
    } = this.props;

    if (!this.state.model) {
      return;
    }

    this.state.model.setUniforms({
      u_Camera: this.state.model.getUniforms().project_uCameraPosition,
      u_pickFeatureIds: Boolean(featureIds)
    });
    super.draw(opts);
  }

  getModel(mesh) {
    const {
      id,
      pbrMaterial
    } = this.props;
    const materialParser = this.parseMaterial(pbrMaterial, mesh);
    const shaders = this.getShaders();
    validateGeometryAttributes(mesh.attributes);
    const model = new _core.Model(this.context.gl, { ...this.getShaders(),
      id,
      geometry: mesh,
      defines: { ...shaders.defines,
        ...(materialParser === null || materialParser === void 0 ? void 0 : materialParser.defines)
      },
      parameters: materialParser === null || materialParser === void 0 ? void 0 : materialParser.parameters,
      isInstanced: true
    });
    return model;
  }

  updatePbrMaterialUniforms(pbrMaterial) {
    const {
      model
    } = this.state;

    if (model) {
      const {
        mesh
      } = this.props;
      const materialParser = this.parseMaterial(pbrMaterial, mesh);
      model.setUniforms(materialParser.uniforms);
    }
  }

  parseMaterial(pbrMaterial, mesh) {
    const unlit = Boolean(pbrMaterial.pbrMetallicRoughness && pbrMaterial.pbrMetallicRoughness.baseColorTexture);
    const materialParser = new _experimental.GLTFMaterialParser(this.context.gl, {
      attributes: {
        NORMAL: mesh.attributes.normals,
        TEXCOORD_0: mesh.attributes.texCoords
      },
      material: {
        unlit,
        ...pbrMaterial
      },
      pbrDebug: false,
      imageBasedLightingEnvironment: null,
      lights: true,
      useTangents: false
    });
    return materialParser;
  }

  calculateFeatureIdsPickingColors(attribute) {
    const {
      featureIds
    } = this.props;
    const value = new Uint8ClampedArray(featureIds.length * attribute.size);
    const pickingColor = [];

    for (let index = 0; index < featureIds.length; index++) {
      this.encodePickingColor(featureIds[index], pickingColor);
      value[index * 3] = pickingColor[0];
      value[index * 3 + 1] = pickingColor[1];
      value[index * 3 + 2] = pickingColor[2];
    }

    attribute.value = value;
  }

}

exports.default = _MeshLayer;
_MeshLayer.layerName = '_MeshLayer';
_MeshLayer.defaultProps = defaultProps;
//# sourceMappingURL=mesh-layer.js.map