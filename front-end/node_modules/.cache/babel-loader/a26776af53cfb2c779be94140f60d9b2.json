{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport DoublyLinkedList from '../utils/doubly-linked-list';\n\nfunction defined(x) {\n  return x !== undefined && x !== null;\n}\n\nexport default class TilesetCache {\n  constructor() {\n    _defineProperty(this, \"_list\", void 0);\n\n    _defineProperty(this, \"_sentinel\", void 0);\n\n    _defineProperty(this, \"_trimTiles\", void 0);\n\n    this._list = new DoublyLinkedList();\n    this._sentinel = this._list.add('sentinel');\n    this._trimTiles = false;\n  }\n\n  reset() {\n    this._list.splice(this._list.tail, this._sentinel);\n  }\n\n  touch(tile) {\n    const node = tile._cacheNode;\n\n    if (defined(node)) {\n      this._list.splice(this._sentinel, node);\n    }\n  }\n\n  add(tileset, tile, addCallback) {\n    if (!defined(tile._cacheNode)) {\n      tile._cacheNode = this._list.add(tile);\n\n      if (addCallback) {\n        addCallback(tileset, tile);\n      }\n    }\n  }\n\n  unloadTile(tileset, tile, unloadCallback) {\n    const node = tile._cacheNode;\n\n    if (!defined(node)) {\n      return;\n    }\n\n    this._list.remove(node);\n\n    tile._cacheNode = undefined;\n\n    if (unloadCallback) {\n      unloadCallback(tileset, tile);\n    }\n  }\n\n  unloadTiles(tileset, unloadCallback) {\n    const trimTiles = this._trimTiles;\n    this._trimTiles = false;\n    const list = this._list;\n    const maximumMemoryUsageInBytes = tileset.maximumMemoryUsage * 1024 * 1024;\n    const sentinel = this._sentinel;\n    let node = list.head;\n\n    while (node !== sentinel && (tileset.gpuMemoryUsageInBytes > maximumMemoryUsageInBytes || trimTiles)) {\n      const tile = node.item;\n      node = node.next;\n      this.unloadTile(tileset, tile, unloadCallback);\n    }\n  }\n\n  trim() {\n    this._trimTiles = true;\n  }\n\n}","map":{"version":3,"sources":["../../../src/tileset/tileset-cache.ts"],"names":["x","constructor","reset","touch","node","tile","defined","add","addCallback","unloadTile","unloadCallback","unloadTiles","trimTiles","list","maximumMemoryUsageInBytes","tileset","sentinel","trim"],"mappings":";AAGA,OAAA,gBAAA,MAAA,6BAAA;;AAEA,SAAA,OAAA,CAAA,CAAA,EAAoB;AAClB,SAAOA,CAAC,KAADA,SAAAA,IAAmBA,CAAC,KAA3B,IAAA;AACD;;AAOD,eAAe,MAAA,YAAA,CAAmB;AAKhCC,EAAAA,WAAW,GAAG;AAAA,IAAA,eAAA,CAAA,IAAA,EAAA,OAAA,EAAA,KAAA,CAAA,CAAA;;AAAA,IAAA,eAAA,CAAA,IAAA,EAAA,WAAA,EAAA,KAAA,CAAA,CAAA;;AAAA,IAAA,eAAA,CAAA,IAAA,EAAA,YAAA,EAAA,KAAA,CAAA,CAAA;;AAGZ,SAAA,KAAA,GAAa,IAAb,gBAAa,EAAb;AACA,SAAA,SAAA,GAAiB,KAAA,KAAA,CAAA,GAAA,CAAjB,UAAiB,CAAjB;AACA,SAAA,UAAA,GAAA,KAAA;AACD;;AAEDC,EAAAA,KAAK,GAAG;AAIN,SAAA,KAAA,CAAA,MAAA,CAAkB,KAAA,KAAA,CAAlB,IAAA,EAAmC,KAAnC,SAAA;AACD;;AAEDC,EAAAA,KAAK,CAAA,IAAA,EAAO;AACV,UAAMC,IAAI,GAAGC,IAAI,CAAjB,UAAA;;AACA,QAAIC,OAAO,CAAX,IAAW,CAAX,EAAmB;AACjB,WAAA,KAAA,CAAA,MAAA,CAAkB,KAAlB,SAAA,EAAA,IAAA;AACD;AACF;;AAEDC,EAAAA,GAAG,CAAA,OAAA,EAAA,IAAA,EAAA,WAAA,EAA6B;AAC9B,QAAI,CAACD,OAAO,CAACD,IAAI,CAAjB,UAAY,CAAZ,EAA+B;AAC7BA,MAAAA,IAAI,CAAJA,UAAAA,GAAkB,KAAA,KAAA,CAAA,GAAA,CAAlBA,IAAkB,CAAlBA;;AAEA,UAAA,WAAA,EAAiB;AACfG,QAAAA,WAAW,CAAA,OAAA,EAAXA,IAAW,CAAXA;AACD;AACF;AACF;;AAEDC,EAAAA,UAAU,CAAA,OAAA,EAAA,IAAA,EAAA,cAAA,EAAiC;AACzC,UAAML,IAAI,GAAGC,IAAI,CAAjB,UAAA;;AACA,QAAI,CAACC,OAAO,CAAZ,IAAY,CAAZ,EAAoB;AAClB;AACD;;AAED,SAAA,KAAA,CAAA,MAAA,CAAA,IAAA;;AACAD,IAAAA,IAAI,CAAJA,UAAAA,GAAAA,SAAAA;;AACA,QAAA,cAAA,EAAoB;AAClBK,MAAAA,cAAc,CAAA,OAAA,EAAdA,IAAc,CAAdA;AACD;AACF;;AAEDC,EAAAA,WAAW,CAAA,OAAA,EAAA,cAAA,EAA0B;AACnC,UAAMC,SAAS,GAAG,KAAlB,UAAA;AACA,SAAA,UAAA,GAAA,KAAA;AAEA,UAAMC,IAAI,GAAG,KAAb,KAAA;AAEA,UAAMC,yBAAyB,GAAGC,OAAO,CAAPA,kBAAAA,GAAAA,IAAAA,GAAlC,IAAA;AAKA,UAAMC,QAAQ,GAAG,KAAjB,SAAA;AACA,QAAIZ,IAAI,GAAGS,IAAI,CAAf,IAAA;;AAEA,WACET,IAAI,KAAJA,QAAAA,KACCW,OAAO,CAAPA,qBAAAA,GAAAA,yBAAAA,IAFH,SACEX,CADF,EAGE;AACA,YAAMC,IAAI,GAAGD,IAAI,CAAjB,IAAA;AACAA,MAAAA,IAAI,GAAGA,IAAI,CAAXA,IAAAA;AACA,WAAA,UAAA,CAAA,OAAA,EAAA,IAAA,EAAA,cAAA;AACD;AACF;;AAEDa,EAAAA,IAAI,GAAG;AACL,SAAA,UAAA,GAAA,IAAA;AACD;;AA5E+B","sourcesContent":["// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\nimport DoublyLinkedList from '../utils/doubly-linked-list';\n\nfunction defined(x) {\n  return x !== undefined && x !== null;\n}\n\n/**\n * Stores tiles with content loaded.\n *\n * @private\n */\nexport default class TilesetCache {\n  private _list: DoublyLinkedList;\n  private _sentinel: any;\n  private _trimTiles: boolean;\n\n  constructor() {\n    // [head, sentinel) -> tiles that weren't selected this frame and may be removed from the cache\n    // (sentinel, tail] -> tiles that were selected this frame\n    this._list = new DoublyLinkedList();\n    this._sentinel = this._list.add('sentinel');\n    this._trimTiles = false;\n  }\n\n  reset() {\n    // Move sentinel node to the tail so, at the start of the frame, all tiles\n    // may be potentially replaced.  Tiles are moved to the right of the sentinel\n    // when they are selected so they will not be replaced.\n    this._list.splice(this._list.tail, this._sentinel);\n  }\n\n  touch(tile) {\n    const node = tile._cacheNode;\n    if (defined(node)) {\n      this._list.splice(this._sentinel, node);\n    }\n  }\n\n  add(tileset, tile, addCallback) {\n    if (!defined(tile._cacheNode)) {\n      tile._cacheNode = this._list.add(tile);\n\n      if (addCallback) {\n        addCallback(tileset, tile);\n      }\n    }\n  }\n\n  unloadTile(tileset, tile, unloadCallback?) {\n    const node = tile._cacheNode;\n    if (!defined(node)) {\n      return;\n    }\n\n    this._list.remove(node);\n    tile._cacheNode = undefined;\n    if (unloadCallback) {\n      unloadCallback(tileset, tile);\n    }\n  }\n\n  unloadTiles(tileset, unloadCallback) {\n    const trimTiles = this._trimTiles;\n    this._trimTiles = false;\n\n    const list = this._list;\n\n    const maximumMemoryUsageInBytes = tileset.maximumMemoryUsage * 1024 * 1024;\n\n    // Traverse the list only to the sentinel since tiles/nodes to the\n    // right of the sentinel were used this frame.\n    // The sub-list to the left of the sentinel is ordered from LRU to MRU.\n    const sentinel = this._sentinel;\n    let node = list.head;\n\n    while (\n      node !== sentinel &&\n      (tileset.gpuMemoryUsageInBytes > maximumMemoryUsageInBytes || trimTiles)\n    ) {\n      const tile = node.item;\n      node = node.next;\n      this.unloadTile(tileset, tile, unloadCallback);\n    }\n  }\n\n  trim() {\n    this._trimTiles = true;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}