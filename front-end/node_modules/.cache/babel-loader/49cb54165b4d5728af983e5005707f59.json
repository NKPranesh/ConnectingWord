{"ast":null,"code":"import { cloneTextureFrom, readPixelsToArray, getShaderVersion, Buffer, Texture2D, Framebuffer } from '@luma.gl/webgl';\nimport { _transform as transformModule, getPassthroughFS, typeToChannelCount, combineInjects } from '@luma.gl/shadertools';\nimport { updateForTextures, getSizeUniforms } from './transform-shader-utils';\nconst SRC_TEX_PARAMETER_OVERRIDES = {\n  [10241]: 9728,\n  [10240]: 9728,\n  [10242]: 33071,\n  [10243]: 33071\n};\nconst FS_OUTPUT_VARIABLE = 'transform_output';\nexport default class TextureTransform {\n  constructor(gl) {\n    let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.gl = gl;\n    this.id = this.currentIndex = 0;\n    this._swapTexture = null;\n    this.targetTextureVarying = null;\n    this.targetTextureType = null;\n    this.samplerTextureMap = null;\n    this.bindings = [];\n    this.resources = {};\n\n    this._initialize(props);\n\n    Object.seal(this);\n  }\n\n  updateModelProps() {\n    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    const updatedModelProps = this._processVertexShader(props);\n\n    return Object.assign({}, props, updatedModelProps);\n  }\n\n  getDrawOptions() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const {\n      sourceBuffers,\n      sourceTextures,\n      framebuffer,\n      targetTexture\n    } = this.bindings[this.currentIndex];\n    const attributes = Object.assign({}, sourceBuffers, opts.attributes);\n    const uniforms = Object.assign({}, opts.uniforms);\n    const parameters = Object.assign({}, opts.parameters);\n    let discard = opts.discard;\n\n    if (this.hasSourceTextures || this.hasTargetTexture) {\n      attributes.transform_elementID = this.elementIDBuffer;\n\n      for (const sampler in this.samplerTextureMap) {\n        const textureName = this.samplerTextureMap[sampler];\n        uniforms[sampler] = sourceTextures[textureName];\n      }\n\n      this._setSourceTextureParameters();\n\n      const sizeUniforms = getSizeUniforms({\n        sourceTextureMap: sourceTextures,\n        targetTextureVarying: this.targetTextureVarying,\n        targetTexture\n      });\n      Object.assign(uniforms, sizeUniforms);\n    }\n\n    if (this.hasTargetTexture) {\n      discard = false;\n      parameters.viewport = [0, 0, framebuffer.width, framebuffer.height];\n    }\n\n    return {\n      attributes,\n      framebuffer,\n      uniforms,\n      discard,\n      parameters\n    };\n  }\n\n  swap() {\n    if (this._swapTexture) {\n      this.currentIndex = this._getNextIndex();\n      return true;\n    }\n\n    return false;\n  }\n\n  update() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    this._setupTextures(opts);\n  }\n\n  getTargetTexture() {\n    const {\n      targetTexture\n    } = this.bindings[this.currentIndex];\n    return targetTexture;\n  }\n\n  getData() {\n    let {\n      packed = false\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const {\n      framebuffer\n    } = this.bindings[this.currentIndex];\n    const pixels = readPixelsToArray(framebuffer);\n\n    if (!packed) {\n      return pixels;\n    }\n\n    const ArrayType = pixels.constructor;\n    const channelCount = typeToChannelCount(this.targetTextureType);\n    const packedPixels = new ArrayType(pixels.length * channelCount / 4);\n    let packCount = 0;\n\n    for (let i = 0; i < pixels.length; i += 4) {\n      for (let j = 0; j < channelCount; j++) {\n        packedPixels[packCount++] = pixels[i + j];\n      }\n    }\n\n    return packedPixels;\n  }\n\n  getFramebuffer() {\n    const currentResources = this.bindings[this.currentIndex];\n    return currentResources.framebuffer;\n  }\n\n  delete() {\n    if (this.ownTexture) {\n      this.ownTexture.delete();\n    }\n\n    if (this.elementIDBuffer) {\n      this.elementIDBuffer.delete();\n    }\n  }\n\n  _initialize() {\n    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const {\n      _targetTextureVarying,\n      _swapTexture\n    } = props;\n    this._swapTexture = _swapTexture;\n    this.targetTextureVarying = _targetTextureVarying;\n    this.hasTargetTexture = _targetTextureVarying;\n\n    this._setupTextures(props);\n  }\n\n  _createTargetTexture(props) {\n    const {\n      sourceTextures,\n      textureOrReference\n    } = props;\n\n    if (textureOrReference instanceof Texture2D) {\n      return textureOrReference;\n    }\n\n    const refTexture = sourceTextures[textureOrReference];\n\n    if (!refTexture) {\n      return null;\n    }\n\n    this._targetRefTexName = textureOrReference;\n    return this._createNewTexture(refTexture);\n  }\n\n  _setupTextures() {\n    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const {\n      sourceBuffers,\n      _sourceTextures = {},\n      _targetTexture\n    } = props;\n\n    const targetTexture = this._createTargetTexture({\n      sourceTextures: _sourceTextures,\n      textureOrReference: _targetTexture\n    });\n\n    this.hasSourceTextures = this.hasSourceTextures || _sourceTextures && Object.keys(_sourceTextures).length > 0;\n\n    this._updateBindings({\n      sourceBuffers,\n      sourceTextures: _sourceTextures,\n      targetTexture\n    });\n\n    if ('elementCount' in props) {\n      this._updateElementIDBuffer(props.elementCount);\n    }\n  }\n\n  _updateElementIDBuffer(elementCount) {\n    if (typeof elementCount !== 'number' || this.elementCount >= elementCount) {\n      return;\n    }\n\n    const elementIds = new Float32Array(elementCount);\n    elementIds.forEach((_, index, array) => {\n      array[index] = index;\n    });\n\n    if (!this.elementIDBuffer) {\n      this.elementIDBuffer = new Buffer(this.gl, {\n        data: elementIds,\n        accessor: {\n          size: 1\n        }\n      });\n    } else {\n      this.elementIDBuffer.setData({\n        data: elementIds\n      });\n    }\n\n    this.elementCount = elementCount;\n  }\n\n  _updateBindings(opts) {\n    this.bindings[this.currentIndex] = this._updateBinding(this.bindings[this.currentIndex], opts);\n\n    if (this._swapTexture) {\n      const {\n        sourceTextures,\n        targetTexture\n      } = this._swapTextures(this.bindings[this.currentIndex]);\n\n      const nextIndex = this._getNextIndex();\n\n      this.bindings[nextIndex] = this._updateBinding(this.bindings[nextIndex], {\n        sourceTextures,\n        targetTexture\n      });\n    }\n  }\n\n  _updateBinding(binding, opts) {\n    const {\n      sourceBuffers,\n      sourceTextures,\n      targetTexture\n    } = opts;\n\n    if (!binding) {\n      binding = {\n        sourceBuffers: {},\n        sourceTextures: {},\n        targetTexture: null\n      };\n    }\n\n    Object.assign(binding.sourceTextures, sourceTextures);\n    Object.assign(binding.sourceBuffers, sourceBuffers);\n\n    if (targetTexture) {\n      binding.targetTexture = targetTexture;\n      const {\n        width,\n        height\n      } = targetTexture;\n      const {\n        framebuffer\n      } = binding;\n\n      if (framebuffer) {\n        framebuffer.update({\n          attachments: {\n            [36064]: targetTexture\n          },\n          resizeAttachments: false\n        });\n        framebuffer.resize({\n          width,\n          height\n        });\n      } else {\n        binding.framebuffer = new Framebuffer(this.gl, {\n          id: `transform-framebuffer`,\n          width,\n          height,\n          attachments: {\n            [36064]: targetTexture\n          }\n        });\n      }\n    }\n\n    return binding;\n  }\n\n  _setSourceTextureParameters() {\n    const index = this.currentIndex;\n    const {\n      sourceTextures\n    } = this.bindings[index];\n\n    for (const name in sourceTextures) {\n      sourceTextures[name].setParameters(SRC_TEX_PARAMETER_OVERRIDES);\n    }\n  }\n\n  _swapTextures(opts) {\n    if (!this._swapTexture) {\n      return null;\n    }\n\n    const sourceTextures = Object.assign({}, opts.sourceTextures);\n    sourceTextures[this._swapTexture] = opts.targetTexture;\n    const targetTexture = opts.sourceTextures[this._swapTexture];\n    return {\n      sourceTextures,\n      targetTexture\n    };\n  }\n\n  _createNewTexture(refTexture) {\n    const texture = cloneTextureFrom(refTexture, {\n      parameters: {\n        [10241]: 9728,\n        [10240]: 9728,\n        [10242]: 33071,\n        [10243]: 33071\n      },\n      pixelStore: {\n        [37440]: false\n      }\n    });\n\n    if (this.ownTexture) {\n      this.ownTexture.delete();\n    }\n\n    this.ownTexture = texture;\n    return texture;\n  }\n\n  _getNextIndex() {\n    return (this.currentIndex + 1) % 2;\n  }\n\n  _processVertexShader() {\n    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const {\n      sourceTextures,\n      targetTexture\n    } = this.bindings[this.currentIndex];\n    const {\n      vs,\n      uniforms,\n      targetTextureType,\n      inject,\n      samplerTextureMap\n    } = updateForTextures({\n      vs: props.vs,\n      sourceTextureMap: sourceTextures,\n      targetTextureVarying: this.targetTextureVarying,\n      targetTexture\n    });\n    const combinedInject = combineInjects([props.inject || {}, inject]);\n    this.targetTextureType = targetTextureType;\n    this.samplerTextureMap = samplerTextureMap;\n    const fs = props._fs || getPassthroughFS({\n      version: getShaderVersion(vs),\n      input: this.targetTextureVarying,\n      inputType: targetTextureType,\n      output: FS_OUTPUT_VARIABLE\n    });\n    const modules = this.hasSourceTextures || this.targetTextureVarying ? [transformModule].concat(props.modules || []) : props.modules;\n    return {\n      vs,\n      fs,\n      modules,\n      uniforms,\n      inject: combinedInject\n    };\n  }\n\n}","map":{"version":3,"sources":["../../../src/transform/texture-transform.js"],"names":["_transform","SRC_TEX_PARAMETER_OVERRIDES","FS_OUTPUT_VARIABLE","constructor","props","Object","updateModelProps","updatedModelProps","getDrawOptions","opts","targetTexture","attributes","uniforms","parameters","discard","textureName","sourceTextures","sizeUniforms","getSizeUniforms","sourceTextureMap","targetTextureVarying","framebuffer","swap","update","getTargetTexture","getData","packed","pixels","readPixelsToArray","ArrayType","channelCount","typeToChannelCount","packedPixels","packCount","i","j","getFramebuffer","currentResources","delete","_initialize","_swapTexture","_createTargetTexture","textureOrReference","refTexture","_setupTextures","_sourceTextures","_targetTexture","_updateElementIDBuffer","elementIds","array","data","accessor","size","_updateBindings","nextIndex","_updateBinding","binding","sourceBuffers","height","attachments","resizeAttachments","id","_setSourceTextureParameters","index","_swapTextures","_createNewTexture","texture","cloneTextureFrom","pixelStore","_getNextIndex","_processVertexShader","samplerTextureMap","updateForTextures","vs","combinedInject","combineInjects","fs","getPassthroughFS","version","getShaderVersion","input","inputType","output","modules","inject"],"mappings":"AAGA,SAAA,gBAAA,EAAA,iBAAA,EAAA,gBAAA,EAAA,MAAA,EAAA,SAAA,EAAA,WAAA,QAAA,gBAAA;AASA,SACEA,UAAU,IADZ,eAAA,EAAA,gBAAA,EAAA,kBAAA,EAAA,cAAA,QAAA,sBAAA;AAOA,SAAA,iBAAA,EAAA,eAAA,QAAA,0BAAA;AAIA,MAAMC,2BAA2B,GAAG;AAClC,GAAA,KAAA,GADkC,IAAA;AAElC,GAAA,KAAA,GAFkC,IAAA;AAGlC,GAAA,KAAA,GAHkC,KAAA;AAIlC,GAAA,KAAA,GAAA;AAJkC,CAApC;AAMA,MAAMC,kBAAkB,GAAxB,kBAAA;AAEA,eAAe,MAAA,gBAAA,CAAuB;AACpCC,EAAAA,WAAW,CAAA,EAAA,EAAiB;AAAA,QAAZC,KAAY,uEAAjB,EAAiB;AAC1B,SAAA,EAAA,GAAA,EAAA;AACA,SAAA,EAAA,GAAU,KAAA,YAAA,GAAV,CAAA;AACA,SAAA,YAAA,GAAA,IAAA;AACA,SAAA,oBAAA,GAAA,IAAA;AACA,SAAA,iBAAA,GAAA,IAAA;AACA,SAAA,iBAAA,GAAA,IAAA;AACA,SAAA,QAAA,GAAA,EAAA;AAEA,SAAA,SAAA,GAAA,EAAA;;AAEA,SAAA,WAAA,CAAA,KAAA;;AACAC,IAAAA,MAAM,CAANA,IAAAA,CAAAA,IAAAA;AACD;;AAEDC,EAAAA,gBAAgB,GAAa;AAAA,QAAZF,KAAY,uEAAb,EAAa;;AAC3B,UAAMG,iBAAiB,GAAG,KAAA,oBAAA,CAA1B,KAA0B,CAA1B;;AACA,WAAOF,MAAM,CAANA,MAAAA,CAAAA,EAAAA,EAAAA,KAAAA,EAAP,iBAAOA,CAAP;AACD;;AAEDG,EAAAA,cAAc,GAAY;AAAA,QAAXC,IAAW,uEAAZ,EAAY;AACxB,UAAM;AAAA,MAAA,aAAA;AAAA,MAAA,cAAA;AAAA,MAAA,WAAA;AAA6CC,MAAAA;AAA7C,QAA8D,KAAA,QAAA,CAClE,KADF,YAAoE,CAApE;AAIA,UAAMC,UAAU,GAAGN,MAAM,CAANA,MAAAA,CAAAA,EAAAA,EAAAA,aAAAA,EAAiCI,IAAI,CAAxD,UAAmBJ,CAAnB;AACA,UAAMO,QAAQ,GAAGP,MAAM,CAANA,MAAAA,CAAAA,EAAAA,EAAkBI,IAAI,CAAvC,QAAiBJ,CAAjB;AACA,UAAMQ,UAAU,GAAGR,MAAM,CAANA,MAAAA,CAAAA,EAAAA,EAAkBI,IAAI,CAAzC,UAAmBJ,CAAnB;AACA,QAAIS,OAAO,GAAGL,IAAI,CAAlB,OAAA;;AAEA,QAAI,KAAA,iBAAA,IAA0B,KAA9B,gBAAA,EAAqD;AACnDE,MAAAA,UAAU,CAAVA,mBAAAA,GAAiC,KAAjCA,eAAAA;;AAEA,WAAK,MAAL,OAAA,IAAsB,KAAtB,iBAAA,EAA8C;AAC5C,cAAMI,WAAW,GAAG,KAAA,iBAAA,CAApB,OAAoB,CAApB;AACAH,QAAAA,QAAQ,CAARA,OAAQ,CAARA,GAAoBI,cAAc,CAAlCJ,WAAkC,CAAlCA;AACD;;AACD,WAAA,2BAAA;;AAEA,YAAMK,YAAY,GAAGC,eAAe,CAAC;AACnCC,QAAAA,gBAAgB,EADmB,cAAA;AAEnCC,QAAAA,oBAAoB,EAAE,KAFa,oBAAA;AAGnCV,QAAAA;AAHmC,OAAD,CAApC;AAKAL,MAAAA,MAAM,CAANA,MAAAA,CAAAA,QAAAA,EAAAA,YAAAA;AACD;;AAED,QAAI,KAAJ,gBAAA,EAA2B;AACzBS,MAAAA,OAAO,GAAPA,KAAAA;AACAD,MAAAA,UAAU,CAAVA,QAAAA,GAAsB,CAAA,CAAA,EAAA,CAAA,EAAOQ,WAAW,CAAlB,KAAA,EAA0BA,WAAW,CAA3DR,MAAsB,CAAtBA;AACD;;AAED,WAAO;AAAA,MAAA,UAAA;AAAA,MAAA,WAAA;AAAA,MAAA,QAAA;AAAA,MAAA,OAAA;AAA6CA,MAAAA;AAA7C,KAAP;AACD;;AAEDS,EAAAA,IAAI,GAAG;AACL,QAAI,KAAJ,YAAA,EAAuB;AACrB,WAAA,YAAA,GAAoB,KAApB,aAAoB,EAApB;AACA,aAAA,IAAA;AACD;;AACD,WAAA,KAAA;AACD;;AAGDC,EAAAA,MAAM,GAAY;AAAA,QAAXd,IAAW,uEAAZ,EAAY;;AAChB,SAAA,cAAA,CAAA,IAAA;AACD;;AAGDe,EAAAA,gBAAgB,GAAG;AACjB,UAAM;AAACd,MAAAA;AAAD,QAAkB,KAAA,QAAA,CAAc,KAAtC,YAAwB,CAAxB;AACA,WAAA,aAAA;AACD;;AAEDe,EAAAA,OAAO,GAAwB;AAAA,QAAvB;AAACC,MAAAA,MAAM,GAAG;AAAV,KAAuB,uEAAxB,EAAwB;AAC7B,UAAM;AAACL,MAAAA;AAAD,QAAgB,KAAA,QAAA,CAAc,KAApC,YAAsB,CAAtB;AACA,UAAMM,MAAM,GAAGC,iBAAiB,CAAhC,WAAgC,CAAhC;;AAEA,QAAI,CAAJ,MAAA,EAAa;AACX,aAAA,MAAA;AACD;;AAGD,UAAMC,SAAS,GAAGF,MAAM,CAAxB,WAAA;AACA,UAAMG,YAAY,GAAGC,kBAAkB,CAAC,KAAxC,iBAAuC,CAAvC;AAEA,UAAMC,YAAY,GAAG,IAAA,SAAA,CAAeL,MAAM,CAANA,MAAAA,GAAD,YAACA,GAApC,CAAqB,CAArB;AACA,QAAIM,SAAS,GAAb,CAAA;;AACA,SAAK,IAAIC,CAAC,GAAV,CAAA,EAAgBA,CAAC,GAAGP,MAAM,CAA1B,MAAA,EAAmCO,CAAC,IAApC,CAAA,EAA2C;AACzC,WAAK,IAAIC,CAAC,GAAV,CAAA,EAAgBA,CAAC,GAAjB,YAAA,EAAkCA,CAAlC,EAAA,EAAuC;AACrCH,QAAAA,YAAY,CAACC,SAAbD,EAAY,CAAZA,GAA4BL,MAAM,CAACO,CAAC,GAApCF,CAAkC,CAAlCA;AACD;AACF;;AACD,WAAA,YAAA;AACD;;AAGDI,EAAAA,cAAc,GAAG;AACf,UAAMC,gBAAgB,GAAG,KAAA,QAAA,CAAc,KAAvC,YAAyB,CAAzB;AACA,WAAOA,gBAAgB,CAAvB,WAAA;AACD;;AAGDC,EAAAA,MAAM,GAAG;AACP,QAAI,KAAJ,UAAA,EAAqB;AACnB,WAAA,UAAA,CAAA,MAAA;AACD;;AACD,QAAI,KAAJ,eAAA,EAA0B;AACxB,WAAA,eAAA,CAAA,MAAA;AACD;AACF;;AAIDC,EAAAA,WAAW,GAAa;AAAA,QAAZnC,KAAY,uEAAb,EAAa;AACtB,UAAM;AAAA,MAAA,qBAAA;AAAwBoC,MAAAA;AAAxB,QAAN,KAAA;AACA,SAAA,YAAA,GAAA,YAAA;AACA,SAAA,oBAAA,GAAA,qBAAA;AACA,SAAA,gBAAA,GAAA,qBAAA;;AACA,SAAA,cAAA,CAAA,KAAA;AACD;;AAGDC,EAAAA,oBAAoB,CAAA,KAAA,EAAQ;AAC1B,UAAM;AAAA,MAAA,cAAA;AAAiBC,MAAAA;AAAjB,QAAN,KAAA;;AACA,QAAIA,kBAAkB,YAAtB,SAAA,EAA6C;AAC3C,aAAA,kBAAA;AACD;;AAED,UAAMC,UAAU,GAAG3B,cAAc,CAAjC,kBAAiC,CAAjC;;AACA,QAAI,CAAJ,UAAA,EAAiB;AACf,aAAA,IAAA;AACD;;AAID,SAAA,iBAAA,GAAA,kBAAA;AAEA,WAAO,KAAA,iBAAA,CAAP,UAAO,CAAP;AACD;;AAGD4B,EAAAA,cAAc,GAAa;AAAA,QAAZxC,KAAY,uEAAb,EAAa;AACzB,UAAM;AAAA,MAAA,aAAA;AAAgByC,MAAAA,eAAe,GAA/B,EAAA;AAAsCC,MAAAA;AAAtC,QAAN,KAAA;;AACA,UAAMpC,aAAa,GAAG,KAAA,oBAAA,CAA0B;AAC9CM,MAAAA,cAAc,EADgC,eAAA;AAE9C0B,MAAAA,kBAAkB,EAAEI;AAF0B,KAA1B,CAAtB;;AAIA,SAAA,iBAAA,GACE,KAAA,iBAAA,IAA2BD,eAAe,IAAIxC,MAAM,CAANA,IAAAA,CAAAA,eAAAA,EAAAA,MAAAA,GADhD,CAAA;;AAEA,SAAA,eAAA,CAAqB;AAAA,MAAA,aAAA;AAAgBW,MAAAA,cAAc,EAA9B,eAAA;AAAiDN,MAAAA;AAAjD,KAArB;;AACA,QAAI,kBAAJ,KAAA,EAA6B;AAC3B,WAAA,sBAAA,CAA4BN,KAAK,CAAjC,YAAA;AACD;AACF;;AAED2C,EAAAA,sBAAsB,CAAA,YAAA,EAAe;AACnC,QAAI,OAAA,YAAA,KAAA,QAAA,IAAoC,KAAA,YAAA,IAAxC,YAAA,EAA2E;AACzE;AACD;;AAED,UAAMC,UAAU,GAAG,IAAA,YAAA,CAAnB,YAAmB,CAAnB;AACAA,IAAAA,UAAU,CAAVA,OAAAA,CAAmB,CAAA,CAAA,EAAA,KAAA,EAAA,KAAA,KAAqB;AACtCC,MAAAA,KAAK,CAALA,KAAK,CAALA,GAAAA,KAAAA;AADFD,KAAAA;;AAGA,QAAI,CAAC,KAAL,eAAA,EAA2B;AACzB,WAAA,eAAA,GAAuB,IAAA,MAAA,CAAW,KAAX,EAAA,EAAoB;AACzCE,QAAAA,IAAI,EADqC,UAAA;AAEzCC,QAAAA,QAAQ,EAAE;AAACC,UAAAA,IAAI,EAAE;AAAP;AAF+B,OAApB,CAAvB;AADF,KAAA,MAKO;AACL,WAAA,eAAA,CAAA,OAAA,CAA6B;AAACF,QAAAA,IAAI,EAAEF;AAAP,OAA7B;AACD;;AACD,SAAA,YAAA,GAAA,YAAA;AACD;;AAEDK,EAAAA,eAAe,CAAA,IAAA,EAAO;AACpB,SAAA,QAAA,CAAc,KAAd,YAAA,IAAmC,KAAA,cAAA,CAAoB,KAAA,QAAA,CAAc,KAAlC,YAAoB,CAApB,EAAnC,IAAmC,CAAnC;;AACA,QAAI,KAAJ,YAAA,EAAuB;AACrB,YAAM;AAAA,QAAA,cAAA;AAAiB3C,QAAAA;AAAjB,UAAkC,KAAA,aAAA,CAAmB,KAAA,QAAA,CAAc,KAAzE,YAA2D,CAAnB,CAAxC;;AACA,YAAM4C,SAAS,GAAG,KAAlB,aAAkB,EAAlB;;AACA,WAAA,QAAA,CAAA,SAAA,IAA2B,KAAA,cAAA,CAAoB,KAAA,QAAA,CAApB,SAAoB,CAApB,EAA8C;AAAA,QAAA,cAAA;AAEvE5C,QAAAA;AAFuE,OAA9C,CAA3B;AAID;AACF;;AAED6C,EAAAA,cAAc,CAAA,OAAA,EAAA,IAAA,EAAgB;AAC5B,UAAM;AAAA,MAAA,aAAA;AAAA,MAAA,cAAA;AAAgC7C,MAAAA;AAAhC,QAAN,IAAA;;AACA,QAAI,CAAJ,OAAA,EAAc;AACZ8C,MAAAA,OAAO,GAAG;AACRC,QAAAA,aAAa,EADL,EAAA;AAERzC,QAAAA,cAAc,EAFN,EAAA;AAGRN,QAAAA,aAAa,EAAE;AAHP,OAAV8C;AAKD;;AACDnD,IAAAA,MAAM,CAANA,MAAAA,CAAcmD,OAAO,CAArBnD,cAAAA,EAAAA,cAAAA;AACAA,IAAAA,MAAM,CAANA,MAAAA,CAAcmD,OAAO,CAArBnD,aAAAA,EAAAA,aAAAA;;AACA,QAAA,aAAA,EAAmB;AACjBmD,MAAAA,OAAO,CAAPA,aAAAA,GAAAA,aAAAA;AAEA,YAAM;AAAA,QAAA,KAAA;AAAQE,QAAAA;AAAR,UAAN,aAAA;AACA,YAAM;AAACrC,QAAAA;AAAD,UAAN,OAAA;;AACA,UAAA,WAAA,EAAiB;AAEfA,QAAAA,WAAW,CAAXA,MAAAA,CAAmB;AACjBsC,UAAAA,WAAW,EAAE;AAAC,aAAA,KAAA,GAAwBjD;AAAzB,WADI;AAEjBkD,UAAAA,iBAAiB,EAAE;AAFF,SAAnBvC;AAKAA,QAAAA,WAAW,CAAXA,MAAAA,CAAmB;AAAA,UAAA,KAAA;AAAQqC,UAAAA;AAAR,SAAnBrC;AAPF,OAAA,MAQO;AACLmC,QAAAA,OAAO,CAAPA,WAAAA,GAAsB,IAAA,WAAA,CAAgB,KAAhB,EAAA,EAAyB;AAC7CK,UAAAA,EAAE,EAD2C,uBAAA;AAAA,UAAA,KAAA;AAAA,UAAA,MAAA;AAI7CF,UAAAA,WAAW,EAAE;AACX,aAAA,KAAA,GAAwBjD;AADb;AAJgC,SAAzB,CAAtB8C;AAQD;AACF;;AACD,WAAA,OAAA;AACD;;AAGDM,EAAAA,2BAA2B,GAAG;AAC5B,UAAMC,KAAK,GAAG,KAAd,YAAA;AACA,UAAM;AAAC/C,MAAAA;AAAD,QAAmB,KAAA,QAAA,CAAzB,KAAyB,CAAzB;;AACA,SAAK,MAAL,IAAA,IAAA,cAAA,EAAmC;AACjCA,MAAAA,cAAc,CAAdA,IAAc,CAAdA,CAAAA,aAAAA,CAAAA,2BAAAA;AACD;AACF;;AAEDgD,EAAAA,aAAa,CAAA,IAAA,EAAO;AAClB,QAAI,CAAC,KAAL,YAAA,EAAwB;AACtB,aAAA,IAAA;AACD;;AACD,UAAMhD,cAAc,GAAGX,MAAM,CAANA,MAAAA,CAAAA,EAAAA,EAAkBI,IAAI,CAA7C,cAAuBJ,CAAvB;AACAW,IAAAA,cAAc,CAAC,KAAfA,YAAc,CAAdA,GAAoCP,IAAI,CAAxCO,aAAAA;AAEA,UAAMN,aAAa,GAAGD,IAAI,CAAJA,cAAAA,CAAoB,KAA1C,YAAsBA,CAAtB;AAEA,WAAO;AAAA,MAAA,cAAA;AAAiBC,MAAAA;AAAjB,KAAP;AACD;;AAGDuD,EAAAA,iBAAiB,CAAA,UAAA,EAAa;AAC5B,UAAMC,OAAO,GAAGC,gBAAgB,CAAA,UAAA,EAAa;AAC3CtD,MAAAA,UAAU,EAAE;AACV,SAAA,KAAA,GADU,IAAA;AAEV,SAAA,KAAA,GAFU,IAAA;AAGV,SAAA,KAAA,GAHU,KAAA;AAIV,SAAA,KAAA,GAAA;AAJU,OAD+B;AAO3CuD,MAAAA,UAAU,EAAE;AACV,SAAA,KAAA,GAA0B;AADhB;AAP+B,KAAb,CAAhC;;AAaA,QAAI,KAAJ,UAAA,EAAqB;AACnB,WAAA,UAAA,CAAA,MAAA;AACD;;AACD,SAAA,UAAA,GAAA,OAAA;AAEA,WAAA,OAAA;AACD;;AAEDC,EAAAA,aAAa,GAAG;AACd,WAAO,CAAC,KAAA,YAAA,GAAD,CAAA,IAAP,CAAA;AACD;;AAGDC,EAAAA,oBAAoB,GAAa;AAAA,QAAZlE,KAAY,uEAAb,EAAa;AAC/B,UAAM;AAAA,MAAA,cAAA;AAAiBM,MAAAA;AAAjB,QAAkC,KAAA,QAAA,CAAc,KAAtD,YAAwC,CAAxC;AAEA,UAAM;AAAA,MAAA,EAAA;AAAA,MAAA,QAAA;AAAA,MAAA,iBAAA;AAAA,MAAA,MAAA;AAA0C6D,MAAAA;AAA1C,QAA+DC,iBAAiB,CAAC;AACrFC,MAAAA,EAAE,EAAErE,KAAK,CAD4E,EAAA;AAErFe,MAAAA,gBAAgB,EAFqE,cAAA;AAGrFC,MAAAA,oBAAoB,EAAE,KAH+D,oBAAA;AAIrFV,MAAAA;AAJqF,KAAD,CAAtF;AAMA,UAAMgE,cAAc,GAAGC,cAAc,CAAC,CAACvE,KAAK,CAALA,MAAAA,IAAD,EAAA,EAAtC,MAAsC,CAAD,CAArC;AACA,SAAA,iBAAA,GAAA,iBAAA;AACA,SAAA,iBAAA,GAAA,iBAAA;AACA,UAAMwE,EAAE,GACNxE,KAAK,CAALA,GAAAA,IACAyE,gBAAgB,CAAC;AACfC,MAAAA,OAAO,EAAEC,gBAAgB,CADV,EACU,CADV;AAEfC,MAAAA,KAAK,EAAE,KAFQ,oBAAA;AAGfC,MAAAA,SAAS,EAHM,iBAAA;AAIfC,MAAAA,MAAM,EAAEhF;AAJO,KAAD,CAFlB;AAQA,UAAMiF,OAAO,GACX,KAAA,iBAAA,IAA0B,KAA1B,oBAAA,GACI,CAAA,eAAA,EAAA,MAAA,CAAyB/E,KAAK,CAALA,OAAAA,IAD7B,EACI,CADJ,GAEIA,KAAK,CAHX,OAAA;AAIA,WAAO;AAAA,MAAA,EAAA;AAAA,MAAA,EAAA;AAAA,MAAA,OAAA;AAAA,MAAA,QAAA;AAA4BgF,MAAAA,MAAM,EAAEV;AAApC,KAAP;AACD;;AA7SmC","sourcesContent":["/** @typedef {import('./transform').TransformProps} TransformProps */\nimport GL from '@luma.gl/constants';\n\nimport {\n  cloneTextureFrom,\n  readPixelsToArray,\n  getShaderVersion,\n  Buffer,\n  Texture2D,\n  Framebuffer\n} from '@luma.gl/webgl';\n\nimport {\n  _transform as transformModule,\n  getPassthroughFS,\n  typeToChannelCount,\n  combineInjects\n} from '@luma.gl/shadertools';\n\nimport {updateForTextures, getSizeUniforms} from './transform-shader-utils';\n\n// TODO: move these constants to transform-shader-utils\n// Texture parameters needed so sample can precisely pick pixel for given element id.\nconst SRC_TEX_PARAMETER_OVERRIDES = {\n  [GL.TEXTURE_MIN_FILTER]: GL.NEAREST,\n  [GL.TEXTURE_MAG_FILTER]: GL.NEAREST,\n  [GL.TEXTURE_WRAP_S]: GL.CLAMP_TO_EDGE,\n  [GL.TEXTURE_WRAP_T]: GL.CLAMP_TO_EDGE\n};\nconst FS_OUTPUT_VARIABLE = 'transform_output';\n\nexport default class TextureTransform {\n  constructor(gl, props = {}) {\n    this.gl = gl;\n    this.id = this.currentIndex = 0;\n    this._swapTexture = null;\n    this.targetTextureVarying = null;\n    this.targetTextureType = null;\n    this.samplerTextureMap = null;\n    this.bindings = []; // each element is an object : {sourceTextures, targetTexture, framebuffer}\n\n    this.resources = {}; // resources to be deleted\n\n    this._initialize(props);\n    Object.seal(this);\n  }\n\n  updateModelProps(props = {}) {\n    const updatedModelProps = this._processVertexShader(props);\n    return Object.assign({}, props, updatedModelProps);\n  }\n\n  getDrawOptions(opts = {}) {\n    const {sourceBuffers, sourceTextures, framebuffer, targetTexture} = this.bindings[\n      this.currentIndex\n    ];\n\n    const attributes = Object.assign({}, sourceBuffers, opts.attributes);\n    const uniforms = Object.assign({}, opts.uniforms);\n    const parameters = Object.assign({}, opts.parameters);\n    let discard = opts.discard;\n\n    if (this.hasSourceTextures || this.hasTargetTexture) {\n      attributes.transform_elementID = this.elementIDBuffer;\n\n      for (const sampler in this.samplerTextureMap) {\n        const textureName = this.samplerTextureMap[sampler];\n        uniforms[sampler] = sourceTextures[textureName];\n      }\n      this._setSourceTextureParameters();\n      // get texture size uniforms\n      const sizeUniforms = getSizeUniforms({\n        sourceTextureMap: sourceTextures,\n        targetTextureVarying: this.targetTextureVarying,\n        targetTexture\n      });\n      Object.assign(uniforms, sizeUniforms);\n    }\n\n    if (this.hasTargetTexture) {\n      discard = false;\n      parameters.viewport = [0, 0, framebuffer.width, framebuffer.height];\n    }\n\n    return {attributes, framebuffer, uniforms, discard, parameters};\n  }\n\n  swap() {\n    if (this._swapTexture) {\n      this.currentIndex = this._getNextIndex();\n      return true;\n    }\n    return false;\n  }\n\n  // update source and/or feedbackBuffers\n  update(opts = {}) {\n    this._setupTextures(opts);\n  }\n\n  // returns current target texture\n  getTargetTexture() {\n    const {targetTexture} = this.bindings[this.currentIndex];\n    return targetTexture;\n  }\n\n  getData({packed = false} = {}) {\n    const {framebuffer} = this.bindings[this.currentIndex];\n    const pixels = readPixelsToArray(framebuffer);\n\n    if (!packed) {\n      return pixels;\n    }\n\n    // readPixels returns 4 elements for each pixel, pack the elements when requested\n    const ArrayType = pixels.constructor;\n    const channelCount = typeToChannelCount(this.targetTextureType);\n    // @ts-ignore\n    const packedPixels = new ArrayType((pixels.length * channelCount) / 4);\n    let packCount = 0;\n    for (let i = 0; i < pixels.length; i += 4) {\n      for (let j = 0; j < channelCount; j++) {\n        packedPixels[packCount++] = pixels[i + j];\n      }\n    }\n    return packedPixels;\n  }\n\n  // returns current framebuffer object that is being used.\n  getFramebuffer() {\n    const currentResources = this.bindings[this.currentIndex];\n    return currentResources.framebuffer;\n  }\n\n  // Delete owned resources.\n  delete() {\n    if (this.ownTexture) {\n      this.ownTexture.delete();\n    }\n    if (this.elementIDBuffer) {\n      this.elementIDBuffer.delete();\n    }\n  }\n\n  // Private\n\n  _initialize(props = {}) {\n    const {_targetTextureVarying, _swapTexture} = props;\n    this._swapTexture = _swapTexture;\n    this.targetTextureVarying = _targetTextureVarying;\n    this.hasTargetTexture = _targetTextureVarying;\n    this._setupTextures(props);\n  }\n\n  // auto create target texture if requested\n  _createTargetTexture(props) {\n    const {sourceTextures, textureOrReference} = props;\n    if (textureOrReference instanceof Texture2D) {\n      return textureOrReference;\n    }\n    // 'targetTexture' is a reference souce texture.\n    const refTexture = sourceTextures[textureOrReference];\n    if (!refTexture) {\n      return null;\n    }\n\n    // save reference texture name, when corresponding source texture is updated\n    // we also update target texture.\n    this._targetRefTexName = textureOrReference;\n\n    return this._createNewTexture(refTexture);\n  }\n\n  /** @param {TransformProps} props */\n  _setupTextures(props = {}) {\n    const {sourceBuffers, _sourceTextures = {}, _targetTexture} = props;\n    const targetTexture = this._createTargetTexture({\n      sourceTextures: _sourceTextures,\n      textureOrReference: _targetTexture\n    });\n    this.hasSourceTextures =\n      this.hasSourceTextures || (_sourceTextures && Object.keys(_sourceTextures).length > 0);\n    this._updateBindings({sourceBuffers, sourceTextures: _sourceTextures, targetTexture});\n    if ('elementCount' in props) {\n      this._updateElementIDBuffer(props.elementCount);\n    }\n  }\n\n  _updateElementIDBuffer(elementCount) {\n    if (typeof elementCount !== 'number' || this.elementCount >= elementCount) {\n      return;\n    }\n    // NOTE: using float so this will work with GLSL 1.0 shaders.\n    const elementIds = new Float32Array(elementCount);\n    elementIds.forEach((_, index, array) => {\n      array[index] = index;\n    });\n    if (!this.elementIDBuffer) {\n      this.elementIDBuffer = new Buffer(this.gl, {\n        data: elementIds,\n        accessor: {size: 1}\n      });\n    } else {\n      this.elementIDBuffer.setData({data: elementIds});\n    }\n    this.elementCount = elementCount;\n  }\n\n  _updateBindings(opts) {\n    this.bindings[this.currentIndex] = this._updateBinding(this.bindings[this.currentIndex], opts);\n    if (this._swapTexture) {\n      const {sourceTextures, targetTexture} = this._swapTextures(this.bindings[this.currentIndex]);\n      const nextIndex = this._getNextIndex();\n      this.bindings[nextIndex] = this._updateBinding(this.bindings[nextIndex], {\n        sourceTextures,\n        targetTexture\n      });\n    }\n  }\n\n  _updateBinding(binding, opts) {\n    const {sourceBuffers, sourceTextures, targetTexture} = opts;\n    if (!binding) {\n      binding = {\n        sourceBuffers: {},\n        sourceTextures: {},\n        targetTexture: null\n      };\n    }\n    Object.assign(binding.sourceTextures, sourceTextures);\n    Object.assign(binding.sourceBuffers, sourceBuffers);\n    if (targetTexture) {\n      binding.targetTexture = targetTexture;\n\n      const {width, height} = targetTexture;\n      const {framebuffer} = binding;\n      if (framebuffer) {\n        // First update texture without re-sizing attachments\n        framebuffer.update({\n          attachments: {[GL.COLOR_ATTACHMENT0]: targetTexture},\n          resizeAttachments: false\n        });\n        // Resize to new taget texture size\n        framebuffer.resize({width, height});\n      } else {\n        binding.framebuffer = new Framebuffer(this.gl, {\n          id: `transform-framebuffer`,\n          width,\n          height,\n          attachments: {\n            [GL.COLOR_ATTACHMENT0]: targetTexture\n          }\n        });\n      }\n    }\n    return binding;\n  }\n\n  // set texture filtering parameters on source textures.\n  _setSourceTextureParameters() {\n    const index = this.currentIndex;\n    const {sourceTextures} = this.bindings[index];\n    for (const name in sourceTextures) {\n      sourceTextures[name].setParameters(SRC_TEX_PARAMETER_OVERRIDES);\n    }\n  }\n\n  _swapTextures(opts) {\n    if (!this._swapTexture) {\n      return null;\n    }\n    const sourceTextures = Object.assign({}, opts.sourceTextures);\n    sourceTextures[this._swapTexture] = opts.targetTexture;\n\n    const targetTexture = opts.sourceTextures[this._swapTexture];\n\n    return {sourceTextures, targetTexture};\n  }\n\n  // Create a buffer and add to list of buffers to be deleted.\n  _createNewTexture(refTexture) {\n    const texture = cloneTextureFrom(refTexture, {\n      parameters: {\n        [GL.TEXTURE_MIN_FILTER]: GL.NEAREST,\n        [GL.TEXTURE_MAG_FILTER]: GL.NEAREST,\n        [GL.TEXTURE_WRAP_S]: GL.CLAMP_TO_EDGE,\n        [GL.TEXTURE_WRAP_T]: GL.CLAMP_TO_EDGE\n      },\n      pixelStore: {\n        [GL.UNPACK_FLIP_Y_WEBGL]: false\n      }\n    });\n\n    // thre can only be one target texture\n    if (this.ownTexture) {\n      this.ownTexture.delete();\n    }\n    this.ownTexture = texture;\n\n    return texture;\n  }\n\n  _getNextIndex() {\n    return (this.currentIndex + 1) % 2;\n  }\n\n  // build and return shader releated parameters\n  _processVertexShader(props = {}) {\n    const {sourceTextures, targetTexture} = this.bindings[this.currentIndex];\n    // @ts-ignore TODO - uniforms is not present\n    const {vs, uniforms, targetTextureType, inject, samplerTextureMap} = updateForTextures({\n      vs: props.vs,\n      sourceTextureMap: sourceTextures,\n      targetTextureVarying: this.targetTextureVarying,\n      targetTexture\n    });\n    const combinedInject = combineInjects([props.inject || {}, inject]);\n    this.targetTextureType = targetTextureType;\n    this.samplerTextureMap = samplerTextureMap;\n    const fs =\n      props._fs ||\n      getPassthroughFS({\n        version: getShaderVersion(vs),\n        input: this.targetTextureVarying,\n        inputType: targetTextureType,\n        output: FS_OUTPUT_VARIABLE\n      });\n    const modules =\n      this.hasSourceTextures || this.targetTextureVarying\n        ? [transformModule].concat(props.modules || [])\n        : props.modules;\n    return {vs, fs, modules, uniforms, inject: combinedInject};\n  }\n}\n"]},"metadata":{},"sourceType":"module"}