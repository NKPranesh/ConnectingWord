{"ast":null,"code":"import lightingShader from './lights.glsl';\nconst INITIAL_MODULE_OPTIONS = {\n  lightSources: {}\n};\n\nfunction convertColor() {\n  let {\n    color = [0, 0, 0],\n    intensity = 1.0\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return color.map(component => component * intensity / 255.0);\n}\n\nfunction getLightSourceUniforms(_ref) {\n  let {\n    ambientLight,\n    pointLights = [],\n    directionalLights = []\n  } = _ref;\n  const lightSourceUniforms = {};\n\n  if (ambientLight) {\n    lightSourceUniforms['lighting_uAmbientLight.color'] = convertColor(ambientLight);\n  } else {\n    lightSourceUniforms['lighting_uAmbientLight.color'] = [0, 0, 0];\n  }\n\n  pointLights.forEach((pointLight, index) => {\n    lightSourceUniforms[`lighting_uPointLight[${index}].color`] = convertColor(pointLight);\n    lightSourceUniforms[`lighting_uPointLight[${index}].position`] = pointLight.position;\n    lightSourceUniforms[`lighting_uPointLight[${index}].attenuation`] = pointLight.attenuation || [1, 0, 0];\n  });\n  lightSourceUniforms.lighting_uPointLightCount = pointLights.length;\n  directionalLights.forEach((directionalLight, index) => {\n    lightSourceUniforms[`lighting_uDirectionalLight[${index}].color`] = convertColor(directionalLight);\n    lightSourceUniforms[`lighting_uDirectionalLight[${index}].direction`] = directionalLight.direction;\n  });\n  lightSourceUniforms.lighting_uDirectionalLightCount = directionalLights.length;\n  return lightSourceUniforms;\n}\n\nfunction getUniforms() {\n  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : INITIAL_MODULE_OPTIONS;\n\n  if ('lightSources' in opts) {\n    const {\n      ambientLight,\n      pointLights,\n      directionalLights\n    } = opts.lightSources || {};\n    const hasLights = ambientLight || pointLights && pointLights.length > 0 || directionalLights && directionalLights.length > 0;\n\n    if (!hasLights) {\n      return {\n        lighting_uEnabled: false\n      };\n    }\n\n    return Object.assign({}, getLightSourceUniforms({\n      ambientLight,\n      pointLights,\n      directionalLights\n    }), {\n      lighting_uEnabled: true\n    });\n  }\n\n  if ('lights' in opts) {\n    const lightSources = {\n      pointLights: [],\n      directionalLights: []\n    };\n\n    for (const light of opts.lights || []) {\n      switch (light.type) {\n        case 'ambient':\n          lightSources.ambientLight = light;\n          break;\n\n        case 'directional':\n          lightSources.directionalLights.push(light);\n          break;\n\n        case 'point':\n          lightSources.pointLights.push(light);\n          break;\n\n        default:\n      }\n    }\n\n    return getUniforms({\n      lightSources\n    });\n  }\n\n  return {};\n}\n\nexport const lights = {\n  name: 'lights',\n  vs: lightingShader,\n  fs: lightingShader,\n  getUniforms,\n  defines: {\n    MAX_LIGHTS: 3\n  }\n};","map":{"version":3,"sources":["../../../../src/modules/lights/lights.js"],"names":["INITIAL_MODULE_OPTIONS","lightSources","color","intensity","component","pointLights","directionalLights","lightSourceUniforms","convertColor","index","pointLight","directionalLight","opts","hasLights","ambientLight","lighting_uEnabled","getLightSourceUniforms","light","getUniforms","lights","name","vs","fs","defines","MAX_LIGHTS"],"mappings":"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","sourcesContent":["/** @typedef {import('../../types').ShaderModule} ShaderModule */\n\nimport lightingShader from './lights.glsl';\n\nconst INITIAL_MODULE_OPTIONS = {\n  lightSources: {}\n};\n\n// Take color 0-255 and intensity as input and output 0.0-1.0 range\nfunction convertColor({color = [0, 0, 0], intensity = 1.0} = {}) {\n  return color.map(component => (component * intensity) / 255.0);\n}\n\nfunction getLightSourceUniforms({ambientLight, pointLights = [], directionalLights = []}) {\n  const lightSourceUniforms = {};\n\n  if (ambientLight) {\n    lightSourceUniforms['lighting_uAmbientLight.color'] = convertColor(ambientLight);\n  } else {\n    lightSourceUniforms['lighting_uAmbientLight.color'] = [0, 0, 0];\n  }\n\n  pointLights.forEach((pointLight, index) => {\n    lightSourceUniforms[`lighting_uPointLight[${index}].color`] = convertColor(pointLight);\n    lightSourceUniforms[`lighting_uPointLight[${index}].position`] = pointLight.position;\n    lightSourceUniforms[`lighting_uPointLight[${index}].attenuation`] = pointLight.attenuation || [\n      1,\n      0,\n      0\n    ];\n  });\n  lightSourceUniforms.lighting_uPointLightCount = pointLights.length;\n\n  directionalLights.forEach((directionalLight, index) => {\n    lightSourceUniforms[`lighting_uDirectionalLight[${index}].color`] = convertColor(\n      directionalLight\n    );\n    lightSourceUniforms[`lighting_uDirectionalLight[${index}].direction`] =\n      directionalLight.direction;\n  });\n  lightSourceUniforms.lighting_uDirectionalLightCount = directionalLights.length;\n\n  return lightSourceUniforms;\n}\n\n// eslint-disable-next-line complexity\nfunction getUniforms(opts = INITIAL_MODULE_OPTIONS) {\n  // Specify lights separately\n  if ('lightSources' in opts) {\n    const {ambientLight, pointLights, directionalLights} = opts.lightSources || {};\n    const hasLights =\n      ambientLight ||\n      (pointLights && pointLights.length > 0) ||\n      (directionalLights && directionalLights.length > 0);\n\n    if (!hasLights) {\n      return {lighting_uEnabled: false};\n    }\n\n    return Object.assign(\n      {},\n      getLightSourceUniforms({ambientLight, pointLights, directionalLights}),\n      {\n        lighting_uEnabled: true\n      }\n    );\n  }\n\n  // Support for array of lights. Type of light is detected by type field\n  if ('lights' in opts) {\n    const lightSources = {pointLights: [], directionalLights: []};\n    // @ts-ignore\n    for (const light of opts.lights || []) {\n      switch (light.type) {\n        case 'ambient':\n          // Note: Only uses last ambient light\n          // TODO - add ambient light sources on CPU?\n          lightSources.ambientLight = light;\n          break;\n        case 'directional':\n          lightSources.directionalLights.push(light);\n          break;\n        case 'point':\n          lightSources.pointLights.push(light);\n          break;\n        default:\n        // eslint-disable-next-line\n        // console.warn(light.type);\n      }\n    }\n\n    // Call the `opts.lightSources`` version\n    return getUniforms({lightSources});\n  }\n\n  return {};\n}\n\n/** @type {ShaderModule} */\nexport const lights = {\n  name: 'lights',\n  vs: lightingShader,\n  fs: lightingShader,\n  getUniforms,\n  defines: {\n    MAX_LIGHTS: 3\n  }\n};\n"]},"metadata":{},"sourceType":"module"}