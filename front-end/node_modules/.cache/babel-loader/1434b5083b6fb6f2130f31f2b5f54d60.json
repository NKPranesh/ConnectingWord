{"ast":null,"code":"'use strict';\n\nmodule.exports = TinySDF;\nmodule.exports.default = TinySDF;\nvar INF = 1e20;\n\nfunction TinySDF(fontSize, buffer, radius, cutoff, fontFamily, fontWeight) {\n  this.fontSize = fontSize || 24;\n  this.buffer = buffer === undefined ? 3 : buffer;\n  this.cutoff = cutoff || 0.25;\n  this.fontFamily = fontFamily || 'sans-serif';\n  this.fontWeight = fontWeight || 'normal';\n  this.radius = radius || 8; // For backwards compatibility, we honor the implicit contract that the\n  // size of the returned bitmap will be fontSize + buffer * 2\n\n  var size = this.size = this.fontSize + this.buffer * 2; // Glyphs may be slightly larger than their fontSize. The canvas already\n  // has buffer space, but create extra buffer space in the output grid for the\n  // \"halo\" to extend into (if metric extraction is enabled)\n\n  var gridSize = size + this.buffer * 2;\n  this.canvas = document.createElement('canvas');\n  this.canvas.width = this.canvas.height = size;\n  this.ctx = this.canvas.getContext('2d');\n  this.ctx.font = this.fontWeight + ' ' + this.fontSize + 'px ' + this.fontFamily;\n  this.ctx.textAlign = 'left'; // Necessary so that RTL text doesn't have different alignment\n\n  this.ctx.fillStyle = 'black'; // temporary arrays for the distance transform\n\n  this.gridOuter = new Float64Array(gridSize * gridSize);\n  this.gridInner = new Float64Array(gridSize * gridSize);\n  this.f = new Float64Array(gridSize);\n  this.z = new Float64Array(gridSize + 1);\n  this.v = new Uint16Array(gridSize);\n  this.useMetrics = this.ctx.measureText('A').actualBoundingBoxLeft !== undefined; // hack around https://bugzilla.mozilla.org/show_bug.cgi?id=737852\n\n  this.middle = Math.round(size / 2 * (navigator.userAgent.indexOf('Gecko/') >= 0 ? 1.2 : 1));\n}\n\nfunction prepareGrids(imgData, width, height, glyphWidth, glyphHeight, gridOuter, gridInner) {\n  // Initialize grids outside the glyph range to alpha 0\n  gridOuter.fill(INF, 0, width * height);\n  gridInner.fill(0, 0, width * height);\n  var offset = (width - glyphWidth) / 2; // This is zero if we're not extracting metrics\n\n  for (var y = 0; y < glyphHeight; y++) {\n    for (var x = 0; x < glyphWidth; x++) {\n      var j = (y + offset) * width + x + offset;\n      var a = imgData.data[4 * (y * glyphWidth + x) + 3] / 255; // alpha value\n\n      if (a === 1) {\n        gridOuter[j] = 0;\n        gridInner[j] = INF;\n      } else if (a === 0) {\n        gridOuter[j] = INF;\n        gridInner[j] = 0;\n      } else {\n        var b = Math.max(0, 0.5 - a);\n        var c = Math.max(0, a - 0.5);\n        gridOuter[j] = b * b;\n        gridInner[j] = c * c;\n      }\n    }\n  }\n}\n\nfunction extractAlpha(alphaChannel, width, height, gridOuter, gridInner, radius, cutoff) {\n  for (var i = 0; i < width * height; i++) {\n    var d = Math.sqrt(gridOuter[i]) - Math.sqrt(gridInner[i]);\n    alphaChannel[i] = Math.round(255 - 255 * (d / radius + cutoff));\n  }\n}\n\nTinySDF.prototype._draw = function (char, getMetrics) {\n  var textMetrics = this.ctx.measureText(char); // Older browsers only expose the glyph width\n  // This is enough for basic layout with all glyphs using the same fixed size\n\n  var advance = textMetrics.width;\n  var doubleBuffer = 2 * this.buffer;\n  var width, glyphWidth, height, glyphHeight, top;\n  var imgTop, imgLeft, baselinePosition; // If the browser supports bounding box metrics, we can generate a smaller\n  // SDF. This is a significant performance win.\n\n  if (getMetrics && this.useMetrics) {\n    // The integer/pixel part of the top alignment is encoded in metrics.top\n    // The remainder is implicitly encoded in the rasterization\n    top = Math.floor(textMetrics.actualBoundingBoxAscent);\n    baselinePosition = this.buffer + Math.ceil(textMetrics.actualBoundingBoxAscent);\n    imgTop = this.buffer;\n    imgLeft = this.buffer; // If the glyph overflows the canvas size, it will be clipped at the\n    // bottom/right\n\n    glyphWidth = Math.min(this.size, Math.ceil(textMetrics.actualBoundingBoxRight - textMetrics.actualBoundingBoxLeft));\n    glyphHeight = Math.min(this.size - imgTop, Math.ceil(textMetrics.actualBoundingBoxAscent + textMetrics.actualBoundingBoxDescent));\n    width = glyphWidth + doubleBuffer;\n    height = glyphHeight + doubleBuffer;\n    this.ctx.textBaseline = 'alphabetic';\n  } else {\n    width = glyphWidth = this.size;\n    height = glyphHeight = this.size; // 19 points is an approximation of the \"cap height\" ascent from alphabetic\n    // baseline (even though actual drawing is from middle baseline, we can\n    // use the approximation because every glyph fills the em box)\n\n    top = 19 * this.fontSize / 24;\n    imgTop = imgLeft = 0;\n    baselinePosition = this.middle;\n    this.ctx.textBaseline = 'middle';\n  }\n\n  var imgData;\n\n  if (glyphWidth && glyphHeight) {\n    this.ctx.clearRect(imgLeft, imgTop, glyphWidth, glyphHeight);\n    this.ctx.fillText(char, this.buffer, baselinePosition);\n    imgData = this.ctx.getImageData(imgLeft, imgTop, glyphWidth, glyphHeight);\n  }\n\n  var alphaChannel = new Uint8ClampedArray(width * height);\n  prepareGrids(imgData, width, height, glyphWidth, glyphHeight, this.gridOuter, this.gridInner);\n  edt(this.gridOuter, width, height, this.f, this.v, this.z);\n  edt(this.gridInner, width, height, this.f, this.v, this.z);\n  extractAlpha(alphaChannel, width, height, this.gridOuter, this.gridInner, this.radius, this.cutoff);\n  return {\n    data: alphaChannel,\n    metrics: {\n      width: glyphWidth,\n      height: glyphHeight,\n      sdfWidth: width,\n      sdfHeight: height,\n      top: top,\n      left: 0,\n      advance: advance\n    }\n  };\n};\n\nTinySDF.prototype.draw = function (char) {\n  return this._draw(char, false).data;\n};\n\nTinySDF.prototype.drawWithMetrics = function (char) {\n  return this._draw(char, true);\n}; // 2D Euclidean squared distance transform by Felzenszwalb & Huttenlocher https://cs.brown.edu/~pff/papers/dt-final.pdf\n\n\nfunction edt(data, width, height, f, v, z) {\n  for (var x = 0; x < width; x++) edt1d(data, x, width, height, f, v, z);\n\n  for (var y = 0; y < height; y++) edt1d(data, y * width, 1, width, f, v, z);\n} // 1D squared distance transform\n\n\nfunction edt1d(grid, offset, stride, length, f, v, z) {\n  var q, k, s, r;\n  v[0] = 0;\n  z[0] = -INF;\n  z[1] = INF;\n\n  for (q = 0; q < length; q++) f[q] = grid[offset + q * stride];\n\n  for (q = 1, k = 0, s = 0; q < length; q++) {\n    do {\n      r = v[k];\n      s = (f[q] - f[r] + q * q - r * r) / (q - r) / 2;\n    } while (s <= z[k] && --k > -1);\n\n    k++;\n    v[k] = q;\n    z[k] = s;\n    z[k + 1] = INF;\n  }\n\n  for (q = 0, k = 0; q < length; q++) {\n    while (z[k + 1] < q) k++;\n\n    r = v[k];\n    grid[offset + q * stride] = f[r] + (q - r) * (q - r);\n  }\n}","map":{"version":3,"sources":["P:/projects/ConnectingWord/front-end/node_modules/@mapbox/tiny-sdf/index.js"],"names":["module","exports","TinySDF","default","INF","fontSize","buffer","radius","cutoff","fontFamily","fontWeight","undefined","size","gridSize","canvas","document","createElement","width","height","ctx","getContext","font","textAlign","fillStyle","gridOuter","Float64Array","gridInner","f","z","v","Uint16Array","useMetrics","measureText","actualBoundingBoxLeft","middle","Math","round","navigator","userAgent","indexOf","prepareGrids","imgData","glyphWidth","glyphHeight","fill","offset","y","x","j","a","data","b","max","c","extractAlpha","alphaChannel","i","d","sqrt","prototype","_draw","char","getMetrics","textMetrics","advance","doubleBuffer","top","imgTop","imgLeft","baselinePosition","floor","actualBoundingBoxAscent","ceil","min","actualBoundingBoxRight","actualBoundingBoxDescent","textBaseline","clearRect","fillText","getImageData","Uint8ClampedArray","edt","metrics","sdfWidth","sdfHeight","left","draw","drawWithMetrics","edt1d","grid","stride","length","q","k","s","r"],"mappings":"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","sourcesContent":["'use strict';\n\nmodule.exports = TinySDF;\nmodule.exports.default = TinySDF;\n\nvar INF = 1e20;\n\nfunction TinySDF(fontSize, buffer, radius, cutoff, fontFamily, fontWeight) {\n    this.fontSize = fontSize || 24;\n    this.buffer = buffer === undefined ? 3 : buffer;\n    this.cutoff = cutoff || 0.25;\n    this.fontFamily = fontFamily || 'sans-serif';\n    this.fontWeight = fontWeight || 'normal';\n    this.radius = radius || 8;\n\n    // For backwards compatibility, we honor the implicit contract that the\n    // size of the returned bitmap will be fontSize + buffer * 2\n    var size = this.size = this.fontSize + this.buffer * 2;\n    // Glyphs may be slightly larger than their fontSize. The canvas already\n    // has buffer space, but create extra buffer space in the output grid for the\n    // \"halo\" to extend into (if metric extraction is enabled)\n    var gridSize = size + this.buffer * 2;\n\n    this.canvas = document.createElement('canvas');\n    this.canvas.width = this.canvas.height = size;\n\n    this.ctx = this.canvas.getContext('2d');\n    this.ctx.font = this.fontWeight + ' ' + this.fontSize + 'px ' + this.fontFamily;\n\n    this.ctx.textAlign = 'left'; // Necessary so that RTL text doesn't have different alignment\n    this.ctx.fillStyle = 'black';\n\n    // temporary arrays for the distance transform\n    this.gridOuter = new Float64Array(gridSize * gridSize);\n    this.gridInner = new Float64Array(gridSize * gridSize);\n    this.f = new Float64Array(gridSize);\n    this.z = new Float64Array(gridSize + 1);\n    this.v = new Uint16Array(gridSize);\n\n    this.useMetrics = this.ctx.measureText('A').actualBoundingBoxLeft !== undefined;\n\n    // hack around https://bugzilla.mozilla.org/show_bug.cgi?id=737852\n    this.middle = Math.round((size / 2) * (navigator.userAgent.indexOf('Gecko/') >= 0 ? 1.2 : 1));\n}\n\nfunction prepareGrids(imgData, width, height, glyphWidth, glyphHeight, gridOuter, gridInner) {\n    // Initialize grids outside the glyph range to alpha 0\n    gridOuter.fill(INF, 0, width * height);\n    gridInner.fill(0, 0, width * height);\n\n    var offset = (width - glyphWidth) / 2; // This is zero if we're not extracting metrics\n\n    for (var y = 0; y < glyphHeight; y++) {\n        for (var x = 0; x < glyphWidth; x++) {\n            var j = (y + offset) * width + x + offset;\n            var a = imgData.data[4 * (y * glyphWidth + x) + 3] / 255; // alpha value\n            if (a === 1) {\n                gridOuter[j] = 0;\n                gridInner[j] = INF;\n            } else if (a === 0) {\n                gridOuter[j] = INF;\n                gridInner[j] = 0;\n            } else {\n                var b = Math.max(0, 0.5 - a);\n                var c = Math.max(0, a - 0.5);\n                gridOuter[j] = b * b;\n                gridInner[j] = c * c;\n            }\n        }\n    }\n}\n\nfunction extractAlpha(alphaChannel, width, height, gridOuter, gridInner, radius, cutoff) {\n    for (var i = 0; i < width * height; i++) {\n        var d = Math.sqrt(gridOuter[i]) - Math.sqrt(gridInner[i]);\n        alphaChannel[i] = Math.round(255 - 255 * (d / radius + cutoff));\n    }\n}\n\nTinySDF.prototype._draw = function (char, getMetrics) {\n    var textMetrics = this.ctx.measureText(char);\n    // Older browsers only expose the glyph width\n    // This is enough for basic layout with all glyphs using the same fixed size\n    var advance = textMetrics.width;\n\n    var doubleBuffer = 2 * this.buffer;\n    var width, glyphWidth, height, glyphHeight, top;\n\n    var imgTop, imgLeft, baselinePosition;\n    // If the browser supports bounding box metrics, we can generate a smaller\n    // SDF. This is a significant performance win.\n    if (getMetrics && this.useMetrics) {\n        // The integer/pixel part of the top alignment is encoded in metrics.top\n        // The remainder is implicitly encoded in the rasterization\n        top = Math.floor(textMetrics.actualBoundingBoxAscent);\n        baselinePosition = this.buffer + Math.ceil(textMetrics.actualBoundingBoxAscent);\n        imgTop = this.buffer;\n        imgLeft = this.buffer;\n\n        // If the glyph overflows the canvas size, it will be clipped at the\n        // bottom/right\n        glyphWidth = Math.min(this.size,\n            Math.ceil(textMetrics.actualBoundingBoxRight - textMetrics.actualBoundingBoxLeft));\n        glyphHeight = Math.min(this.size - imgTop,\n            Math.ceil(textMetrics.actualBoundingBoxAscent + textMetrics.actualBoundingBoxDescent));\n\n        width = glyphWidth + doubleBuffer;\n        height = glyphHeight + doubleBuffer;\n        this.ctx.textBaseline = 'alphabetic';\n    } else {\n        width = glyphWidth = this.size;\n        height = glyphHeight = this.size;\n        // 19 points is an approximation of the \"cap height\" ascent from alphabetic\n        // baseline (even though actual drawing is from middle baseline, we can\n        // use the approximation because every glyph fills the em box)\n        top = 19 * this.fontSize / 24;\n        imgTop = imgLeft = 0;\n        baselinePosition = this.middle;\n        this.ctx.textBaseline = 'middle';\n    }\n\n    var imgData;\n    if (glyphWidth && glyphHeight) {\n        this.ctx.clearRect(imgLeft, imgTop, glyphWidth, glyphHeight);\n        this.ctx.fillText(char, this.buffer, baselinePosition);\n        imgData = this.ctx.getImageData(imgLeft, imgTop, glyphWidth, glyphHeight);\n    }\n\n    var alphaChannel = new Uint8ClampedArray(width * height);\n\n    prepareGrids(imgData, width, height, glyphWidth, glyphHeight, this.gridOuter, this.gridInner);\n\n    edt(this.gridOuter, width, height, this.f, this.v, this.z);\n    edt(this.gridInner, width, height, this.f, this.v, this.z);\n\n    extractAlpha(alphaChannel, width, height, this.gridOuter, this.gridInner, this.radius, this.cutoff);\n\n    return {\n        data: alphaChannel,\n        metrics: {\n            width: glyphWidth,\n            height: glyphHeight,\n            sdfWidth: width,\n            sdfHeight: height,\n            top: top,\n            left: 0,\n            advance: advance\n        }\n    };\n};\n\nTinySDF.prototype.draw = function (char) {\n    return this._draw(char, false).data;\n};\n\nTinySDF.prototype.drawWithMetrics = function (char) {\n    return this._draw(char, true);\n};\n\n// 2D Euclidean squared distance transform by Felzenszwalb & Huttenlocher https://cs.brown.edu/~pff/papers/dt-final.pdf\nfunction edt(data, width, height, f, v, z) {\n    for (var x = 0; x < width; x++) edt1d(data, x, width, height, f, v, z);\n    for (var y = 0; y < height; y++) edt1d(data, y * width, 1, width, f, v, z);\n}\n\n// 1D squared distance transform\nfunction edt1d(grid, offset, stride, length, f, v, z) {\n    var q, k, s, r;\n    v[0] = 0;\n    z[0] = -INF;\n    z[1] = INF;\n\n    for (q = 0; q < length; q++) f[q] = grid[offset + q * stride];\n\n    for (q = 1, k = 0, s = 0; q < length; q++) {\n        do {\n            r = v[k];\n            s = (f[q] - f[r] + q * q - r * r) / (q - r) / 2;\n        } while (s <= z[k] && --k > -1);\n\n        k++;\n        v[k] = q;\n        z[k] = s;\n        z[k + 1] = INF;\n    }\n\n    for (q = 0, k = 0; q < length; q++) {\n        while (z[k + 1] < q) k++;\n        r = v[k];\n        grid[offset + q * stride] = f[r] + (q - r) * (q - r);\n    }\n}\n"]},"metadata":{},"sourceType":"script"}