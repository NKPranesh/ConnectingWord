{"ast":null,"code":"export function cssToDeviceRatio(gl) {\n  const {\n    luma\n  } = gl;\n\n  if (gl.canvas && luma) {\n    const {\n      clientWidth\n    } = luma.canvasSizeInfo;\n    return clientWidth ? gl.drawingBufferWidth / clientWidth : 1;\n  }\n\n  return 1;\n}\nexport function cssToDevicePixels(gl, cssPixel) {\n  let yInvert = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  const ratio = cssToDeviceRatio(gl);\n  const width = gl.drawingBufferWidth;\n  const height = gl.drawingBufferHeight;\n  return scalePixels(cssPixel, ratio, width, height, yInvert);\n}\nexport function getDevicePixelRatio(useDevicePixels) {\n  const windowRatio = typeof window === 'undefined' ? 1 : window.devicePixelRatio || 1;\n\n  if (Number.isFinite(useDevicePixels)) {\n    return useDevicePixels <= 0 ? 1 : useDevicePixels;\n  }\n\n  return useDevicePixels ? windowRatio : 1;\n}\n\nfunction scalePixels(pixel, ratio, width, height, yInvert) {\n  const x = scaleX(pixel[0], ratio, width);\n  let y = scaleY(pixel[1], ratio, height, yInvert);\n  let t = scaleX(pixel[0] + 1, ratio, width);\n  const xHigh = t === width - 1 ? t : t - 1;\n  t = scaleY(pixel[1] + 1, ratio, height, yInvert);\n  let yHigh;\n\n  if (yInvert) {\n    t = t === 0 ? t : t + 1;\n    yHigh = y;\n    y = t;\n  } else {\n    yHigh = t === height - 1 ? t : t - 1;\n  }\n\n  return {\n    x,\n    y,\n    width: Math.max(xHigh - x + 1, 1),\n    height: Math.max(yHigh - y + 1, 1)\n  };\n}\n\nfunction scaleX(x, ratio, width) {\n  const r = Math.min(Math.round(x * ratio), width - 1);\n  return r;\n}\n\nfunction scaleY(y, ratio, height, yInvert) {\n  return yInvert ? Math.max(0, height - 1 - Math.round(y * ratio)) : Math.min(Math.round(y * ratio), height - 1);\n}","map":{"version":3,"sources":["../../../src/utils/device-pixels.js"],"names":["luma","gl","clientWidth","yInvert","ratio","cssToDeviceRatio","width","height","scalePixels","windowRatio","window","Number","useDevicePixels","x","scaleX","pixel","y","scaleY","t","xHigh","yHigh","Math","r"],"mappings":"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","sourcesContent":["/** @typedef {import('./device-pixels')} types */\n\n/**\n * Returns multiplier need to convert CSS size to Device size\n * @type {types['cssToDeviceRatio']}\n */\nexport function cssToDeviceRatio(gl) {\n  // @ts-ignore\n  const {luma} = gl;\n\n  if (gl.canvas && luma) {\n    // For headless gl we might have used custom width and height\n    // hence use cached clientWidth\n    const {clientWidth} = luma.canvasSizeInfo;\n    return clientWidth ? gl.drawingBufferWidth / clientWidth : 1;\n  }\n  // use default device pixel ratio\n  return 1;\n}\n\n/**\n * Maps CSS pixel position to device pixel position\n * @type {types['cssToDevicePixels']}\n */\nexport function cssToDevicePixels(gl, cssPixel, yInvert = true) {\n  const ratio = cssToDeviceRatio(gl);\n  const width = gl.drawingBufferWidth;\n  const height = gl.drawingBufferHeight;\n  return scalePixels(cssPixel, ratio, width, height, yInvert);\n}\n\n// HELPER METHOD\n\n/**\n * Calulates device pixel ratio, used during context creation\n * @type {types['getDevicePixelRatio']}\n */\nexport function getDevicePixelRatio(useDevicePixels) {\n  const windowRatio = typeof window === 'undefined' ? 1 : window.devicePixelRatio || 1;\n  if (Number.isFinite(useDevicePixels)) {\n    // @ts-ignore Can no longer be boolean after previous line\n    return useDevicePixels <= 0 ? 1 : useDevicePixels;\n  }\n  return useDevicePixels ? windowRatio : 1;\n}\n\n// PRIVATE\n\nfunction scalePixels(pixel, ratio, width, height, yInvert) {\n  const x = scaleX(pixel[0], ratio, width);\n  let y = scaleY(pixel[1], ratio, height, yInvert);\n\n  // Find boundaries of next pixel to provide valid range of device pixel locaitons\n\n  let t = scaleX(pixel[0] + 1, ratio, width);\n  // If next pixel's position is clamped to boundary, use it as is, otherwise subtract 1 for current pixel boundary\n  const xHigh = t === width - 1 ? t : t - 1;\n\n  t = scaleY(pixel[1] + 1, ratio, height, yInvert);\n  let yHigh;\n  if (yInvert) {\n    // If next pixel's position is clamped to boundary, use it as is, otherwise clamp it to valid range\n    t = t === 0 ? t : t + 1;\n    // swap y and yHigh\n    yHigh = y;\n    y = t;\n  } else {\n    // If next pixel's position is clamped to boundary, use it as is, otherwise clamp it to valid range\n    yHigh = t === height - 1 ? t : t - 1;\n    // y remains same\n  }\n  return {\n    x,\n    y,\n    // when ratio < 1, current css pixel and next css pixel may point to same device pixel, set width/height to 1 in those cases.\n    width: Math.max(xHigh - x + 1, 1),\n    height: Math.max(yHigh - y + 1, 1)\n  };\n}\n\nfunction scaleX(x, ratio, width) {\n  // since we are rounding to nearest, when ratio > 1, edge pixels may point to out of bounds value, clamp to the limit\n  const r = Math.min(Math.round(x * ratio), width - 1);\n  return r;\n}\n\nfunction scaleY(y, ratio, height, yInvert) {\n  // since we are rounding to nearest, when ratio > 1, edge pixels may point to out of bounds value, clamp to the limit\n  return yInvert\n    ? Math.max(0, height - 1 - Math.round(y * ratio))\n    : Math.min(Math.round(y * ratio), height - 1);\n}\n"]},"metadata":{},"sourceType":"module"}