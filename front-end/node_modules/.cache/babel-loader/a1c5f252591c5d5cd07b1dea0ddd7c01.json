{"ast":null,"code":"import { WorkerBody } from '@loaders.gl/worker-utils';\nlet requestId = 0;\nexport function createLoaderWorker(loader) {\n  if (typeof self === 'undefined') {\n    return;\n  }\n\n  WorkerBody.onmessage = async (type, payload) => {\n    switch (type) {\n      case 'process':\n        try {\n          const {\n            input,\n            options = {}\n          } = payload;\n          const result = await parseData({\n            loader,\n            arrayBuffer: input,\n            options,\n            context: {\n              parse: parseOnMainThread\n            }\n          });\n          WorkerBody.postMessage('done', {\n            result\n          });\n        } catch (error) {\n          const message = error instanceof Error ? error.message : '';\n          WorkerBody.postMessage('error', {\n            error: message\n          });\n        }\n\n        break;\n\n      default:\n    }\n  };\n}\n\nfunction parseOnMainThread(arrayBuffer, options) {\n  return new Promise((resolve, reject) => {\n    const id = requestId++;\n\n    const onMessage = (type, payload) => {\n      if (payload.id !== id) {\n        return;\n      }\n\n      switch (type) {\n        case 'done':\n          WorkerBody.removeEventListener(onMessage);\n          resolve(payload.result);\n          break;\n\n        case 'error':\n          WorkerBody.removeEventListener(onMessage);\n          reject(payload.error);\n          break;\n\n        default:\n      }\n    };\n\n    WorkerBody.addEventListener(onMessage);\n    const payload = {\n      id,\n      input: arrayBuffer,\n      options\n    };\n    WorkerBody.postMessage('process', payload);\n  });\n}\n\nasync function parseData(_ref) {\n  let {\n    loader,\n    arrayBuffer,\n    options,\n    context\n  } = _ref;\n  let data;\n  let parser;\n\n  if (loader.parseSync || loader.parse) {\n    data = arrayBuffer;\n    parser = loader.parseSync || loader.parse;\n  } else if (loader.parseTextSync) {\n    const textDecoder = new TextDecoder();\n    data = textDecoder.decode(arrayBuffer);\n    parser = loader.parseTextSync;\n  } else {\n    throw new Error(\"Could not load data with \".concat(loader.name, \" loader\"));\n  }\n\n  options = { ...options,\n    modules: loader && loader.options && loader.options.modules || {},\n    worker: false\n  };\n  return await parser(data, { ...options\n  }, context, loader);\n}","map":{"version":3,"sources":["../../../../src/lib/worker-loader-utils/create-loader-worker.ts"],"names":["requestId","WorkerBody","options","result","parseData","arrayBuffer","context","parse","parseOnMainThread","message","error","id","onMessage","payload","resolve","reject","input","loader","data","parser","textDecoder","modules","worker"],"mappings":"AAEA,SAAA,UAAA,QAAA,0BAAA;AAGA,IAAIA,SAAS,GAAb,CAAA;AAMA,OAAO,SAAA,kBAAA,CAAA,MAAA,EAAsD;AAE3D,MAAI,OAAA,IAAA,KAAJ,WAAA,EAAiC;AAC/B;AACD;;AAEDC,EAAAA,UAAU,CAAVA,SAAAA,GAAuB,OAAA,IAAA,EAAA,OAAA,KAAyB;AAC9C,YAAA,IAAA;AACE,WAAA,SAAA;AACE,YAAI;AAGF,gBAAM;AAAA,YAAA,KAAA;AAAQC,YAAAA,OAAO,GAAG;AAAlB,cAAN,OAAA;AAEA,gBAAMC,MAAM,GAAG,MAAMC,SAAS,CAAC;AAAA,YAAA,MAAA;AAE7BC,YAAAA,WAAW,EAFkB,KAAA;AAAA,YAAA,OAAA;AAI7BC,YAAAA,OAAO,EAAE;AACPC,cAAAA,KAAK,EAAEC;AADA;AAJoB,WAAD,CAA9B;AAQAP,UAAAA,UAAU,CAAVA,WAAAA,CAAAA,MAAAA,EAA+B;AAACE,YAAAA;AAAD,WAA/BF;AAbF,SAAA,CAcE,OAAA,KAAA,EAAc;AACd,gBAAMQ,OAAO,GAAGC,KAAK,YAALA,KAAAA,GAAyBA,KAAK,CAA9BA,OAAAA,GAAhB,EAAA;AACAT,UAAAA,UAAU,CAAVA,WAAAA,CAAAA,OAAAA,EAAgC;AAACS,YAAAA,KAAK,EAAED;AAAR,WAAhCR;AACD;;AACD;;AACF;AArBF;AADFA,GAAAA;AAyBD;;AAED,SAAA,iBAAA,CAAA,WAAA,EAAA,OAAA,EAAmG;AACjG,SAAO,IAAA,OAAA,CAAY,CAAA,OAAA,EAAA,MAAA,KAAqB;AACtC,UAAMU,EAAE,GAAGX,SAAX,EAAA;;AAIA,UAAMY,SAAS,GAAG,CAAA,IAAA,EAAA,OAAA,KAAmB;AACnC,UAAIC,OAAO,CAAPA,EAAAA,KAAJ,EAAA,EAAuB;AAErB;AACD;;AAED,cAAA,IAAA;AACE,aAAA,MAAA;AACEZ,UAAAA,UAAU,CAAVA,mBAAAA,CAAAA,SAAAA;AACAa,UAAAA,OAAO,CAACD,OAAO,CAAfC,MAAO,CAAPA;AACA;;AAEF,aAAA,OAAA;AACEb,UAAAA,UAAU,CAAVA,mBAAAA,CAAAA,SAAAA;AACAc,UAAAA,MAAM,CAACF,OAAO,CAAdE,KAAM,CAANA;AACA;;AAEF;AAXF;AANF,KAAA;;AAsBAd,IAAAA,UAAU,CAAVA,gBAAAA,CAAAA,SAAAA;AAGA,UAAMY,OAAO,GAAG;AAAA,MAAA,EAAA;AAAKG,MAAAA,KAAK,EAAV,WAAA;AAAyBd,MAAAA;AAAzB,KAAhB;AACAD,IAAAA,UAAU,CAAVA,WAAAA,CAAAA,SAAAA,EAAAA,OAAAA;AA/BF,GAAO,CAAP;AAiCD;;AAMD,eAAA,SAAA,OAAkE;AAAA,MAAzC;AAAA,IAAA,MAAA;AAAA,IAAA,WAAA;AAAA,IAAA,OAAA;AAA+BK,IAAAA;AAA/B,GAAyC;AAChE,MAAA,IAAA;AACA,MAAA,MAAA;;AACA,MAAIW,MAAM,CAANA,SAAAA,IAAoBA,MAAM,CAA9B,KAAA,EAAsC;AACpCC,IAAAA,IAAI,GAAJA,WAAAA;AACAC,IAAAA,MAAM,GAAGF,MAAM,CAANA,SAAAA,IAAoBA,MAAM,CAAnCE,KAAAA;AAFF,GAAA,MAGO,IAAIF,MAAM,CAAV,aAAA,EAA0B;AAC/B,UAAMG,WAAW,GAAG,IAApB,WAAoB,EAApB;AACAF,IAAAA,IAAI,GAAGE,WAAW,CAAXA,MAAAA,CAAPF,WAAOE,CAAPF;AACAC,IAAAA,MAAM,GAAGF,MAAM,CAAfE,aAAAA;AAHK,GAAA,MAIA;AACL,UAAM,IAAA,KAAA,CAAA,4BAAA,MAAA,CAAsCF,MAAM,CAA5C,IAAA,EAAN,SAAM,CAAA,CAAN;AACD;;AAGDf,EAAAA,OAAO,GAAG,EACR,GADQ,OAAA;AAERmB,IAAAA,OAAO,EAAGJ,MAAM,IAAIA,MAAM,CAAhBA,OAAAA,IAA4BA,MAAM,CAANA,OAAAA,CAA7B,OAACA,IAFF,EAAA;AAGRK,IAAAA,MAAM,EAAE;AAHA,GAAVpB;AAMA,SAAO,MAAMiB,MAAM,CAAA,IAAA,EAAO,EAAC,GAAGjB;AAAJ,GAAP,EAAA,OAAA,EAAnB,MAAmB,CAAnB;AACD","sourcesContent":["/* eslint-disable no-restricted-globals */\nimport type {LoaderWithParser} from '../../types';\nimport {WorkerBody} from '@loaders.gl/worker-utils';\n// import {validateLoaderVersion} from './validate-loader-version';\n\nlet requestId = 0;\n\n/**\n * Set up a WebWorkerGlobalScope to talk with the main thread\n * @param loader\n */\nexport function createLoaderWorker(loader: LoaderWithParser) {\n  // Check that we are actually in a worker thread\n  if (typeof self === 'undefined') {\n    return;\n  }\n\n  WorkerBody.onmessage = async (type, payload) => {\n    switch (type) {\n      case 'process':\n        try {\n          // validateLoaderVersion(loader, data.source.split('@')[1]);\n\n          const {input, options = {}} = payload;\n\n          const result = await parseData({\n            loader,\n            arrayBuffer: input,\n            options,\n            context: {\n              parse: parseOnMainThread\n            }\n          });\n          WorkerBody.postMessage('done', {result});\n        } catch (error) {\n          const message = error instanceof Error ? error.message : '';\n          WorkerBody.postMessage('error', {error: message});\n        }\n        break;\n      default:\n    }\n  };\n}\n\nfunction parseOnMainThread(arrayBuffer: ArrayBuffer, options: {[key: string]: any}): Promise<void> {\n  return new Promise((resolve, reject) => {\n    const id = requestId++;\n\n    /**\n     */\n    const onMessage = (type, payload) => {\n      if (payload.id !== id) {\n        // not ours\n        return;\n      }\n\n      switch (type) {\n        case 'done':\n          WorkerBody.removeEventListener(onMessage);\n          resolve(payload.result);\n          break;\n\n        case 'error':\n          WorkerBody.removeEventListener(onMessage);\n          reject(payload.error);\n          break;\n\n        default:\n        // ignore\n      }\n    };\n\n    WorkerBody.addEventListener(onMessage);\n\n    // Ask the main thread to decode data\n    const payload = {id, input: arrayBuffer, options};\n    WorkerBody.postMessage('process', payload);\n  });\n}\n\n// TODO - Support byteOffset and byteLength (enabling parsing of embedded binaries without copies)\n// TODO - Why not support async loader.parse* funcs here?\n// TODO - Why not reuse a common function instead of reimplementing loader.parse* selection logic? Keeping loader small?\n// TODO - Lack of appropriate parser functions can be detected when we create worker, no need to wait until parse\nasync function parseData({loader, arrayBuffer, options, context}) {\n  let data;\n  let parser;\n  if (loader.parseSync || loader.parse) {\n    data = arrayBuffer;\n    parser = loader.parseSync || loader.parse;\n  } else if (loader.parseTextSync) {\n    const textDecoder = new TextDecoder();\n    data = textDecoder.decode(arrayBuffer);\n    parser = loader.parseTextSync;\n  } else {\n    throw new Error(`Could not load data with ${loader.name} loader`);\n  }\n\n  // TODO - proper merge in of loader options...\n  options = {\n    ...options,\n    modules: (loader && loader.options && loader.options.modules) || {},\n    worker: false\n  };\n\n  return await parser(data, {...options}, context, loader);\n}\n"]},"metadata":{},"sourceType":"module"}