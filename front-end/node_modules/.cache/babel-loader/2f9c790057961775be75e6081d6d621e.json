{"ast":null,"code":"import Transition from '../transitions/transition';\n\nconst noop = () => {};\n\nexport const TRANSITION_EVENTS = {\n  BREAK: 1,\n  SNAP_TO_END: 2,\n  IGNORE: 3\n};\nconst DEFAULT_PROPS = {\n  transitionEasing: t => t,\n  transitionInterruption: TRANSITION_EVENTS.BREAK,\n  onTransitionStart: noop,\n  onTransitionInterrupt: noop,\n  onTransitionEnd: noop\n};\nexport default class TransitionManager {\n  constructor(ControllerState) {\n    let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.ControllerState = ControllerState;\n    this.props = { ...DEFAULT_PROPS,\n      ...props\n    };\n    this.propsInTransition = null;\n    this.transition = new Transition(props.timeline);\n    this.onViewStateChange = props.onViewStateChange || noop;\n    this.onStateChange = props.onStateChange || noop;\n    this._onTransitionUpdate = this._onTransitionUpdate.bind(this);\n  }\n\n  finalize() {\n    this.transition.cancel();\n  }\n\n  getViewportInTransition() {\n    return this.propsInTransition;\n  }\n\n  processViewStateChange(nextProps) {\n    let transitionTriggered = false;\n    const currentProps = this.props;\n    nextProps = { ...DEFAULT_PROPS,\n      ...nextProps\n    };\n    this.props = nextProps;\n\n    if (this._shouldIgnoreViewportChange(currentProps, nextProps)) {\n      return transitionTriggered;\n    }\n\n    if (this._isTransitionEnabled(nextProps)) {\n      const {\n        interruption,\n        endProps\n      } = this.transition.settings;\n      const startProps = { ...currentProps,\n        ...(interruption === TRANSITION_EVENTS.SNAP_TO_END ? endProps : this.propsInTransition || currentProps)\n      };\n\n      this._triggerTransition(startProps, nextProps);\n\n      transitionTriggered = true;\n    } else {\n      this.transition.cancel();\n    }\n\n    return transitionTriggered;\n  }\n\n  updateTransition() {\n    this.transition.update();\n  }\n\n  _isTransitionEnabled(props) {\n    const {\n      transitionDuration,\n      transitionInterpolator\n    } = props;\n    return (transitionDuration > 0 || transitionDuration === 'auto') && Boolean(transitionInterpolator);\n  }\n\n  _isUpdateDueToCurrentTransition(props) {\n    if (this.transition.inProgress) {\n      return this.transition.settings.interpolator.arePropsEqual(props, this.propsInTransition);\n    }\n\n    return false;\n  }\n\n  _shouldIgnoreViewportChange(currentProps, nextProps) {\n    if (this.transition.inProgress) {\n      return this.transition.settings.interruption === TRANSITION_EVENTS.IGNORE || this._isUpdateDueToCurrentTransition(nextProps);\n    } else if (this._isTransitionEnabled(nextProps)) {\n      return nextProps.transitionInterpolator.arePropsEqual(currentProps, nextProps);\n    }\n\n    return true;\n  }\n\n  _triggerTransition(startProps, endProps) {\n    const startViewstate = new this.ControllerState(startProps);\n    const endViewStateProps = new this.ControllerState(endProps).shortestPathFrom(startViewstate);\n    const {\n      transitionInterpolator\n    } = endProps;\n    const duration = transitionInterpolator.getDuration ? transitionInterpolator.getDuration(startProps, endProps) : endProps.transitionDuration;\n\n    if (duration === 0) {\n      return;\n    }\n\n    const initialProps = endProps.transitionInterpolator.initializeProps(startProps, endViewStateProps);\n    this.propsInTransition = {};\n    this.duration = duration;\n    this.transition.start({\n      duration,\n      easing: endProps.transitionEasing,\n      interpolator: endProps.transitionInterpolator,\n      interruption: endProps.transitionInterruption,\n      startProps: initialProps.start,\n      endProps: initialProps.end,\n      onStart: endProps.onTransitionStart,\n      onUpdate: this._onTransitionUpdate,\n      onInterrupt: this._onTransitionEnd(endProps.onTransitionInterrupt),\n      onEnd: this._onTransitionEnd(endProps.onTransitionEnd)\n    });\n    this.onStateChange({\n      inTransition: true\n    });\n    this.updateTransition();\n  }\n\n  _onTransitionEnd(callback) {\n    return transition => {\n      this.propsInTransition = null;\n      this.onStateChange({\n        inTransition: false,\n        isZooming: false,\n        isPanning: false,\n        isRotating: false\n      });\n      callback(transition);\n    };\n  }\n\n  _onTransitionUpdate(transition) {\n    const {\n      time,\n      settings: {\n        interpolator,\n        startProps,\n        endProps,\n        duration,\n        easing\n      }\n    } = transition;\n    const t = easing(time / duration);\n    const viewport = interpolator.interpolateProps(startProps, endProps, t);\n    this.propsInTransition = new this.ControllerState({ ...this.props,\n      ...viewport\n    }).getViewportProps();\n    this.onViewStateChange({\n      viewState: this.propsInTransition,\n      oldViewState: this.props\n    });\n  }\n\n}","map":{"version":3,"sources":["../../../src/controllers/transition-manager.js"],"names":["noop","TRANSITION_EVENTS","BREAK","SNAP_TO_END","IGNORE","DEFAULT_PROPS","transitionEasing","t","transitionInterruption","onTransitionStart","onTransitionInterrupt","onTransitionEnd","constructor","props","finalize","getViewportInTransition","processViewStateChange","transitionTriggered","currentProps","nextProps","endProps","startProps","interruption","updateTransition","_isTransitionEnabled","transitionInterpolator","transitionDuration","Boolean","_isUpdateDueToCurrentTransition","_shouldIgnoreViewportChange","_triggerTransition","startViewstate","endViewStateProps","duration","initialProps","easing","interpolator","onStart","onUpdate","onInterrupt","onEnd","inTransition","_onTransitionEnd","transition","isZooming","isPanning","isRotating","callback","_onTransitionUpdate","settings","time","viewport","viewState","oldViewState"],"mappings":"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","sourcesContent":["import Transition from '../transitions/transition';\n\nconst noop = () => {};\n\nexport const TRANSITION_EVENTS = {\n  BREAK: 1,\n  SNAP_TO_END: 2,\n  IGNORE: 3\n};\n\nconst DEFAULT_PROPS = {\n  transitionEasing: t => t,\n  transitionInterruption: TRANSITION_EVENTS.BREAK,\n  onTransitionStart: noop,\n  onTransitionInterrupt: noop,\n  onTransitionEnd: noop\n};\n\nexport default class TransitionManager {\n  constructor(ControllerState, props = {}) {\n    this.ControllerState = ControllerState;\n    this.props = {...DEFAULT_PROPS, ...props};\n    this.propsInTransition = null;\n    this.transition = new Transition(props.timeline);\n\n    this.onViewStateChange = props.onViewStateChange || noop;\n    this.onStateChange = props.onStateChange || noop;\n\n    this._onTransitionUpdate = this._onTransitionUpdate.bind(this);\n  }\n\n  finalize() {\n    this.transition.cancel();\n  }\n\n  // Returns current transitioned viewport.\n  getViewportInTransition() {\n    return this.propsInTransition;\n  }\n\n  // Process the vewiport change, either ignore or trigger a new transition.\n  // Return true if a new transition is triggered, false otherwise.\n  processViewStateChange(nextProps) {\n    let transitionTriggered = false;\n    const currentProps = this.props;\n    // Set this.props here as '_triggerTransition' calls '_updateViewport' that uses this.props.\n    nextProps = {...DEFAULT_PROPS, ...nextProps};\n    this.props = nextProps;\n\n    // NOTE: Be cautious re-ordering statements in this function.\n    if (this._shouldIgnoreViewportChange(currentProps, nextProps)) {\n      return transitionTriggered;\n    }\n\n    if (this._isTransitionEnabled(nextProps)) {\n      const {interruption, endProps} = this.transition.settings;\n      const startProps = {\n        ...currentProps,\n        ...(interruption === TRANSITION_EVENTS.SNAP_TO_END\n          ? endProps\n          : this.propsInTransition || currentProps)\n      };\n\n      this._triggerTransition(startProps, nextProps);\n\n      transitionTriggered = true;\n    } else {\n      this.transition.cancel();\n    }\n\n    return transitionTriggered;\n  }\n\n  updateTransition() {\n    this.transition.update();\n  }\n\n  // Helper methods\n\n  _isTransitionEnabled(props) {\n    const {transitionDuration, transitionInterpolator} = props;\n    return (\n      (transitionDuration > 0 || transitionDuration === 'auto') && Boolean(transitionInterpolator)\n    );\n  }\n\n  _isUpdateDueToCurrentTransition(props) {\n    if (this.transition.inProgress) {\n      return this.transition.settings.interpolator.arePropsEqual(props, this.propsInTransition);\n    }\n    return false;\n  }\n\n  _shouldIgnoreViewportChange(currentProps, nextProps) {\n    if (this.transition.inProgress) {\n      // Ignore update if it is requested to be ignored\n      return (\n        this.transition.settings.interruption === TRANSITION_EVENTS.IGNORE ||\n        // Ignore update if it is due to current active transition.\n        this._isUpdateDueToCurrentTransition(nextProps)\n      );\n    } else if (this._isTransitionEnabled(nextProps)) {\n      // Ignore if none of the viewport props changed.\n      return nextProps.transitionInterpolator.arePropsEqual(currentProps, nextProps);\n    }\n    return true;\n  }\n\n  _triggerTransition(startProps, endProps) {\n    const startViewstate = new this.ControllerState(startProps);\n    const endViewStateProps = new this.ControllerState(endProps).shortestPathFrom(startViewstate);\n\n    // update transitionDuration for 'auto' mode\n    const {transitionInterpolator} = endProps;\n    const duration = transitionInterpolator.getDuration\n      ? transitionInterpolator.getDuration(startProps, endProps)\n      : endProps.transitionDuration;\n\n    if (duration === 0) {\n      return;\n    }\n\n    const initialProps = endProps.transitionInterpolator.initializeProps(\n      startProps,\n      endViewStateProps\n    );\n\n    this.propsInTransition = {};\n    this.duration = duration;\n    this.transition.start({\n      duration,\n      easing: endProps.transitionEasing,\n      interpolator: endProps.transitionInterpolator,\n      interruption: endProps.transitionInterruption,\n\n      startProps: initialProps.start,\n      endProps: initialProps.end,\n\n      onStart: endProps.onTransitionStart,\n      onUpdate: this._onTransitionUpdate,\n      onInterrupt: this._onTransitionEnd(endProps.onTransitionInterrupt),\n      onEnd: this._onTransitionEnd(endProps.onTransitionEnd)\n    });\n\n    this.onStateChange({inTransition: true});\n\n    this.updateTransition();\n  }\n\n  _onTransitionEnd(callback) {\n    return transition => {\n      this.propsInTransition = null;\n\n      this.onStateChange({\n        inTransition: false,\n        isZooming: false,\n        isPanning: false,\n        isRotating: false\n      });\n\n      callback(transition);\n    };\n  }\n\n  _onTransitionUpdate(transition) {\n    // NOTE: Be cautious re-ordering statements in this function.\n    const {\n      time,\n      settings: {interpolator, startProps, endProps, duration, easing}\n    } = transition;\n    const t = easing(time / duration);\n    const viewport = interpolator.interpolateProps(startProps, endProps, t);\n\n    // This gurantees all props (e.g. bearing, longitude) are normalized\n    // So when viewports are compared they are in same range.\n    this.propsInTransition = new this.ControllerState({\n      ...this.props,\n      ...viewport\n    }).getViewportProps();\n\n    this.onViewStateChange({\n      viewState: this.propsInTransition,\n      oldViewState: this.props\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"module"}