{"ast":null,"code":"const GEOM_TYPES = ['points', 'lines', 'polygons'];\nexport default function findIndexBinary(data, uniqueIdProperty, featureId, layerName) {\n  for (const gt of GEOM_TYPES) {\n    const index = data[gt] && findIndexByType(data[gt], uniqueIdProperty, featureId, layerName);\n\n    if (index >= 0) {\n      return index;\n    }\n  }\n\n  return -1;\n}\n\nfunction findIndexByType(geomData, uniqueIdProperty, featureId, layerName) {\n  const featureIds = geomData.featureIds.value;\n\n  if (!featureIds.length) {\n    return -1;\n  }\n\n  let startFeatureIndex = 0;\n  let endFeatureIndex = featureIds[featureIds.length - 1] + 1;\n\n  if (layerName) {\n    const layerRange = getLayerRange(geomData, layerName);\n\n    if (layerRange) {\n      startFeatureIndex = layerRange[0];\n      endFeatureIndex = layerRange[1] + 1;\n    } else {\n      return -1;\n    }\n  }\n\n  let featureIndex = -1;\n\n  if (uniqueIdProperty in geomData.numericProps) {\n    const vertexIndex = geomData.numericProps[uniqueIdProperty].value.findIndex((x, i) => x === featureId && featureIds[i] >= startFeatureIndex && featureIds[i] < endFeatureIndex);\n    return vertexIndex >= 0 ? geomData.globalFeatureIds.value[vertexIndex] : -1;\n  } else if (uniqueIdProperty) {\n    featureIndex = findIndex(geomData.properties, elem => elem[uniqueIdProperty] === featureId, startFeatureIndex, endFeatureIndex);\n  } else {\n    featureIndex = findIndex(geomData.fields, elem => elem.id === featureId, startFeatureIndex, endFeatureIndex);\n  }\n\n  return featureIndex >= 0 ? getGlobalFeatureId(geomData, featureIndex) : -1;\n}\n\nfunction getLayerRange(geomData, layerName) {\n  if (!geomData.__layers) {\n    const layerNames = {};\n    const {\n      properties\n    } = geomData;\n\n    for (let i = 0; i < properties.length; i++) {\n      const {\n        layerName: key\n      } = properties[i];\n\n      if (!key) {} else if (layerNames[key]) {\n        layerNames[key][1] = i;\n      } else {\n        layerNames[key] = [i, i];\n      }\n    }\n\n    geomData.__layers = layerNames;\n  }\n\n  return geomData.__layers[layerName];\n}\n\nfunction getGlobalFeatureId(geomData, featureIndex) {\n  if (!geomData.__ids) {\n    const result = [];\n    const featureIds = geomData.featureIds.value;\n    const globalFeatureIds = geomData.globalFeatureIds.value;\n\n    for (let i = 0; i < featureIds.length; i++) {\n      result[featureIds[i]] = globalFeatureIds[i];\n    }\n\n    geomData.__ids = result;\n  }\n\n  return geomData.__ids[featureIndex];\n}\n\nfunction findIndex(array, predicate, startIndex, endIndex) {\n  for (let i = startIndex; i < endIndex; i++) {\n    if (predicate(array[i], i)) {\n      return i;\n    }\n  }\n\n  return -1;\n}","map":{"version":3,"sources":["../../../src/mvt-layer/find-index-binary.js"],"names":["GEOM_TYPES","index","data","findIndexByType","featureIds","geomData","startFeatureIndex","endFeatureIndex","layerRange","getLayerRange","featureIndex","uniqueIdProperty","vertexIndex","x","findIndex","elem","getGlobalFeatureId","layerNames","properties","i","layerName","key","result","globalFeatureIds","predicate","array"],"mappings":"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","sourcesContent":["const GEOM_TYPES = ['points', 'lines', 'polygons'];\n/**\n * Return the index of feature (numericProps or featureIds) for given feature id\n * Example: findIndexBinary(data, 'id', 33) will return the index in the array of numericProps\n * of the feature 33.\n * @param {Object} data - The data in binary format\n * @param {String} uniqueIdProperty - Name of the unique id property\n * @param {Number|String} featureId - feature id to find\n * @param {String} layerName - the layer to search in\n */\nexport default function findIndexBinary(data, uniqueIdProperty, featureId, layerName) {\n  for (const gt of GEOM_TYPES) {\n    const index = data[gt] && findIndexByType(data[gt], uniqueIdProperty, featureId, layerName);\n    if (index >= 0) {\n      return index;\n    }\n  }\n\n  return -1;\n}\n\nfunction findIndexByType(geomData, uniqueIdProperty, featureId, layerName) {\n  const featureIds = geomData.featureIds.value;\n\n  if (!featureIds.length) {\n    return -1;\n  }\n\n  let startFeatureIndex = 0;\n  let endFeatureIndex = featureIds[featureIds.length - 1] + 1;\n  if (layerName) {\n    const layerRange = getLayerRange(geomData, layerName);\n    if (layerRange) {\n      startFeatureIndex = layerRange[0];\n      endFeatureIndex = layerRange[1] + 1;\n    } else {\n      return -1;\n    }\n  }\n\n  // Look for the uniqueIdProperty\n  let featureIndex = -1;\n  if (uniqueIdProperty in geomData.numericProps) {\n    const vertexIndex = geomData.numericProps[uniqueIdProperty].value.findIndex(\n      (x, i) =>\n        x === featureId && featureIds[i] >= startFeatureIndex && featureIds[i] < endFeatureIndex\n    );\n    return vertexIndex >= 0 ? geomData.globalFeatureIds.value[vertexIndex] : -1;\n  } else if (uniqueIdProperty) {\n    featureIndex = findIndex(\n      geomData.properties,\n      elem => elem[uniqueIdProperty] === featureId,\n      startFeatureIndex,\n      endFeatureIndex\n    );\n  } else {\n    featureIndex = findIndex(\n      geomData.fields,\n      elem => elem.id === featureId,\n      startFeatureIndex,\n      endFeatureIndex\n    );\n  }\n  return featureIndex >= 0 ? getGlobalFeatureId(geomData, featureIndex) : -1;\n}\n\n// Returns [firstFeatureIndex, lastFeatureIndex]\n// MVTLoader parses tiles layer-by-layer, so each layer is a continuous range\nfunction getLayerRange(geomData, layerName) {\n  if (!geomData.__layers) {\n    // Cache a map from properties.layerName to index ranges\n    const layerNames = {};\n    const {properties} = geomData;\n    for (let i = 0; i < properties.length; i++) {\n      const {layerName: key} = properties[i];\n      if (!key) {\n        // ignore\n      } else if (layerNames[key]) {\n        layerNames[key][1] = i;\n      } else {\n        layerNames[key] = [i, i];\n      }\n    }\n    geomData.__layers = layerNames;\n  }\n  return geomData.__layers[layerName];\n}\n\n// Returns global feature id\nfunction getGlobalFeatureId(geomData, featureIndex) {\n  if (!geomData.__ids) {\n    // Cache a map from featureId to globalFeatureId\n    const result = [];\n    const featureIds = geomData.featureIds.value;\n    const globalFeatureIds = geomData.globalFeatureIds.value;\n    for (let i = 0; i < featureIds.length; i++) {\n      result[featureIds[i]] = globalFeatureIds[i];\n    }\n    geomData.__ids = result;\n  }\n  return geomData.__ids[featureIndex];\n}\n\n// Like array.findIndex, but only search within a range\nfunction findIndex(array, predicate, startIndex, endIndex) {\n  for (let i = startIndex; i < endIndex; i++) {\n    if (predicate(array[i], i)) {\n      return i;\n    }\n  }\n  return -1;\n}\n"]},"metadata":{},"sourceType":"module"}