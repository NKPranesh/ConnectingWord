{"ast":null,"code":"import { createIterable, getAccessorFromBuffer } from './iterable-utils';\nimport defaultTypedArrayManager from './typed-array-manager';\nimport assert from './assert';\nimport { Buffer } from '@luma.gl/core';\nexport default class Tesselator {\n  constructor() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const {\n      attributes = {}\n    } = opts;\n    this.typedArrayManager = defaultTypedArrayManager;\n    this.indexStarts = null;\n    this.vertexStarts = null;\n    this.vertexCount = 0;\n    this.instanceCount = 0;\n    this.attributes = {};\n    this._attributeDefs = attributes;\n    this.opts = opts;\n    this.updateGeometry(opts);\n    Object.seal(this);\n  }\n\n  updateGeometry(opts) {\n    Object.assign(this.opts, opts);\n    const {\n      data,\n      buffers = {},\n      getGeometry,\n      geometryBuffer,\n      positionFormat,\n      dataChanged,\n      normalize = true\n    } = this.opts;\n    this.data = data;\n    this.getGeometry = getGeometry;\n    this.positionSize = geometryBuffer && geometryBuffer.size || (positionFormat === 'XY' ? 2 : 3);\n    this.buffers = buffers;\n    this.normalize = normalize;\n\n    if (geometryBuffer) {\n      assert(data.startIndices);\n      this.getGeometry = this.getGeometryFromBuffer(geometryBuffer);\n\n      if (!normalize) {\n        buffers.positions = geometryBuffer;\n      }\n    }\n\n    this.geometryBuffer = buffers.positions;\n\n    if (Array.isArray(dataChanged)) {\n      for (const dataRange of dataChanged) {\n        this._rebuildGeometry(dataRange);\n      }\n    } else {\n      this._rebuildGeometry();\n    }\n  }\n\n  updatePartialGeometry(_ref) {\n    let {\n      startRow,\n      endRow\n    } = _ref;\n\n    this._rebuildGeometry({\n      startRow,\n      endRow\n    });\n  }\n\n  normalizeGeometry(geometry) {\n    return geometry;\n  }\n\n  updateGeometryAttributes(geometry, startIndex, size) {\n    throw new Error('Not implemented');\n  }\n\n  getGeometrySize(geometry) {\n    throw new Error('Not implemented');\n  }\n\n  getGeometryFromBuffer(geometryBuffer) {\n    const value = geometryBuffer.value || geometryBuffer;\n    assert(ArrayBuffer.isView(value));\n    return getAccessorFromBuffer(value, {\n      size: this.positionSize,\n      offset: geometryBuffer.offset,\n      stride: geometryBuffer.stride,\n      startIndices: this.data.startIndices\n    });\n  }\n\n  _allocate(instanceCount, copy) {\n    const {\n      attributes,\n      buffers,\n      _attributeDefs,\n      typedArrayManager\n    } = this;\n\n    for (const name in _attributeDefs) {\n      if (name in buffers) {\n        typedArrayManager.release(attributes[name]);\n        attributes[name] = null;\n      } else {\n        const def = _attributeDefs[name];\n        def.copy = copy;\n        attributes[name] = typedArrayManager.allocate(attributes[name], instanceCount, def);\n      }\n    }\n  }\n\n  _forEachGeometry(visitor, startRow, endRow) {\n    const {\n      data,\n      getGeometry\n    } = this;\n    const {\n      iterable,\n      objectInfo\n    } = createIterable(data, startRow, endRow);\n\n    for (const object of iterable) {\n      objectInfo.index++;\n      const geometry = getGeometry(object, objectInfo);\n      visitor(geometry, objectInfo.index);\n    }\n  }\n\n  _rebuildGeometry(dataRange) {\n    if (!this.data || !this.getGeometry) {\n      return;\n    }\n\n    let {\n      indexStarts,\n      vertexStarts,\n      instanceCount\n    } = this;\n    const {\n      data,\n      geometryBuffer\n    } = this;\n    const {\n      startRow = 0,\n      endRow = Infinity\n    } = dataRange || {};\n    const normalizedData = {};\n\n    if (!dataRange) {\n      indexStarts = [0];\n      vertexStarts = [0];\n    }\n\n    if (this.normalize || !geometryBuffer) {\n      this._forEachGeometry((geometry, dataIndex) => {\n        geometry = this.normalizeGeometry(geometry);\n        normalizedData[dataIndex] = geometry;\n        vertexStarts[dataIndex + 1] = vertexStarts[dataIndex] + this.getGeometrySize(geometry);\n      }, startRow, endRow);\n\n      instanceCount = vertexStarts[vertexStarts.length - 1];\n    } else if (geometryBuffer.buffer instanceof Buffer) {\n      const byteStride = geometryBuffer.stride || this.positionSize * 4;\n      vertexStarts = data.startIndices;\n      instanceCount = vertexStarts[data.length] || geometryBuffer.buffer.byteLength / byteStride;\n    } else {\n      const bufferValue = geometryBuffer.value || geometryBuffer;\n      const elementStride = geometryBuffer.stride / bufferValue.BYTES_PER_ELEMENT || this.positionSize;\n      vertexStarts = data.startIndices;\n      instanceCount = vertexStarts[data.length] || bufferValue.length / elementStride;\n    }\n\n    this._allocate(instanceCount, Boolean(dataRange));\n\n    this.indexStarts = indexStarts;\n    this.vertexStarts = vertexStarts;\n    this.instanceCount = instanceCount;\n    const context = {};\n\n    this._forEachGeometry((geometry, dataIndex) => {\n      geometry = normalizedData[dataIndex] || geometry;\n      context.vertexStart = vertexStarts[dataIndex];\n      context.indexStart = indexStarts[dataIndex];\n      const vertexEnd = dataIndex < vertexStarts.length - 1 ? vertexStarts[dataIndex + 1] : instanceCount;\n      context.geometrySize = vertexEnd - vertexStarts[dataIndex];\n      context.geometryIndex = dataIndex;\n      this.updateGeometryAttributes(geometry, context);\n    }, startRow, endRow);\n\n    this.vertexCount = indexStarts[indexStarts.length - 1];\n  }\n\n}","map":{"version":3,"sources":["../../../src/utils/tesselator.js"],"names":["constructor","opts","attributes","Object","updateGeometry","buffers","normalize","geometryBuffer","positionFormat","assert","data","Array","updatePartialGeometry","endRow","normalizeGeometry","updateGeometryAttributes","getGeometrySize","getGeometryFromBuffer","value","ArrayBuffer","getAccessorFromBuffer","size","offset","stride","startIndices","_allocate","typedArrayManager","name","def","_attributeDefs","_forEachGeometry","getGeometry","objectInfo","createIterable","geometry","visitor","_rebuildGeometry","instanceCount","startRow","Infinity","dataRange","normalizedData","indexStarts","vertexStarts","dataIndex","byteStride","bufferValue","elementStride","Boolean","context","vertexEnd"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nimport {createIterable, getAccessorFromBuffer} from './iterable-utils';\nimport defaultTypedArrayManager from './typed-array-manager';\nimport assert from './assert';\n\nimport {Buffer} from '@luma.gl/core';\n\nexport default class Tesselator {\n  constructor(opts = {}) {\n    const {attributes = {}} = opts;\n\n    this.typedArrayManager = defaultTypedArrayManager;\n    this.indexStarts = null;\n    this.vertexStarts = null;\n    this.vertexCount = 0;\n    this.instanceCount = 0;\n    this.attributes = {};\n    this._attributeDefs = attributes;\n    this.opts = opts;\n\n    this.updateGeometry(opts);\n\n    Object.seal(this);\n  }\n\n  /* Public methods */\n  updateGeometry(opts) {\n    Object.assign(this.opts, opts);\n    const {\n      data,\n      buffers = {},\n      getGeometry,\n      geometryBuffer,\n      positionFormat,\n      dataChanged,\n      normalize = true\n    } = this.opts;\n    this.data = data;\n    this.getGeometry = getGeometry;\n    this.positionSize =\n      (geometryBuffer && geometryBuffer.size) || (positionFormat === 'XY' ? 2 : 3);\n    this.buffers = buffers;\n    this.normalize = normalize;\n\n    // Handle external logical value\n    if (geometryBuffer) {\n      assert(data.startIndices); // binary data missing startIndices\n      this.getGeometry = this.getGeometryFromBuffer(geometryBuffer);\n\n      if (!normalize) {\n        // skip packing and set attribute value directly\n        // TODO - avoid mutating user-provided object\n        buffers.positions = geometryBuffer;\n      }\n    }\n    this.geometryBuffer = buffers.positions;\n\n    if (Array.isArray(dataChanged)) {\n      // is partial update\n      for (const dataRange of dataChanged) {\n        this._rebuildGeometry(dataRange);\n      }\n    } else {\n      this._rebuildGeometry();\n    }\n  }\n\n  updatePartialGeometry({startRow, endRow}) {\n    this._rebuildGeometry({startRow, endRow});\n  }\n\n  /* Subclass interface */\n  normalizeGeometry(geometry) {\n    return geometry;\n  }\n\n  // Update the positions of a single geometry\n  updateGeometryAttributes(geometry, startIndex, size) {\n    throw new Error('Not implemented');\n  }\n\n  // Returns the number of vertices in a geometry\n  getGeometrySize(geometry) {\n    throw new Error('Not implemented');\n  }\n\n  getGeometryFromBuffer(geometryBuffer) {\n    const value = geometryBuffer.value || geometryBuffer;\n    assert(ArrayBuffer.isView(value)); // invalid binary geometries\n\n    return getAccessorFromBuffer(value, {\n      size: this.positionSize,\n      offset: geometryBuffer.offset,\n      stride: geometryBuffer.stride,\n      startIndices: this.data.startIndices\n    });\n  }\n\n  /* Private utility methods */\n  _allocate(instanceCount, copy) {\n    // allocate attributes\n    const {attributes, buffers, _attributeDefs, typedArrayManager} = this;\n    for (const name in _attributeDefs) {\n      if (name in buffers) {\n        // Use external buffer\n        typedArrayManager.release(attributes[name]);\n        attributes[name] = null;\n      } else {\n        const def = _attributeDefs[name];\n        // If dataRange is supplied, this is a partial update.\n        // In case we need to reallocate the typed array, it will need the old values copied\n        // before performing partial update.\n        def.copy = copy;\n\n        attributes[name] = typedArrayManager.allocate(attributes[name], instanceCount, def);\n      }\n    }\n  }\n\n  /**\n   * Visit all objects\n   * `data` is expected to be an iterable consistent with the base Layer expectation\n   */\n  _forEachGeometry(visitor, startRow, endRow) {\n    const {data, getGeometry} = this;\n    const {iterable, objectInfo} = createIterable(data, startRow, endRow);\n    for (const object of iterable) {\n      objectInfo.index++;\n      const geometry = getGeometry(object, objectInfo);\n      visitor(geometry, objectInfo.index);\n    }\n  }\n\n  /* eslint-disable complexity,max-statements */\n  _rebuildGeometry(dataRange) {\n    if (!this.data || !this.getGeometry) {\n      return;\n    }\n\n    let {indexStarts, vertexStarts, instanceCount} = this;\n    const {data, geometryBuffer} = this;\n    const {startRow = 0, endRow = Infinity} = dataRange || {};\n\n    const normalizedData = {};\n\n    if (!dataRange) {\n      // Full update - regenerate buffer layout from scratch\n      indexStarts = [0];\n      vertexStarts = [0];\n    }\n    if (this.normalize || !geometryBuffer) {\n      this._forEachGeometry(\n        (geometry, dataIndex) => {\n          geometry = this.normalizeGeometry(geometry);\n          normalizedData[dataIndex] = geometry;\n          vertexStarts[dataIndex + 1] = vertexStarts[dataIndex] + this.getGeometrySize(geometry);\n        },\n        startRow,\n        endRow\n      );\n      // count instances\n      instanceCount = vertexStarts[vertexStarts.length - 1];\n    } else if (geometryBuffer.buffer instanceof Buffer) {\n      const byteStride = geometryBuffer.stride || this.positionSize * 4;\n      // assume user provided data is already normalized\n      vertexStarts = data.startIndices;\n      instanceCount = vertexStarts[data.length] || geometryBuffer.buffer.byteLength / byteStride;\n    } else {\n      const bufferValue = geometryBuffer.value || geometryBuffer;\n      const elementStride =\n        geometryBuffer.stride / bufferValue.BYTES_PER_ELEMENT || this.positionSize;\n      // assume user provided data is already normalized\n      vertexStarts = data.startIndices;\n      instanceCount = vertexStarts[data.length] || bufferValue.length / elementStride;\n    }\n\n    // allocate attributes\n    this._allocate(instanceCount, Boolean(dataRange));\n\n    this.indexStarts = indexStarts;\n    this.vertexStarts = vertexStarts;\n    this.instanceCount = instanceCount;\n\n    const context = {};\n\n    this._forEachGeometry(\n      (geometry, dataIndex) => {\n        geometry = normalizedData[dataIndex] || geometry;\n        context.vertexStart = vertexStarts[dataIndex];\n        context.indexStart = indexStarts[dataIndex];\n        const vertexEnd =\n          dataIndex < vertexStarts.length - 1 ? vertexStarts[dataIndex + 1] : instanceCount;\n        context.geometrySize = vertexEnd - vertexStarts[dataIndex];\n        context.geometryIndex = dataIndex;\n        this.updateGeometryAttributes(geometry, context);\n      },\n      startRow,\n      endRow\n    );\n\n    this.vertexCount = indexStarts[indexStarts.length - 1];\n  }\n}\n"]},"metadata":{},"sourceType":"module"}