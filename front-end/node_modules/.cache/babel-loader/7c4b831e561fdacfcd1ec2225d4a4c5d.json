{"ast":null,"code":"let channelHandles = 1;\nlet animationHandles = 1;\nexport class Timeline {\n  constructor() {\n    this.time = 0;\n    this.channels = new Map();\n    this.animations = new Map();\n    this.playing = false;\n    this.lastEngineTime = -1;\n  }\n\n  addChannel(props) {\n    const {\n      delay = 0,\n      duration = Number.POSITIVE_INFINITY,\n      rate = 1,\n      repeat = 1\n    } = props;\n    const handle = channelHandles++;\n    const channel = {\n      time: 0,\n      delay,\n      duration,\n      rate,\n      repeat\n    };\n\n    this._setChannelTime(channel, this.time);\n\n    this.channels.set(handle, channel);\n    return handle;\n  }\n\n  removeChannel(handle) {\n    this.channels.delete(handle);\n\n    for (const [animationHandle, animation] of this.animations) {\n      if (animation.channel === handle) {\n        this.detachAnimation(animationHandle);\n      }\n    }\n  }\n\n  isFinished(handle) {\n    const channel = this.channels.get(handle);\n\n    if (channel === undefined) {\n      return false;\n    }\n\n    return this.time >= channel.delay + channel.duration * channel.repeat;\n  }\n\n  getTime(handle) {\n    if (handle === undefined) {\n      return this.time;\n    }\n\n    const channel = this.channels.get(handle);\n\n    if (channel === undefined) {\n      return -1;\n    }\n\n    return channel.time;\n  }\n\n  setTime(time) {\n    this.time = Math.max(0, time);\n    const channels = this.channels.values();\n\n    for (const channel of channels) {\n      this._setChannelTime(channel, this.time);\n    }\n\n    const animations = this.animations.values();\n\n    for (const animationData of animations) {\n      const {\n        animation,\n        channel\n      } = animationData;\n      animation.setTime(this.getTime(channel));\n    }\n  }\n\n  play() {\n    this.playing = true;\n  }\n\n  pause() {\n    this.playing = false;\n    this.lastEngineTime = -1;\n  }\n\n  reset() {\n    this.setTime(0);\n  }\n\n  attachAnimation(animation, channelHandle) {\n    const animationHandle = animationHandles++;\n    this.animations.set(animationHandle, {\n      animation,\n      channel: channelHandle\n    });\n    animation.setTime(this.getTime(channelHandle));\n    return animationHandle;\n  }\n\n  detachAnimation(handle) {\n    this.animations.delete(handle);\n  }\n\n  update(engineTime) {\n    if (this.playing) {\n      if (this.lastEngineTime === -1) {\n        this.lastEngineTime = engineTime;\n      }\n\n      this.setTime(this.time + (engineTime - this.lastEngineTime));\n      this.lastEngineTime = engineTime;\n    }\n  }\n\n  _setChannelTime(channel, time) {\n    const offsetTime = time - channel.delay;\n    const totalDuration = channel.duration * channel.repeat;\n\n    if (offsetTime >= totalDuration) {\n      channel.time = channel.duration * channel.rate;\n    } else {\n      channel.time = Math.max(0, offsetTime) % channel.duration;\n      channel.time *= channel.rate;\n    }\n  }\n\n}","map":{"version":3,"sources":["../../../src/animation/timeline.js"],"names":["channelHandles","animationHandles","constructor","addChannel","delay","duration","Number","rate","repeat","handle","channel","time","removeChannel","animation","isFinished","getTime","setTime","Math","channels","animations","play","pause","reset","attachAnimation","animationHandle","channelHandle","detachAnimation","update","engineTime","_setChannelTime","offsetTime","totalDuration"],"mappings":"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","sourcesContent":["let channelHandles = 1;\nlet animationHandles = 1;\n\nexport class Timeline {\n  constructor() {\n    this.time = 0;\n    this.channels = new Map();\n    this.animations = new Map();\n    this.playing = false;\n    this.lastEngineTime = -1;\n  }\n\n  addChannel(props) {\n    const {delay = 0, duration = Number.POSITIVE_INFINITY, rate = 1, repeat = 1} = props;\n\n    const handle = channelHandles++;\n    const channel = {\n      time: 0,\n      delay,\n      duration,\n      rate,\n      repeat\n    };\n    this._setChannelTime(channel, this.time);\n    this.channels.set(handle, channel);\n\n    return handle;\n  }\n\n  removeChannel(handle) {\n    this.channels.delete(handle);\n\n    for (const [animationHandle, animation] of this.animations) {\n      if (animation.channel === handle) {\n        this.detachAnimation(animationHandle);\n      }\n    }\n  }\n\n  isFinished(handle) {\n    const channel = this.channels.get(handle);\n    if (channel === undefined) {\n      return false;\n    }\n\n    return this.time >= channel.delay + channel.duration * channel.repeat;\n  }\n\n  getTime(handle) {\n    if (handle === undefined) {\n      return this.time;\n    }\n\n    const channel = this.channels.get(handle);\n\n    if (channel === undefined) {\n      return -1;\n    }\n\n    return channel.time;\n  }\n\n  setTime(time) {\n    this.time = Math.max(0, time);\n\n    const channels = this.channels.values();\n    for (const channel of channels) {\n      this._setChannelTime(channel, this.time);\n    }\n\n    const animations = this.animations.values();\n    for (const animationData of animations) {\n      const {animation, channel} = animationData;\n      animation.setTime(this.getTime(channel));\n    }\n  }\n\n  play() {\n    this.playing = true;\n  }\n\n  pause() {\n    this.playing = false;\n    this.lastEngineTime = -1;\n  }\n\n  reset() {\n    this.setTime(0);\n  }\n\n  attachAnimation(animation, channelHandle) {\n    const animationHandle = animationHandles++;\n\n    this.animations.set(animationHandle, {\n      animation,\n      channel: channelHandle\n    });\n\n    animation.setTime(this.getTime(channelHandle));\n\n    return animationHandle;\n  }\n\n  detachAnimation(handle) {\n    this.animations.delete(handle);\n  }\n\n  update(engineTime) {\n    if (this.playing) {\n      if (this.lastEngineTime === -1) {\n        this.lastEngineTime = engineTime;\n      }\n      this.setTime(this.time + (engineTime - this.lastEngineTime));\n      this.lastEngineTime = engineTime;\n    }\n  }\n\n  _setChannelTime(channel, time) {\n    const offsetTime = time - channel.delay;\n    const totalDuration = channel.duration * channel.repeat;\n    // Note(Tarek): Don't loop on final repeat.\n    if (offsetTime >= totalDuration) {\n      channel.time = channel.duration * channel.rate;\n    } else {\n      channel.time = Math.max(0, offsetTime) % channel.duration;\n      channel.time *= channel.rate;\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}