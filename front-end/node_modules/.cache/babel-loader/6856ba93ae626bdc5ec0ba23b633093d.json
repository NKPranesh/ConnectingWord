{"ast":null,"code":"import { isWebGL2 } from '@luma.gl/gltools';\nimport { log } from '@luma.gl/webgl';\nimport { pbr } from '@luma.gl/shadertools';\nimport ModelNode from '../scenegraph/model-node';\nimport GLTFMaterialParser from './gltf-material-parser';\nconst vs = `\n#if (__VERSION__ < 300)\n  #define _attr attribute\n#else\n  #define _attr in\n#endif\n\n  _attr vec4 POSITION;\n\n  #ifdef HAS_NORMALS\n    _attr vec4 NORMAL;\n  #endif\n\n  #ifdef HAS_TANGENTS\n    _attr vec4 TANGENT;\n  #endif\n\n  #ifdef HAS_UV\n    _attr vec2 TEXCOORD_0;\n  #endif\n\n  void main(void) {\n    vec4 _NORMAL = vec4(0.);\n    vec4 _TANGENT = vec4(0.);\n    vec2 _TEXCOORD_0 = vec2(0.);\n\n    #ifdef HAS_NORMALS\n      _NORMAL = NORMAL;\n    #endif\n\n    #ifdef HAS_TANGENTS\n      _TANGENT = TANGENT;\n    #endif\n\n    #ifdef HAS_UV\n      _TEXCOORD_0 = TEXCOORD_0;\n    #endif\n\n    pbr_setPositionNormalTangentUV(POSITION, _NORMAL, _TANGENT, _TEXCOORD_0);\n    gl_Position = u_MVPMatrix * POSITION;\n  }\n`;\nconst fs = `\n#if (__VERSION__ < 300)\n  #define fragmentColor gl_FragColor\n#else\n  out vec4 fragmentColor;\n#endif\n\n  void main(void) {\n    fragmentColor = pbr_filterColor(vec4(0));\n  }\n`;\n\nfunction addVersionToShader(gl, source) {\n  if (isWebGL2(gl)) {\n    return `#version 300 es\\n${source}`;\n  }\n\n  return source;\n}\n\nexport default function createGLTFModel(gl, options) {\n  const {\n    id,\n    drawMode,\n    vertexCount,\n    attributes,\n    modelOptions\n  } = options;\n  const materialParser = new GLTFMaterialParser(gl, options);\n  log.info(4, 'createGLTFModel defines: ', materialParser.defines)();\n  const managedResources = [];\n  managedResources.push(...materialParser.generatedTextures);\n  managedResources.push(...Object.values(attributes).map(attribute => attribute.buffer));\n  const model = new ModelNode(gl, Object.assign({\n    id,\n    drawMode,\n    vertexCount,\n    modules: [pbr],\n    defines: materialParser.defines,\n    parameters: materialParser.parameters,\n    vs: addVersionToShader(gl, vs),\n    fs: addVersionToShader(gl, fs),\n    managedResources\n  }, modelOptions));\n  model.setProps({\n    attributes\n  });\n  model.setUniforms(materialParser.uniforms);\n  return model;\n}","map":{"version":3,"sources":["../../../src/gltf/create-gltf-model.js"],"names":["vs","fs","isWebGL2","source","modelOptions","materialParser","log","managedResources","Object","attribute","model","modules","defines","parameters","addVersionToShader","attributes"],"mappings":"AAAA,SAAA,QAAA,QAAA,kBAAA;AACA,SAAA,GAAA,QAAA,gBAAA;AACA,SAAA,GAAA,QAAA,sBAAA;AACA,OAAA,SAAA,MAAA,0BAAA;AACA,OAAA,kBAAA,MAAA,wBAAA;AAEA,MAAMA,EAAE,GAAI;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAxCA,CAAA;AA2CA,MAAMC,EAAE,GAAI;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AATA,CAAA;;AAYA,SAAA,kBAAA,CAAA,EAAA,EAAA,MAAA,EAAwC;AACtC,MAAIC,QAAQ,CAAZ,EAAY,CAAZ,EAAkB;AAChB,WAAQ,oBAAmBC,MAA3B,EAAA;AACD;;AAED,SAAA,MAAA;AACD;;AAED,eAAe,SAAA,eAAA,CAAA,EAAA,EAAA,OAAA,EAAsC;AACnD,QAAM;AAAA,IAAA,EAAA;AAAA,IAAA,QAAA;AAAA,IAAA,WAAA;AAAA,IAAA,UAAA;AAAwCC,IAAAA;AAAxC,MAAN,OAAA;AACA,QAAMC,cAAc,GAAG,IAAA,kBAAA,CAAA,EAAA,EAAvB,OAAuB,CAAvB;AAEAC,EAAAA,GAAG,CAAHA,IAAAA,CAAAA,CAAAA,EAAAA,2BAAAA,EAAyCD,cAAc,CAAvDC,OAAAA;AAKA,QAAMC,gBAAgB,GAAtB,EAAA;AACAA,EAAAA,gBAAgB,CAAhBA,IAAAA,CAAsB,GAAGF,cAAc,CAAvCE,iBAAAA;AACAA,EAAAA,gBAAgB,CAAhBA,IAAAA,CAAsB,GAAGC,MAAM,CAANA,MAAAA,CAAAA,UAAAA,EAAAA,GAAAA,CAA8BC,SAAS,IAAIA,SAAS,CAA7EF,MAAyBC,CAAzBD;AAEA,QAAMG,KAAK,GAAG,IAAA,SAAA,CAAA,EAAA,EAEZ,MAAM,CAAN,MAAA,CACE;AAAA,IAAA,EAAA;AAAA,IAAA,QAAA;AAAA,IAAA,WAAA;AAIEC,IAAAA,OAAO,EAAE,CAJX,GAIW,CAJX;AAKEC,IAAAA,OAAO,EAAEP,cAAc,CALzB,OAAA;AAMEQ,IAAAA,UAAU,EAAER,cAAc,CAN5B,UAAA;AAOEL,IAAAA,EAAE,EAAEc,kBAAkB,CAAA,EAAA,EAPxB,EAOwB,CAPxB;AAQEb,IAAAA,EAAE,EAAEa,kBAAkB,CAAA,EAAA,EARxB,EAQwB,CARxB;AASEP,IAAAA;AATF,GADF,EAFF,YAEE,CAFY,CAAd;AAkBAG,EAAAA,KAAK,CAALA,QAAAA,CAAe;AAACK,IAAAA;AAAD,GAAfL;AACAA,EAAAA,KAAK,CAALA,WAAAA,CAAkBL,cAAc,CAAhCK,QAAAA;AAEA,SAAA,KAAA;AACD","sourcesContent":["import {isWebGL2} from '@luma.gl/gltools';\nimport {log} from '@luma.gl/webgl';\nimport {pbr} from '@luma.gl/shadertools';\nimport ModelNode from '../scenegraph/model-node';\nimport GLTFMaterialParser from './gltf-material-parser';\n\nconst vs = `\n#if (__VERSION__ < 300)\n  #define _attr attribute\n#else\n  #define _attr in\n#endif\n\n  _attr vec4 POSITION;\n\n  #ifdef HAS_NORMALS\n    _attr vec4 NORMAL;\n  #endif\n\n  #ifdef HAS_TANGENTS\n    _attr vec4 TANGENT;\n  #endif\n\n  #ifdef HAS_UV\n    _attr vec2 TEXCOORD_0;\n  #endif\n\n  void main(void) {\n    vec4 _NORMAL = vec4(0.);\n    vec4 _TANGENT = vec4(0.);\n    vec2 _TEXCOORD_0 = vec2(0.);\n\n    #ifdef HAS_NORMALS\n      _NORMAL = NORMAL;\n    #endif\n\n    #ifdef HAS_TANGENTS\n      _TANGENT = TANGENT;\n    #endif\n\n    #ifdef HAS_UV\n      _TEXCOORD_0 = TEXCOORD_0;\n    #endif\n\n    pbr_setPositionNormalTangentUV(POSITION, _NORMAL, _TANGENT, _TEXCOORD_0);\n    gl_Position = u_MVPMatrix * POSITION;\n  }\n`;\n\nconst fs = `\n#if (__VERSION__ < 300)\n  #define fragmentColor gl_FragColor\n#else\n  out vec4 fragmentColor;\n#endif\n\n  void main(void) {\n    fragmentColor = pbr_filterColor(vec4(0));\n  }\n`;\n\nfunction addVersionToShader(gl, source) {\n  if (isWebGL2(gl)) {\n    return `#version 300 es\\n${source}`;\n  }\n\n  return source;\n}\n\nexport default function createGLTFModel(gl, options) {\n  const {id, drawMode, vertexCount, attributes, modelOptions} = options;\n  const materialParser = new GLTFMaterialParser(gl, options);\n\n  log.info(4, 'createGLTFModel defines: ', materialParser.defines)();\n\n  // Calculate managedResources\n  // TODO: Implement resource management logic that will\n  // not deallocate resources/textures/buffers that are shared\n  const managedResources = [];\n  managedResources.push(...materialParser.generatedTextures);\n  managedResources.push(...Object.values(attributes).map(attribute => attribute.buffer));\n\n  const model = new ModelNode(\n    gl,\n    Object.assign(\n      {\n        id,\n        drawMode,\n        vertexCount,\n        modules: [pbr],\n        defines: materialParser.defines,\n        parameters: materialParser.parameters,\n        vs: addVersionToShader(gl, vs),\n        fs: addVersionToShader(gl, fs),\n        managedResources\n      },\n      modelOptions\n    )\n  );\n\n  model.setProps({attributes});\n  model.setUniforms(materialParser.uniforms);\n\n  return model;\n}\n"]},"metadata":{},"sourceType":"module"}