{"ast":null,"code":"import { Schema, Field, FixedSizeList, getArrowTypeFromTypedArray } from '@loaders.gl/schema';\nexport function makeSchemaFromAttributes(attributes, loaderData, indices) {\n  const metadataMap = makeMetadata(loaderData.metadata);\n  const fields = [];\n  const namedLoaderDataAttributes = transformAttributesLoaderData(loaderData.attributes);\n\n  for (const attributeName in attributes) {\n    const attribute = attributes[attributeName];\n    const field = getArrowFieldFromAttribute(attributeName, attribute, namedLoaderDataAttributes[attributeName]);\n    fields.push(field);\n  }\n\n  if (indices) {\n    const indicesField = getArrowFieldFromAttribute('indices', indices);\n    fields.push(indicesField);\n  }\n\n  return new Schema(fields, metadataMap);\n}\n\nfunction transformAttributesLoaderData(loaderData) {\n  const result = {};\n\n  for (const key in loaderData) {\n    const dracoAttribute = loaderData[key];\n    result[dracoAttribute.name || 'undefined'] = dracoAttribute;\n  }\n\n  return result;\n}\n\nfunction getArrowFieldFromAttribute(attributeName, attribute, loaderData) {\n  const metadataMap = loaderData ? makeMetadata(loaderData.metadata) : undefined;\n  const type = getArrowTypeFromTypedArray(attribute.value);\n  return new Field(attributeName, new FixedSizeList(attribute.size, new Field('value', type)), false, metadataMap);\n}\n\nfunction makeMetadata(metadata) {\n  const metadataMap = new Map();\n\n  for (const key in metadata) {\n    metadataMap.set(\"\".concat(key, \".string\"), JSON.stringify(metadata[key]));\n  }\n\n  return metadataMap;\n}","map":{"version":3,"sources":["../../../../src/lib/utils/schema-attribute-utils.ts"],"names":["metadataMap","makeMetadata","loaderData","fields","namedLoaderDataAttributes","transformAttributesLoaderData","attribute","attributes","field","getArrowFieldFromAttribute","indicesField","result","dracoAttribute","type","getArrowTypeFromTypedArray","JSON","metadata"],"mappings":"AAAA,SAAA,MAAA,EAAA,KAAA,EAAA,aAAA,EAAA,0BAAA,QAAA,oBAAA;AAIA,OAAO,SAAA,wBAAA,CAAA,UAAA,EAAA,UAAA,EAAA,OAAA,EAIG;AACR,QAAMA,WAAW,GAAGC,YAAY,CAACC,UAAU,CAA3C,QAAgC,CAAhC;AACA,QAAMC,MAAe,GAArB,EAAA;AACA,QAAMC,yBAAyB,GAAGC,6BAA6B,CAACH,UAAU,CAA1E,UAA+D,CAA/D;;AACA,OAAK,MAAL,aAAA,IAAA,UAAA,EAAwC;AACtC,UAAMI,SAAS,GAAGC,UAAU,CAA5B,aAA4B,CAA5B;AACA,UAAMC,KAAK,GAAGC,0BAA0B,CAAA,aAAA,EAAA,SAAA,EAGtCL,yBAAyB,CAH3B,aAG2B,CAHa,CAAxC;AAKAD,IAAAA,MAAM,CAANA,IAAAA,CAAAA,KAAAA;AACD;;AACD,MAAA,OAAA,EAAa;AACX,UAAMO,YAAY,GAAGD,0BAA0B,CAAA,SAAA,EAA/C,OAA+C,CAA/C;AACAN,IAAAA,MAAM,CAANA,IAAAA,CAAAA,YAAAA;AACD;;AACD,SAAO,IAAA,MAAA,CAAA,MAAA,EAAP,WAAO,CAAP;AACD;;AAED,SAAA,6BAAA,CAAA,UAAA,EAEE;AACA,QAAMQ,MAAiD,GAAvD,EAAA;;AACA,OAAK,MAAL,GAAA,IAAA,UAAA,EAA8B;AAC5B,UAAMC,cAAc,GAAGV,UAAU,CAAjC,GAAiC,CAAjC;AACAS,IAAAA,MAAM,CAACC,cAAc,CAAdA,IAAAA,IAAPD,WAAM,CAANA,GAAAA,cAAAA;AACD;;AACD,SAAA,MAAA;AACD;;AAED,SAAA,0BAAA,CAAA,aAAA,EAAA,SAAA,EAAA,UAAA,EAIS;AACP,QAAMX,WAAW,GAAGE,UAAU,GAAGD,YAAY,CAACC,UAAU,CAA1B,QAAe,CAAf,GAA9B,SAAA;AACA,QAAMW,IAAI,GAAGC,0BAA0B,CAACR,SAAS,CAAjD,KAAuC,CAAvC;AACA,SAAO,IAAA,KAAA,CAAA,aAAA,EAEL,IAAA,aAAA,CAAkBA,SAAS,CAA3B,IAAA,EAAkC,IAAA,KAAA,CAAA,OAAA,EAF7B,IAE6B,CAAlC,CAFK,EAAA,KAAA,EAAP,WAAO,CAAP;AAMD;;AAED,SAAA,YAAA,CAAA,QAAA,EAA0F;AACxF,QAAMN,WAAW,GAAG,IAApB,GAAoB,EAApB;;AACA,OAAK,MAAL,GAAA,IAAA,QAAA,EAA4B;AAC1BA,IAAAA,WAAW,CAAXA,GAAAA,CAAAA,GAAAA,MAAAA,CAAAA,GAAAA,EAAAA,SAAAA,CAAAA,EAAiCe,IAAI,CAAJA,SAAAA,CAAeC,QAAQ,CAAxDhB,GAAwD,CAAvBe,CAAjCf;AACD;;AAED,SAAA,WAAA;AACD","sourcesContent":["import {Schema, Field, FixedSizeList, getArrowTypeFromTypedArray} from '@loaders.gl/schema';\n\nimport {MeshAttribute, DracoAttribute, DracoLoaderData, DracoMetadataEntry} from '../draco-types';\n\nexport function makeSchemaFromAttributes(\n  attributes: {[attributeName: string]: MeshAttribute},\n  loaderData: DracoLoaderData,\n  indices?: MeshAttribute\n): Schema {\n  const metadataMap = makeMetadata(loaderData.metadata);\n  const fields: Field[] = [];\n  const namedLoaderDataAttributes = transformAttributesLoaderData(loaderData.attributes);\n  for (const attributeName in attributes) {\n    const attribute = attributes[attributeName];\n    const field = getArrowFieldFromAttribute(\n      attributeName,\n      attribute,\n      namedLoaderDataAttributes[attributeName]\n    );\n    fields.push(field);\n  }\n  if (indices) {\n    const indicesField = getArrowFieldFromAttribute('indices', indices);\n    fields.push(indicesField);\n  }\n  return new Schema(fields, metadataMap);\n}\n\nfunction transformAttributesLoaderData(loaderData: {[key: number]: DracoAttribute}): {\n  [attributeName: string]: DracoAttribute;\n} {\n  const result: {[attributeName: string]: DracoAttribute} = {};\n  for (const key in loaderData) {\n    const dracoAttribute = loaderData[key];\n    result[dracoAttribute.name || 'undefined'] = dracoAttribute;\n  }\n  return result;\n}\n\nfunction getArrowFieldFromAttribute(\n  attributeName: string,\n  attribute: MeshAttribute,\n  loaderData?: DracoAttribute\n): Field {\n  const metadataMap = loaderData ? makeMetadata(loaderData.metadata) : undefined;\n  const type = getArrowTypeFromTypedArray(attribute.value);\n  return new Field(\n    attributeName,\n    new FixedSizeList(attribute.size, new Field('value', type)),\n    false,\n    metadataMap\n  );\n}\n\nfunction makeMetadata(metadata: {[key: string]: DracoMetadataEntry}): Map<string, string> {\n  const metadataMap = new Map();\n  for (const key in metadata) {\n    metadataMap.set(`${key}.string`, JSON.stringify(metadata[key]));\n  }\n\n  return metadataMap;\n}\n"]},"metadata":{},"sourceType":"module"}