{"ast":null,"code":"export function formatTime(ms) {\n  let formatted;\n\n  if (ms < 10) {\n    formatted = \"\".concat(ms.toFixed(2), \"ms\");\n  } else if (ms < 100) {\n    formatted = \"\".concat(ms.toFixed(1), \"ms\");\n  } else if (ms < 1000) {\n    formatted = \"\".concat(ms.toFixed(0), \"ms\");\n  } else {\n    formatted = \"\".concat((ms / 1000).toFixed(2), \"s\");\n  }\n\n  return formatted;\n}\nexport function leftPad(string) {\n  let length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;\n  const padLength = Math.max(length - string.length, 0);\n  return \"\".concat(' '.repeat(padLength)).concat(string);\n}\nexport function rightPad(string) {\n  let length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;\n  const padLength = Math.max(length - string.length, 0);\n  return \"\".concat(string).concat(' '.repeat(padLength));\n}\nexport function formatValue(v) {\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const EPSILON = 1e-16;\n  const {\n    isInteger = false\n  } = opts;\n\n  if (Array.isArray(v) || ArrayBuffer.isView(v)) {\n    return formatArrayValue(v, opts);\n  }\n\n  if (!Number.isFinite(v)) {\n    return String(v);\n  }\n\n  if (Math.abs(v) < EPSILON) {\n    return isInteger ? '0' : '0.';\n  }\n\n  if (isInteger) {\n    return v.toFixed(0);\n  }\n\n  if (Math.abs(v) > 100 && Math.abs(v) < 10000) {\n    return v.toFixed(0);\n  }\n\n  const string = v.toPrecision(2);\n  const decimal = string.indexOf('.0');\n  return decimal === string.length - 2 ? string.slice(0, -1) : string;\n}\n\nfunction formatArrayValue(v, opts) {\n  const {\n    maxElts = 16,\n    size = 1\n  } = opts;\n  let string = '[';\n\n  for (let i = 0; i < v.length && i < maxElts; ++i) {\n    if (i > 0) {\n      string += \",\".concat(i % size === 0 ? ' ' : '');\n    }\n\n    string += formatValue(v[i], opts);\n  }\n\n  const terminator = v.length > maxElts ? '...' : ']';\n  return \"\".concat(string).concat(terminator);\n}\n\nexport function formatImage(image, message, scale) {\n  let maxWidth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 600;\n  const imageUrl = image.src.replace(/\\(/g, '%28').replace(/\\)/g, '%29');\n\n  if (image.width > maxWidth) {\n    scale = Math.min(scale, maxWidth / image.width);\n  }\n\n  const width = image.width * scale;\n  const height = image.height * scale;\n  const style = ['font-size:1px;', \"padding:\".concat(Math.floor(height / 2), \"px \").concat(Math.floor(width / 2), \"px;\"), \"line-height:\".concat(height, \"px;\"), \"background:url(\".concat(imageUrl, \");\"), \"background-size:\".concat(width, \"px \").concat(height, \"px;\"), 'color:transparent;'].join('');\n  return [\"\".concat(message, \" %c+\"), style];\n}","map":{"version":3,"sources":["../../../src/utils/formatters.js"],"names":["ms","formatted","length","padLength","Math","string","opts","EPSILON","isInteger","Array","ArrayBuffer","formatArrayValue","Number","String","v","decimal","maxElts","size","i","formatValue","terminator","maxWidth","imageUrl","image","scale","width","height","style"],"mappings":"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","sourcesContent":["// TODO: Currently unused, keeping in case we want it later for log formatting\nexport function formatTime(ms) {\n  let formatted;\n  if (ms < 10) {\n    formatted = `${ms.toFixed(2)}ms`;\n  } else if (ms < 100) {\n    formatted = `${ms.toFixed(1)}ms`;\n  } else if (ms < 1000) {\n    formatted = `${ms.toFixed(0)}ms`;\n  } else {\n    formatted = `${(ms / 1000).toFixed(2)}s`;\n  }\n  return formatted;\n}\n\nexport function leftPad(string, length = 8) {\n  const padLength = Math.max(length - string.length, 0);\n  return `${' '.repeat(padLength)}${string}`;\n}\n\nexport function rightPad(string, length = 8) {\n  const padLength = Math.max(length - string.length, 0);\n  return `${string}${' '.repeat(padLength)}`;\n}\n\nexport function formatValue(v, opts = {}) {\n  const EPSILON = 1e-16;\n  const {isInteger = false} = opts;\n  if (Array.isArray(v) || ArrayBuffer.isView(v)) {\n    return formatArrayValue(v, opts);\n  }\n  if (!Number.isFinite(v)) {\n    return String(v);\n  }\n  if (Math.abs(v) < EPSILON) {\n    return isInteger ? '0' : '0.';\n  }\n  if (isInteger) {\n    return v.toFixed(0);\n  }\n  if (Math.abs(v) > 100 && Math.abs(v) < 10000) {\n    return v.toFixed(0);\n  }\n  const string = v.toPrecision(2);\n  const decimal = string.indexOf('.0');\n  return decimal === string.length - 2 ? string.slice(0, -1) : string;\n}\n\n// Helper to formatValue\nfunction formatArrayValue(v, opts) {\n  const {maxElts = 16, size = 1} = opts;\n  let string = '[';\n  for (let i = 0; i < v.length && i < maxElts; ++i) {\n    if (i > 0) {\n      string += `,${i % size === 0 ? ' ' : ''}`;\n    }\n    string += formatValue(v[i], opts);\n  }\n  const terminator = v.length > maxElts ? '...' : ']';\n  return `${string}${terminator}`;\n}\n\n// Inspired by https://github.com/hughsk/console-image (MIT license)\nexport function formatImage(image, message, scale, maxWidth = 600) {\n  const imageUrl = image.src.replace(/\\(/g, '%28').replace(/\\)/g, '%29');\n\n  if (image.width > maxWidth) {\n    scale = Math.min(scale, maxWidth / image.width);\n  }\n\n  const width = image.width * scale;\n  const height = image.height * scale;\n\n  const style = [\n    'font-size:1px;',\n    `padding:${Math.floor(height / 2)}px ${Math.floor(width / 2)}px;`,\n    `line-height:${height}px;`,\n    `background:url(${imageUrl});`,\n    `background-size:${width}px ${height}px;`,\n    'color:transparent;'\n  ].join('');\n\n  return [`${message} %c+`, style];\n}\n"]},"metadata":{},"sourceType":"module"}