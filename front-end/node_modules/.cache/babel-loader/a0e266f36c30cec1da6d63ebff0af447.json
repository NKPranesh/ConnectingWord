{"ast":null,"code":"import { isWebGL, createGLContext, instrumentGLContext, resizeGLContext, resetParameters } from '@luma.gl/gltools';\nimport { requestAnimationFrame, cancelAnimationFrame, Query, lumaStats, Framebuffer, log, assert } from '@luma.gl/webgl';\nimport { isBrowser } from 'probe.gl/env';\nconst isPage = isBrowser() && typeof document !== 'undefined';\nlet statIdCounter = 0;\nexport default class AnimationLoop {\n  constructor() {\n    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const {\n      onCreateContext = opts => createGLContext(opts),\n      onAddHTML = null,\n      onInitialize = () => {},\n      onRender = () => {},\n      onFinalize = () => {},\n      onError,\n      gl = null,\n      glOptions = {},\n      debug = false,\n      createFramebuffer = false,\n      autoResizeViewport = true,\n      autoResizeDrawingBuffer = true,\n      stats = lumaStats.get(`animation-loop-${statIdCounter++}`)\n    } = props;\n    let {\n      useDevicePixels = true\n    } = props;\n\n    if ('useDevicePixelRatio' in props) {\n      log.deprecated('useDevicePixelRatio', 'useDevicePixels')();\n      useDevicePixels = props.useDevicePixelRatio;\n    }\n\n    this.props = {\n      onCreateContext,\n      onAddHTML,\n      onInitialize,\n      onRender,\n      onFinalize,\n      onError,\n      gl,\n      glOptions,\n      debug,\n      createFramebuffer\n    };\n    this.gl = gl;\n    this.needsRedraw = null;\n    this.timeline = null;\n    this.stats = stats;\n    this.cpuTime = this.stats.get('CPU Time');\n    this.gpuTime = this.stats.get('GPU Time');\n    this.frameRate = this.stats.get('Frame Rate');\n    this._initialized = false;\n    this._running = false;\n    this._animationFrameId = null;\n    this._nextFramePromise = null;\n    this._resolveNextFrame = null;\n    this._cpuStartTime = 0;\n    this.setProps({\n      autoResizeViewport,\n      autoResizeDrawingBuffer,\n      useDevicePixels\n    });\n    this.start = this.start.bind(this);\n    this.stop = this.stop.bind(this);\n    this._pageLoadPromise = null;\n    this._onMousemove = this._onMousemove.bind(this);\n    this._onMouseleave = this._onMouseleave.bind(this);\n  }\n\n  delete() {\n    this.stop();\n\n    this._setDisplay(null);\n  }\n\n  setNeedsRedraw(reason) {\n    assert(typeof reason === 'string');\n    this.needsRedraw = this.needsRedraw || reason;\n    return this;\n  }\n\n  setProps(props) {\n    if ('autoResizeViewport' in props) {\n      this.autoResizeViewport = props.autoResizeViewport;\n    }\n\n    if ('autoResizeDrawingBuffer' in props) {\n      this.autoResizeDrawingBuffer = props.autoResizeDrawingBuffer;\n    }\n\n    if ('useDevicePixels' in props) {\n      this.useDevicePixels = props.useDevicePixels;\n    }\n\n    return this;\n  }\n\n  start() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (this._running) {\n      return this;\n    }\n\n    this._running = true;\n\n    const startPromise = this._getPageLoadPromise().then(() => {\n      if (!this._running || this._initialized) {\n        return null;\n      }\n\n      this._createWebGLContext(opts);\n\n      this._createFramebuffer();\n\n      this._startEventHandling();\n\n      this._initializeCallbackData();\n\n      this._updateCallbackData();\n\n      this._resizeCanvasDrawingBuffer();\n\n      this._resizeViewport();\n\n      this._gpuTimeQuery = Query.isSupported(this.gl, ['timers']) ? new Query(this.gl) : null;\n      this._initialized = true;\n      return this.onInitialize(this.animationProps);\n    }).then(appContext => {\n      if (this._running) {\n        this._addCallbackData(appContext || {});\n\n        if (appContext !== false) {\n          this._startLoop();\n        }\n      }\n    });\n\n    if (this.props.onError) {\n      startPromise.catch(this.props.onError);\n    }\n\n    return this;\n  }\n\n  redraw() {\n    if (this.isContextLost()) {\n      return this;\n    }\n\n    this._beginTimers();\n\n    this._setupFrame();\n\n    this._updateCallbackData();\n\n    this._renderFrame(this.animationProps);\n\n    this._clearNeedsRedraw();\n\n    if (this.offScreen && this.gl.commit) {\n      this.gl.commit();\n    }\n\n    if (this._resolveNextFrame) {\n      this._resolveNextFrame(this);\n\n      this._nextFramePromise = null;\n      this._resolveNextFrame = null;\n    }\n\n    this._endTimers();\n\n    return this;\n  }\n\n  stop() {\n    if (this._running) {\n      this._finalizeCallbackData();\n\n      this._cancelAnimationFrame(this._animationFrameId);\n\n      this._nextFramePromise = null;\n      this._resolveNextFrame = null;\n      this._animationFrameId = null;\n      this._running = false;\n    }\n\n    return this;\n  }\n\n  attachTimeline(timeline) {\n    this.timeline = timeline;\n    return this.timeline;\n  }\n\n  detachTimeline() {\n    this.timeline = null;\n  }\n\n  waitForRender() {\n    this.setNeedsRedraw('waitForRender');\n\n    if (!this._nextFramePromise) {\n      this._nextFramePromise = new Promise(resolve => {\n        this._resolveNextFrame = resolve;\n      });\n    }\n\n    return this._nextFramePromise;\n  }\n\n  async toDataURL() {\n    this.setNeedsRedraw('toDataURL');\n    await this.waitForRender();\n    return this.gl.canvas.toDataURL();\n  }\n\n  isContextLost() {\n    return this.gl.isContextLost();\n  }\n\n  onCreateContext() {\n    return this.props.onCreateContext(...arguments);\n  }\n\n  onInitialize() {\n    return this.props.onInitialize(...arguments);\n  }\n\n  onRender() {\n    return this.props.onRender(...arguments);\n  }\n\n  onFinalize() {\n    return this.props.onFinalize(...arguments);\n  }\n\n  getHTMLControlValue(id) {\n    let defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    const element = document.getElementById(id);\n    return element ? Number(element.value) : defaultValue;\n  }\n\n  setViewParameters() {\n    log.removed('AnimationLoop.setViewParameters', 'AnimationLoop.setProps')();\n    return this;\n  }\n\n  _startLoop() {\n    const renderFrame = () => {\n      if (!this._running) {\n        return;\n      }\n\n      this.redraw();\n      this._animationFrameId = this._requestAnimationFrame(renderFrame);\n    };\n\n    this._cancelAnimationFrame(this._animationFrameId);\n\n    this._animationFrameId = this._requestAnimationFrame(renderFrame);\n  }\n\n  _getPageLoadPromise() {\n    if (!this._pageLoadPromise) {\n      this._pageLoadPromise = isPage ? new Promise((resolve, reject) => {\n        if (isPage && document.readyState === 'complete') {\n          resolve(document);\n          return;\n        }\n\n        window.addEventListener('load', () => {\n          resolve(document);\n        });\n      }) : Promise.resolve({});\n    }\n\n    return this._pageLoadPromise;\n  }\n\n  _setDisplay(display) {\n    if (this.display) {\n      this.display.delete();\n      this.display.animationLoop = null;\n    }\n\n    if (display) {\n      display.animationLoop = this;\n    }\n\n    this.display = display;\n  }\n\n  _cancelAnimationFrame(animationFrameId) {\n    if (this.display && this.display.cancelAnimationFrame) {\n      return this.display.cancelAnimationFrame(animationFrameId);\n    }\n\n    return cancelAnimationFrame(animationFrameId);\n  }\n\n  _requestAnimationFrame(renderFrameCallback) {\n    if (this._running) {\n      if (this.display && this.display.requestAnimationFrame) {\n        return this.display.requestAnimationFrame(renderFrameCallback);\n      }\n\n      return requestAnimationFrame(renderFrameCallback);\n    }\n\n    return undefined;\n  }\n\n  _renderFrame() {\n    if (this.display) {\n      this.display._renderFrame(...arguments);\n\n      return;\n    }\n\n    this.onRender(...arguments);\n  }\n\n  _clearNeedsRedraw() {\n    this.needsRedraw = null;\n  }\n\n  _setupFrame() {\n    this._resizeCanvasDrawingBuffer();\n\n    this._resizeViewport();\n\n    this._resizeFramebuffer();\n  }\n\n  _initializeCallbackData() {\n    this.animationProps = {\n      gl: this.gl,\n      stop: this.stop,\n      canvas: this.gl.canvas,\n      framebuffer: this.framebuffer,\n      useDevicePixels: this.useDevicePixels,\n      needsRedraw: null,\n      startTime: Date.now(),\n      engineTime: 0,\n      tick: 0,\n      tock: 0,\n      time: 0,\n      _timeline: this.timeline,\n      _loop: this,\n      _animationLoop: this,\n      _mousePosition: null\n    };\n  }\n\n  _updateCallbackData() {\n    const {\n      width,\n      height,\n      aspect\n    } = this._getSizeAndAspect();\n\n    if (width !== this.animationProps.width || height !== this.animationProps.height) {\n      this.setNeedsRedraw('drawing buffer resized');\n    }\n\n    if (aspect !== this.animationProps.aspect) {\n      this.setNeedsRedraw('drawing buffer aspect changed');\n    }\n\n    this.animationProps.width = width;\n    this.animationProps.height = height;\n    this.animationProps.aspect = aspect;\n    this.animationProps.needsRedraw = this.needsRedraw;\n    this.animationProps.engineTime = Date.now() - this.animationProps.startTime;\n\n    if (this.timeline) {\n      this.timeline.update(this.animationProps.engineTime);\n    }\n\n    this.animationProps.tick = Math.floor(this.animationProps.time / 1000 * 60);\n    this.animationProps.tock++;\n    this.animationProps.time = this.timeline ? this.timeline.getTime() : this.animationProps.engineTime;\n    this.animationProps._offScreen = this.offScreen;\n  }\n\n  _finalizeCallbackData() {\n    this.onFinalize(this.animationProps);\n  }\n\n  _addCallbackData(appContext) {\n    if (typeof appContext === 'object' && appContext !== null) {\n      this.animationProps = Object.assign({}, this.animationProps, appContext);\n    }\n  }\n\n  _createWebGLContext(opts) {\n    this.offScreen = opts.canvas && typeof OffscreenCanvas !== 'undefined' && opts.canvas instanceof OffscreenCanvas;\n    opts = Object.assign({}, opts, this.props.glOptions);\n    this.gl = this.props.gl ? instrumentGLContext(this.props.gl, opts) : this.onCreateContext(opts);\n\n    if (!isWebGL(this.gl)) {\n      throw new Error('AnimationLoop.onCreateContext - illegal context returned');\n    }\n\n    resetParameters(this.gl);\n\n    this._createInfoDiv();\n  }\n\n  _createInfoDiv() {\n    if (this.gl.canvas && this.props.onAddHTML) {\n      const wrapperDiv = document.createElement('div');\n      document.body.appendChild(wrapperDiv);\n      wrapperDiv.style.position = 'relative';\n      const div = document.createElement('div');\n      div.style.position = 'absolute';\n      div.style.left = '10px';\n      div.style.bottom = '10px';\n      div.style.width = '300px';\n      div.style.background = 'white';\n      wrapperDiv.appendChild(this.gl.canvas);\n      wrapperDiv.appendChild(div);\n      const html = this.props.onAddHTML(div);\n\n      if (html) {\n        div.innerHTML = html;\n      }\n    }\n  }\n\n  _getSizeAndAspect() {\n    const width = this.gl.drawingBufferWidth;\n    const height = this.gl.drawingBufferHeight;\n    let aspect = 1;\n    const {\n      canvas\n    } = this.gl;\n\n    if (canvas && canvas.clientHeight) {\n      aspect = canvas.clientWidth / canvas.clientHeight;\n    } else if (width > 0 && height > 0) {\n      aspect = width / height;\n    }\n\n    return {\n      width,\n      height,\n      aspect\n    };\n  }\n\n  _resizeViewport() {\n    if (this.autoResizeViewport) {\n      this.gl.viewport(0, 0, this.gl.drawingBufferWidth, this.gl.drawingBufferHeight);\n    }\n  }\n\n  _resizeCanvasDrawingBuffer() {\n    if (this.autoResizeDrawingBuffer) {\n      resizeGLContext(this.gl, {\n        useDevicePixels: this.useDevicePixels\n      });\n    }\n  }\n\n  _createFramebuffer() {\n    if (this.props.createFramebuffer) {\n      this.framebuffer = new Framebuffer(this.gl);\n    }\n  }\n\n  _resizeFramebuffer() {\n    if (this.framebuffer) {\n      this.framebuffer.resize({\n        width: this.gl.drawingBufferWidth,\n        height: this.gl.drawingBufferHeight\n      });\n    }\n  }\n\n  _beginTimers() {\n    this.frameRate.timeEnd();\n    this.frameRate.timeStart();\n\n    if (this._gpuTimeQuery && this._gpuTimeQuery.isResultAvailable() && !this._gpuTimeQuery.isTimerDisjoint()) {\n      this.stats.get('GPU Time').addTime(this._gpuTimeQuery.getTimerMilliseconds());\n    }\n\n    if (this._gpuTimeQuery) {\n      this._gpuTimeQuery.beginTimeElapsedQuery();\n    }\n\n    this.cpuTime.timeStart();\n  }\n\n  _endTimers() {\n    this.cpuTime.timeEnd();\n\n    if (this._gpuTimeQuery) {\n      this._gpuTimeQuery.end();\n    }\n  }\n\n  _startEventHandling() {\n    const {\n      canvas\n    } = this.gl;\n\n    if (canvas) {\n      canvas.addEventListener('mousemove', this._onMousemove);\n      canvas.addEventListener('mouseleave', this._onMouseleave);\n    }\n  }\n\n  _onMousemove(e) {\n    this.animationProps._mousePosition = [e.offsetX, e.offsetY];\n  }\n\n  _onMouseleave(e) {\n    this.animationProps._mousePosition = null;\n  }\n\n}","map":{"version":3,"sources":["../../../src/lib/animation-loop.js"],"names":["isPage","isBrowser","statIdCounter","constructor","props","onCreateContext","opts","createGLContext","onAddHTML","onInitialize","onRender","onFinalize","gl","glOptions","debug","createFramebuffer","autoResizeViewport","autoResizeDrawingBuffer","stats","lumaStats","useDevicePixels","log","delete","setNeedsRedraw","assert","setProps","start","startPromise","Query","appContext","redraw","stop","attachTimeline","detachTimeline","waitForRender","resolve","toDataURL","isContextLost","getHTMLControlValue","defaultValue","element","document","Number","setViewParameters","_startLoop","renderFrame","_getPageLoadPromise","window","Promise","_setDisplay","display","_cancelAnimationFrame","cancelAnimationFrame","_requestAnimationFrame","requestAnimationFrame","_renderFrame","_clearNeedsRedraw","_setupFrame","_initializeCallbackData","canvas","framebuffer","needsRedraw","startTime","Date","engineTime","tick","tock","time","_timeline","_loop","_animationLoop","_mousePosition","_updateCallbackData","aspect","width","height","Math","_finalizeCallbackData","_addCallbackData","Object","_createWebGLContext","instrumentGLContext","isWebGL","resetParameters","_createInfoDiv","wrapperDiv","div","html","_getSizeAndAspect","_resizeViewport","_resizeCanvasDrawingBuffer","resizeGLContext","_createFramebuffer","_resizeFramebuffer","drawingBufferHeight","_beginTimers","_endTimers","_startEventHandling","_onMousemove","e","_onMouseleave"],"mappings":"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","sourcesContent":["import {\n  isWebGL,\n  createGLContext,\n  instrumentGLContext,\n  resizeGLContext,\n  resetParameters\n} from '@luma.gl/gltools';\n\nimport {\n  requestAnimationFrame,\n  cancelAnimationFrame,\n  Query,\n  lumaStats,\n  // TODO - remove dependency on framebuffer (bundle size impact)\n  Framebuffer,\n  log,\n  assert\n} from '@luma.gl/webgl';\n\nimport {isBrowser} from 'probe.gl/env';\n\nconst isPage = isBrowser() && typeof document !== 'undefined';\n\nlet statIdCounter = 0;\n\nexport default class AnimationLoop {\n  /*\n   * @param {HTMLCanvasElement} canvas - if provided, width and height will be passed to context\n   */\n  constructor(props = {}) {\n    const {\n      onCreateContext = opts => createGLContext(opts),\n      onAddHTML = null,\n      onInitialize = () => {},\n      onRender = () => {},\n      onFinalize = () => {},\n      onError,\n\n      gl = null,\n      glOptions = {},\n      debug = false,\n\n      createFramebuffer = false,\n\n      // view parameters\n      autoResizeViewport = true,\n      autoResizeDrawingBuffer = true,\n      stats = lumaStats.get(`animation-loop-${statIdCounter++}`)\n    } = props;\n\n    let {useDevicePixels = true} = props;\n\n    if ('useDevicePixelRatio' in props) {\n      log.deprecated('useDevicePixelRatio', 'useDevicePixels')();\n      // @ts-ignore\n      useDevicePixels = props.useDevicePixelRatio;\n    }\n\n    this.props = {\n      onCreateContext,\n      onAddHTML,\n      onInitialize,\n      onRender,\n      onFinalize,\n      onError,\n\n      gl,\n      glOptions,\n      debug,\n      createFramebuffer\n    };\n\n    // state\n    this.gl = gl;\n    this.needsRedraw = null;\n    this.timeline = null;\n    this.stats = stats;\n    this.cpuTime = this.stats.get('CPU Time');\n    this.gpuTime = this.stats.get('GPU Time');\n    this.frameRate = this.stats.get('Frame Rate');\n\n    this._initialized = false;\n    this._running = false;\n    this._animationFrameId = null;\n    this._nextFramePromise = null;\n    this._resolveNextFrame = null;\n    this._cpuStartTime = 0;\n\n    this.setProps({\n      autoResizeViewport,\n      autoResizeDrawingBuffer,\n      useDevicePixels\n    });\n\n    // Bind methods\n    this.start = this.start.bind(this);\n    this.stop = this.stop.bind(this);\n\n    this._pageLoadPromise = null;\n\n    this._onMousemove = this._onMousemove.bind(this);\n    this._onMouseleave = this._onMouseleave.bind(this);\n  }\n\n  delete() {\n    this.stop();\n    this._setDisplay(null);\n  }\n\n  setNeedsRedraw(reason) {\n    assert(typeof reason === 'string');\n    this.needsRedraw = this.needsRedraw || reason;\n    return this;\n  }\n\n  setProps(props) {\n    if ('autoResizeViewport' in props) {\n      this.autoResizeViewport = props.autoResizeViewport;\n    }\n    if ('autoResizeDrawingBuffer' in props) {\n      this.autoResizeDrawingBuffer = props.autoResizeDrawingBuffer;\n    }\n    if ('useDevicePixels' in props) {\n      this.useDevicePixels = props.useDevicePixels;\n    }\n    return this;\n  }\n\n  // Starts a render loop if not already running\n  // @param {Object} context - contains frame specific info (E.g. tick, width, height, etc)\n  start(opts = {}) {\n    if (this._running) {\n      return this;\n    }\n    this._running = true;\n    // console.debug(`Starting ${this.constructor.name}`);\n    // Wait for start promise before rendering frame\n    const startPromise = this._getPageLoadPromise()\n      .then(() => {\n        if (!this._running || this._initialized) {\n          return null;\n        }\n\n        // Create the WebGL context\n        this._createWebGLContext(opts);\n        this._createFramebuffer();\n        this._startEventHandling();\n\n        // Initialize the callback data\n        this._initializeCallbackData();\n        this._updateCallbackData();\n\n        // Default viewport setup, in case onInitialize wants to render\n        this._resizeCanvasDrawingBuffer();\n        this._resizeViewport();\n\n        this._gpuTimeQuery = Query.isSupported(this.gl, ['timers']) ? new Query(this.gl) : null;\n\n        this._initialized = true;\n\n        // Note: onIntialize can return a promise (in case it needs to load resources)\n        return this.onInitialize(this.animationProps);\n      })\n      .then(appContext => {\n        if (this._running) {\n          this._addCallbackData(appContext || {});\n          if (appContext !== false) {\n            this._startLoop();\n          }\n        }\n      });\n\n    if (this.props.onError) {\n      startPromise.catch(this.props.onError);\n    }\n\n    return this;\n  }\n\n  // Redraw now\n  redraw() {\n    if (this.isContextLost()) {\n      return this;\n    }\n\n    this._beginTimers();\n\n    this._setupFrame();\n    this._updateCallbackData();\n\n    this._renderFrame(this.animationProps);\n\n    // clear needsRedraw flag\n    this._clearNeedsRedraw();\n\n    // https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/commit\n    // Chrome's offscreen canvas does not require gl.commit\n    if (this.offScreen && this.gl.commit) {\n      this.gl.commit();\n    }\n\n    if (this._resolveNextFrame) {\n      this._resolveNextFrame(this);\n      this._nextFramePromise = null;\n      this._resolveNextFrame = null;\n    }\n\n    this._endTimers();\n\n    return this;\n  }\n\n  // Stops a render loop if already running, finalizing\n  stop() {\n    // console.debug(`Stopping ${this.constructor.name}`);\n    if (this._running) {\n      this._finalizeCallbackData();\n      this._cancelAnimationFrame(this._animationFrameId);\n      this._nextFramePromise = null;\n      this._resolveNextFrame = null;\n      this._animationFrameId = null;\n      this._running = false;\n    }\n    return this;\n  }\n\n  attachTimeline(timeline) {\n    this.timeline = timeline;\n\n    return this.timeline;\n  }\n\n  detachTimeline() {\n    this.timeline = null;\n  }\n\n  waitForRender() {\n    this.setNeedsRedraw('waitForRender');\n\n    if (!this._nextFramePromise) {\n      this._nextFramePromise = new Promise(resolve => {\n        this._resolveNextFrame = resolve;\n      });\n    }\n    return this._nextFramePromise;\n  }\n\n  async toDataURL() {\n    this.setNeedsRedraw('toDataURL');\n\n    await this.waitForRender();\n\n    return this.gl.canvas.toDataURL();\n  }\n\n  isContextLost() {\n    return this.gl.isContextLost();\n  }\n\n  onCreateContext(...args) {\n    return this.props.onCreateContext(...args);\n  }\n\n  onInitialize(...args) {\n    return this.props.onInitialize(...args);\n  }\n\n  onRender(...args) {\n    return this.props.onRender(...args);\n  }\n\n  onFinalize(...args) {\n    return this.props.onFinalize(...args);\n  }\n\n  // DEPRECATED/REMOVED METHODS\n\n  getHTMLControlValue(id, defaultValue = 1) {\n    const element = document.getElementById(id);\n    // @ts-ignore Not all html elements have value\n    return element ? Number(element.value) : defaultValue;\n  }\n\n  // Update parameters\n  setViewParameters() {\n    log.removed('AnimationLoop.setViewParameters', 'AnimationLoop.setProps')();\n    return this;\n  }\n\n  // PRIVATE METHODS\n\n  _startLoop() {\n    const renderFrame = () => {\n      if (!this._running) {\n        return;\n      }\n      this.redraw();\n      this._animationFrameId = this._requestAnimationFrame(renderFrame);\n    };\n\n    // cancel any pending renders to ensure only one loop can ever run\n    this._cancelAnimationFrame(this._animationFrameId);\n    this._animationFrameId = this._requestAnimationFrame(renderFrame);\n  }\n\n  // PRIVATE METHODS\n\n  _getPageLoadPromise() {\n    if (!this._pageLoadPromise) {\n      this._pageLoadPromise = isPage\n        ? new Promise((resolve, reject) => {\n            if (isPage && document.readyState === 'complete') {\n              resolve(document);\n              return;\n            }\n            window.addEventListener('load', () => {\n              resolve(document);\n            });\n          })\n        : Promise.resolve({});\n    }\n    return this._pageLoadPromise;\n  }\n\n  _setDisplay(display) {\n    if (this.display) {\n      this.display.delete();\n      this.display.animationLoop = null;\n    }\n\n    // store animation loop on the display\n    if (display) {\n      display.animationLoop = this;\n    }\n\n    this.display = display;\n  }\n\n  _cancelAnimationFrame(animationFrameId) {\n    // E.g. VR display has a separate animation frame to sync with headset\n    if (this.display && this.display.cancelAnimationFrame) {\n      return this.display.cancelAnimationFrame(animationFrameId);\n    }\n\n    return cancelAnimationFrame(animationFrameId);\n  }\n\n  _requestAnimationFrame(renderFrameCallback) {\n    if (this._running) {\n      // E.g. VR display has a separate animation frame to sync with headset\n      if (this.display && this.display.requestAnimationFrame) {\n        return this.display.requestAnimationFrame(renderFrameCallback);\n      }\n\n      return requestAnimationFrame(renderFrameCallback);\n    }\n    return undefined;\n  }\n\n  // Called on each frame, can be overridden to call onRender multiple times\n  // to support e.g. stereoscopic rendering\n  _renderFrame(...args) {\n    // Allow e.g. VR display to render multiple frames.\n    if (this.display) {\n      this.display._renderFrame(...args);\n      return;\n    }\n\n    // call callback\n    this.onRender(...args);\n    // end callback\n  }\n\n  _clearNeedsRedraw() {\n    this.needsRedraw = null;\n  }\n\n  _setupFrame() {\n    this._resizeCanvasDrawingBuffer();\n    this._resizeViewport();\n    this._resizeFramebuffer();\n  }\n\n  // Initialize the  object that will be passed to app callbacks\n  _initializeCallbackData() {\n    this.animationProps = {\n      gl: this.gl,\n\n      stop: this.stop,\n      canvas: this.gl.canvas,\n      framebuffer: this.framebuffer,\n\n      // Initial values\n      useDevicePixels: this.useDevicePixels,\n      needsRedraw: null,\n\n      // Animation props\n      startTime: Date.now(),\n      engineTime: 0,\n      tick: 0,\n      tock: 0,\n\n      // Timeline time for back compatibility\n      time: 0,\n\n      // Experimental\n      _timeline: this.timeline,\n      _loop: this,\n      _animationLoop: this,\n      _mousePosition: null // Event props\n    };\n  }\n\n  // Update the context object that will be passed to app callbacks\n  _updateCallbackData() {\n    const {width, height, aspect} = this._getSizeAndAspect();\n    if (width !== this.animationProps.width || height !== this.animationProps.height) {\n      this.setNeedsRedraw('drawing buffer resized');\n    }\n    if (aspect !== this.animationProps.aspect) {\n      this.setNeedsRedraw('drawing buffer aspect changed');\n    }\n\n    this.animationProps.width = width;\n    this.animationProps.height = height;\n    this.animationProps.aspect = aspect;\n\n    this.animationProps.needsRedraw = this.needsRedraw;\n\n    // Update time properties\n    this.animationProps.engineTime = Date.now() - this.animationProps.startTime;\n\n    if (this.timeline) {\n      this.timeline.update(this.animationProps.engineTime);\n    }\n\n    this.animationProps.tick = Math.floor((this.animationProps.time / 1000) * 60);\n    this.animationProps.tock++;\n\n    // For back compatibility\n    this.animationProps.time = this.timeline\n      ? this.timeline.getTime()\n      : this.animationProps.engineTime;\n\n    // experimental\n    this.animationProps._offScreen = this.offScreen;\n  }\n\n  _finalizeCallbackData() {\n    // call callback\n    this.onFinalize(this.animationProps);\n    // end callback\n  }\n\n  // Add application's data to the app context object\n  _addCallbackData(appContext) {\n    if (typeof appContext === 'object' && appContext !== null) {\n      this.animationProps = Object.assign({}, this.animationProps, appContext);\n    }\n  }\n\n  // Either uses supplied or existing context, or calls provided callback to create one\n  _createWebGLContext(opts) {\n    this.offScreen =\n      opts.canvas &&\n      typeof OffscreenCanvas !== 'undefined' &&\n      opts.canvas instanceof OffscreenCanvas;\n\n    // Create the WebGL context if necessary\n    opts = Object.assign({}, opts, this.props.glOptions);\n    this.gl = this.props.gl ? instrumentGLContext(this.props.gl, opts) : this.onCreateContext(opts);\n\n    if (!isWebGL(this.gl)) {\n      throw new Error('AnimationLoop.onCreateContext - illegal context returned');\n    }\n\n    // Reset the WebGL context.\n    resetParameters(this.gl);\n\n    this._createInfoDiv();\n  }\n\n  _createInfoDiv() {\n    if (this.gl.canvas && this.props.onAddHTML) {\n      const wrapperDiv = document.createElement('div');\n      document.body.appendChild(wrapperDiv);\n      wrapperDiv.style.position = 'relative';\n      const div = document.createElement('div');\n      div.style.position = 'absolute';\n      div.style.left = '10px';\n      div.style.bottom = '10px';\n      div.style.width = '300px';\n      div.style.background = 'white';\n      wrapperDiv.appendChild(this.gl.canvas);\n      wrapperDiv.appendChild(div);\n      const html = this.props.onAddHTML(div);\n      if (html) {\n        div.innerHTML = html;\n      }\n    }\n  }\n\n  _getSizeAndAspect() {\n    // https://webglfundamentals.org/webgl/lessons/webgl-resizing-the-canvas.html\n    const width = this.gl.drawingBufferWidth;\n    const height = this.gl.drawingBufferHeight;\n\n    // https://webglfundamentals.org/webgl/lessons/webgl-anti-patterns.html\n    let aspect = 1;\n    const {canvas} = this.gl;\n\n    if (canvas && canvas.clientHeight) {\n      aspect = canvas.clientWidth / canvas.clientHeight;\n    } else if (width > 0 && height > 0) {\n      aspect = width / height;\n    }\n\n    return {width, height, aspect};\n  }\n\n  // Default viewport setup\n  _resizeViewport() {\n    if (this.autoResizeViewport) {\n      this.gl.viewport(0, 0, this.gl.drawingBufferWidth, this.gl.drawingBufferHeight);\n    }\n  }\n\n  // Resize the render buffer of the canvas to match canvas client size\n  // Optionally multiplying with devicePixel ratio\n  _resizeCanvasDrawingBuffer() {\n    if (this.autoResizeDrawingBuffer) {\n      resizeGLContext(this.gl, {useDevicePixels: this.useDevicePixels});\n    }\n  }\n\n  // TBD - deprecated?\n  _createFramebuffer() {\n    // Setup default framebuffer\n    if (this.props.createFramebuffer) {\n      this.framebuffer = new Framebuffer(this.gl);\n    }\n  }\n\n  _resizeFramebuffer() {\n    if (this.framebuffer) {\n      this.framebuffer.resize({\n        width: this.gl.drawingBufferWidth,\n        height: this.gl.drawingBufferHeight\n      });\n    }\n  }\n\n  _beginTimers() {\n    this.frameRate.timeEnd();\n    this.frameRate.timeStart();\n\n    // Check if timer for last frame has completed.\n    // GPU timer results are never available in the same\n    // frame they are captured.\n    if (\n      this._gpuTimeQuery &&\n      this._gpuTimeQuery.isResultAvailable() &&\n      !this._gpuTimeQuery.isTimerDisjoint()\n    ) {\n      this.stats.get('GPU Time').addTime(this._gpuTimeQuery.getTimerMilliseconds());\n    }\n\n    if (this._gpuTimeQuery) {\n      // GPU time query start\n      this._gpuTimeQuery.beginTimeElapsedQuery();\n    }\n\n    this.cpuTime.timeStart();\n  }\n\n  _endTimers() {\n    this.cpuTime.timeEnd();\n\n    if (this._gpuTimeQuery) {\n      // GPU time query end. Results will be available on next frame.\n      this._gpuTimeQuery.end();\n    }\n  }\n\n  // Event handling\n\n  _startEventHandling() {\n    const {canvas} = this.gl;\n    if (canvas) {\n      canvas.addEventListener('mousemove', this._onMousemove);\n      canvas.addEventListener('mouseleave', this._onMouseleave);\n    }\n  }\n\n  _onMousemove(e) {\n    this.animationProps._mousePosition = [e.offsetX, e.offsetY];\n  }\n  _onMouseleave(e) {\n    this.animationProps._mousePosition = null;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}