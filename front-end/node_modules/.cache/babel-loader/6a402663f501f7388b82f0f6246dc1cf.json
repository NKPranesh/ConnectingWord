{"ast":null,"code":"import { padToNBytes } from './memory-copy-utils';\nexport function copyPaddedArrayBufferToDataView(dataView, byteOffset, sourceBuffer, padding) {\n  const paddedLength = padToNBytes(sourceBuffer.byteLength, padding);\n  const padLength = paddedLength - sourceBuffer.byteLength;\n\n  if (dataView) {\n    const targetArray = new Uint8Array(dataView.buffer, dataView.byteOffset + byteOffset, sourceBuffer.byteLength);\n    const sourceArray = new Uint8Array(sourceBuffer);\n    targetArray.set(sourceArray);\n\n    for (let i = 0; i < padLength; ++i) {\n      dataView.setUint8(byteOffset + sourceBuffer.byteLength + i, 0x20);\n    }\n  }\n\n  byteOffset += paddedLength;\n  return byteOffset;\n}\nexport function copyPaddedStringToDataView(dataView, byteOffset, string, padding) {\n  const textEncoder = new TextEncoder();\n  const stringBuffer = textEncoder.encode(string);\n  byteOffset = copyPaddedArrayBufferToDataView(dataView, byteOffset, stringBuffer, padding);\n  return byteOffset;\n}","map":{"version":3,"sources":["../../../../src/lib/binary-utils/binary-copy-utils.ts"],"names":["paddedLength","padToNBytes","sourceBuffer","padLength","targetArray","dataView","sourceArray","i","byteOffset","textEncoder","stringBuffer","copyPaddedArrayBufferToDataView"],"mappings":"AACA,SAAA,WAAA,QAAA,qBAAA;AAYA,OAAO,SAAA,+BAAA,CAAA,QAAA,EAAA,UAAA,EAAA,YAAA,EAAA,OAAA,EAKL;AACA,QAAMA,YAAY,GAAGC,WAAW,CAACC,YAAY,CAAb,UAAA,EAAhC,OAAgC,CAAhC;AACA,QAAMC,SAAS,GAAGH,YAAY,GAAGE,YAAY,CAA7C,UAAA;;AAEA,MAAA,QAAA,EAAc;AAEZ,UAAME,WAAW,GAAG,IAAA,UAAA,CAClBC,QAAQ,CADU,MAAA,EAElBA,QAAQ,CAARA,UAAAA,GAFkB,UAAA,EAGlBH,YAAY,CAHd,UAAoB,CAApB;AAKA,UAAMI,WAAW,GAAG,IAAA,UAAA,CAApB,YAAoB,CAApB;AACAF,IAAAA,WAAW,CAAXA,GAAAA,CAAAA,WAAAA;;AAGA,SAAK,IAAIG,CAAC,GAAV,CAAA,EAAgBA,CAAC,GAAjB,SAAA,EAA+B,EAA/B,CAAA,EAAoC;AAElCF,MAAAA,QAAQ,CAARA,QAAAA,CAAkBG,UAAU,GAAGN,YAAY,CAAzBM,UAAAA,GAAlBH,CAAAA,EAAAA,IAAAA;AACD;AACF;;AACDG,EAAAA,UAAU,IAAVA,YAAAA;AACA,SAAA,UAAA;AACD;AAYD,OAAO,SAAA,0BAAA,CAAA,QAAA,EAAA,UAAA,EAAA,MAAA,EAAA,OAAA,EAKG;AACR,QAAMC,WAAW,GAAG,IAApB,WAAoB,EAApB;AAGA,QAAMC,YAAY,GAAGD,WAAW,CAAXA,MAAAA,CAArB,MAAqBA,CAArB;AAEAD,EAAAA,UAAU,GAAGG,+BAA+B,CAAA,QAAA,EAAA,UAAA,EAAA,YAAA,EAA5CH,OAA4C,CAA5CA;AAEA,SAAA,UAAA;AACD","sourcesContent":["import {TypedArray} from '../../types';\nimport {padToNBytes} from './memory-copy-utils';\n\n/**\n * Copy sourceBuffer to dataView with some padding\n *\n * @param {DataView | null} dataView - destination data container. If null - only new offset is calculated\n * @param {number} byteOffset - destination byte offset to copy to\n * @param {Array | TypedArray} sourceBuffer - source data buffer\n * @param {number} padding - pad the resulting array to multiple of \"padding\" bytes. Additional bytes are filled with 0x20 (ASCII space)\n *\n * @return new byteOffset of resulting dataView\n */\nexport function copyPaddedArrayBufferToDataView(\n  dataView: DataView | null,\n  byteOffset: number,\n  sourceBuffer: TypedArray,\n  padding: number\n) {\n  const paddedLength = padToNBytes(sourceBuffer.byteLength, padding);\n  const padLength = paddedLength - sourceBuffer.byteLength;\n\n  if (dataView) {\n    // Copy array\n    const targetArray = new Uint8Array(\n      dataView.buffer,\n      dataView.byteOffset + byteOffset,\n      sourceBuffer.byteLength\n    );\n    const sourceArray = new Uint8Array(sourceBuffer);\n    targetArray.set(sourceArray);\n\n    // Add PADDING\n    for (let i = 0; i < padLength; ++i) {\n      // json chunk is padded with spaces (ASCII 0x20)\n      dataView.setUint8(byteOffset + sourceBuffer.byteLength + i, 0x20);\n    }\n  }\n  byteOffset += paddedLength;\n  return byteOffset;\n}\n\n/**\n * Copy string to dataView with some padding\n *\n * @param {DataView | null} dataView - destination data container. If null - only new offset is calculated\n * @param {number} byteOffset - destination byte offset to copy to\n * @param {string} string - source string\n * @param {number} padding - pad the resulting array to multiple of \"padding\" bytes. Additional bytes are filled with 0x20 (ASCII space)\n *\n * @return new byteOffset of resulting dataView\n */\nexport function copyPaddedStringToDataView(\n  dataView: DataView | null,\n  byteOffset: number,\n  string: string,\n  padding: number\n): number {\n  const textEncoder = new TextEncoder();\n  // PERFORMANCE IDEA: We encode twice, once to get size and once to store\n  // PERFORMANCE IDEA: Use TextEncoder.encodeInto() to avoid temporary copy\n  const stringBuffer = textEncoder.encode(string);\n\n  byteOffset = copyPaddedArrayBufferToDataView(dataView, byteOffset, stringBuffer, padding);\n\n  return byteOffset;\n}\n"]},"metadata":{},"sourceType":"module"}