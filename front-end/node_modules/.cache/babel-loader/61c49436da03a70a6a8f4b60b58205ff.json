{"ast":null,"code":"import { Geometry } from '@luma.gl/core';\nimport { COORDINATE_SYSTEM, CompositeLayer } from '@deck.gl/core';\nimport { PointCloudLayer } from '@deck.gl/layers';\nimport { ScenegraphLayer } from '@deck.gl/mesh-layers';\nimport { default as _MeshLayer } from '../mesh-layer/mesh-layer';\nimport { log } from '@deck.gl/core';\nimport { load } from '@loaders.gl/core';\nimport { Tileset3D, TILE_TYPE } from '@loaders.gl/tiles';\nimport { Tiles3DLoader } from '@loaders.gl/3d-tiles';\nconst SINGLE_DATA = [0];\nconst defaultProps = {\n  getPointColor: {\n    type: 'accessor',\n    value: [0, 0, 0, 255]\n  },\n  pointSize: 1.0,\n  data: null,\n  loader: Tiles3DLoader,\n  onTilesetLoad: {\n    type: 'function',\n    value: tileset3d => {},\n    compare: false\n  },\n  onTileLoad: {\n    type: 'function',\n    value: tileHeader => {},\n    compare: false\n  },\n  onTileUnload: {\n    type: 'function',\n    value: tileHeader => {},\n    compare: false\n  },\n  onTileError: {\n    type: 'function',\n    value: (tile, message, url) => {},\n    compare: false\n  },\n  _getMeshColor: {\n    type: 'function',\n    value: tileHeader => [255, 255, 255],\n    compare: false\n  }\n};\nexport default class Tile3DLayer extends CompositeLayer {\n  initializeState() {\n    if ('onTileLoadFail' in this.props) {\n      log.removed('onTileLoadFail', 'onTileError')();\n    }\n\n    this.state = {\n      layerMap: {},\n      tileset3d: null,\n      activeViewports: {},\n      lastUpdatedViewports: null\n    };\n  }\n\n  get isLoaded() {\n    const {\n      tileset3d\n    } = this.state;\n    return tileset3d && tileset3d.isLoaded();\n  }\n\n  shouldUpdateState(_ref) {\n    let {\n      changeFlags\n    } = _ref;\n    return changeFlags.somethingChanged;\n  }\n\n  updateState(_ref2) {\n    let {\n      props,\n      oldProps,\n      changeFlags\n    } = _ref2;\n\n    if (props.data && props.data !== oldProps.data) {\n      this._loadTileset(props.data);\n    }\n\n    if (changeFlags.viewportChanged) {\n      const {\n        activeViewports\n      } = this.state;\n      const viewportsNumber = Object.keys(activeViewports).length;\n\n      if (viewportsNumber) {\n        this._updateTileset(activeViewports);\n\n        this.state.lastUpdatedViewports = activeViewports;\n        this.state.activeViewports = {};\n      }\n    }\n\n    if (changeFlags.propsChanged) {\n      const {\n        layerMap\n      } = this.state;\n\n      for (const key in layerMap) {\n        layerMap[key].needsUpdate = true;\n      }\n    }\n  }\n\n  activateViewport(viewport) {\n    const {\n      activeViewports,\n      lastUpdatedViewports\n    } = this.state;\n    this.internalState.viewport = viewport;\n    activeViewports[viewport.id] = viewport;\n    const lastViewport = lastUpdatedViewports === null || lastUpdatedViewports === void 0 ? void 0 : lastUpdatedViewports[viewport.id];\n\n    if (!lastViewport || !viewport.equals(lastViewport)) {\n      this.setChangeFlags({\n        viewportChanged: true\n      });\n      this.setNeedsUpdate();\n    }\n  }\n\n  getPickingInfo(_ref3) {\n    let {\n      info,\n      sourceLayer\n    } = _ref3;\n    const {\n      layerMap\n    } = this.state;\n    const layerId = sourceLayer && sourceLayer.id;\n\n    if (layerId) {\n      const substr = layerId.substring(this.id.length + 1);\n      const tileId = substr.substring(substr.indexOf('-') + 1);\n      info.object = layerMap[tileId] && layerMap[tileId].tile;\n    }\n\n    return info;\n  }\n\n  filterSubLayer(_ref4) {\n    let {\n      layer,\n      viewport\n    } = _ref4;\n    const {\n      tile\n    } = layer.props;\n    const {\n      id: viewportId\n    } = viewport;\n    return tile.selected && tile.viewportIds.includes(viewportId);\n  }\n\n  _updateAutoHighlight(info) {\n    if (info.sourceLayer) {\n      info.sourceLayer.updateAutoHighlight(info);\n    }\n  }\n\n  async _loadTileset(tilesetUrl) {\n    const {\n      loadOptions = {}\n    } = this.props;\n    let loader = this.props.loader || this.props.loaders;\n\n    if (Array.isArray(loader)) {\n      loader = loader[0];\n    }\n\n    const options = {\n      loadOptions: { ...loadOptions\n      }\n    };\n\n    if (loader.preload) {\n      const preloadOptions = await loader.preload(tilesetUrl, loadOptions);\n\n      if (preloadOptions.headers) {\n        options.loadOptions.fetch = { ...options.loadOptions.fetch,\n          headers: preloadOptions.headers\n        };\n      }\n\n      Object.assign(options, preloadOptions);\n    }\n\n    const tilesetJson = await load(tilesetUrl, loader, options.loadOptions);\n    const tileset3d = new Tileset3D(tilesetJson, {\n      onTileLoad: this._onTileLoad.bind(this),\n      onTileUnload: this._onTileUnload.bind(this),\n      onTileLoadFail: this.props.onTileError,\n      ...options\n    });\n    this.setState({\n      tileset3d,\n      layerMap: {}\n    });\n\n    this._updateTileset(this.state.activeViewports);\n\n    this.props.onTilesetLoad(tileset3d);\n  }\n\n  _onTileLoad(tileHeader) {\n    const {\n      lastUpdatedViewports\n    } = this.state;\n    this.props.onTileLoad(tileHeader);\n\n    this._updateTileset(lastUpdatedViewports);\n\n    this.setNeedsUpdate();\n  }\n\n  _onTileUnload(tileHeader) {\n    delete this.state.layerMap[tileHeader.id];\n    this.props.onTileUnload(tileHeader);\n  }\n\n  _updateTileset(viewports) {\n    const {\n      tileset3d\n    } = this.state;\n    const {\n      timeline\n    } = this.context;\n    const viewportsNumber = Object.keys(viewports).length;\n\n    if (!timeline || !viewportsNumber || !tileset3d) {\n      return;\n    }\n\n    const frameNumber = tileset3d.update(Object.values(viewports));\n    const tilesetChanged = this.state.frameNumber !== frameNumber;\n\n    if (tilesetChanged) {\n      this.setState({\n        frameNumber\n      });\n    }\n  }\n\n  _getSubLayer(tileHeader, oldLayer) {\n    if (!tileHeader.content) {\n      return null;\n    }\n\n    switch (tileHeader.type) {\n      case TILE_TYPE.POINTCLOUD:\n        return this._makePointCloudLayer(tileHeader, oldLayer);\n\n      case TILE_TYPE.SCENEGRAPH:\n        return this._make3DModelLayer(tileHeader, oldLayer);\n\n      case TILE_TYPE.MESH:\n        return this._makeSimpleMeshLayer(tileHeader, oldLayer);\n\n      default:\n        throw new Error(\"Tile3DLayer: Failed to render layer of type \".concat(tileHeader.content.type));\n    }\n  }\n\n  _makePointCloudLayer(tileHeader, oldLayer) {\n    const {\n      attributes,\n      pointCount,\n      constantRGBA,\n      cartographicOrigin,\n      modelMatrix\n    } = tileHeader.content;\n    const {\n      positions,\n      normals,\n      colors\n    } = attributes;\n\n    if (!positions) {\n      return null;\n    }\n\n    const data = oldLayer && oldLayer.props.data || {\n      header: {\n        vertexCount: pointCount\n      },\n      attributes: {\n        POSITION: positions,\n        NORMAL: normals,\n        COLOR_0: colors\n      }\n    };\n    const {\n      pointSize,\n      getPointColor\n    } = this.props;\n    const SubLayerClass = this.getSubLayerClass('pointcloud', PointCloudLayer);\n    return new SubLayerClass({\n      pointSize\n    }, this.getSubLayerProps({\n      id: 'pointcloud'\n    }), {\n      id: \"\".concat(this.id, \"-pointcloud-\").concat(tileHeader.id),\n      tile: tileHeader,\n      data,\n      coordinateSystem: COORDINATE_SYSTEM.METER_OFFSETS,\n      coordinateOrigin: cartographicOrigin,\n      modelMatrix,\n      getColor: constantRGBA || getPointColor,\n      _offset: 0\n    });\n  }\n\n  _make3DModelLayer(tileHeader) {\n    const {\n      gltf,\n      instances,\n      cartographicOrigin,\n      modelMatrix\n    } = tileHeader.content;\n    const SubLayerClass = this.getSubLayerClass('scenegraph', ScenegraphLayer);\n    return new SubLayerClass({\n      _lighting: 'pbr'\n    }, this.getSubLayerProps({\n      id: 'scenegraph'\n    }), {\n      id: \"\".concat(this.id, \"-scenegraph-\").concat(tileHeader.id),\n      tile: tileHeader,\n      data: instances || SINGLE_DATA,\n      scenegraph: gltf,\n      coordinateSystem: COORDINATE_SYSTEM.METER_OFFSETS,\n      coordinateOrigin: cartographicOrigin,\n      modelMatrix,\n      getTransformMatrix: instance => instance.modelMatrix,\n      getPosition: [0, 0, 0],\n      _offset: 0\n    });\n  }\n\n  _makeSimpleMeshLayer(tileHeader, oldLayer) {\n    const content = tileHeader.content;\n    const {\n      attributes,\n      indices,\n      modelMatrix,\n      cartographicOrigin,\n      material,\n      featureIds\n    } = content;\n    const {\n      _getMeshColor\n    } = this.props;\n    const geometry = oldLayer && oldLayer.props.mesh || new Geometry({\n      drawMode: 4,\n      attributes: getMeshGeometry(attributes),\n      indices\n    });\n    const SubLayerClass = this.getSubLayerClass('mesh', _MeshLayer);\n    return new SubLayerClass(this.getSubLayerProps({\n      id: 'mesh'\n    }), {\n      id: \"\".concat(this.id, \"-mesh-\").concat(tileHeader.id),\n      tile: tileHeader,\n      mesh: geometry,\n      data: SINGLE_DATA,\n      getColor: _getMeshColor(tileHeader),\n      pbrMaterial: material,\n      modelMatrix,\n      coordinateOrigin: cartographicOrigin,\n      coordinateSystem: COORDINATE_SYSTEM.METER_OFFSETS,\n      featureIds,\n      _offset: 0\n    });\n  }\n\n  renderLayers() {\n    const {\n      tileset3d,\n      layerMap\n    } = this.state;\n\n    if (!tileset3d) {\n      return null;\n    }\n\n    return tileset3d.tiles.map(tile => {\n      const layerCache = layerMap[tile.id] = layerMap[tile.id] || {\n        tile\n      };\n      let {\n        layer\n      } = layerCache;\n\n      if (tile.selected) {\n        if (!layer) {\n          layer = this._getSubLayer(tile);\n        } else if (layerCache.needsUpdate) {\n          layer = this._getSubLayer(tile, layer);\n          layerCache.needsUpdate = false;\n        }\n      }\n\n      layerCache.layer = layer;\n      return layer;\n    }).filter(Boolean);\n  }\n\n}\n\nfunction getMeshGeometry(contentAttributes) {\n  const attributes = {};\n  attributes.positions = { ...contentAttributes.positions,\n    value: new Float32Array(contentAttributes.positions.value)\n  };\n\n  if (contentAttributes.normals) {\n    attributes.normals = contentAttributes.normals;\n  }\n\n  if (contentAttributes.texCoords) {\n    attributes.texCoords = contentAttributes.texCoords;\n  }\n\n  if (contentAttributes.colors) {\n    attributes.colors = contentAttributes.colors;\n  }\n\n  if (contentAttributes.uvRegions) {\n    attributes.uvRegions = contentAttributes.uvRegions;\n  }\n\n  return attributes;\n}\n\nTile3DLayer.layerName = 'Tile3DLayer';\nTile3DLayer.defaultProps = defaultProps;","map":{"version":3,"sources":["../../../src/tile-3d-layer/tile-3d-layer.js"],"names":["default","SINGLE_DATA","defaultProps","getPointColor","type","value","pointSize","data","loader","onTilesetLoad","tileset3d","compare","onTileLoad","tileHeader","onTileUnload","onTileError","_getMeshColor","initializeState","log","layerMap","activeViewports","lastUpdatedViewports","isLoaded","shouldUpdateState","changeFlags","updateState","props","oldProps","viewportsNumber","Object","activateViewport","viewport","lastViewport","viewportChanged","getPickingInfo","sourceLayer","layerId","substr","tileId","info","filterSubLayer","tile","layer","id","viewportId","_updateAutoHighlight","_loadTileset","loadOptions","Array","options","preloadOptions","headers","tilesetJson","load","onTileLoadFail","_onTileLoad","_onTileUnload","_updateTileset","timeline","frameNumber","tilesetChanged","_getSubLayer","TILE_TYPE","_makePointCloudLayer","modelMatrix","colors","oldLayer","header","vertexCount","pointCount","attributes","POSITION","NORMAL","COLOR_0","SubLayerClass","coordinateSystem","COORDINATE_SYSTEM","coordinateOrigin","getColor","constantRGBA","_offset","_make3DModelLayer","_lighting","instances","scenegraph","getTransformMatrix","instance","getPosition","_makeSimpleMeshLayer","content","featureIds","geometry","drawMode","getMeshGeometry","indices","mesh","pbrMaterial","renderLayers","layerCache","contentAttributes","Tile3DLayer"],"mappings":"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","sourcesContent":["import GL from '@luma.gl/constants';\nimport {Geometry} from '@luma.gl/core';\nimport {COORDINATE_SYSTEM, CompositeLayer} from '@deck.gl/core';\nimport {PointCloudLayer} from '@deck.gl/layers';\nimport {ScenegraphLayer} from '@deck.gl/mesh-layers';\nimport {default as _MeshLayer} from '../mesh-layer/mesh-layer';\nimport {log} from '@deck.gl/core';\n\nimport {load} from '@loaders.gl/core';\nimport {Tileset3D, TILE_TYPE} from '@loaders.gl/tiles';\nimport {Tiles3DLoader} from '@loaders.gl/3d-tiles';\n\nconst SINGLE_DATA = [0];\n\nconst defaultProps = {\n  getPointColor: {type: 'accessor', value: [0, 0, 0, 255]},\n  pointSize: 1.0,\n\n  data: null,\n  loader: Tiles3DLoader,\n\n  onTilesetLoad: {type: 'function', value: tileset3d => {}, compare: false},\n  onTileLoad: {type: 'function', value: tileHeader => {}, compare: false},\n  onTileUnload: {type: 'function', value: tileHeader => {}, compare: false},\n  onTileError: {type: 'function', value: (tile, message, url) => {}, compare: false},\n  _getMeshColor: {type: 'function', value: tileHeader => [255, 255, 255], compare: false}\n};\n\nexport default class Tile3DLayer extends CompositeLayer {\n  initializeState() {\n    if ('onTileLoadFail' in this.props) {\n      log.removed('onTileLoadFail', 'onTileError')();\n    }\n    // prop verification\n    this.state = {\n      layerMap: {},\n      tileset3d: null,\n      activeViewports: {},\n      lastUpdatedViewports: null\n    };\n  }\n\n  get isLoaded() {\n    const {tileset3d} = this.state;\n    return tileset3d && tileset3d.isLoaded();\n  }\n\n  shouldUpdateState({changeFlags}) {\n    return changeFlags.somethingChanged;\n  }\n\n  updateState({props, oldProps, changeFlags}) {\n    if (props.data && props.data !== oldProps.data) {\n      this._loadTileset(props.data);\n    }\n\n    if (changeFlags.viewportChanged) {\n      const {activeViewports} = this.state;\n      const viewportsNumber = Object.keys(activeViewports).length;\n      if (viewportsNumber) {\n        this._updateTileset(activeViewports);\n        this.state.lastUpdatedViewports = activeViewports;\n        this.state.activeViewports = {};\n      }\n    }\n    if (changeFlags.propsChanged) {\n      const {layerMap} = this.state;\n      for (const key in layerMap) {\n        layerMap[key].needsUpdate = true;\n      }\n    }\n  }\n\n  activateViewport(viewport) {\n    const {activeViewports, lastUpdatedViewports} = this.state;\n    this.internalState.viewport = viewport;\n\n    activeViewports[viewport.id] = viewport;\n    const lastViewport = lastUpdatedViewports?.[viewport.id];\n    if (!lastViewport || !viewport.equals(lastViewport)) {\n      this.setChangeFlags({viewportChanged: true});\n      this.setNeedsUpdate();\n    }\n  }\n\n  getPickingInfo({info, sourceLayer}) {\n    const {layerMap} = this.state;\n    const layerId = sourceLayer && sourceLayer.id;\n    if (layerId) {\n      // layerId: this.id-[scenegraph|pointcloud]-tileId\n      const substr = layerId.substring(this.id.length + 1);\n      const tileId = substr.substring(substr.indexOf('-') + 1);\n      info.object = layerMap[tileId] && layerMap[tileId].tile;\n    }\n\n    return info;\n  }\n\n  filterSubLayer({layer, viewport}) {\n    const {tile} = layer.props;\n    const {id: viewportId} = viewport;\n    return tile.selected && tile.viewportIds.includes(viewportId);\n  }\n\n  _updateAutoHighlight(info) {\n    if (info.sourceLayer) {\n      info.sourceLayer.updateAutoHighlight(info);\n    }\n  }\n\n  async _loadTileset(tilesetUrl) {\n    const {loadOptions = {}} = this.props;\n\n    // TODO: deprecate `loader` in v9.0\n    let loader = this.props.loader || this.props.loaders;\n    if (Array.isArray(loader)) {\n      loader = loader[0];\n    }\n\n    const options = {loadOptions: {...loadOptions}};\n    if (loader.preload) {\n      const preloadOptions = await loader.preload(tilesetUrl, loadOptions);\n\n      if (preloadOptions.headers) {\n        options.loadOptions.fetch = {\n          ...options.loadOptions.fetch,\n          headers: preloadOptions.headers\n        };\n      }\n      Object.assign(options, preloadOptions);\n    }\n    const tilesetJson = await load(tilesetUrl, loader, options.loadOptions);\n\n    const tileset3d = new Tileset3D(tilesetJson, {\n      onTileLoad: this._onTileLoad.bind(this),\n      onTileUnload: this._onTileUnload.bind(this),\n      onTileLoadFail: this.props.onTileError,\n      ...options\n    });\n\n    this.setState({\n      tileset3d,\n      layerMap: {}\n    });\n\n    this._updateTileset(this.state.activeViewports);\n    this.props.onTilesetLoad(tileset3d);\n  }\n\n  _onTileLoad(tileHeader) {\n    const {lastUpdatedViewports} = this.state;\n    this.props.onTileLoad(tileHeader);\n    this._updateTileset(lastUpdatedViewports);\n    this.setNeedsUpdate();\n  }\n\n  _onTileUnload(tileHeader) {\n    // Was cleaned up from tileset cache. We no longer need to track it.\n    delete this.state.layerMap[tileHeader.id];\n    this.props.onTileUnload(tileHeader);\n  }\n\n  _updateTileset(viewports) {\n    const {tileset3d} = this.state;\n    const {timeline} = this.context;\n    const viewportsNumber = Object.keys(viewports).length;\n    if (!timeline || !viewportsNumber || !tileset3d) {\n      return;\n    }\n    const frameNumber = tileset3d.update(Object.values(viewports));\n    const tilesetChanged = this.state.frameNumber !== frameNumber;\n    if (tilesetChanged) {\n      this.setState({frameNumber});\n    }\n  }\n\n  _getSubLayer(tileHeader, oldLayer) {\n    if (!tileHeader.content) {\n      return null;\n    }\n\n    switch (tileHeader.type) {\n      case TILE_TYPE.POINTCLOUD:\n        return this._makePointCloudLayer(tileHeader, oldLayer);\n      case TILE_TYPE.SCENEGRAPH:\n        return this._make3DModelLayer(tileHeader, oldLayer);\n      case TILE_TYPE.MESH:\n        return this._makeSimpleMeshLayer(tileHeader, oldLayer);\n      default:\n        throw new Error(`Tile3DLayer: Failed to render layer of type ${tileHeader.content.type}`);\n    }\n  }\n\n  _makePointCloudLayer(tileHeader, oldLayer) {\n    const {\n      attributes,\n      pointCount,\n      constantRGBA,\n      cartographicOrigin,\n      modelMatrix\n    } = tileHeader.content;\n    const {positions, normals, colors} = attributes;\n\n    if (!positions) {\n      return null;\n    }\n    const data = (oldLayer && oldLayer.props.data) || {\n      header: {\n        vertexCount: pointCount\n      },\n      attributes: {\n        POSITION: positions,\n        NORMAL: normals,\n        COLOR_0: colors\n      }\n    };\n\n    const {pointSize, getPointColor} = this.props;\n    const SubLayerClass = this.getSubLayerClass('pointcloud', PointCloudLayer);\n    return new SubLayerClass(\n      {\n        pointSize\n      },\n      this.getSubLayerProps({\n        id: 'pointcloud'\n      }),\n      {\n        id: `${this.id}-pointcloud-${tileHeader.id}`,\n        tile: tileHeader,\n        data,\n        coordinateSystem: COORDINATE_SYSTEM.METER_OFFSETS,\n        coordinateOrigin: cartographicOrigin,\n        modelMatrix,\n        getColor: constantRGBA || getPointColor,\n        _offset: 0\n      }\n    );\n  }\n\n  _make3DModelLayer(tileHeader) {\n    const {gltf, instances, cartographicOrigin, modelMatrix} = tileHeader.content;\n\n    const SubLayerClass = this.getSubLayerClass('scenegraph', ScenegraphLayer);\n\n    return new SubLayerClass(\n      {\n        _lighting: 'pbr'\n      },\n      this.getSubLayerProps({\n        id: 'scenegraph'\n      }),\n      {\n        id: `${this.id}-scenegraph-${tileHeader.id}`,\n        tile: tileHeader,\n        data: instances || SINGLE_DATA,\n        scenegraph: gltf,\n\n        coordinateSystem: COORDINATE_SYSTEM.METER_OFFSETS,\n        coordinateOrigin: cartographicOrigin,\n        modelMatrix,\n        getTransformMatrix: instance => instance.modelMatrix,\n        getPosition: [0, 0, 0],\n        _offset: 0\n      }\n    );\n  }\n\n  _makeSimpleMeshLayer(tileHeader, oldLayer) {\n    const content = tileHeader.content;\n    const {attributes, indices, modelMatrix, cartographicOrigin, material, featureIds} = content;\n    const {_getMeshColor} = this.props;\n\n    const geometry =\n      (oldLayer && oldLayer.props.mesh) ||\n      new Geometry({\n        drawMode: GL.TRIANGLES,\n        attributes: getMeshGeometry(attributes),\n        indices\n      });\n\n    const SubLayerClass = this.getSubLayerClass('mesh', _MeshLayer);\n\n    return new SubLayerClass(\n      this.getSubLayerProps({\n        id: 'mesh'\n      }),\n      {\n        id: `${this.id}-mesh-${tileHeader.id}`,\n        tile: tileHeader,\n        mesh: geometry,\n        data: SINGLE_DATA,\n        getColor: _getMeshColor(tileHeader),\n        pbrMaterial: material,\n        modelMatrix,\n        coordinateOrigin: cartographicOrigin,\n        coordinateSystem: COORDINATE_SYSTEM.METER_OFFSETS,\n        featureIds,\n        _offset: 0\n      }\n    );\n  }\n\n  renderLayers() {\n    const {tileset3d, layerMap} = this.state;\n    if (!tileset3d) {\n      return null;\n    }\n\n    return tileset3d.tiles\n      .map(tile => {\n        const layerCache = (layerMap[tile.id] = layerMap[tile.id] || {tile});\n        let {layer} = layerCache;\n        if (tile.selected) {\n          // render selected tiles\n          if (!layer) {\n            // create layer\n            layer = this._getSubLayer(tile);\n          } else if (layerCache.needsUpdate) {\n            // props have changed, rerender layer\n            layer = this._getSubLayer(tile, layer);\n            layerCache.needsUpdate = false;\n          }\n        }\n        layerCache.layer = layer;\n        return layer;\n      })\n      .filter(Boolean);\n  }\n}\n\nfunction getMeshGeometry(contentAttributes) {\n  const attributes = {};\n  attributes.positions = {\n    ...contentAttributes.positions,\n    value: new Float32Array(contentAttributes.positions.value)\n  };\n  if (contentAttributes.normals) {\n    attributes.normals = contentAttributes.normals;\n  }\n  if (contentAttributes.texCoords) {\n    attributes.texCoords = contentAttributes.texCoords;\n  }\n  if (contentAttributes.colors) {\n    attributes.colors = contentAttributes.colors;\n  }\n  if (contentAttributes.uvRegions) {\n    attributes.uvRegions = contentAttributes.uvRegions;\n  }\n  return attributes;\n}\n\nTile3DLayer.layerName = 'Tile3DLayer';\nTile3DLayer.defaultProps = defaultProps;\n"]},"metadata":{},"sourceType":"module"}