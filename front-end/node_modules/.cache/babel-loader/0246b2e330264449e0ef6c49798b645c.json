{"ast":null,"code":"import LayersPass from './layers-pass';\nimport { withParameters } from '@luma.gl/core';\nimport log from '../utils/log';\nconst PICKING_PARAMETERS = {\n  blendFunc: [1, 0, 32771, 0],\n  blendEquation: 32774\n};\nexport default class PickLayersPass extends LayersPass {\n  render(props) {\n    if (props.pickingFBO) {\n      return this._drawPickingBuffer(props);\n    }\n\n    return super.render(props);\n  }\n\n  _drawPickingBuffer(_ref) {\n    let {\n      layers,\n      layerFilter,\n      views,\n      viewports,\n      onViewportActive,\n      pickingFBO,\n      deviceRect: {\n        x,\n        y,\n        width,\n        height\n      },\n      pass = 'picking',\n      redrawReason,\n      pickZ\n    } = _ref;\n    const gl = this.gl;\n    this.pickZ = pickZ;\n    const encodedColors = !pickZ && {\n      byLayer: new Map(),\n      byAlpha: []\n    };\n    this._colors = encodedColors;\n    const renderStatus = withParameters(gl, {\n      scissorTest: true,\n      scissor: [x, y, width, height],\n      clearColor: [0, 0, 0, 0],\n      depthMask: true,\n      depthTest: true,\n      depthRange: [0, 1],\n      colorMask: [true, true, true, true],\n      ...PICKING_PARAMETERS,\n      blend: !pickZ\n    }, () => super.render({\n      target: pickingFBO,\n      layers,\n      layerFilter,\n      views,\n      viewports,\n      onViewportActive,\n      pass,\n      redrawReason\n    }));\n    this._colors = null;\n    const decodePickingColor = encodedColors && decodeColor.bind(null, encodedColors);\n    return {\n      decodePickingColor,\n      stats: renderStatus\n    };\n  }\n\n  shouldDrawLayer(layer) {\n    return layer.props.pickable;\n  }\n\n  getModuleParameters() {\n    return {\n      pickingActive: 1,\n      pickingAttribute: this.pickZ,\n      lightSources: {}\n    };\n  }\n\n  getLayerParameters(layer, layerIndex, viewport) {\n    const pickParameters = { ...layer.props.parameters\n    };\n\n    if (this.pickZ) {\n      pickParameters.blend = false;\n    } else {\n      Object.assign(pickParameters, PICKING_PARAMETERS);\n      pickParameters.blend = true;\n      pickParameters.blendColor = encodeColor(this._colors, layer, viewport);\n    }\n\n    return pickParameters;\n  }\n\n}\n\nfunction encodeColor(encoded, layer, viewport) {\n  const {\n    byLayer,\n    byAlpha\n  } = encoded;\n  let a;\n\n  if (byLayer.has(layer)) {\n    const entry = byLayer.get(layer);\n    entry.viewports.push(viewport);\n    a = entry.a;\n  } else {\n    a = byLayer.size + 1;\n\n    if (a <= 255) {\n      const entry = {\n        a,\n        layer,\n        viewports: [viewport]\n      };\n      byLayer.set(layer, entry);\n      byAlpha[a] = entry;\n    } else {\n      log.warn('Too many pickable layers, only picking the first 255')();\n      a = 0;\n    }\n  }\n\n  return [0, 0, 0, a / 255];\n}\n\nfunction decodeColor(encoded, pickedColor) {\n  const entry = encoded.byAlpha[pickedColor[3]];\n  return entry && {\n    pickedLayer: entry.layer,\n    pickedViewports: entry.viewports,\n    pickedObjectIndex: entry.layer.decodePickingColor(pickedColor)\n  };\n}","map":{"version":3,"sources":["../../../src/passes/pick-layers-pass.js"],"names":["PICKING_PARAMETERS","blendFunc","blendEquation","render","props","_drawPickingBuffer","deviceRect","height","pass","pickZ","gl","encodedColors","byLayer","byAlpha","renderStatus","withParameters","scissorTest","scissor","clearColor","depthMask","depthTest","depthRange","colorMask","blend","target","redrawReason","decodePickingColor","decodeColor","stats","shouldDrawLayer","layer","getModuleParameters","pickingActive","pickingAttribute","lightSources","getLayerParameters","pickParameters","parameters","Object","encodeColor","entry","a","viewports","log","encoded","pickedColor","pickedLayer","pickedViewports","pickedObjectIndex"],"mappings":"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","sourcesContent":["import LayersPass from './layers-pass';\nimport {withParameters} from '@luma.gl/core';\nimport GL from '@luma.gl/constants';\nimport log from '../utils/log';\n\nconst PICKING_PARAMETERS = {\n  blendFunc: [GL.ONE, GL.ZERO, GL.CONSTANT_ALPHA, GL.ZERO],\n  blendEquation: GL.FUNC_ADD\n};\n\nexport default class PickLayersPass extends LayersPass {\n  render(props) {\n    if (props.pickingFBO) {\n      // When drawing into an off-screen buffer, use the alpha channel to encode layer index\n      return this._drawPickingBuffer(props);\n    }\n    // When drawing to screen (debug mode), do not use the alpha channel so that result is always visible\n    return super.render(props);\n  }\n\n  // Private\n  // Draws list of layers and viewports into the picking buffer\n  // Note: does not sample the buffer, that has to be done by the caller\n  _drawPickingBuffer({\n    layers,\n    layerFilter,\n    views,\n    viewports,\n    onViewportActive,\n    pickingFBO,\n    deviceRect: {x, y, width, height},\n    pass = 'picking',\n    redrawReason,\n    pickZ\n  }) {\n    const gl = this.gl;\n    this.pickZ = pickZ;\n\n    // Track encoded layer indices\n    const encodedColors = !pickZ && {\n      byLayer: new Map(),\n      byAlpha: []\n    };\n    // Temporarily store it on the instance so that it can be accessed by this.getLayerParameters\n    this._colors = encodedColors;\n\n    // Make sure we clear scissor test and fbo bindings in case of exceptions\n    // We are only interested in one pixel, no need to render anything else\n    // Note that the callback here is called synchronously.\n    // Set blend mode for picking\n    // always overwrite existing pixel with [r,g,b,layerIndex]\n    const renderStatus = withParameters(\n      gl,\n      {\n        scissorTest: true,\n        scissor: [x, y, width, height],\n        clearColor: [0, 0, 0, 0],\n        // When used as Mapbox custom layer, the context state may be dirty\n        // TODO - Remove when mapbox fixes this issue\n        // https://github.com/mapbox/mapbox-gl-js/issues/7801\n        depthMask: true,\n        depthTest: true,\n        depthRange: [0, 1],\n        colorMask: [true, true, true, true],\n        // Blending\n        ...PICKING_PARAMETERS,\n        blend: !pickZ\n      },\n      () =>\n        super.render({\n          target: pickingFBO,\n          layers,\n          layerFilter,\n          views,\n          viewports,\n          onViewportActive,\n          pass,\n          redrawReason\n        })\n    );\n\n    // Clear the temp field\n    this._colors = null;\n    const decodePickingColor = encodedColors && decodeColor.bind(null, encodedColors);\n    return {decodePickingColor, stats: renderStatus};\n  }\n\n  // PRIVATE\n  shouldDrawLayer(layer) {\n    return layer.props.pickable;\n  }\n\n  getModuleParameters() {\n    return {\n      pickingActive: 1,\n      pickingAttribute: this.pickZ,\n      // turn off lighting by adding empty light source object\n      // lights shader module relies on the `lightSources` to turn on/off lighting\n      lightSources: {}\n    };\n  }\n\n  getLayerParameters(layer, layerIndex, viewport) {\n    const pickParameters = {...layer.props.parameters};\n\n    if (this.pickZ) {\n      pickParameters.blend = false;\n    } else {\n      Object.assign(pickParameters, PICKING_PARAMETERS);\n      pickParameters.blend = true;\n      pickParameters.blendColor = encodeColor(this._colors, layer, viewport);\n    }\n\n    return pickParameters;\n  }\n}\n\n// Assign an unique alpha value for each pickable layer and track the encoding in the cache object\n// Returns normalized blend color\nfunction encodeColor(encoded, layer, viewport) {\n  const {byLayer, byAlpha} = encoded;\n  let a;\n\n  // Encode layerIndex in the alpha channel\n  // TODO - combine small layers to better utilize the picking color space\n  if (byLayer.has(layer)) {\n    const entry = byLayer.get(layer);\n    entry.viewports.push(viewport);\n    a = entry.a;\n  } else {\n    a = byLayer.size + 1;\n    if (a <= 255) {\n      const entry = {a, layer, viewports: [viewport]};\n      byLayer.set(layer, entry);\n      byAlpha[a] = entry;\n    } else {\n      log.warn('Too many pickable layers, only picking the first 255')();\n      a = 0;\n    }\n  }\n  return [0, 0, 0, a / 255];\n}\n\n// Given a picked color, retrieve the corresponding layer and viewports from cache\nfunction decodeColor(encoded, pickedColor) {\n  const entry = encoded.byAlpha[pickedColor[3]];\n  return (\n    entry && {\n      pickedLayer: entry.layer,\n      pickedViewports: entry.viewports,\n      pickedObjectIndex: entry.layer.decodePickingColor(pickedColor)\n    }\n  );\n}\n"]},"metadata":{},"sourceType":"module"}