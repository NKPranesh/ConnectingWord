{"ast":null,"code":"import { assert, log } from '@luma.gl/webgl';\nimport { Matrix4, Quaternion } from '@math.gl/core';\nexport const ATTRIBUTE_TYPE_TO_COMPONENTS = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n};\nexport const ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY = {\n  5120: Int8Array,\n  5121: Uint8Array,\n  5122: Int16Array,\n  5123: Uint16Array,\n  5125: Uint32Array,\n  5126: Float32Array\n};\n\nfunction accessorToJsArray(accessor) {\n  if (!accessor._animation) {\n    const ArrayType = ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY[accessor.componentType];\n    const components = ATTRIBUTE_TYPE_TO_COMPONENTS[accessor.type];\n    const length = components * accessor.count;\n    const {\n      buffer,\n      byteOffset\n    } = accessor.bufferView.data;\n    const array = new ArrayType(buffer, byteOffset + (accessor.byteOffset || 0), length);\n\n    if (components === 1) {\n      accessor._animation = Array.from(array);\n    } else {\n      const slicedArray = [];\n\n      for (let i = 0; i < array.length; i += components) {\n        slicedArray.push(Array.from(array.slice(i, i + components)));\n      }\n\n      accessor._animation = slicedArray;\n    }\n  }\n\n  return accessor._animation;\n}\n\nconst helperMatrix = new Matrix4();\n\nfunction applyTranslationRotationScale(gltfNode, node) {\n  node.matrix.identity();\n\n  if (gltfNode.translation) {\n    node.matrix.translate(gltfNode.translation);\n  }\n\n  if (gltfNode.rotation) {\n    const rotationMatrix = helperMatrix.fromQuaternion(gltfNode.rotation);\n    node.matrix.multiplyRight(rotationMatrix);\n  }\n\n  if (gltfNode.scale) {\n    node.matrix.scale(gltfNode.scale);\n  }\n}\n\nconst quaternion = new Quaternion();\n\nfunction linearInterpolate(target, path, start, stop, ratio) {\n  if (path === 'rotation') {\n    quaternion.slerp({\n      start,\n      target: stop,\n      ratio\n    });\n\n    for (let i = 0; i < quaternion.length; i++) {\n      target[path][i] = quaternion[i];\n    }\n  } else {\n    for (let i = 0; i < start.length; i++) {\n      target[path][i] = ratio * stop[i] + (1 - ratio) * start[i];\n    }\n  }\n}\n\nfunction cubicsplineInterpolate(target, path, _ref) {\n  let {\n    p0,\n    outTangent0,\n    inTangent1,\n    p1,\n    tDiff,\n    ratio: t\n  } = _ref;\n\n  for (let i = 0; i < target[path].length; i++) {\n    const m0 = outTangent0[i] * tDiff;\n    const m1 = inTangent1[i] * tDiff;\n    target[path][i] = (2 * Math.pow(t, 3) - 3 * Math.pow(t, 2) + 1) * p0[i] + (Math.pow(t, 3) - 2 * Math.pow(t, 2) + t) * m0 + (-2 * Math.pow(t, 3) + 3 * Math.pow(t, 2)) * p1[i] + (Math.pow(t, 3) - Math.pow(t, 2)) * m1;\n  }\n}\n\nfunction stepInterpolate(target, path, value) {\n  for (let i = 0; i < value.length; i++) {\n    target[path][i] = value[i];\n  }\n}\n\nfunction interpolate(time, _ref2, target, path) {\n  let {\n    input,\n    interpolation,\n    output\n  } = _ref2;\n  const maxTime = input[input.length - 1];\n  const animationTime = time % maxTime;\n  const nextIndex = input.findIndex(t => t >= animationTime);\n  const previousIndex = Math.max(0, nextIndex - 1);\n\n  if (!Array.isArray(target[path])) {\n    switch (path) {\n      case 'translation':\n        target[path] = [0, 0, 0];\n        break;\n\n      case 'rotation':\n        target[path] = [0, 0, 0, 1];\n        break;\n\n      case 'scale':\n        target[path] = [1, 1, 1];\n        break;\n\n      default:\n        log.warn(`Bad animation path ${path}`)();\n    }\n  }\n\n  assert(target[path].length === output[previousIndex].length);\n  const previousTime = input[previousIndex];\n  const nextTime = input[nextIndex];\n\n  switch (interpolation) {\n    case 'STEP':\n      stepInterpolate(target, path, output[previousIndex]);\n      break;\n\n    case 'LINEAR':\n      if (nextTime > previousTime) {\n        const ratio = (animationTime - previousTime) / (nextTime - previousTime);\n        linearInterpolate(target, path, output[previousIndex], output[nextIndex], ratio);\n      }\n\n      break;\n\n    case 'CUBICSPLINE':\n      if (nextTime > previousTime) {\n        const ratio = (animationTime - previousTime) / (nextTime - previousTime);\n        const tDiff = nextTime - previousTime;\n        const p0 = output[3 * previousIndex + 1];\n        const outTangent0 = output[3 * previousIndex + 2];\n        const inTangent1 = output[3 * nextIndex + 0];\n        const p1 = output[3 * nextIndex + 1];\n        cubicsplineInterpolate(target, path, {\n          p0,\n          outTangent0,\n          inTangent1,\n          p1,\n          tDiff,\n          ratio\n        });\n      }\n\n      break;\n\n    default:\n      log.warn(`Interpolation ${interpolation} not supported`)();\n      break;\n  }\n}\n\nclass GLTFAnimation {\n  constructor(props) {\n    this.startTime = 0;\n    this.playing = true;\n    this.speed = 1;\n    this.channels = [];\n    Object.assign(this, props);\n  }\n\n  animate(timeMs) {\n    if (!this.playing) {\n      return;\n    }\n\n    const absTime = timeMs / 1000;\n    const time = (absTime - this.startTime) * this.speed;\n    this.channels.forEach(_ref3 => {\n      let {\n        sampler,\n        target,\n        path\n      } = _ref3;\n      interpolate(time, sampler, target, path);\n      applyTranslationRotationScale(target, target._node);\n    });\n  }\n\n}\n\nexport default class GLTFAnimator {\n  constructor(gltf) {\n    this.animations = gltf.animations.map((animation, index) => {\n      const name = animation.name || `Animation-${index}`;\n      const samplers = animation.samplers.map(_ref4 => {\n        let {\n          input,\n          interpolation = 'LINEAR',\n          output\n        } = _ref4;\n        return {\n          input: accessorToJsArray(gltf.accessors[input]),\n          interpolation,\n          output: accessorToJsArray(gltf.accessors[output])\n        };\n      });\n      const channels = animation.channels.map(_ref5 => {\n        let {\n          sampler,\n          target\n        } = _ref5;\n        return {\n          sampler: samplers[sampler],\n          target: gltf.nodes[target.node],\n          path: target.path\n        };\n      });\n      return new GLTFAnimation({\n        name,\n        channels\n      });\n    });\n  }\n\n  animate(time) {\n    this.setTime(time);\n  }\n\n  setTime(time) {\n    this.animations.forEach(animation => animation.animate(time));\n  }\n\n  getAnimations() {\n    return this.animations;\n  }\n\n}","map":{"version":3,"sources":["../../../src/gltf/gltf-animator.js"],"names":["ATTRIBUTE_TYPE_TO_COMPONENTS","SCALAR","VEC2","VEC3","VEC4","MAT2","MAT3","MAT4","ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY","Float32Array","accessor","ArrayType","components","length","byteOffset","array","Array","slicedArray","i","helperMatrix","node","gltfNode","rotationMatrix","quaternion","path","target","ratio","start","stop","t","m0","outTangent0","m1","inTangent1","Math","p0","p1","value","output","maxTime","input","animationTime","time","nextIndex","previousIndex","log","assert","previousTime","nextTime","stepInterpolate","linearInterpolate","tDiff","cubicsplineInterpolate","interpolation","constructor","Object","animate","absTime","timeMs","interpolate","applyTranslationRotationScale","name","animation","index","samplers","accessorToJsArray","gltf","channels","sampler","setTime","getAnimations"],"mappings":"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","sourcesContent":["import {assert, log} from '@luma.gl/webgl';\nimport {Matrix4, Quaternion} from '@math.gl/core';\n\n// TODO: import from loaders.gl?\nexport const ATTRIBUTE_TYPE_TO_COMPONENTS = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n};\n\nexport const ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY = {\n  5120: Int8Array,\n  5121: Uint8Array,\n  5122: Int16Array,\n  5123: Uint16Array,\n  5125: Uint32Array,\n  5126: Float32Array\n};\n//\n\nfunction accessorToJsArray(accessor) {\n  if (!accessor._animation) {\n    const ArrayType = ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY[accessor.componentType];\n    const components = ATTRIBUTE_TYPE_TO_COMPONENTS[accessor.type];\n    const length = components * accessor.count;\n    const {buffer, byteOffset} = accessor.bufferView.data;\n\n    const array = new ArrayType(buffer, byteOffset + (accessor.byteOffset || 0), length);\n\n    if (components === 1) {\n      accessor._animation = Array.from(array);\n    } else {\n      // Slice array\n      const slicedArray = [];\n      for (let i = 0; i < array.length; i += components) {\n        slicedArray.push(Array.from(array.slice(i, i + components)));\n      }\n      accessor._animation = slicedArray;\n    }\n  }\n\n  return accessor._animation;\n}\n\n// TODO: share with GLTFInstantiator\nconst helperMatrix = new Matrix4();\nfunction applyTranslationRotationScale(gltfNode, node) {\n  node.matrix.identity();\n\n  if (gltfNode.translation) {\n    node.matrix.translate(gltfNode.translation);\n  }\n\n  if (gltfNode.rotation) {\n    const rotationMatrix = helperMatrix.fromQuaternion(gltfNode.rotation);\n    node.matrix.multiplyRight(rotationMatrix);\n  }\n\n  if (gltfNode.scale) {\n    node.matrix.scale(gltfNode.scale);\n  }\n}\n\nconst quaternion = new Quaternion();\nfunction linearInterpolate(target, path, start, stop, ratio) {\n  if (path === 'rotation') {\n    // SLERP when path is rotation\n    quaternion.slerp({start, target: stop, ratio});\n    for (let i = 0; i < quaternion.length; i++) {\n      target[path][i] = quaternion[i];\n    }\n  } else {\n    // regular interpolation\n    for (let i = 0; i < start.length; i++) {\n      target[path][i] = ratio * stop[i] + (1 - ratio) * start[i];\n    }\n  }\n}\n\nfunction cubicsplineInterpolate(target, path, {p0, outTangent0, inTangent1, p1, tDiff, ratio: t}) {\n  // TODO: Quaternion might need normalization\n  for (let i = 0; i < target[path].length; i++) {\n    const m0 = outTangent0[i] * tDiff;\n    const m1 = inTangent1[i] * tDiff;\n    target[path][i] =\n      (2 * Math.pow(t, 3) - 3 * Math.pow(t, 2) + 1) * p0[i] +\n      (Math.pow(t, 3) - 2 * Math.pow(t, 2) + t) * m0 +\n      (-2 * Math.pow(t, 3) + 3 * Math.pow(t, 2)) * p1[i] +\n      (Math.pow(t, 3) - Math.pow(t, 2)) * m1;\n  }\n}\n\nfunction stepInterpolate(target, path, value) {\n  for (let i = 0; i < value.length; i++) {\n    target[path][i] = value[i];\n  }\n}\n\nfunction interpolate(time, {input, interpolation, output}, target, path) {\n  const maxTime = input[input.length - 1];\n  const animationTime = time % maxTime;\n\n  const nextIndex = input.findIndex(t => t >= animationTime);\n  const previousIndex = Math.max(0, nextIndex - 1);\n\n  if (!Array.isArray(target[path])) {\n    switch (path) {\n      case 'translation':\n        target[path] = [0, 0, 0];\n        break;\n\n      case 'rotation':\n        target[path] = [0, 0, 0, 1];\n        break;\n\n      case 'scale':\n        target[path] = [1, 1, 1];\n        break;\n\n      default:\n        log.warn(`Bad animation path ${path}`)();\n    }\n  }\n\n  assert(target[path].length === output[previousIndex].length);\n  const previousTime = input[previousIndex];\n  const nextTime = input[nextIndex];\n\n  switch (interpolation) {\n    case 'STEP':\n      stepInterpolate(target, path, output[previousIndex]);\n      break;\n\n    case 'LINEAR':\n      if (nextTime > previousTime) {\n        const ratio = (animationTime - previousTime) / (nextTime - previousTime);\n        linearInterpolate(target, path, output[previousIndex], output[nextIndex], ratio);\n      }\n      break;\n\n    case 'CUBICSPLINE':\n      if (nextTime > previousTime) {\n        const ratio = (animationTime - previousTime) / (nextTime - previousTime);\n        const tDiff = nextTime - previousTime;\n\n        const p0 = output[3 * previousIndex + 1];\n        const outTangent0 = output[3 * previousIndex + 2];\n        const inTangent1 = output[3 * nextIndex + 0];\n        const p1 = output[3 * nextIndex + 1];\n\n        cubicsplineInterpolate(target, path, {p0, outTangent0, inTangent1, p1, tDiff, ratio});\n      }\n      break;\n\n    default:\n      log.warn(`Interpolation ${interpolation} not supported`)();\n      break;\n  }\n}\n\nclass GLTFAnimation {\n  constructor(props) {\n    this.startTime = 0;\n    this.playing = true;\n    this.speed = 1;\n    this.channels = [];\n\n    Object.assign(this, props);\n  }\n\n  animate(timeMs) {\n    if (!this.playing) {\n      return;\n    }\n\n    const absTime = timeMs / 1000;\n    const time = (absTime - this.startTime) * this.speed;\n\n    this.channels.forEach(({sampler, target, path}) => {\n      interpolate(time, sampler, target, path);\n      applyTranslationRotationScale(target, target._node);\n    });\n  }\n}\n\nexport default class GLTFAnimator {\n  constructor(gltf) {\n    this.animations = gltf.animations.map((animation, index) => {\n      const name = animation.name || `Animation-${index}`;\n      const samplers = animation.samplers.map(({input, interpolation = 'LINEAR', output}) => ({\n        input: accessorToJsArray(gltf.accessors[input]),\n        interpolation,\n        output: accessorToJsArray(gltf.accessors[output])\n      }));\n      const channels = animation.channels.map(({sampler, target}) => ({\n        sampler: samplers[sampler],\n        target: gltf.nodes[target.node],\n        path: target.path\n      }));\n      return new GLTFAnimation({name, channels});\n    });\n  }\n\n  // TODO(Tarek): This should be removed? (deck.gl is using this)\n  animate(time) {\n    this.setTime(time);\n  }\n\n  setTime(time) {\n    this.animations.forEach(animation => animation.animate(time));\n  }\n\n  getAnimations() {\n    return this.animations;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}