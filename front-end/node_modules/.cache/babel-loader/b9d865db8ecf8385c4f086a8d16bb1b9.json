{"ast":null,"code":"const defined = x => x !== undefined;\n\nexport function initializeHierarchy(batchTable, jsonHeader, binaryBody) {\n  if (!jsonHeader) {\n    return null;\n  }\n\n  let hierarchy = batchTable.getExtension('3DTILES_batch_table_hierarchy');\n  const legacyHierarchy = jsonHeader.HIERARCHY;\n\n  if (legacyHierarchy) {\n    console.warn('3D Tile Parser: HIERARCHY is deprecated. Use 3DTILES_batch_table_hierarchy.');\n    jsonHeader.extensions = jsonHeader.extensions || {};\n    jsonHeader.extensions['3DTILES_batch_table_hierarchy'] = legacyHierarchy;\n    hierarchy = legacyHierarchy;\n  }\n\n  if (!hierarchy) {\n    return null;\n  }\n\n  return initializeHierarchyValues(hierarchy, binaryBody);\n}\n\nfunction initializeHierarchyValues(hierarchyJson, binaryBody) {\n  let i;\n  let classId;\n  let binaryAccessor;\n  const instancesLength = hierarchyJson.instancesLength;\n  const classes = hierarchyJson.classes;\n  let classIds = hierarchyJson.classIds;\n  let parentCounts = hierarchyJson.parentCounts;\n  let parentIds = hierarchyJson.parentIds;\n  let parentIdsLength = instancesLength;\n\n  if (defined(classIds.byteOffset)) {\n    classIds.componentType = defaultValue(classIds.componentType, GL.UNSIGNED_SHORT);\n    classIds.type = AttributeType.SCALAR;\n    binaryAccessor = getBinaryAccessor(classIds);\n    classIds = binaryAccessor.createArrayBufferView(binaryBody.buffer, binaryBody.byteOffset + classIds.byteOffset, instancesLength);\n  }\n\n  let parentIndexes;\n\n  if (defined(parentCounts)) {\n    if (defined(parentCounts.byteOffset)) {\n      parentCounts.componentType = defaultValue(parentCounts.componentType, GL.UNSIGNED_SHORT);\n      parentCounts.type = AttributeType.SCALAR;\n      binaryAccessor = getBinaryAccessor(parentCounts);\n      parentCounts = binaryAccessor.createArrayBufferView(binaryBody.buffer, binaryBody.byteOffset + parentCounts.byteOffset, instancesLength);\n    }\n\n    parentIndexes = new Uint16Array(instancesLength);\n    parentIdsLength = 0;\n\n    for (i = 0; i < instancesLength; ++i) {\n      parentIndexes[i] = parentIdsLength;\n      parentIdsLength += parentCounts[i];\n    }\n  }\n\n  if (defined(parentIds) && defined(parentIds.byteOffset)) {\n    parentIds.componentType = defaultValue(parentIds.componentType, GL.UNSIGNED_SHORT);\n    parentIds.type = AttributeType.SCALAR;\n    binaryAccessor = getBinaryAccessor(parentIds);\n    parentIds = binaryAccessor.createArrayBufferView(binaryBody.buffer, binaryBody.byteOffset + parentIds.byteOffset, parentIdsLength);\n  }\n\n  const classesLength = classes.length;\n\n  for (i = 0; i < classesLength; ++i) {\n    const classInstancesLength = classes[i].length;\n    const properties = classes[i].instances;\n    const binaryProperties = getBinaryProperties(classInstancesLength, properties, binaryBody);\n    classes[i].instances = combine(binaryProperties, properties);\n  }\n\n  const classCounts = new Array(classesLength).fill(0);\n  const classIndexes = new Uint16Array(instancesLength);\n\n  for (i = 0; i < instancesLength; ++i) {\n    classId = classIds[i];\n    classIndexes[i] = classCounts[classId];\n    ++classCounts[classId];\n  }\n\n  const hierarchy = {\n    classes,\n    classIds,\n    classIndexes,\n    parentCounts,\n    parentIndexes,\n    parentIds\n  };\n  validateHierarchy(hierarchy);\n  return hierarchy;\n}\n\nexport function traverseHierarchy(hierarchy, instanceIndex, endConditionCallback) {\n  if (!hierarchy) {\n    return;\n  }\n\n  const parentCounts = hierarchy.parentCounts;\n  const parentIds = hierarchy.parentIds;\n\n  if (parentIds) {\n    return endConditionCallback(hierarchy, instanceIndex);\n  }\n\n  if (parentCounts > 0) {\n    return traverseHierarchyMultipleParents(hierarchy, instanceIndex, endConditionCallback);\n  }\n\n  return traverseHierarchySingleParent(hierarchy, instanceIndex, endConditionCallback);\n}\n\nfunction traverseHierarchyMultipleParents(hierarchy, instanceIndex, endConditionCallback) {\n  const classIds = hierarchy.classIds;\n  const parentCounts = hierarchy.parentCounts;\n  const parentIds = hierarchy.parentIds;\n  const parentIndexes = hierarchy.parentIndexes;\n  const instancesLength = classIds.length;\n  const visited = scratchVisited;\n  visited.length = Math.max(visited.length, instancesLength);\n  const visitedMarker = ++marker;\n  const stack = scratchStack;\n  stack.length = 0;\n  stack.push(instanceIndex);\n\n  while (stack.length > 0) {\n    instanceIndex = stack.pop();\n\n    if (visited[instanceIndex] === visitedMarker) {\n      continue;\n    }\n\n    visited[instanceIndex] = visitedMarker;\n    const result = endConditionCallback(hierarchy, instanceIndex);\n\n    if (defined(result)) {\n      return result;\n    }\n\n    const parentCount = parentCounts[instanceIndex];\n    const parentIndex = parentIndexes[instanceIndex];\n\n    for (let i = 0; i < parentCount; ++i) {\n      const parentId = parentIds[parentIndex + i];\n\n      if (parentId !== instanceIndex) {\n        stack.push(parentId);\n      }\n    }\n  }\n\n  return null;\n}\n\nfunction traverseHierarchySingleParent(hierarchy, instanceIndex, endConditionCallback) {\n  let hasParent = true;\n\n  while (hasParent) {\n    const result = endConditionCallback(hierarchy, instanceIndex);\n\n    if (defined(result)) {\n      return result;\n    }\n\n    const parentId = hierarchy.parentIds[instanceIndex];\n    hasParent = parentId !== instanceIndex;\n    instanceIndex = parentId;\n  }\n\n  throw new Error('traverseHierarchySingleParent');\n}\n\nfunction validateHierarchy(hierarchy) {\n  const scratchValidateStack = [];\n  const classIds = hierarchy.classIds;\n  const instancesLength = classIds.length;\n\n  for (let i = 0; i < instancesLength; ++i) {\n    validateInstance(hierarchy, i, stack);\n  }\n}\n\nfunction validateInstance(hierarchy, instanceIndex, stack) {\n  const parentCounts = hierarchy.parentCounts;\n  const parentIds = hierarchy.parentIds;\n  const parentIndexes = hierarchy.parentIndexes;\n  const classIds = hierarchy.classIds;\n  const instancesLength = classIds.length;\n\n  if (!defined(parentIds)) {\n    return;\n  }\n\n  assert(instanceIndex < instancesLength, \"Parent index \".concat(instanceIndex, \" exceeds the total number of instances: \").concat(instancesLength));\n  assert(stack.indexOf(instanceIndex) === -1, 'Circular dependency detected in the batch table hierarchy.');\n  stack.push(instanceIndex);\n  const parentCount = defined(parentCounts) ? parentCounts[instanceIndex] : 1;\n  const parentIndex = defined(parentCounts) ? parentIndexes[instanceIndex] : instanceIndex;\n\n  for (let i = 0; i < parentCount; ++i) {\n    const parentId = parentIds[parentIndex + i];\n\n    if (parentId !== instanceIndex) {\n      validateInstance(hierarchy, parentId, stack);\n    }\n  }\n\n  stack.pop(instanceIndex);\n}","map":{"version":3,"sources":["../../../../src/lib/classes/tile-3d-batch-table-hierarchy.js"],"names":["defined","x","hierarchy","batchTable","legacyHierarchy","jsonHeader","console","initializeHierarchyValues","instancesLength","hierarchyJson","classes","classIds","parentCounts","parentIds","parentIdsLength","defaultValue","GL","AttributeType","binaryAccessor","getBinaryAccessor","binaryBody","parentIndexes","i","classesLength","classInstancesLength","properties","binaryProperties","getBinaryProperties","combine","classCounts","classIndexes","classId","validateHierarchy","endConditionCallback","traverseHierarchyMultipleParents","traverseHierarchySingleParent","visited","Math","visitedMarker","stack","instanceIndex","result","parentCount","parentIndex","parentId","hasParent","scratchValidateStack","validateInstance","assert"],"mappings":"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","sourcesContent":["// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\n// TODO - Finish hierarchy suypport: this file is only half ported\n/* eslint-disable */\n// @ts-nocheck\nconst defined = (x) => x !== undefined;\n\nexport function initializeHierarchy(batchTable, jsonHeader, binaryBody) {\n  if (!jsonHeader) {\n    return null;\n  }\n\n  let hierarchy = batchTable.getExtension('3DTILES_batch_table_hierarchy');\n\n  const legacyHierarchy = jsonHeader.HIERARCHY;\n  if (legacyHierarchy) {\n    // eslint-disable-next-line\n    console.warn('3D Tile Parser: HIERARCHY is deprecated. Use 3DTILES_batch_table_hierarchy.');\n    jsonHeader.extensions = jsonHeader.extensions || {};\n    jsonHeader.extensions['3DTILES_batch_table_hierarchy'] = legacyHierarchy;\n    hierarchy = legacyHierarchy;\n  }\n\n  if (!hierarchy) {\n    return null;\n  }\n\n  return initializeHierarchyValues(hierarchy, binaryBody);\n}\n\n// eslint-disable-next-line max-statements\nfunction initializeHierarchyValues(hierarchyJson, binaryBody) {\n  let i;\n  let classId;\n  let binaryAccessor;\n\n  const instancesLength = hierarchyJson.instancesLength;\n  const classes = hierarchyJson.classes;\n  let classIds = hierarchyJson.classIds;\n  let parentCounts = hierarchyJson.parentCounts;\n  let parentIds = hierarchyJson.parentIds;\n  let parentIdsLength = instancesLength;\n\n  if (defined(classIds.byteOffset)) {\n    classIds.componentType = defaultValue(classIds.componentType, GL.UNSIGNED_SHORT);\n    classIds.type = AttributeType.SCALAR;\n    binaryAccessor = getBinaryAccessor(classIds);\n    classIds = binaryAccessor.createArrayBufferView(\n      binaryBody.buffer,\n      binaryBody.byteOffset + classIds.byteOffset,\n      instancesLength\n    );\n  }\n\n  let parentIndexes;\n  if (defined(parentCounts)) {\n    if (defined(parentCounts.byteOffset)) {\n      parentCounts.componentType = defaultValue(parentCounts.componentType, GL.UNSIGNED_SHORT);\n      parentCounts.type = AttributeType.SCALAR;\n      binaryAccessor = getBinaryAccessor(parentCounts);\n      parentCounts = binaryAccessor.createArrayBufferView(\n        binaryBody.buffer,\n        binaryBody.byteOffset + parentCounts.byteOffset,\n        instancesLength\n      );\n    }\n    parentIndexes = new Uint16Array(instancesLength);\n    parentIdsLength = 0;\n    for (i = 0; i < instancesLength; ++i) {\n      parentIndexes[i] = parentIdsLength;\n      parentIdsLength += parentCounts[i];\n    }\n  }\n\n  if (defined(parentIds) && defined(parentIds.byteOffset)) {\n    parentIds.componentType = defaultValue(parentIds.componentType, GL.UNSIGNED_SHORT);\n    parentIds.type = AttributeType.SCALAR;\n    binaryAccessor = getBinaryAccessor(parentIds);\n    parentIds = binaryAccessor.createArrayBufferView(\n      binaryBody.buffer,\n      binaryBody.byteOffset + parentIds.byteOffset,\n      parentIdsLength\n    );\n  }\n\n  const classesLength = classes.length;\n  for (i = 0; i < classesLength; ++i) {\n    const classInstancesLength = classes[i].length;\n    const properties = classes[i].instances;\n    const binaryProperties = getBinaryProperties(classInstancesLength, properties, binaryBody);\n    classes[i].instances = combine(binaryProperties, properties);\n  }\n\n  const classCounts = new Array(classesLength).fill(0);\n  const classIndexes = new Uint16Array(instancesLength);\n  for (i = 0; i < instancesLength; ++i) {\n    classId = classIds[i];\n    classIndexes[i] = classCounts[classId];\n    ++classCounts[classId];\n  }\n\n  const hierarchy = {\n    classes,\n    classIds,\n    classIndexes,\n    parentCounts,\n    parentIndexes,\n    parentIds\n  };\n\n  validateHierarchy(hierarchy);\n\n  return hierarchy;\n}\n\n// HELPER CODE\n\n// Traverse over the hierarchy and process each instance with the endConditionCallback.\n// When the endConditionCallback returns a value, the traversal stops and that value is returned.\nexport function traverseHierarchy(hierarchy, instanceIndex, endConditionCallback) {\n  if (!hierarchy) {\n    return;\n  }\n\n  const parentCounts = hierarchy.parentCounts;\n  const parentIds = hierarchy.parentIds;\n  if (parentIds) {\n    return endConditionCallback(hierarchy, instanceIndex);\n  }\n  if (parentCounts > 0) {\n    return traverseHierarchyMultipleParents(hierarchy, instanceIndex, endConditionCallback);\n  }\n  return traverseHierarchySingleParent(hierarchy, instanceIndex, endConditionCallback);\n}\n\n// eslint-disable-next-line max-statements\nfunction traverseHierarchyMultipleParents(hierarchy, instanceIndex, endConditionCallback) {\n  const classIds = hierarchy.classIds;\n  const parentCounts = hierarchy.parentCounts;\n  const parentIds = hierarchy.parentIds;\n  const parentIndexes = hierarchy.parentIndexes;\n  const instancesLength = classIds.length;\n\n  // Ignore instances that have already been visited. This occurs in diamond inheritance situations.\n  // Use a marker value to indicate that an instance has been visited, which increments with each run.\n  // This is more efficient than clearing the visited array every time.\n  const visited = scratchVisited;\n  visited.length = Math.max(visited.length, instancesLength);\n  const visitedMarker = ++marker;\n\n  const stack = scratchStack;\n  stack.length = 0;\n  stack.push(instanceIndex);\n\n  while (stack.length > 0) {\n    instanceIndex = stack.pop();\n    if (visited[instanceIndex] === visitedMarker) {\n      // This instance has already been visited, stop traversal\n      continue;\n    }\n    visited[instanceIndex] = visitedMarker;\n    const result = endConditionCallback(hierarchy, instanceIndex);\n    if (defined(result)) {\n      // The end condition was met, stop the traversal and return the result\n      return result;\n    }\n    const parentCount = parentCounts[instanceIndex];\n    const parentIndex = parentIndexes[instanceIndex];\n    for (let i = 0; i < parentCount; ++i) {\n      const parentId = parentIds[parentIndex + i];\n      // Stop the traversal when the instance has no parent (its parentId equals itself)\n      // else add the parent to the stack to continue the traversal.\n      if (parentId !== instanceIndex) {\n        stack.push(parentId);\n      }\n    }\n  }\n\n  return null;\n}\n\nfunction traverseHierarchySingleParent(hierarchy, instanceIndex, endConditionCallback) {\n  let hasParent = true;\n  while (hasParent) {\n    const result = endConditionCallback(hierarchy, instanceIndex);\n    if (defined(result)) {\n      // The end condition was met, stop the traversal and return the result\n      return result;\n    }\n    const parentId = hierarchy.parentIds[instanceIndex];\n    hasParent = parentId !== instanceIndex;\n    instanceIndex = parentId;\n  }\n  throw new Error('traverseHierarchySingleParent');\n}\n\n// DEBUG CODE\n\nfunction validateHierarchy(hierarchy) {\n  const scratchValidateStack = [];\n\n  const classIds = hierarchy.classIds;\n  const instancesLength = classIds.length;\n\n  for (let i = 0; i < instancesLength; ++i) {\n    validateInstance(hierarchy, i, stack);\n  }\n}\n\nfunction validateInstance(hierarchy, instanceIndex, stack) {\n  const parentCounts = hierarchy.parentCounts;\n  const parentIds = hierarchy.parentIds;\n  const parentIndexes = hierarchy.parentIndexes;\n  const classIds = hierarchy.classIds;\n  const instancesLength = classIds.length;\n\n  if (!defined(parentIds)) {\n    // No need to validate if there are no parents\n    return;\n  }\n\n  assert(\n    instanceIndex < instancesLength,\n    `Parent index ${instanceIndex} exceeds the total number of instances: ${instancesLength}`\n  );\n  assert(\n    stack.indexOf(instanceIndex) === -1,\n    'Circular dependency detected in the batch table hierarchy.'\n  );\n\n  stack.push(instanceIndex);\n  const parentCount = defined(parentCounts) ? parentCounts[instanceIndex] : 1;\n  const parentIndex = defined(parentCounts) ? parentIndexes[instanceIndex] : instanceIndex;\n  for (let i = 0; i < parentCount; ++i) {\n    const parentId = parentIds[parentIndex + i];\n    // Stop the traversal when the instance has no parent (its parentId equals itself), else continue the traversal.\n    if (parentId !== instanceIndex) {\n      validateInstance(hierarchy, parentId, stack);\n    }\n  }\n  stack.pop(instanceIndex);\n}\n"]},"metadata":{},"sourceType":"module"}