{"ast":null,"code":"import GLTFScenegraph from '../api/gltf-scenegraph';\nimport { KHR_TECHNIQUES_WEBGL } from '../gltf-utils/gltf-constants';\nexport async function decode(gltfData) {\n  const gltfScenegraph = new GLTFScenegraph(gltfData);\n  const {\n    json\n  } = gltfScenegraph;\n  const extension = gltfScenegraph.getExtension(KHR_TECHNIQUES_WEBGL);\n\n  if (extension) {\n    const techniques = resolveTechniques(extension, gltfScenegraph);\n\n    for (const material of json.materials || []) {\n      const materialExtension = gltfScenegraph.getObjectExtension(material, KHR_TECHNIQUES_WEBGL);\n\n      if (materialExtension) {\n        material.technique = Object.assign({}, materialExtension, techniques[materialExtension.technique]);\n        material.technique.values = resolveValues(material.technique, gltfScenegraph);\n      }\n\n      gltfScenegraph.removeObjectExtension(material, KHR_TECHNIQUES_WEBGL);\n    }\n\n    gltfScenegraph.removeExtension(KHR_TECHNIQUES_WEBGL);\n  }\n}\nexport async function encode(gltfData, options) {}\n\nfunction resolveTechniques(techniquesExtension, gltfScenegraph) {\n  const {\n    programs = [],\n    shaders = [],\n    techniques = []\n  } = techniquesExtension;\n  const textDecoder = new TextDecoder();\n  shaders.forEach(shader => {\n    if (Number.isFinite(shader.bufferView)) {\n      shader.code = textDecoder.decode(gltfScenegraph.getTypedArrayForBufferView(shader.bufferView));\n    } else {\n      throw new Error('KHR_techniques_webgl: no shader code');\n    }\n  });\n  programs.forEach(program => {\n    program.fragmentShader = shaders[program.fragmentShader];\n    program.vertexShader = shaders[program.vertexShader];\n  });\n  techniques.forEach(technique => {\n    technique.program = programs[technique.program];\n  });\n  return techniques;\n}\n\nfunction resolveValues(technique, gltfScenegraph) {\n  const values = Object.assign({}, technique.values);\n  Object.keys(technique.uniforms || {}).forEach(uniform => {\n    if (technique.uniforms[uniform].value && !(uniform in values)) {\n      values[uniform] = technique.uniforms[uniform].value;\n    }\n  });\n  Object.keys(values).forEach(uniform => {\n    if (typeof values[uniform] === 'object' && values[uniform].index !== undefined) {\n      values[uniform].texture = gltfScenegraph.getTexture(values[uniform].index);\n    }\n  });\n  return values;\n}","map":{"version":3,"sources":["../../../../src/lib/extensions/KHR_techniques_webgl.ts"],"names":["gltfScenegraph","json","extension","techniques","resolveTechniques","materialExtension","material","Object","resolveValues","programs","shaders","textDecoder","shader","Number","program","technique","values","uniform"],"mappings":"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","sourcesContent":["// GLTF EXTENSION: KHR_techniques_webgl\n// https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_techniques_webgl\n\nimport type {GLTF} from '../types/gltf-types';\n\nimport GLTFScenegraph from '../api/gltf-scenegraph';\nimport {KHR_TECHNIQUES_WEBGL} from '../gltf-utils/gltf-constants';\n\nexport async function decode(gltfData: {json: GLTF}): Promise<void> {\n  const gltfScenegraph = new GLTFScenegraph(gltfData);\n  const {json} = gltfScenegraph;\n\n  const extension = gltfScenegraph.getExtension(KHR_TECHNIQUES_WEBGL);\n  if (extension) {\n    const techniques = resolveTechniques(extension, gltfScenegraph);\n\n    for (const material of json.materials || []) {\n      const materialExtension = gltfScenegraph.getObjectExtension(material, KHR_TECHNIQUES_WEBGL);\n      if (materialExtension) {\n        // @ts-ignore TODO\n        material.technique = Object.assign(\n          {},\n          materialExtension,\n          // @ts-ignore\n          techniques[materialExtension.technique]\n        );\n        // @ts-ignore TODO\n        material.technique.values = resolveValues(material.technique, gltfScenegraph);\n      }\n      gltfScenegraph.removeObjectExtension(material, KHR_TECHNIQUES_WEBGL);\n    }\n\n    gltfScenegraph.removeExtension(KHR_TECHNIQUES_WEBGL);\n  }\n}\n// eslint-disable-next-line\nexport async function encode(gltfData, options): Promise<void> {\n  // TODO\n}\n\nfunction resolveTechniques(\n  techniquesExtension: {[key: string]: any},\n  // programs: {[key: string]: any}[],\n  // shaders: {[key: string]: any}[],\n  // techniques: {[key: string]: any}[]\n  gltfScenegraph\n) {\n  const {programs = [], shaders = [], techniques = []} = techniquesExtension;\n  const textDecoder = new TextDecoder();\n\n  shaders.forEach((shader) => {\n    if (Number.isFinite(shader.bufferView)) {\n      shader.code = textDecoder.decode(\n        gltfScenegraph.getTypedArrayForBufferView(shader.bufferView)\n      );\n    } else {\n      // TODO: handle URI shader\n      throw new Error('KHR_techniques_webgl: no shader code');\n    }\n  });\n\n  programs.forEach((program) => {\n    program.fragmentShader = shaders[program.fragmentShader];\n    program.vertexShader = shaders[program.vertexShader];\n  });\n\n  techniques.forEach((technique) => {\n    technique.program = programs[technique.program];\n  });\n\n  return techniques;\n}\n\nfunction resolveValues(technique, gltfScenegraph) {\n  const values = Object.assign({}, technique.values);\n\n  // merge values from uniforms\n  Object.keys(technique.uniforms || {}).forEach((uniform) => {\n    if (technique.uniforms[uniform].value && !(uniform in values)) {\n      values[uniform] = technique.uniforms[uniform].value;\n    }\n  });\n\n  // resolve textures\n  Object.keys(values).forEach((uniform) => {\n    if (typeof values[uniform] === 'object' && values[uniform].index !== undefined) {\n      // Assume this is a texture\n      // TODO: find if there are any other types that can be referenced\n      values[uniform].texture = gltfScenegraph.getTexture(values[uniform].index);\n    }\n  });\n\n  return values;\n}\n"]},"metadata":{},"sourceType":"module"}