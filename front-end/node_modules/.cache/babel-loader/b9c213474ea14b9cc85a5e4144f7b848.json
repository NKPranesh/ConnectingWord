{"ast":null,"code":"import { loadLibrary } from '@loaders.gl/worker-utils';\nconst DRACO_VERSION = '1.4.1';\nconst DRACO_JS_DECODER_URL = \"https://www.gstatic.com/draco/versioned/decoders/\".concat(DRACO_VERSION, \"/draco_decoder.js\");\nconst DRACO_WASM_WRAPPER_URL = \"https://www.gstatic.com/draco/versioned/decoders/\".concat(DRACO_VERSION, \"/draco_wasm_wrapper.js\");\nconst DRACO_WASM_DECODER_URL = \"https://www.gstatic.com/draco/versioned/decoders/\".concat(DRACO_VERSION, \"/draco_decoder.wasm\");\nconst DRACO_ENCODER_URL = \"https://raw.githubusercontent.com/google/draco/\".concat(DRACO_VERSION, \"/javascript/draco_encoder.js\");\nlet loadDecoderPromise;\nlet loadEncoderPromise;\nexport async function loadDracoDecoderModule(options) {\n  const modules = options.modules || {};\n\n  if (modules.draco3d) {\n    loadDecoderPromise = loadDecoderPromise || modules.draco3d.createDecoderModule({}).then(draco => {\n      return {\n        draco\n      };\n    });\n  } else {\n    loadDecoderPromise = loadDecoderPromise || loadDracoDecoder(options);\n  }\n\n  return await loadDecoderPromise;\n}\nexport async function loadDracoEncoderModule(options) {\n  const modules = options.modules || {};\n\n  if (modules.draco3d) {\n    loadEncoderPromise = loadEncoderPromise || modules.draco3d.createEncoderModule({}).then(draco => {\n      return {\n        draco\n      };\n    });\n  } else {\n    loadEncoderPromise = loadEncoderPromise || loadDracoEncoder(options);\n  }\n\n  return await loadEncoderPromise;\n}\n\nasync function loadDracoDecoder(options) {\n  let DracoDecoderModule;\n  let wasmBinary;\n\n  switch (options.draco && options.draco.decoderType) {\n    case 'js':\n      DracoDecoderModule = await loadLibrary(DRACO_JS_DECODER_URL, 'draco', options);\n      break;\n\n    case 'wasm':\n    default:\n      [DracoDecoderModule, wasmBinary] = await Promise.all([await loadLibrary(DRACO_WASM_WRAPPER_URL, 'draco', options), await loadLibrary(DRACO_WASM_DECODER_URL, 'draco', options)]);\n  }\n\n  DracoDecoderModule = DracoDecoderModule || globalThis.DracoDecoderModule;\n  return await initializeDracoDecoder(DracoDecoderModule, wasmBinary);\n}\n\nfunction initializeDracoDecoder(DracoDecoderModule, wasmBinary) {\n  const options = {};\n\n  if (wasmBinary) {\n    options.wasmBinary = wasmBinary;\n  }\n\n  return new Promise(resolve => {\n    DracoDecoderModule({ ...options,\n      onModuleLoaded: draco => resolve({\n        draco\n      })\n    });\n  });\n}\n\nasync function loadDracoEncoder(options) {\n  let DracoEncoderModule = await loadLibrary(DRACO_ENCODER_URL, 'draco', options);\n  DracoEncoderModule = DracoEncoderModule || globalThis.DracoEncoderModule;\n  return new Promise(resolve => {\n    DracoEncoderModule({\n      onModuleLoaded: draco => resolve({\n        draco\n      })\n    });\n  });\n}","map":{"version":3,"sources":["../../../src/lib/draco-module-loader.ts"],"names":["DRACO_VERSION","DRACO_JS_DECODER_URL","DRACO_WASM_WRAPPER_URL","DRACO_WASM_DECODER_URL","DRACO_ENCODER_URL","modules","options","loadDecoderPromise","draco","loadDracoDecoder","loadEncoderPromise","loadDracoEncoder","DracoDecoderModule","loadLibrary","Promise","globalThis","initializeDracoDecoder","resolve","onModuleLoaded","DracoEncoderModule"],"mappings":"AAIA,SAAA,WAAA,QAAA,0BAAA;AAEA,MAAMA,aAAa,GAAnB,OAAA;AACA,MAAMC,oBAAoB,GAAA,oDAAA,MAAA,CAAA,aAAA,EAA1B,mBAA0B,CAA1B;AACA,MAAMC,sBAAsB,GAAA,oDAAA,MAAA,CAAA,aAAA,EAA5B,wBAA4B,CAA5B;AACA,MAAMC,sBAAsB,GAAA,oDAAA,MAAA,CAAA,aAAA,EAA5B,qBAA4B,CAA5B;AAEA,MAAMC,iBAAiB,GAAA,kDAAA,MAAA,CAAA,aAAA,EAAvB,8BAAuB,CAAvB;AAEA,IAAA,kBAAA;AACA,IAAA,kBAAA;AAEA,OAAO,eAAA,sBAAA,CAAA,OAAA,EAA+C;AACpD,QAAMC,OAAO,GAAGC,OAAO,CAAPA,OAAAA,IAAhB,EAAA;;AAGA,MAAID,OAAO,CAAX,OAAA,EAAqB;AACnBE,IAAAA,kBAAkB,GAChBA,kBAAkB,IAClB,OAAO,CAAP,OAAA,CAAA,mBAAA,CAAA,EAAA,EAAA,IAAA,CAA8CC,KAAD,IAAW;AACtD,aAAO;AAACA,QAAAA;AAAD,OAAP;AAHJD,KAEE,CAFFA;AADF,GAAA,MAMO;AAELA,IAAAA,kBAAkB,GAAGA,kBAAkB,IAAIE,gBAAgB,CAA3DF,OAA2D,CAA3DA;AACD;;AACD,SAAO,MAAP,kBAAA;AACD;AAED,OAAO,eAAA,sBAAA,CAAA,OAAA,EAA+C;AACpD,QAAMF,OAAO,GAAGC,OAAO,CAAPA,OAAAA,IAAhB,EAAA;;AAGA,MAAID,OAAO,CAAX,OAAA,EAAqB;AACnBK,IAAAA,kBAAkB,GAChBA,kBAAkB,IAClB,OAAO,CAAP,OAAA,CAAA,mBAAA,CAAA,EAAA,EAAA,IAAA,CAA8CF,KAAD,IAAW;AACtD,aAAO;AAACA,QAAAA;AAAD,OAAP;AAHJE,KAEE,CAFFA;AADF,GAAA,MAMO;AAELA,IAAAA,kBAAkB,GAAGA,kBAAkB,IAAIC,gBAAgB,CAA3DD,OAA2D,CAA3DA;AACD;;AACD,SAAO,MAAP,kBAAA;AACD;;AAID,eAAA,gBAAA,CAAA,OAAA,EAAyC;AACvC,MAAA,kBAAA;AACA,MAAA,UAAA;;AACA,UAAQJ,OAAO,CAAPA,KAAAA,IAAiBA,OAAO,CAAPA,KAAAA,CAAzB,WAAA;AACE,SAAA,IAAA;AACEM,MAAAA,kBAAkB,GAAG,MAAMC,WAAW,CAAA,oBAAA,EAAA,OAAA,EAAtCD,OAAsC,CAAtCA;AACA;;AAEF,SAAA,MAAA;AACA;AACE,OAAA,kBAAA,EAAA,UAAA,IAAmC,MAAME,OAAO,CAAPA,GAAAA,CAAY,CACnD,MAAMD,WAAW,CAAA,sBAAA,EAAA,OAAA,EADkC,OAClC,CADkC,EAEnD,MAAMA,WAAW,CAAA,sBAAA,EAAA,OAAA,EAFnB,OAEmB,CAFkC,CAAZC,CAAzC;AAPJ;;AAcAF,EAAAA,kBAAkB,GAAGA,kBAAkB,IAAIG,UAAU,CAArDH,kBAAAA;AACA,SAAO,MAAMI,sBAAsB,CAAA,kBAAA,EAAnC,UAAmC,CAAnC;AACD;;AAED,SAAA,sBAAA,CAAA,kBAAA,EAAA,UAAA,EAAgE;AAC9D,QAAMV,OAA2B,GAAjC,EAAA;;AACA,MAAA,UAAA,EAAgB;AACdA,IAAAA,OAAO,CAAPA,UAAAA,GAAAA,UAAAA;AACD;;AAED,SAAO,IAAA,OAAA,CAAaW,OAAD,IAAa;AAC9BL,IAAAA,kBAAkB,CAAC,EACjB,GADiB,OAAA;AAEjBM,MAAAA,cAAc,EAAGV,KAAD,IAAWS,OAAO,CAAC;AAACT,QAAAA;AAAD,OAAD;AAFjB,KAAD,CAAlBI;AADF,GAAO,CAAP;AAMD;;AAID,eAAA,gBAAA,CAAA,OAAA,EAAyC;AACvC,MAAIO,kBAAkB,GAAG,MAAMN,WAAW,CAAA,iBAAA,EAAA,OAAA,EAA1C,OAA0C,CAA1C;AAEAM,EAAAA,kBAAkB,GAAGA,kBAAkB,IAAIJ,UAAU,CAArDI,kBAAAA;AAEA,SAAO,IAAA,OAAA,CAAaF,OAAD,IAAa;AAC9BE,IAAAA,kBAAkB,CAAC;AACjBD,MAAAA,cAAc,EAAGV,KAAD,IAAWS,OAAO,CAAC;AAACT,QAAAA;AAAD,OAAD;AADjB,KAAD,CAAlBW;AADF,GAAO,CAAP;AAKD","sourcesContent":["// Dynamic DRACO module loading inspired by THREE.DRACOLoader\n// https://github.com/mrdoob/three.js/blob/398c4f39ebdb8b23eefd4a7a5ec49ec0c96c7462/examples/jsm/loaders/DRACOLoader.js\n// by Don McCurdy / https://www.donmccurdy.com / MIT license\n\nimport {loadLibrary} from '@loaders.gl/worker-utils';\n\nconst DRACO_VERSION = '1.4.1';\nconst DRACO_JS_DECODER_URL = `https://www.gstatic.com/draco/versioned/decoders/${DRACO_VERSION}/draco_decoder.js`;\nconst DRACO_WASM_WRAPPER_URL = `https://www.gstatic.com/draco/versioned/decoders/${DRACO_VERSION}/draco_wasm_wrapper.js`;\nconst DRACO_WASM_DECODER_URL = `https://www.gstatic.com/draco/versioned/decoders/${DRACO_VERSION}/draco_decoder.wasm`;\n\nconst DRACO_ENCODER_URL = `https://raw.githubusercontent.com/google/draco/${DRACO_VERSION}/javascript/draco_encoder.js`;\n\nlet loadDecoderPromise;\nlet loadEncoderPromise;\n\nexport async function loadDracoDecoderModule(options) {\n  const modules = options.modules || {};\n\n  // Check if a bundled draco3d library has been supplied by application\n  if (modules.draco3d) {\n    loadDecoderPromise =\n      loadDecoderPromise ||\n      modules.draco3d.createDecoderModule({}).then((draco) => {\n        return {draco};\n      });\n  } else {\n    // If not, dynamically load the WASM script from our CDN\n    loadDecoderPromise = loadDecoderPromise || loadDracoDecoder(options);\n  }\n  return await loadDecoderPromise;\n}\n\nexport async function loadDracoEncoderModule(options) {\n  const modules = options.modules || {};\n\n  // Check if a bundled draco3d library has been supplied by application\n  if (modules.draco3d) {\n    loadEncoderPromise =\n      loadEncoderPromise ||\n      modules.draco3d.createEncoderModule({}).then((draco) => {\n        return {draco};\n      });\n  } else {\n    // If not, dynamically load the WASM script from our CDN\n    loadEncoderPromise = loadEncoderPromise || loadDracoEncoder(options);\n  }\n  return await loadEncoderPromise;\n}\n\n// DRACO DECODER LOADING\n\nasync function loadDracoDecoder(options) {\n  let DracoDecoderModule;\n  let wasmBinary;\n  switch (options.draco && options.draco.decoderType) {\n    case 'js':\n      DracoDecoderModule = await loadLibrary(DRACO_JS_DECODER_URL, 'draco', options);\n      break;\n\n    case 'wasm':\n    default:\n      [DracoDecoderModule, wasmBinary] = await Promise.all([\n        await loadLibrary(DRACO_WASM_WRAPPER_URL, 'draco', options),\n        await loadLibrary(DRACO_WASM_DECODER_URL, 'draco', options)\n      ]);\n  }\n  // Depends on how import happened...\n  // @ts-ignore\n  DracoDecoderModule = DracoDecoderModule || globalThis.DracoDecoderModule;\n  return await initializeDracoDecoder(DracoDecoderModule, wasmBinary);\n}\n\nfunction initializeDracoDecoder(DracoDecoderModule, wasmBinary) {\n  const options: {wasmBinary?: any} = {};\n  if (wasmBinary) {\n    options.wasmBinary = wasmBinary;\n  }\n\n  return new Promise((resolve) => {\n    DracoDecoderModule({\n      ...options,\n      onModuleLoaded: (draco) => resolve({draco}) // Module is Promise-like. Wrap in object to avoid loop.\n    });\n  });\n}\n\n// ENCODER\n\nasync function loadDracoEncoder(options) {\n  let DracoEncoderModule = await loadLibrary(DRACO_ENCODER_URL, 'draco', options);\n  // @ts-ignore\n  DracoEncoderModule = DracoEncoderModule || globalThis.DracoEncoderModule;\n\n  return new Promise((resolve) => {\n    DracoEncoderModule({\n      onModuleLoaded: (draco) => resolve({draco}) // Module is Promise-like. Wrap in object to avoid loop.\n    });\n  });\n}\n"]},"metadata":{},"sourceType":"module"}