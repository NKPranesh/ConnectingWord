{"ast":null,"code":"import * as KHR_draco_mesh_compression from './KHR_draco_mesh_compression';\nimport * as KHR_materials_unlit from './KHR_materials_unlit';\nimport * as KHR_lights_punctual from './KHR_lights_punctual';\nimport * as KHR_techniques_webgl from './KHR_techniques_webgl';\nexport const EXTENSIONS = {\n  KHR_draco_mesh_compression,\n  KHR_materials_unlit,\n  KHR_lights_punctual,\n  KHR_techniques_webgl\n};\nexport async function decodeExtensions(gltf) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let context = arguments.length > 2 ? arguments[2] : undefined;\n\n  for (const extensionName in EXTENSIONS) {\n    var _options$gltf;\n\n    const excludes = (options === null || options === void 0 ? void 0 : (_options$gltf = options.gltf) === null || _options$gltf === void 0 ? void 0 : _options$gltf.excludeExtensions) || {};\n    const exclude = extensionName in excludes && !excludes[extensionName];\n\n    if (!exclude) {\n      const extension = EXTENSIONS[extensionName];\n      await extension.decode(gltf, options, context);\n    }\n  }\n}","map":{"version":3,"sources":["../../../../src/lib/extensions/gltf-extensions.ts"],"names":["EXTENSIONS","KHR_techniques_webgl","options","excludes","exclude","extensionName","extension"],"mappings":"AAQA,OAAO,KAAP,0BAAA,MAAA,8BAAA;AACA,OAAO,KAAP,mBAAA,MAAA,uBAAA;AACA,OAAO,KAAP,mBAAA,MAAA,uBAAA;AACA,OAAO,KAAP,oBAAA,MAAA,wBAAA;AAaA,OAAO,MAAMA,UAA0D,GAAG;AAAA,EAAA,0BAAA;AAAA,EAAA,mBAAA;AAAA,EAAA,mBAAA;AASxEC,EAAAA;AATwE,CAAnE;AAYP,OAAO,eAAA,gBAAA,CAAA,IAAA,EAAiF;AAAA,MAA3CC,OAA2C,uEAAjF,EAAiF;AAAA,MAAjF,OAAiF;;AACtF,OAAK,MAAL,aAAA,IAAA,UAAA,EAAwC;AAAA,QAAA,aAAA;;AACtC,UAAMC,QAAQ,GAAG,CAAA,OAAO,KAAP,IAAA,IAAA,OAAO,KAAA,KAAP,CAAA,GAAA,KAAA,CAAA,GAAA,CAAA,aAAA,GAAA,OAAO,CAAP,IAAA,MAAA,IAAA,IAAA,aAAA,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAA,aAAA,CAAA,iBAAA,KAAjB,EAAA;AACA,UAAMC,OAAO,GAAGC,aAAa,IAAbA,QAAAA,IAA6B,CAACF,QAAQ,CAAtD,aAAsD,CAAtD;;AACA,QAAI,CAAJ,OAAA,EAAc;AACZ,YAAMG,SAAS,GAAGN,UAAU,CAA5B,aAA4B,CAA5B;AAGA,YAAMM,SAAS,CAATA,MAAAA,CAAAA,IAAAA,EAAAA,OAAAA,EAAN,OAAMA,CAAN;AACD;AACF;AACF","sourcesContent":["/* eslint-disable camelcase */\nimport {GLTF} from '../types/gltf-types';\nimport type {GLTFLoaderOptions} from '../../gltf-loader';\n\n// GLTF 1.0 extensions (read only)\n// import * as KHR_binary_gltf from './KHR_draco_mesh_compression';\n\n// GLTF 2.0 extensions (read/write)\nimport * as KHR_draco_mesh_compression from './KHR_draco_mesh_compression';\nimport * as KHR_materials_unlit from './KHR_materials_unlit';\nimport * as KHR_lights_punctual from './KHR_lights_punctual';\nimport * as KHR_techniques_webgl from './KHR_techniques_webgl';\n\ntype GLTFExtensionPlugin = {\n  decode: (gltfData: {json: GLTF}, options: GLTFLoaderOptions, context) => Promise<void>;\n\n  encode: (gltfData: {json: GLTF}, options: GLTFLoaderOptions) => void;\n};\n\n/**\n * List of extensions processed by the GLTFLoader\n * Note that may extensions can only be handled on the rendering stage and are left out here\n * These are just extensions that can be handled fully or partially during loading.\n */\nexport const EXTENSIONS: {[extensionName: string]: GLTFExtensionPlugin} = {\n  // 1.0\n  // KHR_binary_gltf is handled separately - must be processed before other parsing starts\n  // KHR_binary_gltf,\n\n  // 2.0\n  KHR_draco_mesh_compression,\n  KHR_materials_unlit,\n  KHR_lights_punctual,\n  KHR_techniques_webgl\n};\n\nexport async function decodeExtensions(gltf, options: GLTFLoaderOptions = {}, context?) {\n  for (const extensionName in EXTENSIONS) {\n    const excludes = options?.gltf?.excludeExtensions || {};\n    const exclude = extensionName in excludes && !excludes[extensionName];\n    if (!exclude) {\n      const extension = EXTENSIONS[extensionName];\n      // Note: We decode async extensions sequentially, this might not be necessary\n      // Currently we only have Draco, but when we add Basis we may revisit\n      await extension.decode(gltf, options, context);\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}