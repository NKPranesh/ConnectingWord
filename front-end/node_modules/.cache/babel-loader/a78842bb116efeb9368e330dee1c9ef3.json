{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { load } from '@loaders.gl/core';\nimport TilesetTraverser from './tileset-traverser';\nimport { lodJudge } from '../helpers/i3s-lod';\nimport TileHeader from '../tile-3d';\nimport I3STileManager from './i3s-tile-manager';\nexport default class I3STilesetTraverser extends TilesetTraverser {\n  constructor(options) {\n    super(options);\n\n    _defineProperty(this, \"_tileManager\", void 0);\n\n    this._tileManager = new I3STileManager();\n  }\n\n  shouldRefine(tile, frameState) {\n    tile._lodJudge = lodJudge(tile, frameState);\n    return tile._lodJudge === 'DIG';\n  }\n\n  updateChildTiles(tile, frameState) {\n    const children = tile.header.children || [];\n    const childTiles = tile.children;\n    const tileset = tile.tileset;\n\n    for (const child of children) {\n      const extendedId = \"\".concat(child.id, \"-\").concat(frameState.viewport.id);\n      const childTile = childTiles && childTiles.find(t => t.id === extendedId);\n\n      if (!childTile) {\n        let request = () => this._loadTile(child.id, tileset);\n\n        const cachedRequest = this._tileManager.find(extendedId);\n\n        if (!cachedRequest) {\n          if (tileset.tileset.nodePages) {\n            request = () => tileset.tileset.nodePagesTile.formTileFromNodePages(child.id);\n          }\n\n          this._tileManager.add(request, extendedId, header => this._onTileLoad(header, tile, extendedId), frameState);\n        } else {\n          this._tileManager.update(extendedId, frameState);\n        }\n      } else if (childTile) {\n        this.updateTile(childTile, frameState);\n      }\n    }\n\n    return false;\n  }\n\n  async _loadTile(nodeId, tileset) {\n    const {\n      loader\n    } = tileset;\n    const nodeUrl = tileset.getTileUrl(\"\".concat(tileset.url, \"/nodes/\").concat(nodeId));\n    const options = { ...tileset.loadOptions,\n      i3s: { ...tileset.loadOptions.i3s,\n        isTileHeader: true,\n        loadContent: false\n      }\n    };\n    return await load(nodeUrl, loader, options);\n  }\n\n  _onTileLoad(header, tile, extendedId) {\n    const childTile = new TileHeader(tile.tileset, header, tile, extendedId);\n    tile.children.push(childTile);\n\n    const frameState = this._tileManager.find(childTile.id).frameState;\n\n    this.updateTile(childTile, frameState);\n\n    if (this._frameNumber === frameState.frameNumber) {\n      this.executeTraversal(childTile, frameState);\n    }\n  }\n\n}","map":{"version":3,"sources":["../../../../src/tileset/traversers/i3s-tileset-traverser.ts"],"names":["constructor","shouldRefine","tile","lodJudge","updateChildTiles","children","childTiles","tileset","extendedId","child","frameState","childTile","t","request","cachedRequest","header","_loadTile","loader","nodeUrl","options","i3s","isTileHeader","loadContent","load","_onTileLoad"],"mappings":"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","sourcesContent":["import {load} from '@loaders.gl/core';\nimport TilesetTraverser from './tileset-traverser';\n\nimport {lodJudge} from '../helpers/i3s-lod';\nimport TileHeader from '../tile-3d';\nimport I3STileManager from './i3s-tile-manager';\n\nexport default class I3STilesetTraverser extends TilesetTraverser {\n  private _tileManager: I3STileManager;\n\n  constructor(options) {\n    super(options);\n    this._tileManager = new I3STileManager();\n  }\n\n  shouldRefine(tile, frameState) {\n    // TODO refactor loaJudge\n    tile._lodJudge = lodJudge(tile, frameState);\n    return tile._lodJudge === 'DIG';\n  }\n\n  updateChildTiles(tile, frameState): boolean {\n    const children = tile.header.children || [];\n    // children which are already fetched and constructed as Tile3D instances\n    const childTiles = tile.children;\n    const tileset = tile.tileset;\n\n    for (const child of children) {\n      const extendedId = `${child.id}-${frameState.viewport.id}`;\n      // if child tile is not fetched\n      const childTile = childTiles && childTiles.find((t) => t.id === extendedId);\n      if (!childTile) {\n        let request = () => this._loadTile(child.id, tileset);\n        const cachedRequest = this._tileManager.find(extendedId);\n        if (!cachedRequest) {\n          // eslint-disable-next-line max-depth\n          if (tileset.tileset.nodePages) {\n            request = () => tileset.tileset.nodePagesTile.formTileFromNodePages(child.id);\n          }\n          this._tileManager.add(\n            request,\n            extendedId,\n            (header) => this._onTileLoad(header, tile, extendedId),\n            frameState\n          );\n        } else {\n          // update frameNumber since it is still needed in current frame\n          this._tileManager.update(extendedId, frameState);\n        }\n      } else if (childTile) {\n        // if child tile is fetched and available\n        this.updateTile(childTile, frameState);\n      }\n    }\n    return false;\n  }\n\n  async _loadTile(nodeId, tileset) {\n    const {loader} = tileset;\n    const nodeUrl = tileset.getTileUrl(`${tileset.url}/nodes/${nodeId}`);\n    // load metadata\n    const options = {\n      ...tileset.loadOptions,\n      i3s: {\n        ...tileset.loadOptions.i3s,\n        isTileHeader: true,\n        loadContent: false\n      }\n    };\n\n    return await load(nodeUrl, loader, options);\n  }\n\n  /**\n   * The callback to init TileHeader instance after loading the tile JSON\n   * @param {Object} header - the tile JSON from a dataset\n   * @param {TileHeader} tile - the parent TileHeader instance\n   * @param {string} extendedId - optional ID to separate copies of a tile for different viewports.\n   *                              const extendedId = `${tile.id}-${frameState.viewport.id}`;\n   * @return {void}\n   */\n  _onTileLoad(header, tile, extendedId) {\n    // after child tile is fetched\n    const childTile = new TileHeader(tile.tileset, header, tile, extendedId);\n    tile.children.push(childTile);\n    const frameState = this._tileManager.find(childTile.id).frameState;\n    this.updateTile(childTile, frameState);\n\n    // after tile fetched, resume traversal if still in current update/traversal frame\n    if (this._frameNumber === frameState.frameNumber) {\n      this.executeTraversal(childTile, frameState);\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}