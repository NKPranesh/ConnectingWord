{"ast":null,"code":"import { Matrix4 } from '@math.gl/core';\nconst IDENTITY_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\nconst DEFAULT_MODULE_OPTIONS = {\n  modelMatrix: IDENTITY_MATRIX,\n  viewMatrix: IDENTITY_MATRIX,\n  projectionMatrix: IDENTITY_MATRIX,\n  cameraPositionWorld: [0, 0, 0]\n};\n\nfunction getUniforms() {\n  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_MODULE_OPTIONS;\n  let prevUniforms = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const uniforms = {};\n\n  if (opts.modelMatrix !== undefined) {\n    uniforms.modelMatrix = opts.modelMatrix;\n  }\n\n  if (opts.viewMatrix !== undefined) {\n    uniforms.viewMatrix = opts.viewMatrix;\n  }\n\n  if (opts.projectionMatrix !== undefined) {\n    uniforms.projectionMatrix = opts.projectionMatrix;\n  }\n\n  if (opts.cameraPositionWorld !== undefined) {\n    uniforms.cameraPositionWorld = opts.cameraPositionWorld;\n  }\n\n  if (opts.projectionMatrix !== undefined || opts.viewMatrix !== undefined) {\n    uniforms.viewProjectionMatrix = new Matrix4(opts.projectionMatrix).multiplyRight(opts.viewMatrix);\n  }\n\n  return uniforms;\n}\n\nconst common = `\\\nvarying vec4 project_vPositionWorld;\nvarying vec3 project_vNormalWorld;\n\nvec4 project_getPosition_World() {\n  return project_vPositionWorld;\n}\n\nvec3 project_getNormal_World() {\n  return project_vNormalWorld;\n}\n`;\nconst vs = `\\\n${common}\nuniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewProjectionMatrix;\nuniform vec3 cameraPositionWorld;\n\nstruct World {\n  vec3 position;\n  vec3 normal;\n};\n\nWorld world;\n\nvoid project_setPosition(vec4 position) {\n  project_vPositionWorld = position;\n}\n\nvoid project_setNormal(vec3 normal) {\n  project_vNormalWorld = normal;\n}\n\nvoid project_setPositionAndNormal_World(vec3 position, vec3 normal) {\n  world.position = position;\n  world.normal = normal;\n}\n\nvoid project_setPositionAndNormal_Model(vec3 position, vec3 normal) {\n  world.position = (modelMatrix * vec4(position, 1.)).xyz;\n  world.normal = mat3(modelMatrix) * normal;\n}\n\nvec4 project_model_to_clipspace(vec4 position) {\n  return viewProjectionMatrix * modelMatrix * position;\n}\n\nvec4 project_model_to_clipspace(vec3 position) {\n  return viewProjectionMatrix * modelMatrix * vec4(position, 1.);\n}\n\nvec4 project_world_to_clipspace(vec3 position) {\n  return viewProjectionMatrix * vec4(position, 1.);\n}\n\nvec4 project_view_to_clipspace(vec3 position) {\n  return projectionMatrix * vec4(position, 1.);\n}\n\nvec4 project_to_clipspace(vec3 position) {\n  return viewProjectionMatrix * vec4(position, 1.);\n}\n`;\nconst fs = `\n${common}\\\n`;\nexport const project = {\n  name: 'project',\n  getUniforms,\n  vs,\n  fs\n};","map":{"version":3,"sources":["../../../../src/modules/project/project.js"],"names":["IDENTITY_MATRIX","DEFAULT_MODULE_OPTIONS","modelMatrix","viewMatrix","projectionMatrix","cameraPositionWorld","opts","prevUniforms","uniforms","common","vs","fs","project","name"],"mappings":"AAEA,SAAA,OAAA,QAAA,eAAA;AAEA,MAAMA,eAAe,GAAG,CAAA,CAAA,EAAA,CAAA,EAAA,CAAA,EAAA,CAAA,EAAA,CAAA,EAAA,CAAA,EAAA,CAAA,EAAA,CAAA,EAAA,CAAA,EAAA,CAAA,EAAA,CAAA,EAAA,CAAA,EAAA,CAAA,EAAA,CAAA,EAAA,CAAA,EAAxB,CAAwB,CAAxB;AAEA,MAAMC,sBAAsB,GAAG;AAC7BC,EAAAA,WAAW,EADkB,eAAA;AAE7BC,EAAAA,UAAU,EAFmB,eAAA;AAG7BC,EAAAA,gBAAgB,EAHa,eAAA;AAI7BC,EAAAA,mBAAmB,EAAE,CAAA,CAAA,EAAA,CAAA,EAAA,CAAA;AAJQ,CAA/B;;AAOA,SAAA,WAAA,GAAuE;AAAA,MAAlDC,IAAkD,uEAAvE,sBAAuE;AAAA,MAAnBC,YAAmB,uEAAvE,EAAuE;AAKrE,QAAMC,QAAQ,GAAd,EAAA;;AACA,MAAIF,IAAI,CAAJA,WAAAA,KAAJ,SAAA,EAAoC;AAClCE,IAAAA,QAAQ,CAARA,WAAAA,GAAuBF,IAAI,CAA3BE,WAAAA;AACD;;AACD,MAAIF,IAAI,CAAJA,UAAAA,KAAJ,SAAA,EAAmC;AACjCE,IAAAA,QAAQ,CAARA,UAAAA,GAAsBF,IAAI,CAA1BE,UAAAA;AACD;;AACD,MAAIF,IAAI,CAAJA,gBAAAA,KAAJ,SAAA,EAAyC;AACvCE,IAAAA,QAAQ,CAARA,gBAAAA,GAA4BF,IAAI,CAAhCE,gBAAAA;AACD;;AACD,MAAIF,IAAI,CAAJA,mBAAAA,KAAJ,SAAA,EAA4C;AAC1CE,IAAAA,QAAQ,CAARA,mBAAAA,GAA+BF,IAAI,CAAnCE,mBAAAA;AACD;;AAGD,MAAIF,IAAI,CAAJA,gBAAAA,KAAAA,SAAAA,IAAuCA,IAAI,CAAJA,UAAAA,KAA3C,SAAA,EAA0E;AACxEE,IAAAA,QAAQ,CAARA,oBAAAA,GAAgC,IAAA,OAAA,CAAYF,IAAI,CAAhB,gBAAA,EAAA,aAAA,CAC9BA,IAAI,CADNE,UAAgC,CAAhCA;AAGD;;AAED,SAAA,QAAA;AACD;;AAED,MAAMC,MAAM,GAAI;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAVA,CAAA;AAaA,MAAMC,EAAE,GAAI;AACZ,EAAED,MAAO;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAnDA,CAAA;AAwDA,MAAME,EAAE,GAAI;AACZ,EAAEF,MAAO;AADT,CAAA;AAKA,OAAO,MAAMG,OAAO,GAAG;AACrBC,EAAAA,IAAI,EADiB,SAAA;AAAA,EAAA,WAAA;AAAA,EAAA,EAAA;AAIrBF,EAAAA;AAJqB,CAAhB","sourcesContent":["/** @typedef {import('../../types').ShaderModule} ShaderModule */\n\nimport {Matrix4} from '@math.gl/core';\n\nconst IDENTITY_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n\nconst DEFAULT_MODULE_OPTIONS = {\n  modelMatrix: IDENTITY_MATRIX,\n  viewMatrix: IDENTITY_MATRIX,\n  projectionMatrix: IDENTITY_MATRIX,\n  cameraPositionWorld: [0, 0, 0]\n};\n\nfunction getUniforms(opts = DEFAULT_MODULE_OPTIONS, prevUniforms = {}) {\n  // const viewProjectionInverse = viewProjection.invert();\n  // viewInverseMatrix: view.invert(),\n  // viewProjectionInverseMatrix: viewProjectionInverse\n\n  const uniforms = {};\n  if (opts.modelMatrix !== undefined) {\n    uniforms.modelMatrix = opts.modelMatrix;\n  }\n  if (opts.viewMatrix !== undefined) {\n    uniforms.viewMatrix = opts.viewMatrix;\n  }\n  if (opts.projectionMatrix !== undefined) {\n    uniforms.projectionMatrix = opts.projectionMatrix;\n  }\n  if (opts.cameraPositionWorld !== undefined) {\n    uniforms.cameraPositionWorld = opts.cameraPositionWorld;\n  }\n\n  // COMPOSITE UNIFORMS\n  if (opts.projectionMatrix !== undefined || opts.viewMatrix !== undefined) {\n    uniforms.viewProjectionMatrix = new Matrix4(opts.projectionMatrix).multiplyRight(\n      opts.viewMatrix\n    );\n  }\n\n  return uniforms;\n}\n\nconst common = `\\\nvarying vec4 project_vPositionWorld;\nvarying vec3 project_vNormalWorld;\n\nvec4 project_getPosition_World() {\n  return project_vPositionWorld;\n}\n\nvec3 project_getNormal_World() {\n  return project_vNormalWorld;\n}\n`;\n\nconst vs = `\\\n${common}\n\n// Unprefixed uniforms\nuniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewProjectionMatrix;\nuniform vec3 cameraPositionWorld;\n\nstruct World {\n  vec3 position;\n  vec3 normal;\n};\n\nWorld world;\n\nvoid project_setPosition(vec4 position) {\n  project_vPositionWorld = position;\n}\n\nvoid project_setNormal(vec3 normal) {\n  project_vNormalWorld = normal;\n}\n\nvoid project_setPositionAndNormal_World(vec3 position, vec3 normal) {\n  world.position = position;\n  world.normal = normal;\n}\n\nvoid project_setPositionAndNormal_Model(vec3 position, vec3 normal) {\n  world.position = (modelMatrix * vec4(position, 1.)).xyz;\n  world.normal = mat3(modelMatrix) * normal;\n}\n\nvec4 project_model_to_clipspace(vec4 position) {\n  return viewProjectionMatrix * modelMatrix * position;\n}\n\nvec4 project_model_to_clipspace(vec3 position) {\n  return viewProjectionMatrix * modelMatrix * vec4(position, 1.);\n}\n\nvec4 project_world_to_clipspace(vec3 position) {\n  return viewProjectionMatrix * vec4(position, 1.);\n}\n\nvec4 project_view_to_clipspace(vec3 position) {\n  return projectionMatrix * vec4(position, 1.);\n}\n\nvec4 project_to_clipspace(vec3 position) {\n  return viewProjectionMatrix * vec4(position, 1.);\n}\n`;\n\nconst fs = `\n${common}\\\n`;\n\n/** @type {ShaderModule} */\nexport const project = {\n  name: 'project',\n  getUniforms,\n  vs,\n  fs\n};\n"]},"metadata":{},"sourceType":"module"}