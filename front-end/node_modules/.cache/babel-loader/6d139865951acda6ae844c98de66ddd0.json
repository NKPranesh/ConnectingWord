{"ast":null,"code":"import { GL_TYPE as GL } from '../constants';\nconst GL_TYPE_TO_ARRAY_TYPE = {\n  [GL.DOUBLE]: Float64Array,\n  [GL.FLOAT]: Float32Array,\n  [GL.UNSIGNED_SHORT]: Uint16Array,\n  [GL.UNSIGNED_INT]: Uint32Array,\n  [GL.UNSIGNED_BYTE]: Uint8Array,\n  [GL.BYTE]: Int8Array,\n  [GL.SHORT]: Int16Array,\n  [GL.INT]: Int32Array\n};\nconst NAME_TO_GL_TYPE = {\n  DOUBLE: GL.DOUBLE,\n  FLOAT: GL.FLOAT,\n  UNSIGNED_SHORT: GL.UNSIGNED_SHORT,\n  UNSIGNED_INT: GL.UNSIGNED_INT,\n  UNSIGNED_BYTE: GL.UNSIGNED_BYTE,\n  BYTE: GL.BYTE,\n  SHORT: GL.SHORT,\n  INT: GL.INT\n};\nconst ERR_TYPE_CONVERSION = 'Failed to convert GL type';\nexport default class GLType {\n  static fromTypedArray(arrayOrType) {\n    arrayOrType = ArrayBuffer.isView(arrayOrType) ? arrayOrType.constructor : arrayOrType;\n\n    for (const glType in GL_TYPE_TO_ARRAY_TYPE) {\n      const ArrayType = GL_TYPE_TO_ARRAY_TYPE[glType];\n\n      if (ArrayType === arrayOrType) {\n        return glType;\n      }\n    }\n\n    throw new Error(ERR_TYPE_CONVERSION);\n  }\n\n  static fromName(name) {\n    const glType = NAME_TO_GL_TYPE[name];\n\n    if (!glType) {\n      throw new Error(ERR_TYPE_CONVERSION);\n    }\n\n    return glType;\n  }\n\n  static getArrayType(glType) {\n    switch (glType) {\n      case GL.UNSIGNED_SHORT_5_6_5:\n      case GL.UNSIGNED_SHORT_4_4_4_4:\n      case GL.UNSIGNED_SHORT_5_5_5_1:\n        return Uint16Array;\n\n      default:\n        const ArrayType = GL_TYPE_TO_ARRAY_TYPE[glType];\n\n        if (!ArrayType) {\n          throw new Error(ERR_TYPE_CONVERSION);\n        }\n\n        return ArrayType;\n    }\n  }\n\n  static getByteSize(glType) {\n    const ArrayType = GLType.getArrayType(glType);\n    return ArrayType.BYTES_PER_ELEMENT;\n  }\n\n  static validate(glType) {\n    return Boolean(GLType.getArrayType(glType));\n  }\n\n  static createTypedArray(glType, buffer) {\n    let byteOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    let length = arguments.length > 3 ? arguments[3] : undefined;\n\n    if (length === undefined) {\n      length = (buffer.byteLength - byteOffset) / GLType.getByteSize(glType);\n    }\n\n    const ArrayType = GLType.getArrayType(glType);\n    return new ArrayType(buffer, byteOffset, length);\n  }\n\n}","map":{"version":3,"sources":["../../../../src/geometry/gl/gl-type.ts"],"names":["GL_TYPE","GL_TYPE_TO_ARRAY_TYPE","GL","Int32Array","NAME_TO_GL_TYPE","DOUBLE","FLOAT","UNSIGNED_SHORT","UNSIGNED_INT","UNSIGNED_BYTE","BYTE","SHORT","INT","ERR_TYPE_CONVERSION","fromTypedArray","arrayOrType","ArrayBuffer","ArrayType","fromName","glType","getArrayType","getByteSize","GLType","validate","Boolean","createTypedArray","byteOffset","length","buffer"],"mappings":"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","sourcesContent":["import {TypedArray} from '../types';\nimport {GL_TYPE as GL} from '../constants';\n\nconst GL_TYPE_TO_ARRAY_TYPE = {\n  [GL.DOUBLE]: Float64Array,\n  [GL.FLOAT]: Float32Array,\n  [GL.UNSIGNED_SHORT]: Uint16Array,\n  [GL.UNSIGNED_INT]: Uint32Array,\n  [GL.UNSIGNED_BYTE]: Uint8Array,\n  [GL.BYTE]: Int8Array,\n  [GL.SHORT]: Int16Array,\n  [GL.INT]: Int32Array\n};\ntype GlTypeMap = {\n  [index: string]: number;\n};\nconst NAME_TO_GL_TYPE: GlTypeMap = {\n  DOUBLE: GL.DOUBLE,\n  FLOAT: GL.FLOAT,\n  UNSIGNED_SHORT: GL.UNSIGNED_SHORT,\n  UNSIGNED_INT: GL.UNSIGNED_INT,\n  UNSIGNED_BYTE: GL.UNSIGNED_BYTE,\n  BYTE: GL.BYTE,\n  SHORT: GL.SHORT,\n  INT: GL.INT\n};\nconst ERR_TYPE_CONVERSION = 'Failed to convert GL type';\n// Converts TYPED ARRAYS to corresponding GL constant\n// Used to auto deduce gl parameter types\nexport default class GLType {\n  // Signature: fromTypedArray(new Uint8Array())\n  // Signature: fromTypedArray(Uint8Array)\n  /**\n   * Returns the size, in bytes, of the corresponding datatype\n   * @param arrayOrType\n   * @returns glType a a string\n   */\n  static fromTypedArray(arrayOrType: TypedArray | Function): string {\n    // If typed array, look up constructor\n    arrayOrType = ArrayBuffer.isView(arrayOrType) ? arrayOrType.constructor : arrayOrType;\n    for (const glType in GL_TYPE_TO_ARRAY_TYPE) {\n      const ArrayType = GL_TYPE_TO_ARRAY_TYPE[glType];\n      if (ArrayType === arrayOrType) {\n        return glType;\n      }\n    }\n    throw new Error(ERR_TYPE_CONVERSION);\n  }\n  /**\n   * Extracts name for glType from array NAME_TO_GL_TYPE\n   * @param name\n   * @returns glType as a number\n   */\n  static fromName(name: string): number {\n    const glType = NAME_TO_GL_TYPE[name];\n    if (!glType) {\n      throw new Error(ERR_TYPE_CONVERSION);\n    }\n    return glType;\n  }\n  // Converts GL constant to corresponding typed array type\n  // eslint-disable-next-line complexity\n  static getArrayType(glType: number) {\n    switch (glType) {\n      /*eslint-disable*/\n      // @ts-ignore\n      case GL.UNSIGNED_SHORT_5_6_5:\n      // @ts-ignore\n      case GL.UNSIGNED_SHORT_4_4_4_4:\n      // @ts-ignore\n      case GL.UNSIGNED_SHORT_5_5_5_1:\n        /* eslint-enable*/\n        return Uint16Array;\n      default:\n        const ArrayType = GL_TYPE_TO_ARRAY_TYPE[glType];\n        if (!ArrayType) {\n          throw new Error(ERR_TYPE_CONVERSION);\n        }\n        return ArrayType;\n    }\n  }\n  /**\n   * Returns the size in bytes of one element of the provided WebGL type\n   * @param glType\n   * @returns size of glType\n   */\n  static getByteSize(glType: number): number {\n    const ArrayType = GLType.getArrayType(glType);\n    return ArrayType.BYTES_PER_ELEMENT;\n  }\n  /**\n   * Returns `true` if `glType` is a valid WebGL data type.\n   * @param glType\n   * @returns boolean\n   */\n  static validate(glType: number): boolean {\n    return Boolean(GLType.getArrayType(glType));\n  }\n  /**\n   * Creates a typed view of an array of bytes\n   * @param glType The type of typed array (ArrayBuffer view) to create\n   * @param buffer The buffer storage to use for the view.\n   * @param byteOffset The offset, in bytes, to the first element in the view\n   * @param length The number of elements in the view. Defaults to buffer length\n   * @returns A typed array view of the buffer\n   */\n  static createTypedArray(\n    glType: number,\n    buffer: TypedArray,\n    byteOffset: number = 0,\n    length?: number\n  ): TypedArray {\n    if (length === undefined) {\n      length = (buffer.byteLength - byteOffset) / GLType.getByteSize(glType);\n    }\n    const ArrayType = GLType.getArrayType(glType);\n    return new ArrayType(buffer, byteOffset, length);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}