{"ast":null,"code":"import { isResponse } from '../../javascript-utils/is-type';\nimport { getResourceContentLength, getResourceUrlAndType } from './resource-utils';\nexport async function makeResponse(resource) {\n  if (isResponse(resource)) {\n    return resource;\n  }\n\n  const headers = {};\n  const contentLength = getResourceContentLength(resource);\n\n  if (contentLength >= 0) {\n    headers['content-length'] = String(contentLength);\n  }\n\n  const {\n    url,\n    type\n  } = getResourceUrlAndType(resource);\n\n  if (type) {\n    headers['content-type'] = type;\n  }\n\n  const initialDataUrl = await getInitialDataUrl(resource);\n\n  if (initialDataUrl) {\n    headers['x-first-bytes'] = initialDataUrl;\n  }\n\n  if (typeof resource === 'string') {\n    resource = new TextEncoder().encode(resource);\n  }\n\n  const response = new Response(resource, {\n    headers\n  });\n  Object.defineProperty(response, 'url', {\n    value: url\n  });\n  return response;\n}\nexport async function checkResponse(response) {\n  if (!response.ok) {\n    const message = await getResponseError(response);\n    throw new Error(message);\n  }\n}\nexport function checkResponseSync(response) {\n  if (!response.ok) {\n    let message = \"\".concat(response.status, \" \").concat(response.statusText);\n    message = message.length > 60 ? \"\".concat(message.slice(60), \"...\") : message;\n    throw new Error(message);\n  }\n}\n\nasync function getResponseError(response) {\n  let message = \"Failed to fetch resource \".concat(response.url, \" (\").concat(response.status, \"): \");\n\n  try {\n    const contentType = response.headers.get('Content-Type');\n    let text = response.statusText;\n\n    if (contentType.includes('application/json')) {\n      text += \" \".concat(await response.text());\n    }\n\n    message += text;\n    message = message.length > 60 ? \"\".concat(message.slice(60), \"...\") : message;\n  } catch (error) {}\n\n  return message;\n}\n\nasync function getInitialDataUrl(resource) {\n  const INITIAL_DATA_LENGTH = 5;\n\n  if (typeof resource === 'string') {\n    return \"data:,\".concat(resource.slice(0, INITIAL_DATA_LENGTH));\n  }\n\n  if (resource instanceof Blob) {\n    const blobSlice = resource.slice(0, 5);\n    return await new Promise(resolve => {\n      const reader = new FileReader();\n\n      reader.onload = event => {\n        var _event$target;\n\n        return resolve(event === null || event === void 0 ? void 0 : (_event$target = event.target) === null || _event$target === void 0 ? void 0 : _event$target.result);\n      };\n\n      reader.readAsDataURL(blobSlice);\n    });\n  }\n\n  if (resource instanceof ArrayBuffer) {\n    const slice = resource.slice(0, INITIAL_DATA_LENGTH);\n    const base64 = arrayBufferToBase64(slice);\n    return \"data:base64,\".concat(base64);\n  }\n\n  return null;\n}\n\nfunction arrayBufferToBase64(buffer) {\n  let binary = '';\n  const bytes = new Uint8Array(buffer);\n\n  for (let i = 0; i < bytes.byteLength; i++) {\n    binary += String.fromCharCode(bytes[i]);\n  }\n\n  return btoa(binary);\n}","map":{"version":3,"sources":["../../../../src/lib/utils/response-utils.ts"],"names":["isResponse","headers","contentLength","getResourceContentLength","String","type","getResourceUrlAndType","initialDataUrl","getInitialDataUrl","resource","response","Object","value","url","message","getResponseError","contentType","text","INITIAL_DATA_LENGTH","blobSlice","resolve","reader","event","slice","base64","arrayBufferToBase64","binary","bytes","i","btoa"],"mappings":"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","sourcesContent":["import {isResponse} from '../../javascript-utils/is-type';\nimport {getResourceContentLength, getResourceUrlAndType} from './resource-utils';\n\n/**\n * Returns a Response object\n * Adds content-length header when possible\n *\n * @param resource\n */\nexport async function makeResponse(resource: any): Promise<Response> {\n  if (isResponse(resource)) {\n    return resource;\n  }\n\n  // Add content-length header if possible\n  const headers: {[header: string]: string} = {};\n\n  const contentLength = getResourceContentLength(resource);\n  if (contentLength >= 0) {\n    headers['content-length'] = String(contentLength);\n  }\n\n  // `new Response(File)` does not preserve content-type and URL\n  // so we add them here\n  const {url, type} = getResourceUrlAndType(resource);\n  if (type) {\n    headers['content-type'] = type;\n  }\n\n  // Add a custom header with initial bytes if available\n  const initialDataUrl = await getInitialDataUrl(resource);\n  if (initialDataUrl) {\n    headers['x-first-bytes'] = initialDataUrl;\n  }\n\n  // TODO - is this the best way of handling strings?\n  // Maybe package as data URL instead?\n  if (typeof resource === 'string') {\n    // Convert to ArrayBuffer to avoid Response treating it as a URL\n    resource = new TextEncoder().encode(resource);\n  }\n\n  // Attempt to create a Response from the resource, adding headers and setting url\n  const response = new Response(resource, {headers});\n  // We can't control `Response.url` via constructor, use a property override to record URL.\n  Object.defineProperty(response, 'url', {value: url});\n  return response;\n}\n\n/**\n * Checks response status (async) and throws a helpful error message if status is not OK.\n * @param response\n */\nexport async function checkResponse(response: Response): Promise<void> {\n  if (!response.ok) {\n    const message = await getResponseError(response);\n    throw new Error(message);\n  }\n}\n\n/**\n * Checks response status (sync) and throws a helpful error message if status is not OK.\n * @param response\n */\nexport function checkResponseSync(response: Response): void {\n  if (!response.ok) {\n    let message = `${response.status} ${response.statusText}`;\n    message = message.length > 60 ? `${message.slice(60)}...` : message;\n    throw new Error(message);\n  }\n}\n\n// HELPERS\n\nasync function getResponseError(response): Promise<string> {\n  let message = `Failed to fetch resource ${response.url} (${response.status}): `;\n  try {\n    const contentType = response.headers.get('Content-Type');\n    let text = response.statusText;\n    if (contentType.includes('application/json')) {\n      text += ` ${await response.text()}`;\n    }\n    message += text;\n    message = message.length > 60 ? `${message.slice(60)}...` : message;\n  } catch (error) {\n    // eslint forbids return in a finally statement, so we just catch here\n  }\n  return message;\n}\n\nasync function getInitialDataUrl(resource): Promise<string | null> {\n  const INITIAL_DATA_LENGTH = 5;\n  if (typeof resource === 'string') {\n    return `data:,${resource.slice(0, INITIAL_DATA_LENGTH)}`;\n  }\n  if (resource instanceof Blob) {\n    const blobSlice = resource.slice(0, 5);\n    return await new Promise((resolve) => {\n      const reader = new FileReader();\n      reader.onload = (event) => resolve(event?.target?.result as string);\n      reader.readAsDataURL(blobSlice);\n    });\n  }\n  if (resource instanceof ArrayBuffer) {\n    const slice = resource.slice(0, INITIAL_DATA_LENGTH);\n    const base64 = arrayBufferToBase64(slice);\n    return `data:base64,${base64}`;\n  }\n  return null;\n}\n\n// https://stackoverflow.com/questions/9267899/arraybuffer-to-base64-encoded-string\nfunction arrayBufferToBase64(buffer) {\n  let binary = '';\n  const bytes = new Uint8Array(buffer);\n  for (let i = 0; i < bytes.byteLength; i++) {\n    binary += String.fromCharCode(bytes[i]);\n  }\n  return btoa(binary);\n}\n"]},"metadata":{},"sourceType":"module"}