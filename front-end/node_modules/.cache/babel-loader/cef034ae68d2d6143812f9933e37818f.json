{"ast":null,"code":"import { getMeshBoundingBox } from '@loaders.gl/schema';\nimport decode, { DECODING_STEPS } from './decode-quantized-mesh';\nimport { addSkirt } from './helpers/skirt';\n\nfunction getMeshAttributes(vertexData, header, bounds) {\n  const {\n    minHeight,\n    maxHeight\n  } = header;\n  const [minX, minY, maxX, maxY] = bounds || [0, 0, 1, 1];\n  const xScale = maxX - minX;\n  const yScale = maxY - minY;\n  const zScale = maxHeight - minHeight;\n  const nCoords = vertexData.length / 3;\n  const positions = new Float32Array(nCoords * 3);\n  const texCoords = new Float32Array(nCoords * 2);\n\n  for (let i = 0; i < nCoords; i++) {\n    const x = vertexData[i] / 32767;\n    const y = vertexData[i + nCoords] / 32767;\n    const z = vertexData[i + nCoords * 2] / 32767;\n    positions[3 * i + 0] = x * xScale + minX;\n    positions[3 * i + 1] = y * yScale + minY;\n    positions[3 * i + 2] = z * zScale + minHeight;\n    texCoords[2 * i + 0] = x;\n    texCoords[2 * i + 1] = y;\n  }\n\n  return {\n    POSITION: {\n      value: positions,\n      size: 3\n    },\n    TEXCOORD_0: {\n      value: texCoords,\n      size: 2\n    }\n  };\n}\n\nfunction getTileMesh(arrayBuffer, options) {\n  if (!arrayBuffer) {\n    return null;\n  }\n\n  const {\n    bounds\n  } = options;\n  const {\n    header,\n    vertexData,\n    triangleIndices: originalTriangleIndices,\n    westIndices,\n    northIndices,\n    eastIndices,\n    southIndices\n  } = decode(arrayBuffer, DECODING_STEPS.triangleIndices);\n  let triangleIndices = originalTriangleIndices;\n  let attributes = getMeshAttributes(vertexData, header, bounds);\n  const boundingBox = getMeshBoundingBox(attributes);\n\n  if (options.skirtHeight) {\n    const {\n      attributes: newAttributes,\n      triangles: newTriangles\n    } = addSkirt(attributes, triangleIndices, options.skirtHeight, {\n      westIndices,\n      northIndices,\n      eastIndices,\n      southIndices\n    });\n    attributes = newAttributes;\n    triangleIndices = newTriangles;\n  }\n\n  return {\n    loaderData: {\n      header: {}\n    },\n    header: {\n      vertexCount: triangleIndices.length,\n      boundingBox\n    },\n    mode: 4,\n    indices: {\n      value: triangleIndices,\n      size: 1\n    },\n    attributes\n  };\n}\n\nexport default function loadQuantizedMesh(arrayBuffer, options) {\n  return getTileMesh(arrayBuffer, options['quantized-mesh']);\n}","map":{"version":3,"sources":["../../../src/lib/parse-quantized-mesh.js"],"names":["maxHeight","bounds","xScale","maxX","yScale","maxY","zScale","nCoords","vertexData","positions","texCoords","i","x","y","z","POSITION","value","size","TEXCOORD_0","triangleIndices","southIndices","decode","DECODING_STEPS","attributes","getMeshAttributes","boundingBox","getMeshBoundingBox","options","triangles","newTriangles","addSkirt","loaderData","header","vertexCount","mode","indices","getTileMesh"],"mappings":"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","sourcesContent":["import {getMeshBoundingBox} from '@loaders.gl/schema';\nimport decode, {DECODING_STEPS} from './decode-quantized-mesh';\nimport {addSkirt} from './helpers/skirt';\n\nfunction getMeshAttributes(vertexData, header, bounds) {\n  const {minHeight, maxHeight} = header;\n  const [minX, minY, maxX, maxY] = bounds || [0, 0, 1, 1];\n  const xScale = maxX - minX;\n  const yScale = maxY - minY;\n  const zScale = maxHeight - minHeight;\n\n  const nCoords = vertexData.length / 3;\n  // vec3. x, y defined by bounds, z in meters\n  const positions = new Float32Array(nCoords * 3);\n\n  // vec2. 1 to 1 relationship with position. represents the uv on the texture image. 0,0 to 1,1.\n  const texCoords = new Float32Array(nCoords * 2);\n\n  // Data is not interleaved; all u, then all v, then all heights\n  for (let i = 0; i < nCoords; i++) {\n    const x = vertexData[i] / 32767;\n    const y = vertexData[i + nCoords] / 32767;\n    const z = vertexData[i + nCoords * 2] / 32767;\n\n    positions[3 * i + 0] = x * xScale + minX;\n    positions[3 * i + 1] = y * yScale + minY;\n    positions[3 * i + 2] = z * zScale + minHeight;\n\n    texCoords[2 * i + 0] = x;\n    texCoords[2 * i + 1] = y;\n  }\n\n  return {\n    POSITION: {value: positions, size: 3},\n    TEXCOORD_0: {value: texCoords, size: 2}\n    // TODO: Parse normals if they exist in the file\n    // NORMAL: {}, - optional, but creates the high poly look with lighting\n  };\n}\n\nfunction getTileMesh(arrayBuffer, options) {\n  if (!arrayBuffer) {\n    return null;\n  }\n  const {bounds} = options;\n  // Don't parse edge indices or format extensions\n  const {\n    header,\n    vertexData,\n    triangleIndices: originalTriangleIndices,\n    westIndices,\n    northIndices,\n    eastIndices,\n    southIndices\n  } = decode(arrayBuffer, DECODING_STEPS.triangleIndices);\n  let triangleIndices = originalTriangleIndices;\n  let attributes = getMeshAttributes(vertexData, header, bounds);\n\n  // Compute bounding box before adding skirt so that z values are not skewed\n  // TODO: Find bounding box from header, instead of doing extra pass over\n  // vertices.\n  const boundingBox = getMeshBoundingBox(attributes);\n\n  if (options.skirtHeight) {\n    const {attributes: newAttributes, triangles: newTriangles} = addSkirt(\n      attributes,\n      triangleIndices,\n      options.skirtHeight,\n      {\n        westIndices,\n        northIndices,\n        eastIndices,\n        southIndices\n      }\n    );\n    attributes = newAttributes;\n    triangleIndices = newTriangles;\n  }\n\n  return {\n    // Data return by this loader implementation\n    loaderData: {\n      header: {}\n    },\n    header: {\n      // @ts-ignore\n      vertexCount: triangleIndices.length,\n      boundingBox\n    },\n    mode: 4, // TRIANGLES\n    indices: {value: triangleIndices, size: 1},\n    attributes\n  };\n}\n\nexport default function loadQuantizedMesh(arrayBuffer, options) {\n  return getTileMesh(arrayBuffer, options['quantized-mesh']);\n}\n"]},"metadata":{},"sourceType":"module"}