{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { getBinaryImageMetadata } from '@loaders.gl/images';\nimport { padToNBytes, copyToArray } from '@loaders.gl/loader-utils';\nimport { assert } from '../utils/assert';\nimport { getAccessorArrayTypeAndLength, getAccessorTypeFromSize, getComponentTypeFromArray } from '../gltf-utils/gltf-utils';\nconst DEFAULT_GLTF_JSON = {\n  asset: {\n    version: '2.0',\n    generator: 'loaders.gl'\n  },\n  buffers: []\n};\nexport default class GLTFScenegraph {\n  constructor(gltf) {\n    _defineProperty(this, \"gltf\", void 0);\n\n    _defineProperty(this, \"sourceBuffers\", void 0);\n\n    _defineProperty(this, \"byteLength\", void 0);\n\n    this.gltf = gltf || {\n      json: { ...DEFAULT_GLTF_JSON\n      },\n      buffers: []\n    };\n    this.sourceBuffers = [];\n    this.byteLength = 0;\n\n    if (this.gltf.buffers && this.gltf.buffers[0]) {\n      this.byteLength = this.gltf.buffers[0].byteLength;\n      this.sourceBuffers = [this.gltf.buffers[0]];\n    }\n  }\n\n  get json() {\n    return this.gltf.json;\n  }\n\n  getApplicationData(key) {\n    const data = this.json[key];\n    return data;\n  }\n\n  getExtraData(key) {\n    const extras = this.json.extras || {};\n    return extras[key];\n  }\n\n  getExtension(extensionName) {\n    const isExtension = this.getUsedExtensions().find(name => name === extensionName);\n    const extensions = this.json.extensions || {};\n    return isExtension ? extensions[extensionName] || true : null;\n  }\n\n  getRequiredExtension(extensionName) {\n    const isRequired = this.getRequiredExtensions().find(name => name === extensionName);\n    return isRequired ? this.getExtension(extensionName) : null;\n  }\n\n  getRequiredExtensions() {\n    return this.json.extensionsRequired || [];\n  }\n\n  getUsedExtensions() {\n    return this.json.extensionsUsed || [];\n  }\n\n  getObjectExtension(object, extensionName) {\n    const extensions = object.extensions || {};\n    return extensions[extensionName];\n  }\n\n  getScene(index) {\n    return this.getObject('scenes', index);\n  }\n\n  getNode(index) {\n    return this.getObject('nodes', index);\n  }\n\n  getSkin(index) {\n    return this.getObject('skins', index);\n  }\n\n  getMesh(index) {\n    return this.getObject('meshes', index);\n  }\n\n  getMaterial(index) {\n    return this.getObject('materials', index);\n  }\n\n  getAccessor(index) {\n    return this.getObject('accessors', index);\n  }\n\n  getTexture(index) {\n    return this.getObject('textures', index);\n  }\n\n  getSampler(index) {\n    return this.getObject('samplers', index);\n  }\n\n  getImage(index) {\n    return this.getObject('images', index);\n  }\n\n  getBufferView(index) {\n    return this.getObject('bufferViews', index);\n  }\n\n  getBuffer(index) {\n    return this.getObject('buffers', index);\n  }\n\n  getObject(array, index) {\n    if (typeof index === 'object') {\n      return index;\n    }\n\n    const object = this.json[array] && this.json[array][index];\n\n    if (!object) {\n      throw new Error(\"glTF file error: Could not find \".concat(array, \"[\").concat(index, \"]\"));\n    }\n\n    return object;\n  }\n\n  getTypedArrayForBufferView(bufferView) {\n    bufferView = this.getBufferView(bufferView);\n    const bufferIndex = bufferView.buffer;\n    const binChunk = this.gltf.buffers[bufferIndex];\n    assert(binChunk);\n    const byteOffset = (bufferView.byteOffset || 0) + binChunk.byteOffset;\n    return new Uint8Array(binChunk.arrayBuffer, byteOffset, bufferView.byteLength);\n  }\n\n  getTypedArrayForAccessor(accessor) {\n    accessor = this.getAccessor(accessor);\n    const bufferView = this.getBufferView(accessor.bufferView);\n    const buffer = this.getBuffer(bufferView.buffer);\n    const arrayBuffer = buffer.data;\n    const {\n      ArrayType,\n      length\n    } = getAccessorArrayTypeAndLength(accessor, bufferView);\n    const byteOffset = bufferView.byteOffset + accessor.byteOffset;\n    return new ArrayType(arrayBuffer, byteOffset, length);\n  }\n\n  getTypedArrayForImageData(image) {\n    image = this.getAccessor(image);\n    const bufferView = this.getBufferView(image.bufferView);\n    const buffer = this.getBuffer(bufferView.buffer);\n    const arrayBuffer = buffer.data;\n    const byteOffset = bufferView.byteOffset || 0;\n    return new Uint8Array(arrayBuffer, byteOffset, bufferView.byteLength);\n  }\n\n  addApplicationData(key, data) {\n    this.json[key] = data;\n    return this;\n  }\n\n  addExtraData(key, data) {\n    this.json.extras = this.json.extras || {};\n    this.json.extras[key] = data;\n    return this;\n  }\n\n  addObjectExtension(object, extensionName, data) {\n    object.extensions = object.extensions || {};\n    object.extensions[extensionName] = data;\n    this.registerUsedExtension(extensionName);\n    return this;\n  }\n\n  setObjectExtension(object, extensionName, data) {\n    const extensions = object.extensions || {};\n    extensions[extensionName] = data;\n  }\n\n  removeObjectExtension(object, extensionName) {\n    const extensions = object.extensions || {};\n    const extension = extensions[extensionName];\n    delete extensions[extensionName];\n    return extension;\n  }\n\n  addExtension(extensionName) {\n    let extensionData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    assert(extensionData);\n    this.json.extensions = this.json.extensions || {};\n    this.json.extensions[extensionName] = extensionData;\n    this.registerUsedExtension(extensionName);\n    return extensionData;\n  }\n\n  addRequiredExtension(extensionName) {\n    let extensionData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    assert(extensionData);\n    this.addExtension(extensionName, extensionData);\n    this.registerRequiredExtension(extensionName);\n    return extensionData;\n  }\n\n  registerUsedExtension(extensionName) {\n    this.json.extensionsUsed = this.json.extensionsUsed || [];\n\n    if (!this.json.extensionsUsed.find(ext => ext === extensionName)) {\n      this.json.extensionsUsed.push(extensionName);\n    }\n  }\n\n  registerRequiredExtension(extensionName) {\n    this.registerUsedExtension(extensionName);\n    this.json.extensionsRequired = this.json.extensionsRequired || [];\n\n    if (!this.json.extensionsRequired.find(ext => ext === extensionName)) {\n      this.json.extensionsRequired.push(extensionName);\n    }\n  }\n\n  removeExtension(extensionName) {\n    if (this.json.extensionsRequired) {\n      this._removeStringFromArray(this.json.extensionsRequired, extensionName);\n    }\n\n    if (this.json.extensionsUsed) {\n      this._removeStringFromArray(this.json.extensionsUsed, extensionName);\n    }\n\n    if (this.json.extensions) {\n      delete this.json.extensions[extensionName];\n    }\n  }\n\n  setDefaultScene(sceneIndex) {\n    this.json.scene = sceneIndex;\n  }\n\n  addScene(scene) {\n    const {\n      nodeIndices\n    } = scene;\n    this.json.scenes = this.json.scenes || [];\n    this.json.scenes.push({\n      nodes: nodeIndices\n    });\n    return this.json.scenes.length - 1;\n  }\n\n  addNode(node) {\n    const {\n      meshIndex,\n      matrix\n    } = node;\n    this.json.nodes = this.json.nodes || [];\n    const nodeData = {\n      mesh: meshIndex\n    };\n\n    if (matrix) {\n      nodeData.matrix = matrix;\n    }\n\n    this.json.nodes.push(nodeData);\n    return this.json.nodes.length - 1;\n  }\n\n  addMesh(mesh) {\n    const {\n      attributes,\n      indices,\n      material,\n      mode = 4\n    } = mesh;\n\n    const accessors = this._addAttributes(attributes);\n\n    const glTFMesh = {\n      primitives: [{\n        attributes: accessors,\n        mode\n      }]\n    };\n\n    if (indices) {\n      const indicesAccessor = this._addIndices(indices);\n\n      glTFMesh.primitives[0].indices = indicesAccessor;\n    }\n\n    if (Number.isFinite(material)) {\n      glTFMesh.primitives[0].material = material;\n    }\n\n    this.json.meshes = this.json.meshes || [];\n    this.json.meshes.push(glTFMesh);\n    return this.json.meshes.length - 1;\n  }\n\n  addPointCloud(attributes) {\n    const accessorIndices = this._addAttributes(attributes);\n\n    const glTFMesh = {\n      primitives: [{\n        attributes: accessorIndices,\n        mode: 0\n      }]\n    };\n    this.json.meshes = this.json.meshes || [];\n    this.json.meshes.push(glTFMesh);\n    return this.json.meshes.length - 1;\n  }\n\n  addImage(imageData, mimeTypeOpt) {\n    const metadata = getBinaryImageMetadata(imageData);\n    const mimeType = mimeTypeOpt || (metadata === null || metadata === void 0 ? void 0 : metadata.mimeType);\n    const bufferViewIndex = this.addBufferView(imageData);\n    const glTFImage = {\n      bufferView: bufferViewIndex,\n      mimeType\n    };\n    this.json.images = this.json.images || [];\n    this.json.images.push(glTFImage);\n    return this.json.images.length - 1;\n  }\n\n  addBufferView(buffer) {\n    const byteLength = buffer.byteLength;\n    assert(Number.isFinite(byteLength));\n    this.sourceBuffers = this.sourceBuffers || [];\n    this.sourceBuffers.push(buffer);\n    const glTFBufferView = {\n      buffer: 0,\n      byteOffset: this.byteLength,\n      byteLength\n    };\n    this.byteLength += padToNBytes(byteLength, 4);\n    this.json.bufferViews = this.json.bufferViews || [];\n    this.json.bufferViews.push(glTFBufferView);\n    return this.json.bufferViews.length - 1;\n  }\n\n  addAccessor(bufferViewIndex, accessor) {\n    const glTFAccessor = {\n      bufferView: bufferViewIndex,\n      type: getAccessorTypeFromSize(accessor.size),\n      componentType: accessor.componentType,\n      count: accessor.count,\n      max: accessor.max,\n      min: accessor.min\n    };\n    this.json.accessors = this.json.accessors || [];\n    this.json.accessors.push(glTFAccessor);\n    return this.json.accessors.length - 1;\n  }\n\n  addBinaryBuffer(sourceBuffer) {\n    let accessor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      size: 3\n    };\n    const bufferViewIndex = this.addBufferView(sourceBuffer);\n    let minMax = {\n      min: accessor.min,\n      max: accessor.max\n    };\n\n    if (!minMax.min || !minMax.max) {\n      minMax = this._getAccessorMinMax(sourceBuffer, accessor.size);\n    }\n\n    const accessorDefaults = {\n      size: accessor.size,\n      componentType: getComponentTypeFromArray(sourceBuffer),\n      count: Math.round(sourceBuffer.length / accessor.size),\n      min: minMax.min,\n      max: minMax.max\n    };\n    return this.addAccessor(bufferViewIndex, Object.assign(accessorDefaults, accessor));\n  }\n\n  addTexture(texture) {\n    const {\n      imageIndex\n    } = texture;\n    const glTFTexture = {\n      source: imageIndex\n    };\n    this.json.textures = this.json.textures || [];\n    this.json.textures.push(glTFTexture);\n    return this.json.textures.length - 1;\n  }\n\n  addMaterial(pbrMaterialInfo) {\n    this.json.materials = this.json.materials || [];\n    this.json.materials.push(pbrMaterialInfo);\n    return this.json.materials.length - 1;\n  }\n\n  createBinaryChunk() {\n    var _this$json, _this$json$buffers;\n\n    this.gltf.buffers = [];\n    const totalByteLength = this.byteLength;\n    const arrayBuffer = new ArrayBuffer(totalByteLength);\n    const targetArray = new Uint8Array(arrayBuffer);\n    let dstByteOffset = 0;\n\n    for (const sourceBuffer of this.sourceBuffers || []) {\n      dstByteOffset = copyToArray(sourceBuffer, targetArray, dstByteOffset);\n    }\n\n    if ((_this$json = this.json) !== null && _this$json !== void 0 && (_this$json$buffers = _this$json.buffers) !== null && _this$json$buffers !== void 0 && _this$json$buffers[0]) {\n      this.json.buffers[0].byteLength = totalByteLength;\n    } else {\n      this.json.buffers = [{\n        byteLength: totalByteLength\n      }];\n    }\n\n    this.gltf.binary = arrayBuffer;\n    this.sourceBuffers = [arrayBuffer];\n  }\n\n  _removeStringFromArray(array, string) {\n    let found = true;\n\n    while (found) {\n      const index = array.indexOf(string);\n\n      if (index > -1) {\n        array.splice(index, 1);\n      } else {\n        found = false;\n      }\n    }\n  }\n\n  _addAttributes() {\n    let attributes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const result = {};\n\n    for (const attributeKey in attributes) {\n      const attributeData = attributes[attributeKey];\n\n      const attrName = this._getGltfAttributeName(attributeKey);\n\n      const accessor = this.addBinaryBuffer(attributeData.value, attributeData);\n      result[attrName] = accessor;\n    }\n\n    return result;\n  }\n\n  _addIndices(indices) {\n    return this.addBinaryBuffer(indices, {\n      size: 1\n    });\n  }\n\n  _getGltfAttributeName(attributeName) {\n    switch (attributeName.toLowerCase()) {\n      case 'position':\n      case 'positions':\n      case 'vertices':\n        return 'POSITION';\n\n      case 'normal':\n      case 'normals':\n        return 'NORMAL';\n\n      case 'color':\n      case 'colors':\n        return 'COLOR_0';\n\n      case 'texcoord':\n      case 'texcoords':\n        return 'TEXCOORD_0';\n\n      default:\n        return attributeName;\n    }\n  }\n\n  _getAccessorMinMax(buffer, size) {\n    const result = {\n      min: null,\n      max: null\n    };\n\n    if (buffer.length < size) {\n      return result;\n    }\n\n    result.min = [];\n    result.max = [];\n    const initValues = buffer.subarray(0, size);\n\n    for (const value of initValues) {\n      result.min.push(value);\n      result.max.push(value);\n    }\n\n    for (let index = size; index < buffer.length; index += size) {\n      for (let componentIndex = 0; componentIndex < size; componentIndex++) {\n        result.min[0 + componentIndex] = Math.min(result.min[0 + componentIndex], buffer[index + componentIndex]);\n        result.max[0 + componentIndex] = Math.max(result.max[0 + componentIndex], buffer[index + componentIndex]);\n      }\n    }\n\n    return result;\n  }\n\n}","map":{"version":3,"sources":["../../../../src/lib/api/gltf-scenegraph.ts"],"names":["DEFAULT_GLTF_JSON","asset","version","generator","buffers","constructor","gltf","json","getApplicationData","data","getExtraData","extras","getExtension","isExtension","name","extensions","getRequiredExtension","isRequired","getRequiredExtensions","getUsedExtensions","getObjectExtension","object","getScene","getNode","getSkin","getMesh","getMaterial","getAccessor","getTexture","getSampler","getImage","getBufferView","getBuffer","getObject","getTypedArrayForBufferView","bufferView","bufferIndex","binChunk","assert","byteOffset","getTypedArrayForAccessor","accessor","buffer","arrayBuffer","length","getAccessorArrayTypeAndLength","getTypedArrayForImageData","image","addApplicationData","addExtraData","addObjectExtension","setObjectExtension","removeObjectExtension","extension","addExtension","extensionData","addRequiredExtension","registerUsedExtension","ext","registerRequiredExtension","removeExtension","setDefaultScene","addScene","nodeIndices","nodes","addNode","matrix","nodeData","mesh","meshIndex","addMesh","mode","accessors","glTFMesh","primitives","attributes","indicesAccessor","Number","addPointCloud","accessorIndices","addImage","metadata","getBinaryImageMetadata","mimeType","mimeTypeOpt","bufferViewIndex","glTFImage","addBufferView","byteLength","glTFBufferView","padToNBytes","addAccessor","glTFAccessor","type","getAccessorTypeFromSize","componentType","count","max","min","addBinaryBuffer","size","minMax","accessorDefaults","getComponentTypeFromArray","Math","sourceBuffer","Object","addTexture","imageIndex","glTFTexture","source","addMaterial","createBinaryChunk","totalByteLength","targetArray","dstByteOffset","copyToArray","_removeStringFromArray","found","index","array","_addAttributes","result","attributeData","attrName","_addIndices","_getGltfAttributeName","attributeName","_getAccessorMinMax","initValues","componentIndex"],"mappings":";AAeA,SAAA,sBAAA,QAAA,oBAAA;AACA,SAAA,WAAA,EAAA,WAAA,QAAA,0BAAA;AACA,SAAA,MAAA,QAAA,iBAAA;AACA,SAAA,6BAAA,EAAA,uBAAA,EAAA,yBAAA,QAAA,0BAAA;AAYA,MAAMA,iBAAuB,GAAG;AAC9BC,EAAAA,KAAK,EAAE;AACLC,IAAAA,OAAO,EADF,KAAA;AAELC,IAAAA,SAAS,EAAE;AAFN,GADuB;AAK9BC,EAAAA,OAAO,EAAE;AALqB,CAAhC;AAWA,eAAe,MAAA,cAAA,CAAqB;AAMlCC,EAAAA,WAAW,CAAA,IAAA,EAAuC;AAAA,IAAA,eAAA,CAAA,IAAA,EAAA,MAAA,EAAA,KAAA,CAAA,CAAA;;AAAA,IAAA,eAAA,CAAA,IAAA,EAAA,eAAA,EAAA,KAAA,CAAA,CAAA;;AAAA,IAAA,eAAA,CAAA,IAAA,EAAA,YAAA,EAAA,KAAA,CAAA,CAAA;;AAEhD,SAAA,IAAA,GAAYC,IAAI,IAAI;AAClBC,MAAAA,IAAI,EAAE,EAAC,GAAGP;AAAJ,OADY;AAElBI,MAAAA,OAAO,EAAE;AAFS,KAApB;AAIA,SAAA,aAAA,GAAA,EAAA;AACA,SAAA,UAAA,GAAA,CAAA;;AAGA,QAAI,KAAA,IAAA,CAAA,OAAA,IAAqB,KAAA,IAAA,CAAA,OAAA,CAAzB,CAAyB,CAAzB,EAA+C;AAC7C,WAAA,UAAA,GAAkB,KAAA,IAAA,CAAA,OAAA,CAAA,CAAA,EAAlB,UAAA;AACA,WAAA,aAAA,GAAqB,CAAC,KAAA,IAAA,CAAA,OAAA,CAAtB,CAAsB,CAAD,CAArB;AACD;AACF;;AAIO,MAAJG,IAAI,GAAS;AACf,WAAO,KAAA,IAAA,CAAP,IAAA;AACD;;AAEDC,EAAAA,kBAAkB,CAAA,GAAA,EAAoC;AAEpD,UAAMC,IAAI,GAAG,KAAA,IAAA,CAAb,GAAa,CAAb;AACA,WAAA,IAAA;AACD;;AAEDC,EAAAA,YAAY,CAAA,GAAA,EAAoC;AAE9C,UAAMC,MAAM,GAAG,KAAA,IAAA,CAAA,MAAA,IAAf,EAAA;AACA,WAAOA,MAAM,CAAb,GAAa,CAAb;AACD;;AAEDC,EAAAA,YAAY,CAAA,aAAA,EAAqD;AAC/D,UAAMC,WAAW,GAAG,KAAA,iBAAA,GAAA,IAAA,CAA+BC,IAAD,IAAUA,IAAI,KAAhE,aAAoB,CAApB;AACA,UAAMC,UAAU,GAAG,KAAA,IAAA,CAAA,UAAA,IAAnB,EAAA;AACA,WAAOF,WAAW,GAAGE,UAAU,CAAVA,aAAU,CAAVA,IAAH,IAAA,GAAlB,IAAA;AACD;;AAEDC,EAAAA,oBAAoB,CAAA,aAAA,EAAqD;AACvE,UAAMC,UAAU,GAAG,KAAA,qBAAA,GAAA,IAAA,CAAmCH,IAAD,IAAUA,IAAI,KAAnE,aAAmB,CAAnB;AACA,WAAOG,UAAU,GAAG,KAAA,YAAA,CAAH,aAAG,CAAH,GAAjB,IAAA;AACD;;AAEDC,EAAAA,qBAAqB,GAAa;AAChC,WAAO,KAAA,IAAA,CAAA,kBAAA,IAAP,EAAA;AACD;;AAEDC,EAAAA,iBAAiB,GAAa;AAC5B,WAAO,KAAA,IAAA,CAAA,cAAA,IAAP,EAAA;AACD;;AAEDC,EAAAA,kBAAkB,CAAA,MAAA,EAAA,aAAA,EAGa;AAC7B,UAAML,UAAU,GAAGM,MAAM,CAANA,UAAAA,IAAnB,EAAA;AACA,WAAON,UAAU,CAAjB,aAAiB,CAAjB;AACD;;AAEDO,EAAAA,QAAQ,CAAA,KAAA,EAA2B;AACjC,WAAO,KAAA,SAAA,CAAA,QAAA,EAAP,KAAO,CAAP;AACD;;AAEDC,EAAAA,OAAO,CAAA,KAAA,EAA0B;AAC/B,WAAO,KAAA,SAAA,CAAA,OAAA,EAAP,KAAO,CAAP;AACD;;AAEDC,EAAAA,OAAO,CAAA,KAAA,EAA0B;AAC/B,WAAO,KAAA,SAAA,CAAA,OAAA,EAAP,KAAO,CAAP;AACD;;AAEDC,EAAAA,OAAO,CAAA,KAAA,EAA0B;AAC/B,WAAO,KAAA,SAAA,CAAA,QAAA,EAAP,KAAO,CAAP;AACD;;AAEDC,EAAAA,WAAW,CAAA,KAAA,EAA8B;AACvC,WAAO,KAAA,SAAA,CAAA,WAAA,EAAP,KAAO,CAAP;AACD;;AAEDC,EAAAA,WAAW,CAAA,KAAA,EAA8B;AACvC,WAAO,KAAA,SAAA,CAAA,WAAA,EAAP,KAAO,CAAP;AACD;;AAMDC,EAAAA,UAAU,CAAA,KAAA,EAA6B;AACrC,WAAO,KAAA,SAAA,CAAA,UAAA,EAAP,KAAO,CAAP;AACD;;AAEDC,EAAAA,UAAU,CAAA,KAAA,EAA6B;AACrC,WAAO,KAAA,SAAA,CAAA,UAAA,EAAP,KAAO,CAAP;AACD;;AAEDC,EAAAA,QAAQ,CAAA,KAAA,EAA2B;AACjC,WAAO,KAAA,SAAA,CAAA,QAAA,EAAP,KAAO,CAAP;AACD;;AAEDC,EAAAA,aAAa,CAAA,KAAA,EAAyC;AACpD,WAAO,KAAA,SAAA,CAAA,aAAA,EAAP,KAAO,CAAP;AACD;;AAEDC,EAAAA,SAAS,CAAA,KAAA,EAA4B;AACnC,WAAO,KAAA,SAAA,CAAA,SAAA,EAAP,KAAO,CAAP;AACD;;AAEDC,EAAAA,SAAS,CAAA,KAAA,EAAA,KAAA,EAAgD;AAEvD,QAAI,OAAA,KAAA,KAAJ,QAAA,EAA+B;AAC7B,aAAA,KAAA;AACD;;AACD,UAAMZ,MAAM,GAAG,KAAA,IAAA,CAAA,KAAA,KAAoB,KAAA,IAAA,CAAA,KAAA,EAAnC,KAAmC,CAAnC;;AACA,QAAI,CAAJ,MAAA,EAAa;AACX,YAAM,IAAA,KAAA,CAAA,mCAAA,MAAA,CAAA,KAAA,EAAA,GAAA,EAAA,MAAA,CAAA,KAAA,EAAN,GAAM,CAAA,CAAN;AACD;;AACD,WAAA,MAAA;AACD;;AAMDa,EAAAA,0BAA0B,CAAA,UAAA,EAA0C;AAClEC,IAAAA,UAAU,GAAG,KAAA,aAAA,CAAbA,UAAa,CAAbA;AAEA,UAAMC,WAAW,GAAGD,UAAU,CAA9B,MAAA;AAIA,UAAME,QAAQ,GAAG,KAAA,IAAA,CAAA,OAAA,CAAjB,WAAiB,CAAjB;AACAC,IAAAA,MAAM,CAANA,QAAM,CAANA;AAGA,UAAMC,UAAU,GAAG,CAACJ,UAAU,CAAVA,UAAAA,IAAD,CAAA,IAA+BE,QAAQ,CAA1D,UAAA;AAEA,WAAO,IAAA,UAAA,CAAeA,QAAQ,CAAvB,WAAA,EAAA,UAAA,EAAiDF,UAAU,CAAlE,UAAO,CAAP;AACD;;AAKDK,EAAAA,wBAAwB,CAAA,QAAA,EAAiC;AAEvDC,IAAAA,QAAQ,GAAG,KAAA,WAAA,CAAXA,QAAW,CAAXA;AAEA,UAAMN,UAAU,GAAG,KAAA,aAAA,CAAmBM,QAAQ,CAA9C,UAAmB,CAAnB;AACA,UAAMC,MAAM,GAAG,KAAA,SAAA,CAAeP,UAAU,CAAxC,MAAe,CAAf;AAEA,UAAMQ,WAAW,GAAGD,MAAM,CAA1B,IAAA;AAGA,UAAM;AAAA,MAAA,SAAA;AAAYE,MAAAA;AAAZ,QAAsBC,6BAA6B,CAAA,QAAA,EAAzD,UAAyD,CAAzD;AAEA,UAAMN,UAAU,GAAGJ,UAAU,CAAVA,UAAAA,GAAwBM,QAAQ,CAAnD,UAAA;AACA,WAAO,IAAA,SAAA,CAAA,WAAA,EAAA,UAAA,EAAP,MAAO,CAAP;AACD;;AAKDK,EAAAA,yBAAyB,CAAA,KAAA,EAAqC;AAE5DC,IAAAA,KAAK,GAAG,KAAA,WAAA,CAARA,KAAQ,CAARA;AAEA,UAAMZ,UAAU,GAAG,KAAA,aAAA,CAAmBY,KAAK,CAA3C,UAAmB,CAAnB;AACA,UAAML,MAAM,GAAG,KAAA,SAAA,CAAeP,UAAU,CAAxC,MAAe,CAAf;AAEA,UAAMQ,WAAW,GAAGD,MAAM,CAA1B,IAAA;AAEA,UAAMH,UAAU,GAAGJ,UAAU,CAAVA,UAAAA,IAAnB,CAAA;AACA,WAAO,IAAA,UAAA,CAAA,WAAA,EAAA,UAAA,EAAwCA,UAAU,CAAzD,UAAO,CAAP;AACD;;AAODa,EAAAA,kBAAkB,CAAA,GAAA,EAAA,IAAA,EAA4C;AAC5D,SAAA,IAAA,CAAA,GAAA,IAAA,IAAA;AACA,WAAA,IAAA;AACD;;AAKDC,EAAAA,YAAY,CAAA,GAAA,EAAA,IAAA,EAA4C;AACtD,SAAA,IAAA,CAAA,MAAA,GAAmB,KAAA,IAAA,CAAA,MAAA,IAAnB,EAAA;AACA,SAAA,IAAA,CAAA,MAAA,CAAA,GAAA,IAAA,IAAA;AACA,WAAA,IAAA;AACD;;AAEDC,EAAAA,kBAAkB,CAAA,MAAA,EAAA,aAAA,EAAA,IAAA,EAAsE;AAEtF7B,IAAAA,MAAM,CAANA,UAAAA,GAAoBA,MAAM,CAANA,UAAAA,IAApBA,EAAAA;AAGAA,IAAAA,MAAM,CAANA,UAAAA,CAAAA,aAAAA,IAAAA,IAAAA;AACA,SAAA,qBAAA,CAAA,aAAA;AACA,WAAA,IAAA;AACD;;AAED8B,EAAAA,kBAAkB,CAAA,MAAA,EAAA,aAAA,EAAA,IAAA,EAA4D;AAE5E,UAAMpC,UAAU,GAAGM,MAAM,CAANA,UAAAA,IAAnB,EAAA;AACAN,IAAAA,UAAU,CAAVA,aAAU,CAAVA,GAAAA,IAAAA;AAED;;AAEDqC,EAAAA,qBAAqB,CAAA,MAAA,EAAA,aAAA,EAAgD;AAEnE,UAAMrC,UAAU,GAAGM,MAAM,CAANA,UAAAA,IAAnB,EAAA;AACA,UAAMgC,SAAS,GAAGtC,UAAU,CAA5B,aAA4B,CAA5B;AACA,WAAOA,UAAU,CAAjB,aAAiB,CAAjB;AACA,WAAA,SAAA;AACD;;AAKDuC,EAAAA,YAAY,CAAA,aAAA,EAA4D;AAAA,QAApCC,aAAoC,uEAA5D,EAA4D;AACtEjB,IAAAA,MAAM,CAANA,aAAM,CAANA;AACA,SAAA,IAAA,CAAA,UAAA,GAAuB,KAAA,IAAA,CAAA,UAAA,IAAvB,EAAA;AACA,SAAA,IAAA,CAAA,UAAA,CAAA,aAAA,IAAA,aAAA;AACA,SAAA,qBAAA,CAAA,aAAA;AACA,WAAA,aAAA;AACD;;AAKDkB,EAAAA,oBAAoB,CAAA,aAAA,EAAoD;AAAA,QAApCD,aAAoC,uEAApD,EAAoD;AACtEjB,IAAAA,MAAM,CAANA,aAAM,CAANA;AACA,SAAA,YAAA,CAAA,aAAA,EAAA,aAAA;AACA,SAAA,yBAAA,CAAA,aAAA;AACA,WAAA,aAAA;AACD;;AAKDmB,EAAAA,qBAAqB,CAAA,aAAA,EAA8B;AACjD,SAAA,IAAA,CAAA,cAAA,GAA2B,KAAA,IAAA,CAAA,cAAA,IAA3B,EAAA;;AACA,QAAI,CAAC,KAAA,IAAA,CAAA,cAAA,CAAA,IAAA,CAA+BC,GAAD,IAASA,GAAG,KAA/C,aAAK,CAAL,EAAoE;AAClE,WAAA,IAAA,CAAA,cAAA,CAAA,IAAA,CAAA,aAAA;AACD;AACF;;AAKDC,EAAAA,yBAAyB,CAAA,aAAA,EAA8B;AACrD,SAAA,qBAAA,CAAA,aAAA;AACA,SAAA,IAAA,CAAA,kBAAA,GAA+B,KAAA,IAAA,CAAA,kBAAA,IAA/B,EAAA;;AACA,QAAI,CAAC,KAAA,IAAA,CAAA,kBAAA,CAAA,IAAA,CAAmCD,GAAD,IAASA,GAAG,KAAnD,aAAK,CAAL,EAAwE;AACtE,WAAA,IAAA,CAAA,kBAAA,CAAA,IAAA,CAAA,aAAA;AACD;AACF;;AAKDE,EAAAA,eAAe,CAAA,aAAA,EAA8B;AAC3C,QAAI,KAAA,IAAA,CAAJ,kBAAA,EAAkC;AAChC,WAAA,sBAAA,CAA4B,KAAA,IAAA,CAA5B,kBAAA,EAAA,aAAA;AACD;;AACD,QAAI,KAAA,IAAA,CAAJ,cAAA,EAA8B;AAC5B,WAAA,sBAAA,CAA4B,KAAA,IAAA,CAA5B,cAAA,EAAA,aAAA;AACD;;AACD,QAAI,KAAA,IAAA,CAAJ,UAAA,EAA0B;AACxB,aAAO,KAAA,IAAA,CAAA,UAAA,CAAP,aAAO,CAAP;AACD;AACF;;AAKDC,EAAAA,eAAe,CAAA,UAAA,EAA2B;AACxC,SAAA,IAAA,CAAA,KAAA,GAAA,UAAA;AACD;;AAODC,EAAAA,QAAQ,CAAA,KAAA,EAAyC;AAC/C,UAAM;AAACC,MAAAA;AAAD,QAAN,KAAA;AACA,SAAA,IAAA,CAAA,MAAA,GAAmB,KAAA,IAAA,CAAA,MAAA,IAAnB,EAAA;AACA,SAAA,IAAA,CAAA,MAAA,CAAA,IAAA,CAAsB;AAACC,MAAAA,KAAK,EAAED;AAAR,KAAtB;AACA,WAAO,KAAA,IAAA,CAAA,MAAA,CAAA,MAAA,GAAP,CAAA;AACD;;AAODE,EAAAA,OAAO,CAAA,IAAA,EAAsD;AAC3D,UAAM;AAAA,MAAA,SAAA;AAAYC,MAAAA;AAAZ,QAAN,IAAA;AACA,SAAA,IAAA,CAAA,KAAA,GAAkB,KAAA,IAAA,CAAA,KAAA,IAAlB,EAAA;AACA,UAAMC,QAAQ,GAAG;AAACC,MAAAA,IAAI,EAAEC;AAAP,KAAjB;;AACA,QAAA,MAAA,EAAY;AAEVF,MAAAA,QAAQ,CAARA,MAAAA,GAAAA,MAAAA;AACD;;AACD,SAAA,IAAA,CAAA,KAAA,CAAA,IAAA,CAAA,QAAA;AACA,WAAO,KAAA,IAAA,CAAA,KAAA,CAAA,MAAA,GAAP,CAAA;AACD;;AAGDG,EAAAA,OAAO,CAAA,IAAA,EAAsF;AAC3F,UAAM;AAAA,MAAA,UAAA;AAAA,MAAA,OAAA;AAAA,MAAA,QAAA;AAAgCC,MAAAA,IAAI,GAAG;AAAvC,QAAN,IAAA;;AACA,UAAMC,SAAS,GAAG,KAAA,cAAA,CAAlB,UAAkB,CAAlB;;AAEA,UAAMC,QAAQ,GAAG;AACfC,MAAAA,UAAU,EAAE,CACV;AACEC,QAAAA,UAAU,EADZ,SAAA;AAEEJ,QAAAA;AAFF,OADU;AADG,KAAjB;;AASA,QAAA,OAAA,EAAa;AACX,YAAMK,eAAe,GAAG,KAAA,WAAA,CAAxB,OAAwB,CAAxB;;AAEAH,MAAAA,QAAQ,CAARA,UAAAA,CAAAA,CAAAA,EAAAA,OAAAA,GAAAA,eAAAA;AACD;;AAED,QAAII,MAAM,CAANA,QAAAA,CAAJ,QAAIA,CAAJ,EAA+B;AAE7BJ,MAAAA,QAAQ,CAARA,UAAAA,CAAAA,CAAAA,EAAAA,QAAAA,GAAAA,QAAAA;AACD;;AAED,SAAA,IAAA,CAAA,MAAA,GAAmB,KAAA,IAAA,CAAA,MAAA,IAAnB,EAAA;AACA,SAAA,IAAA,CAAA,MAAA,CAAA,IAAA,CAAA,QAAA;AACA,WAAO,KAAA,IAAA,CAAA,MAAA,CAAA,MAAA,GAAP,CAAA;AACD;;AAEDK,EAAAA,aAAa,CAAA,UAAA,EAA6B;AAExC,UAAMC,eAAe,GAAG,KAAA,cAAA,CAAxB,UAAwB,CAAxB;;AAEA,UAAMN,QAAQ,GAAG;AACfC,MAAAA,UAAU,EAAE,CACV;AACEC,QAAAA,UAAU,EADZ,eAAA;AAEEJ,QAAAA,IAAI,EAAE;AAFR,OADU;AADG,KAAjB;AASA,SAAA,IAAA,CAAA,MAAA,GAAmB,KAAA,IAAA,CAAA,MAAA,IAAnB,EAAA;AACA,SAAA,IAAA,CAAA,MAAA,CAAA,IAAA,CAAA,QAAA;AACA,WAAO,KAAA,IAAA,CAAA,MAAA,CAAA,MAAA,GAAP,CAAA;AACD;;AASDS,EAAAA,QAAQ,CAAA,SAAA,EAAA,WAAA,EAA+C;AAIrD,UAAMC,QAAQ,GAAGC,sBAAsB,CAAvC,SAAuC,CAAvC;AACA,UAAMC,QAAQ,GAAGC,WAAW,KAAIH,QAAJ,KAAA,IAAIA,IAAAA,QAAJ,KAAA,KAAA,CAAIA,GAAJ,KAAA,CAAIA,GAAAA,QAAQ,CAAxC,QAA4B,CAA5B;AAEA,UAAMI,eAAe,GAAG,KAAA,aAAA,CAAxB,SAAwB,CAAxB;AAEA,UAAMC,SAAS,GAAG;AAChBnD,MAAAA,UAAU,EADM,eAAA;AAEhBgD,MAAAA;AAFgB,KAAlB;AAKA,SAAA,IAAA,CAAA,MAAA,GAAmB,KAAA,IAAA,CAAA,MAAA,IAAnB,EAAA;AACA,SAAA,IAAA,CAAA,MAAA,CAAA,IAAA,CAAA,SAAA;AACA,WAAO,KAAA,IAAA,CAAA,MAAA,CAAA,MAAA,GAAP,CAAA;AACD;;AAMDI,EAAAA,aAAa,CAAA,MAAA,EAAsB;AACjC,UAAMC,UAAU,GAAG9C,MAAM,CAAzB,UAAA;AACAJ,IAAAA,MAAM,CAACuC,MAAM,CAANA,QAAAA,CAAPvC,UAAOuC,CAAD,CAANvC;AAGA,SAAA,aAAA,GAAqB,KAAA,aAAA,IAArB,EAAA;AACA,SAAA,aAAA,CAAA,IAAA,CAAA,MAAA;AAEA,UAAMmD,cAAc,GAAG;AACrB/C,MAAAA,MAAM,EADe,CAAA;AAGrBH,MAAAA,UAAU,EAAE,KAHS,UAAA;AAIrBiD,MAAAA;AAJqB,KAAvB;AASA,SAAA,UAAA,IAAmBE,WAAW,CAAA,UAAA,EAA9B,CAA8B,CAA9B;AAGA,SAAA,IAAA,CAAA,WAAA,GAAwB,KAAA,IAAA,CAAA,WAAA,IAAxB,EAAA;AACA,SAAA,IAAA,CAAA,WAAA,CAAA,IAAA,CAAA,cAAA;AACA,WAAO,KAAA,IAAA,CAAA,WAAA,CAAA,MAAA,GAAP,CAAA;AACD;;AAODC,EAAAA,WAAW,CAAA,eAAA,EAAA,QAAA,EAAoD;AAC7D,UAAMC,YAAY,GAAG;AACnBzD,MAAAA,UAAU,EADS,eAAA;AAGnB0D,MAAAA,IAAI,EAAEC,uBAAuB,CAACrD,QAAQ,CAHnB,IAGU,CAHV;AAKnBsD,MAAAA,aAAa,EAAEtD,QAAQ,CALJ,aAAA;AAOnBuD,MAAAA,KAAK,EAAEvD,QAAQ,CAPI,KAAA;AASnBwD,MAAAA,GAAG,EAAExD,QAAQ,CATM,GAAA;AAWnByD,MAAAA,GAAG,EAAEzD,QAAQ,CAACyD;AAXK,KAArB;AAcA,SAAA,IAAA,CAAA,SAAA,GAAsB,KAAA,IAAA,CAAA,SAAA,IAAtB,EAAA;AACA,SAAA,IAAA,CAAA,SAAA,CAAA,IAAA,CAAA,YAAA;AACA,WAAO,KAAA,IAAA,CAAA,SAAA,CAAA,MAAA,GAAP,CAAA;AACD;;AASDC,EAAAA,eAAe,CAAA,YAAA,EAA0D;AAAA,QAAtC1D,QAAsC,uEAAnB;AAAC2D,MAAAA,IAAI,EAAE;AAAP,KAAmB;AACvE,UAAMf,eAAe,GAAG,KAAA,aAAA,CAAxB,YAAwB,CAAxB;AAEA,QAAIgB,MAAM,GAAG;AAACH,MAAAA,GAAG,EAAEzD,QAAQ,CAAd,GAAA;AAAoBwD,MAAAA,GAAG,EAAExD,QAAQ,CAACwD;AAAlC,KAAb;;AACA,QAAI,CAACI,MAAM,CAAP,GAAA,IAAe,CAACA,MAAM,CAA1B,GAAA,EAAgC;AAE9BA,MAAAA,MAAM,GAAG,KAAA,kBAAA,CAAA,YAAA,EAAsC5D,QAAQ,CAAvD4D,IAAS,CAATA;AACD;;AAED,UAAMC,gBAAgB,GAAG;AAEvBF,MAAAA,IAAI,EAAE3D,QAAQ,CAFS,IAAA;AAGvBsD,MAAAA,aAAa,EAAEQ,yBAAyB,CAHjB,YAGiB,CAHjB;AAKvBP,MAAAA,KAAK,EAAEQ,IAAI,CAAJA,KAAAA,CAAWC,YAAY,CAAZA,MAAAA,GAAsBhE,QAAQ,CALzB,IAKhB+D,CALgB;AAMvBN,MAAAA,GAAG,EAAEG,MAAM,CANY,GAAA;AAOvBJ,MAAAA,GAAG,EAAEI,MAAM,CAACJ;AAPW,KAAzB;AAUA,WAAO,KAAA,WAAA,CAAA,eAAA,EAAkCS,MAAM,CAANA,MAAAA,CAAAA,gBAAAA,EAAzC,QAAyCA,CAAlC,CAAP;AACD;;AAQDC,EAAAA,UAAU,CAAA,OAAA,EAAwC;AAChD,UAAM;AAACC,MAAAA;AAAD,QAAN,OAAA;AACA,UAAMC,WAAW,GAAG;AAClBC,MAAAA,MAAM,EAAEF;AADU,KAApB;AAIA,SAAA,IAAA,CAAA,QAAA,GAAqB,KAAA,IAAA,CAAA,QAAA,IAArB,EAAA;AACA,SAAA,IAAA,CAAA,QAAA,CAAA,IAAA,CAAA,WAAA;AACA,WAAO,KAAA,IAAA,CAAA,QAAA,CAAA,MAAA,GAAP,CAAA;AACD;;AAGDG,EAAAA,WAAW,CAAA,eAAA,EAAkC;AAC3C,SAAA,IAAA,CAAA,SAAA,GAAsB,KAAA,IAAA,CAAA,SAAA,IAAtB,EAAA;AACA,SAAA,IAAA,CAAA,SAAA,CAAA,IAAA,CAAA,eAAA;AACA,WAAO,KAAA,IAAA,CAAA,SAAA,CAAA,MAAA,GAAP,CAAA;AACD;;AAGDC,EAAAA,iBAAiB,GAAS;AAAA,QAAA,UAAA,EAAA,kBAAA;;AAExB,SAAA,IAAA,CAAA,OAAA,GAAA,EAAA;AAGA,UAAMC,eAAe,GAAG,KAAxB,UAAA;AACA,UAAMtE,WAAW,GAAG,IAAA,WAAA,CAApB,eAAoB,CAApB;AACA,UAAMuE,WAAW,GAAG,IAAA,UAAA,CAApB,WAAoB,CAApB;AAGA,QAAIC,aAAa,GAAjB,CAAA;;AACA,SAAK,MAAL,YAAA,IAA2B,KAAA,aAAA,IAA3B,EAAA,EAAqD;AACnDA,MAAAA,aAAa,GAAGC,WAAW,CAAA,YAAA,EAAA,WAAA,EAA3BD,aAA2B,CAA3BA;AACD;;AAGD,QAAA,CAAA,UAAA,GAAI,KAAJ,IAAA,MAAA,IAAA,IAAA,UAAA,KAAA,KAAA,CAAA,IAAA,CAAA,kBAAA,GAAI,UAAA,CAAJ,OAAA,MAAA,IAAA,IAAA,kBAAA,KAAA,KAAA,CAAA,IAAI,kBAAA,CAAJ,CAAI,CAAJ,EAA6B;AAC3B,WAAA,IAAA,CAAA,OAAA,CAAA,CAAA,EAAA,UAAA,GAAA,eAAA;AADF,KAAA,MAEO;AACL,WAAA,IAAA,CAAA,OAAA,GAAoB,CAAC;AAAC3B,QAAAA,UAAU,EAAEyB;AAAb,OAAD,CAApB;AACD;;AAGD,SAAA,IAAA,CAAA,MAAA,GAAA,WAAA;AAGA,SAAA,aAAA,GAAqB,CAArB,WAAqB,CAArB;AACD;;AAIDI,EAAAA,sBAAsB,CAAA,KAAA,EAAA,MAAA,EAAgB;AACpC,QAAIC,KAAK,GAAT,IAAA;;AACA,WAAA,KAAA,EAAc;AACZ,YAAMC,KAAK,GAAGC,KAAK,CAALA,OAAAA,CAAd,MAAcA,CAAd;;AACA,UAAID,KAAK,GAAG,CAAZ,CAAA,EAAgB;AACdC,QAAAA,KAAK,CAALA,MAAAA,CAAAA,KAAAA,EAAAA,CAAAA;AADF,OAAA,MAEO;AACLF,QAAAA,KAAK,GAALA,KAAAA;AACD;AACF;AACF;;AAKDG,EAAAA,cAAc,GAAkB;AAAA,QAAjB9C,UAAiB,uEAAlB,EAAkB;AAC9B,UAAM+C,MAAM,GAAZ,EAAA;;AACA,SAAK,MAAL,YAAA,IAAA,UAAA,EAAuC;AACrC,YAAMC,aAAa,GAAGhD,UAAU,CAAhC,YAAgC,CAAhC;;AACA,YAAMiD,QAAQ,GAAG,KAAA,qBAAA,CAAjB,YAAiB,CAAjB;;AACA,YAAMnF,QAAQ,GAAG,KAAA,eAAA,CAAqBkF,aAAa,CAAlC,KAAA,EAAjB,aAAiB,CAAjB;AACAD,MAAAA,MAAM,CAANA,QAAM,CAANA,GAAAA,QAAAA;AACD;;AACD,WAAA,MAAA;AACD;;AAKDG,EAAAA,WAAW,CAAA,OAAA,EAAU;AACnB,WAAO,KAAA,eAAA,CAAA,OAAA,EAA8B;AAACzB,MAAAA,IAAI,EAAE;AAAP,KAA9B,CAAP;AACD;;AAKD0B,EAAAA,qBAAqB,CAAA,aAAA,EAAgB;AACnC,YAAQC,aAAa,CAArB,WAAQA,EAAR;AACE,WAAA,UAAA;AACA,WAAA,WAAA;AACA,WAAA,UAAA;AACE,eAAA,UAAA;;AACF,WAAA,QAAA;AACA,WAAA,SAAA;AACE,eAAA,QAAA;;AACF,WAAA,OAAA;AACA,WAAA,QAAA;AACE,eAAA,SAAA;;AACF,WAAA,UAAA;AACA,WAAA,WAAA;AACE,eAAA,YAAA;;AACF;AACE,eAAA,aAAA;AAfJ;AAiBD;;AAMDC,EAAAA,kBAAkB,CAAA,MAAA,EAAA,IAAA,EAAe;AAC/B,UAAMN,MAAM,GAAG;AAACxB,MAAAA,GAAG,EAAJ,IAAA;AAAYD,MAAAA,GAAG,EAAE;AAAjB,KAAf;;AACA,QAAIvD,MAAM,CAANA,MAAAA,GAAJ,IAAA,EAA0B;AACxB,aAAA,MAAA;AACD;;AAEDgF,IAAAA,MAAM,CAANA,GAAAA,GAAAA,EAAAA;AAEAA,IAAAA,MAAM,CAANA,GAAAA,GAAAA,EAAAA;AACA,UAAMO,UAAU,GAAGvF,MAAM,CAANA,QAAAA,CAAAA,CAAAA,EAAnB,IAAmBA,CAAnB;;AACA,SAAK,MAAL,KAAA,IAAA,UAAA,EAAgC;AAE9BgF,MAAAA,MAAM,CAANA,GAAAA,CAAAA,IAAAA,CAAAA,KAAAA;AAEAA,MAAAA,MAAM,CAANA,GAAAA,CAAAA,IAAAA,CAAAA,KAAAA;AACD;;AAED,SAAK,IAAIH,KAAK,GAAd,IAAA,EAAuBA,KAAK,GAAG7E,MAAM,CAArC,MAAA,EAA8C6E,KAAK,IAAnD,IAAA,EAA6D;AAC3D,WAAK,IAAIW,cAAc,GAAvB,CAAA,EAA6BA,cAAc,GAA3C,IAAA,EAAoDA,cAApD,EAAA,EAAsE;AAEpER,QAAAA,MAAM,CAANA,GAAAA,CAAW,IAAXA,cAAAA,IAAiClB,IAAI,CAAJA,GAAAA,CAE/BkB,MAAM,CAANA,GAAAA,CAAW,IAFoBlB,cAE/BkB,CAF+BlB,EAG/B9D,MAAM,CAAC6E,KAAK,GAHdG,cAGQ,CAHyBlB,CAAjCkB;AAMAA,QAAAA,MAAM,CAANA,GAAAA,CAAW,IAAXA,cAAAA,IAAiClB,IAAI,CAAJA,GAAAA,CAE/BkB,MAAM,CAANA,GAAAA,CAAW,IAFoBlB,cAE/BkB,CAF+BlB,EAG/B9D,MAAM,CAAC6E,KAAK,GAHdG,cAGQ,CAHyBlB,CAAjCkB;AAKD;AACF;;AACD,WAAA,MAAA;AACD;;AAlnBiC","sourcesContent":["import type {\n  GLTF,\n  GLTFScene,\n  GLTFNode,\n  GLTFMesh,\n  GLTFSkin,\n  GLTFMaterial,\n  GLTFAccessor,\n  GLTFSampler,\n  GLTFTexture,\n  GLTFImage,\n  GLTFBuffer,\n  GLTFBufferView\n} from '../types/gltf-types';\n\nimport {getBinaryImageMetadata} from '@loaders.gl/images';\nimport {padToNBytes, copyToArray} from '@loaders.gl/loader-utils';\nimport {assert} from '../utils/assert';\nimport {\n  getAccessorArrayTypeAndLength,\n  getAccessorTypeFromSize,\n  getComponentTypeFromArray\n} from '../gltf-utils/gltf-utils';\n\ntype GLTFWithBuffers = {\n  json: GLTF;\n  buffers: any[];\n  binary?: ArrayBuffer;\n};\n\nconst DEFAULT_GLTF_JSON: GLTF = {\n  asset: {\n    version: '2.0',\n    generator: 'loaders.gl'\n  },\n  buffers: []\n};\n\n/**\n * Class for structured access to GLTF data\n */\nexport default class GLTFScenegraph {\n  // internal\n  gltf: GLTFWithBuffers;\n  sourceBuffers: any[];\n  byteLength: number;\n\n  constructor(gltf?: {json: GLTF; buffers?: any[]}) {\n    // @ts-ignore\n    this.gltf = gltf || {\n      json: {...DEFAULT_GLTF_JSON},\n      buffers: []\n    };\n    this.sourceBuffers = [];\n    this.byteLength = 0;\n\n    // Initialize buffers\n    if (this.gltf.buffers && this.gltf.buffers[0]) {\n      this.byteLength = this.gltf.buffers[0].byteLength;\n      this.sourceBuffers = [this.gltf.buffers[0]];\n    }\n  }\n\n  // Accessors\n\n  get json(): GLTF {\n    return this.gltf.json;\n  }\n\n  getApplicationData(key: string): {[key: string]: any} {\n    // TODO - Data is already unpacked by GLBParser\n    const data = this.json[key];\n    return data;\n  }\n\n  getExtraData(key: string): {[key: string]: any} {\n    // TODO - Data is already unpacked by GLBParser\n    const extras = this.json.extras || {};\n    return extras[key];\n  }\n\n  getExtension(extensionName: string): {[key: string]: any} | null {\n    const isExtension = this.getUsedExtensions().find((name) => name === extensionName);\n    const extensions = this.json.extensions || {};\n    return isExtension ? extensions[extensionName] || true : null;\n  }\n\n  getRequiredExtension(extensionName: string): {[key: string]: any} | null {\n    const isRequired = this.getRequiredExtensions().find((name) => name === extensionName);\n    return isRequired ? this.getExtension(extensionName) : null;\n  }\n\n  getRequiredExtensions(): string[] {\n    return this.json.extensionsRequired || [];\n  }\n\n  getUsedExtensions(): string[] {\n    return this.json.extensionsUsed || [];\n  }\n\n  getObjectExtension(\n    object: {[key: string]: any},\n    extensionName: string\n  ): {[key: string]: any} | null {\n    const extensions = object.extensions || {};\n    return extensions[extensionName];\n  }\n\n  getScene(index: number): GLTFScene {\n    return this.getObject('scenes', index) as GLTFScene;\n  }\n\n  getNode(index: number): GLTFNode {\n    return this.getObject('nodes', index) as GLTFNode;\n  }\n\n  getSkin(index: number): GLTFSkin {\n    return this.getObject('skins', index) as GLTFSkin;\n  }\n\n  getMesh(index: number): GLTFMesh {\n    return this.getObject('meshes', index) as GLTFMesh;\n  }\n\n  getMaterial(index: number): GLTFMaterial {\n    return this.getObject('materials', index) as GLTFMaterial;\n  }\n\n  getAccessor(index: number): GLTFAccessor {\n    return this.getObject('accessors', index) as GLTFAccessor;\n  }\n\n  // getCamera(index: number): object | null {\n  //   return null; // TODO: fix thi: object  as null;\n  // }\n\n  getTexture(index: number): GLTFTexture {\n    return this.getObject('textures', index) as GLTFTexture;\n  }\n\n  getSampler(index: number): GLTFSampler {\n    return this.getObject('samplers', index) as GLTFSampler;\n  }\n\n  getImage(index: number): GLTFImage {\n    return this.getObject('images', index) as GLTFImage;\n  }\n\n  getBufferView(index: number | object): GLTFBufferView {\n    return this.getObject('bufferViews', index) as GLTFBufferView;\n  }\n\n  getBuffer(index: number): GLTFBuffer {\n    return this.getObject('buffers', index) as GLTFBuffer;\n  }\n\n  getObject(array: string, index: number | object): object {\n    // check if already resolved\n    if (typeof index === 'object') {\n      return index;\n    }\n    const object = this.json[array] && this.json[array][index];\n    if (!object) {\n      throw new Error(`glTF file error: Could not find ${array}[${index}]`); // eslint-disable-line\n    }\n    return object;\n  }\n\n  /**\n   * Accepts buffer view index or buffer view object\n   * @returns a `Uint8Array`\n   */\n  getTypedArrayForBufferView(bufferView: number | object): Uint8Array {\n    bufferView = this.getBufferView(bufferView);\n    // @ts-ignore\n    const bufferIndex = bufferView.buffer;\n\n    // Get hold of the arrayBuffer\n    // const buffer = this.getBuffer(bufferIndex);\n    const binChunk = this.gltf.buffers[bufferIndex];\n    assert(binChunk);\n\n    // @ts-ignore\n    const byteOffset = (bufferView.byteOffset || 0) + binChunk.byteOffset;\n    // @ts-ignore\n    return new Uint8Array(binChunk.arrayBuffer, byteOffset, bufferView.byteLength);\n  }\n\n  /** Accepts accessor index or accessor object\n   * @returns a typed array with type that matches the types\n   */\n  getTypedArrayForAccessor(accessor: number | object): any {\n    // @ts-ignore\n    accessor = this.getAccessor(accessor);\n    // @ts-ignore\n    const bufferView = this.getBufferView(accessor.bufferView);\n    const buffer = this.getBuffer(bufferView.buffer);\n    // @ts-ignore\n    const arrayBuffer = buffer.data;\n\n    // Create a new typed array as a view into the combined buffer\n    const {ArrayType, length} = getAccessorArrayTypeAndLength(accessor, bufferView);\n    // @ts-ignore\n    const byteOffset = bufferView.byteOffset + accessor.byteOffset;\n    return new ArrayType(arrayBuffer, byteOffset, length);\n  }\n\n  /** accepts accessor index or accessor object\n   * returns a `Uint8Array`\n   */\n  getTypedArrayForImageData(image: number | object): Uint8Array {\n    // @ts-ignore\n    image = this.getAccessor(image);\n    // @ts-ignore\n    const bufferView = this.getBufferView(image.bufferView);\n    const buffer = this.getBuffer(bufferView.buffer);\n    // @ts-ignore\n    const arrayBuffer = buffer.data;\n\n    const byteOffset = bufferView.byteOffset || 0;\n    return new Uint8Array(arrayBuffer, byteOffset, bufferView.byteLength);\n  }\n\n  // MODIFERS\n\n  /**\n   * Add an extra application-defined key to the top-level data structure\n   */\n  addApplicationData(key: string, data: object): GLTFScenegraph {\n    this.json[key] = data;\n    return this;\n  }\n\n  /**\n   * `extras` - Standard GLTF field for storing application specific data\n   */\n  addExtraData(key: string, data: object): GLTFScenegraph {\n    this.json.extras = this.json.extras || {};\n    this.json.extras[key] = data;\n    return this;\n  }\n\n  addObjectExtension(object: object, extensionName: string, data: object): GLTFScenegraph {\n    // @ts-ignore\n    object.extensions = object.extensions || {};\n    // TODO - clobber or merge?\n    // @ts-ignore\n    object.extensions[extensionName] = data;\n    this.registerUsedExtension(extensionName);\n    return this;\n  }\n\n  setObjectExtension(object: object, extensionName: string, data: object): void {\n    // @ts-ignore\n    const extensions = object.extensions || {};\n    extensions[extensionName] = data;\n    // TODO - add to usedExtensions...\n  }\n\n  removeObjectExtension(object: object, extensionName: string): object {\n    // @ts-ignore\n    const extensions = object.extensions || {};\n    const extension = extensions[extensionName];\n    delete extensions[extensionName];\n    return extension;\n  }\n\n  /**\n   * Add to standard GLTF top level extension object, mark as used\n   */\n  addExtension(extensionName: string, extensionData: object = {}): object {\n    assert(extensionData);\n    this.json.extensions = this.json.extensions || {};\n    this.json.extensions[extensionName] = extensionData;\n    this.registerUsedExtension(extensionName);\n    return extensionData;\n  }\n\n  /**\n   * Standard GLTF top level extension object, mark as used and required\n   */\n  addRequiredExtension(extensionName, extensionData: object = {}): object {\n    assert(extensionData);\n    this.addExtension(extensionName, extensionData);\n    this.registerRequiredExtension(extensionName);\n    return extensionData;\n  }\n\n  /**\n   * Add extensionName to list of used extensions\n   */\n  registerUsedExtension(extensionName: string): void {\n    this.json.extensionsUsed = this.json.extensionsUsed || [];\n    if (!this.json.extensionsUsed.find((ext) => ext === extensionName)) {\n      this.json.extensionsUsed.push(extensionName);\n    }\n  }\n\n  /**\n   * Add extensionName to list of required extensions\n   */\n  registerRequiredExtension(extensionName: string): void {\n    this.registerUsedExtension(extensionName);\n    this.json.extensionsRequired = this.json.extensionsRequired || [];\n    if (!this.json.extensionsRequired.find((ext) => ext === extensionName)) {\n      this.json.extensionsRequired.push(extensionName);\n    }\n  }\n\n  /**\n   * Removes an extension from the top-level list\n   */\n  removeExtension(extensionName: string): void {\n    if (this.json.extensionsRequired) {\n      this._removeStringFromArray(this.json.extensionsRequired, extensionName);\n    }\n    if (this.json.extensionsUsed) {\n      this._removeStringFromArray(this.json.extensionsUsed, extensionName);\n    }\n    if (this.json.extensions) {\n      delete this.json.extensions[extensionName];\n    }\n  }\n\n  /**\n   *  Set default scene which is to be displayed at load time\n   */\n  setDefaultScene(sceneIndex: number): void {\n    this.json.scene = sceneIndex;\n  }\n\n  /**\n   * @todo: add more properties for scene initialization:\n   *   name`, `extensions`, `extras`\n   *   https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#reference-scene\n   */\n  addScene(scene: {nodeIndices: number[]}): number {\n    const {nodeIndices} = scene;\n    this.json.scenes = this.json.scenes || [];\n    this.json.scenes.push({nodes: nodeIndices});\n    return this.json.scenes.length - 1;\n  }\n\n  /**\n   * @todo: add more properties for node initialization:\n   *   `name`, `extensions`, `extras`, `camera`, `children`, `skin`, `rotation`, `scale`, `translation`, `weights`\n   *   https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#node\n   */\n  addNode(node: {meshIndex: number; matrix: number[]}): number {\n    const {meshIndex, matrix} = node;\n    this.json.nodes = this.json.nodes || [];\n    const nodeData = {mesh: meshIndex};\n    if (matrix) {\n      // @ts-ignore\n      nodeData.matrix = matrix;\n    }\n    this.json.nodes.push(nodeData);\n    return this.json.nodes.length - 1;\n  }\n\n  /** Adds a mesh to the json part */\n  addMesh(mesh: {attributes: object; indices: object; material: number; mode: number}): number {\n    const {attributes, indices, material, mode = 4} = mesh;\n    const accessors = this._addAttributes(attributes);\n\n    const glTFMesh = {\n      primitives: [\n        {\n          attributes: accessors,\n          mode\n        }\n      ]\n    };\n\n    if (indices) {\n      const indicesAccessor = this._addIndices(indices);\n      // @ts-ignore\n      glTFMesh.primitives[0].indices = indicesAccessor;\n    }\n\n    if (Number.isFinite(material)) {\n      // @ts-ignore\n      glTFMesh.primitives[0].material = material;\n    }\n\n    this.json.meshes = this.json.meshes || [];\n    this.json.meshes.push(glTFMesh);\n    return this.json.meshes.length - 1;\n  }\n\n  addPointCloud(attributes: object): number {\n    // @ts-ignore\n    const accessorIndices = this._addAttributes(attributes);\n\n    const glTFMesh = {\n      primitives: [\n        {\n          attributes: accessorIndices,\n          mode: 0 // GL.POINTS\n        }\n      ]\n    };\n\n    this.json.meshes = this.json.meshes || [];\n    this.json.meshes.push(glTFMesh);\n    return this.json.meshes.length - 1;\n  }\n\n  /**\n   * Adds a binary image. Builds glTF \"JSON metadata\" and saves buffer reference\n   * Buffer will be copied into BIN chunk during \"pack\"\n   * Currently encodes as glTF image\n   * @param imageData\n   * @param mimeType\n   */\n  addImage(imageData: any, mimeTypeOpt?: string): number {\n    // If image is referencing a bufferView instead of URI, mimeType must be defined:\n    //   https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#images\n    //   \"a reference to a bufferView; in that case mimeType must be defined.\"\n    const metadata = getBinaryImageMetadata(imageData);\n    const mimeType = mimeTypeOpt || metadata?.mimeType;\n\n    const bufferViewIndex = this.addBufferView(imageData);\n\n    const glTFImage = {\n      bufferView: bufferViewIndex,\n      mimeType\n    };\n\n    this.json.images = this.json.images || [];\n    this.json.images.push(glTFImage);\n    return this.json.images.length - 1;\n  }\n\n  /**\n   * Add one untyped source buffer, create a matching glTF `bufferView`, and return its index\n   * @param buffer\n   */\n  addBufferView(buffer: any): number {\n    const byteLength = buffer.byteLength;\n    assert(Number.isFinite(byteLength));\n\n    // Add this buffer to the list of buffers to be written to the body.\n    this.sourceBuffers = this.sourceBuffers || [];\n    this.sourceBuffers.push(buffer);\n\n    const glTFBufferView = {\n      buffer: 0,\n      // Write offset from the start of the binary body\n      byteOffset: this.byteLength,\n      byteLength\n    };\n\n    // We've now added the contents to the body, so update the total length\n    // Every sub-chunk needs to be 4-byte align ed\n    this.byteLength += padToNBytes(byteLength, 4);\n\n    // Add a bufferView indicating start and length of this binary sub-chunk\n    this.json.bufferViews = this.json.bufferViews || [];\n    this.json.bufferViews.push(glTFBufferView);\n    return this.json.bufferViews.length - 1;\n  }\n\n  /**\n   * Adds an accessor to a bufferView\n   * @param bufferViewIndex\n   * @param accessor\n   */\n  addAccessor(bufferViewIndex: number, accessor: object): number {\n    const glTFAccessor = {\n      bufferView: bufferViewIndex,\n      // @ts-ignore\n      type: getAccessorTypeFromSize(accessor.size),\n      // @ts-ignore\n      componentType: accessor.componentType,\n      // @ts-ignore\n      count: accessor.count,\n      // @ts-ignore\n      max: accessor.max,\n      // @ts-ignore\n      min: accessor.min\n    };\n\n    this.json.accessors = this.json.accessors || [];\n    this.json.accessors.push(glTFAccessor);\n    return this.json.accessors.length - 1;\n  }\n\n  /**\n   * Add a binary buffer. Builds glTF \"JSON metadata\" and saves buffer reference\n   * Buffer will be copied into BIN chunk during \"pack\"\n   * Currently encodes buffers as glTF accessors, but this could be optimized\n   * @param sourceBuffer\n   * @param accessor\n   */\n  addBinaryBuffer(sourceBuffer: any, accessor: object = {size: 3}): number {\n    const bufferViewIndex = this.addBufferView(sourceBuffer);\n    // @ts-ignore\n    let minMax = {min: accessor.min, max: accessor.max};\n    if (!minMax.min || !minMax.max) {\n      // @ts-ignore\n      minMax = this._getAccessorMinMax(sourceBuffer, accessor.size);\n    }\n\n    const accessorDefaults = {\n      // @ts-ignore\n      size: accessor.size,\n      componentType: getComponentTypeFromArray(sourceBuffer),\n      // @ts-ignore\n      count: Math.round(sourceBuffer.length / accessor.size),\n      min: minMax.min,\n      max: minMax.max\n    };\n\n    return this.addAccessor(bufferViewIndex, Object.assign(accessorDefaults, accessor));\n  }\n\n  /**\n   * Adds a texture to the json part\n   * @todo: add more properties for texture initialization\n   * `sampler`, `name`, `extensions`, `extras`\n   * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#texture\n   */\n  addTexture(texture: {imageIndex: number}): number {\n    const {imageIndex} = texture;\n    const glTFTexture = {\n      source: imageIndex\n    };\n\n    this.json.textures = this.json.textures || [];\n    this.json.textures.push(glTFTexture);\n    return this.json.textures.length - 1;\n  }\n\n  /** Adds a material to the json part */\n  addMaterial(pbrMaterialInfo: Object): number {\n    this.json.materials = this.json.materials || [];\n    this.json.materials.push(pbrMaterialInfo);\n    return this.json.materials.length - 1;\n  }\n\n  /** Pack the binary chunk */\n  createBinaryChunk(): void {\n    // Encoder expects this array undefined or empty\n    this.gltf.buffers = [];\n\n    // Allocate total array\n    const totalByteLength = this.byteLength;\n    const arrayBuffer = new ArrayBuffer(totalByteLength);\n    const targetArray = new Uint8Array(arrayBuffer);\n\n    // Copy each array into\n    let dstByteOffset = 0;\n    for (const sourceBuffer of this.sourceBuffers || []) {\n      dstByteOffset = copyToArray(sourceBuffer, targetArray, dstByteOffset);\n    }\n\n    // Update the glTF BIN CHUNK byte length\n    if (this.json?.buffers?.[0]) {\n      this.json.buffers[0].byteLength = totalByteLength;\n    } else {\n      this.json.buffers = [{byteLength: totalByteLength}];\n    }\n\n    // Save generated arrayBuffer\n    this.gltf.binary = arrayBuffer;\n\n    // Put arrayBuffer to sourceBuffers for possible additional writing data in the chunk\n    this.sourceBuffers = [arrayBuffer];\n  }\n\n  // PRIVATE\n\n  _removeStringFromArray(array, string) {\n    let found = true;\n    while (found) {\n      const index = array.indexOf(string);\n      if (index > -1) {\n        array.splice(index, 1);\n      } else {\n        found = false;\n      }\n    }\n  }\n\n  /**\n   * Add attributes to buffers and create `attributes` object which is part of `mesh`\n   */\n  _addAttributes(attributes = {}) {\n    const result = {};\n    for (const attributeKey in attributes) {\n      const attributeData = attributes[attributeKey];\n      const attrName = this._getGltfAttributeName(attributeKey);\n      const accessor = this.addBinaryBuffer(attributeData.value, attributeData);\n      result[attrName] = accessor;\n    }\n    return result;\n  }\n\n  /**\n   * Add indices to buffers\n   */\n  _addIndices(indices) {\n    return this.addBinaryBuffer(indices, {size: 1});\n  }\n\n  /**\n   * Deduce gltf specific attribue name from input attribute name\n   */\n  _getGltfAttributeName(attributeName) {\n    switch (attributeName.toLowerCase()) {\n      case 'position':\n      case 'positions':\n      case 'vertices':\n        return 'POSITION';\n      case 'normal':\n      case 'normals':\n        return 'NORMAL';\n      case 'color':\n      case 'colors':\n        return 'COLOR_0';\n      case 'texcoord':\n      case 'texcoords':\n        return 'TEXCOORD_0';\n      default:\n        return attributeName;\n    }\n  }\n\n  /**\n   * Calculate `min` and `max` arrays of accessor according to spec:\n   * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#reference-accessor\n   */\n  _getAccessorMinMax(buffer, size) {\n    const result = {min: null, max: null};\n    if (buffer.length < size) {\n      return result;\n    }\n    // @ts-ignore\n    result.min = [];\n    // @ts-ignore\n    result.max = [];\n    const initValues = buffer.subarray(0, size);\n    for (const value of initValues) {\n      // @ts-ignore\n      result.min.push(value);\n      // @ts-ignore\n      result.max.push(value);\n    }\n\n    for (let index = size; index < buffer.length; index += size) {\n      for (let componentIndex = 0; componentIndex < size; componentIndex++) {\n        // @ts-ignore\n        result.min[0 + componentIndex] = Math.min(\n          // @ts-ignore\n          result.min[0 + componentIndex],\n          buffer[index + componentIndex]\n        );\n        // @ts-ignore\n        result.max[0 + componentIndex] = Math.max(\n          // @ts-ignore\n          result.max[0 + componentIndex],\n          buffer[index + componentIndex]\n        );\n      }\n    }\n    return result;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}