{"ast":null,"code":"import { assert } from '@loaders.gl/loader-utils';\nimport { createTypedArrayFromAccessor } from './helpers/tile-3d-accessor-utils';\nimport { initializeHierarchy, traverseHierarchy } from './tile-3d-batch-table-hierarchy';\n\nfunction defined(x) {\n  return x !== undefined && x !== null;\n}\n\nconst clone = (x, y) => x;\n\nconst IGNORED_PROPERTY_FIELDS = {\n  HIERARCHY: true,\n  extensions: true,\n  extras: true\n};\nexport default class Tile3DBatchTableParser {\n  constructor(json, binary, featureCount) {\n    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n    var _this$json;\n\n    assert(featureCount >= 0);\n    this.json = json || {};\n    this.binary = binary;\n    this.featureCount = featureCount;\n    this._extensions = ((_this$json = this.json) === null || _this$json === void 0 ? void 0 : _this$json.extensions) || {};\n    this._properties = {};\n\n    for (const propertyName in this.json) {\n      if (!IGNORED_PROPERTY_FIELDS[propertyName]) {\n        this._properties[propertyName] = this.json[propertyName];\n      }\n    }\n\n    this._binaryProperties = this._initializeBinaryProperties();\n\n    if (options['3DTILES_batch_table_hierarchy']) {\n      this._hierarchy = initializeHierarchy(this, this.json, this.binary);\n    }\n  }\n\n  getExtension(extensionName) {\n    return this.json && this.json.extensions && this.json.extensions[extensionName];\n  }\n\n  memorySizeInBytes() {\n    return 0;\n  }\n\n  isClass(batchId, className) {\n    this._checkBatchId(batchId);\n\n    assert(typeof className === 'string', className);\n\n    if (this._hierarchy) {\n      const result = traverseHierarchy(this._hierarchy, batchId, (hierarchy, instanceIndex) => {\n        const classId = hierarchy.classIds[instanceIndex];\n        const instanceClass = hierarchy.classes[classId];\n        return instanceClass.name === className;\n      });\n      return defined(result);\n    }\n\n    return false;\n  }\n\n  isExactClass(batchId, className) {\n    assert(typeof className === 'string', className);\n    return this.getExactClassName(batchId) === className;\n  }\n\n  getExactClassName(batchId) {\n    this._checkBatchId(batchId);\n\n    if (this._hierarchy) {\n      const classId = this._hierarchy.classIds[batchId];\n      const instanceClass = this._hierarchy.classes[classId];\n      return instanceClass.name;\n    }\n\n    return undefined;\n  }\n\n  hasProperty(batchId, name) {\n    this._checkBatchId(batchId);\n\n    assert(typeof name === 'string', name);\n    return defined(this._properties[name]) || this._hasPropertyInHierarchy(batchId, name);\n  }\n\n  getPropertyNames(batchId, results) {\n    this._checkBatchId(batchId);\n\n    results = defined(results) ? results : [];\n    results.length = 0;\n    const propertyNames = Object.keys(this._properties);\n    results.push(...propertyNames);\n\n    if (this._hierarchy) {\n      this._getPropertyNamesInHierarchy(batchId, results);\n    }\n\n    return results;\n  }\n\n  getProperty(batchId, name) {\n    this._checkBatchId(batchId);\n\n    assert(typeof name === 'string', name);\n\n    if (this._binaryProperties) {\n      const binaryProperty = this._binaryProperties[name];\n\n      if (defined(binaryProperty)) {\n        return this._getBinaryProperty(binaryProperty, batchId);\n      }\n    }\n\n    const propertyValues = this._properties[name];\n\n    if (defined(propertyValues)) {\n      return clone(propertyValues[batchId], true);\n    }\n\n    if (this._hierarchy) {\n      const hierarchyProperty = this._getHierarchyProperty(batchId, name);\n\n      if (defined(hierarchyProperty)) {\n        return hierarchyProperty;\n      }\n    }\n\n    return undefined;\n  }\n\n  setProperty(batchId, name, value) {\n    const featureCount = this.featureCount;\n\n    this._checkBatchId(batchId);\n\n    assert(typeof name === 'string', name);\n\n    if (this._binaryProperties) {\n      const binaryProperty = this._binaryProperties[name];\n\n      if (binaryProperty) {\n        this._setBinaryProperty(binaryProperty, batchId, value);\n\n        return;\n      }\n    }\n\n    if (this._hierarchy) {\n      if (this._setHierarchyProperty(this, batchId, name, value)) {\n        return;\n      }\n    }\n\n    let propertyValues = this._properties[name];\n\n    if (!defined(propertyValues)) {\n      this._properties[name] = new Array(featureCount);\n      propertyValues = this._properties[name];\n    }\n\n    propertyValues[batchId] = clone(value, true);\n  }\n\n  _checkBatchId(batchId) {\n    const valid = batchId >= 0 && batchId < this.featureCount;\n\n    if (!valid) {\n      throw new Error(\"batchId not in range [0, featureCount - 1].\");\n    }\n  }\n\n  _getBinaryProperty(binaryProperty, index) {\n    return binaryProperty.unpack(binaryProperty.typedArray, index);\n  }\n\n  _setBinaryProperty(binaryProperty, index, value) {\n    binaryProperty.pack(value, binaryProperty.typedArray, index);\n  }\n\n  _initializeBinaryProperties() {\n    let binaryProperties = null;\n\n    for (const name in this._properties) {\n      const property = this._properties[name];\n\n      const binaryProperty = this._initializeBinaryProperty(name, property);\n\n      if (binaryProperty) {\n        binaryProperties = binaryProperties || {};\n        binaryProperties[name] = binaryProperty;\n      }\n    }\n\n    return binaryProperties;\n  }\n\n  _initializeBinaryProperty(name, property) {\n    if ('byteOffset' in property) {\n      const tile3DAccessor = property;\n      assert(this.binary, \"Property \".concat(name, \" requires a batch table binary.\"));\n      assert(tile3DAccessor.type, \"Property \".concat(name, \" requires a type.\"));\n      const accessor = createTypedArrayFromAccessor(tile3DAccessor, this.binary.buffer, this.binary.byteOffset | 0, this.featureCount);\n      return {\n        typedArray: accessor.values,\n        componentCount: accessor.size,\n        unpack: accessor.unpacker,\n        pack: accessor.packer\n      };\n    }\n\n    return null;\n  }\n\n  _hasPropertyInHierarchy(batchId, name) {\n    if (!this._hierarchy) {\n      return false;\n    }\n\n    const result = traverseHierarchy(this._hierarchy, batchId, (hierarchy, instanceIndex) => {\n      const classId = hierarchy.classIds[instanceIndex];\n      const instances = hierarchy.classes[classId].instances;\n      return defined(instances[name]);\n    });\n    return defined(result);\n  }\n\n  _getPropertyNamesInHierarchy(batchId, results) {\n    traverseHierarchy(this._hierarchy, batchId, (hierarchy, instanceIndex) => {\n      const classId = hierarchy.classIds[instanceIndex];\n      const instances = hierarchy.classes[classId].instances;\n\n      for (const name in instances) {\n        if (instances.hasOwnProperty(name)) {\n          if (results.indexOf(name) === -1) {\n            results.push(name);\n          }\n        }\n      }\n    });\n  }\n\n  _getHierarchyProperty(batchId, name) {\n    return traverseHierarchy(this._hierarchy, batchId, (hierarchy, instanceIndex) => {\n      const classId = hierarchy.classIds[instanceIndex];\n      const instanceClass = hierarchy.classes[classId];\n      const indexInClass = hierarchy.classIndexes[instanceIndex];\n      const propertyValues = instanceClass.instances[name];\n\n      if (defined(propertyValues)) {\n        if (defined(propertyValues.typedArray)) {\n          return this._getBinaryProperty(propertyValues, indexInClass);\n        }\n\n        return clone(propertyValues[indexInClass], true);\n      }\n\n      return null;\n    });\n  }\n\n  _setHierarchyProperty(batchTable, batchId, name, value) {\n    const result = traverseHierarchy(this._hierarchy, batchId, (hierarchy, instanceIndex) => {\n      const classId = hierarchy.classIds[instanceIndex];\n      const instanceClass = hierarchy.classes[classId];\n      const indexInClass = hierarchy.classIndexes[instanceIndex];\n      const propertyValues = instanceClass.instances[name];\n\n      if (defined(propertyValues)) {\n        assert(instanceIndex === batchId, \"Inherited property \\\"\".concat(name, \"\\\" is read-only.\"));\n\n        if (defined(propertyValues.typedArray)) {\n          this._setBinaryProperty(propertyValues, indexInClass, value);\n        } else {\n          propertyValues[indexInClass] = clone(value, true);\n        }\n\n        return true;\n      }\n\n      return false;\n    });\n    return defined(result);\n  }\n\n}","map":{"version":3,"sources":["../../../../src/lib/classes/tile-3d-batch-table.js"],"names":["x","clone","IGNORED_PROPERTY_FIELDS","HIERARCHY","extensions","extras","constructor","options","assert","featureCount","json","initializeHierarchy","getExtension","memorySizeInBytes","isClass","result","traverseHierarchy","classId","hierarchy","instanceClass","defined","isExactClass","getExactClassName","hasProperty","getPropertyNames","results","propertyNames","Object","getProperty","binaryProperty","propertyValues","hierarchyProperty","setProperty","_checkBatchId","valid","batchId","_getBinaryProperty","_setBinaryProperty","_initializeBinaryProperties","binaryProperties","property","_initializeBinaryProperty","tile3DAccessor","accessor","createTypedArrayFromAccessor","typedArray","componentCount","unpack","pack","packer","_hasPropertyInHierarchy","instances","_getPropertyNamesInHierarchy","_getHierarchyProperty","indexInClass","_setHierarchyProperty","instanceIndex"],"mappings":"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","sourcesContent":["// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\nimport {assert} from '@loaders.gl/loader-utils';\n\nimport {createTypedArrayFromAccessor} from './helpers/tile-3d-accessor-utils';\nimport {initializeHierarchy, traverseHierarchy} from './tile-3d-batch-table-hierarchy';\n\nfunction defined(x) {\n  return x !== undefined && x !== null;\n}\n\nconst clone = (x, y) => x;\n\n// These top level fields in the batch table json are not properties\nconst IGNORED_PROPERTY_FIELDS = {\n  HIERARCHY: true, // Deprecated HIERARCHY property\n  extensions: true,\n  extras: true\n};\n\n// The size of this array equals the maximum instance count among all loaded tiles, which has the potential to be large.\nexport default class Tile3DBatchTableParser {\n  constructor(json, binary, featureCount, options = {}) {\n    assert(featureCount >= 0);\n    this.json = json || {};\n    this.binary = binary;\n    this.featureCount = featureCount;\n\n    this._extensions = this.json?.extensions || {};\n\n    // Copy all top-level property fields from the json object, ignoring special fields\n    this._properties = {};\n    for (const propertyName in this.json) {\n      if (!IGNORED_PROPERTY_FIELDS[propertyName]) {\n        this._properties[propertyName] = this.json[propertyName];\n      }\n    }\n\n    this._binaryProperties = this._initializeBinaryProperties();\n\n    // TODO: hierarchy support is only partially implemented and not tested\n    if (options['3DTILES_batch_table_hierarchy']) {\n      this._hierarchy = initializeHierarchy(this, this.json, this.binary);\n    }\n  }\n\n  getExtension(extensionName) {\n    return this.json && this.json.extensions && this.json.extensions[extensionName];\n  }\n\n  memorySizeInBytes() {\n    return 0;\n  }\n\n  isClass(batchId, className) {\n    this._checkBatchId(batchId);\n    assert(typeof className === 'string', className);\n\n    // extension: 3DTILES_batch_table_hierarchy\n    if (this._hierarchy) {\n      // PERFORMANCE_IDEA : cache results in the ancestor classes\n      //   to speed up this check if this area becomes a hotspot\n      // PERFORMANCE_IDEA : treat class names as integers for faster comparisons\n      const result = traverseHierarchy(this._hierarchy, batchId, (hierarchy, instanceIndex) => {\n        const classId = hierarchy.classIds[instanceIndex];\n        const instanceClass = hierarchy.classes[classId];\n        return instanceClass.name === className;\n      });\n      return defined(result);\n    }\n\n    return false;\n  }\n\n  isExactClass(batchId, className) {\n    assert(typeof className === 'string', className);\n\n    return this.getExactClassName(batchId) === className;\n  }\n\n  getExactClassName(batchId) {\n    this._checkBatchId(batchId);\n\n    // extension: 3DTILES_batch_table_hierarchy\n    if (this._hierarchy) {\n      const classId = this._hierarchy.classIds[batchId];\n      const instanceClass = this._hierarchy.classes[classId];\n      return instanceClass.name;\n    }\n\n    return undefined;\n  }\n\n  hasProperty(batchId, name) {\n    this._checkBatchId(batchId);\n    assert(typeof name === 'string', name);\n\n    return defined(this._properties[name]) || this._hasPropertyInHierarchy(batchId, name);\n  }\n\n  getPropertyNames(batchId, results) {\n    this._checkBatchId(batchId);\n\n    results = defined(results) ? results : [];\n    results.length = 0;\n\n    const propertyNames = Object.keys(this._properties);\n    results.push(...propertyNames);\n\n    if (this._hierarchy) {\n      this._getPropertyNamesInHierarchy(batchId, results);\n    }\n\n    return results;\n  }\n\n  getProperty(batchId, name) {\n    this._checkBatchId(batchId);\n    assert(typeof name === 'string', name);\n\n    if (this._binaryProperties) {\n      const binaryProperty = this._binaryProperties[name];\n      if (defined(binaryProperty)) {\n        return this._getBinaryProperty(binaryProperty, batchId);\n      }\n    }\n\n    const propertyValues = this._properties[name];\n    if (defined(propertyValues)) {\n      return clone(propertyValues[batchId], true);\n    }\n\n    // EXTENSION: 3DTILES_batch_table_hierarchy\n    if (this._hierarchy) {\n      const hierarchyProperty = this._getHierarchyProperty(batchId, name);\n      if (defined(hierarchyProperty)) {\n        return hierarchyProperty;\n      }\n    }\n\n    return undefined;\n  }\n\n  setProperty(batchId, name, value) {\n    const featureCount = this.featureCount;\n\n    this._checkBatchId(batchId);\n    assert(typeof name === 'string', name);\n\n    if (this._binaryProperties) {\n      const binaryProperty = this._binaryProperties[name];\n      if (binaryProperty) {\n        this._setBinaryProperty(binaryProperty, batchId, value);\n        return;\n      }\n    }\n\n    // EXTENSION: 3DTILES_batch_table_hierarchy\n    if (this._hierarchy) {\n      if (this._setHierarchyProperty(this, batchId, name, value)) {\n        return;\n      }\n    }\n\n    let propertyValues = this._properties[name];\n    if (!defined(propertyValues)) {\n      // Property does not exist. Create it.\n      this._properties[name] = new Array(featureCount);\n      propertyValues = this._properties[name];\n    }\n\n    propertyValues[batchId] = clone(value, true);\n  }\n\n  // PRIVATE METHODS\n\n  _checkBatchId(batchId) {\n    const valid = batchId >= 0 && batchId < this.featureCount;\n    if (!valid) {\n      throw new Error(`batchId not in range [0, featureCount - 1].`);\n    }\n  }\n\n  _getBinaryProperty(binaryProperty, index) {\n    return binaryProperty.unpack(binaryProperty.typedArray, index);\n  }\n\n  _setBinaryProperty(binaryProperty, index, value) {\n    binaryProperty.pack(value, binaryProperty.typedArray, index);\n  }\n\n  _initializeBinaryProperties() {\n    let binaryProperties = null;\n    for (const name in this._properties) {\n      const property = this._properties[name];\n      const binaryProperty = this._initializeBinaryProperty(name, property);\n      // Store any information needed to access the binary data, including the typed array,\n      // componentCount (e.g. a VEC4 would be 4), and the type used to pack and unpack (e.g. Cartesian4).\n      if (binaryProperty) {\n        binaryProperties = binaryProperties || {};\n        binaryProperties[name] = binaryProperty;\n      }\n    }\n    return binaryProperties;\n  }\n\n  _initializeBinaryProperty(name, property) {\n    if ('byteOffset' in property) {\n      // This is a binary property\n      const tile3DAccessor = property;\n\n      assert(this.binary, `Property ${name} requires a batch table binary.`);\n      assert(tile3DAccessor.type, `Property ${name} requires a type.`);\n\n      const accessor = createTypedArrayFromAccessor(\n        tile3DAccessor,\n        this.binary.buffer,\n        this.binary.byteOffset | 0,\n        this.featureCount\n      );\n\n      // Store any information needed to access the binary data, including the typed array,\n      // componentCount (e.g. a VEC4 would be 4), and the type used to pack and unpack (e.g. Cartesian4).\n      return {\n        typedArray: accessor.values,\n        componentCount: accessor.size,\n        unpack: accessor.unpacker,\n        pack: accessor.packer\n      };\n    }\n\n    return null;\n  }\n\n  //  EXTENSION SUPPORT: 3DTILES_batch_table_hierarchy\n\n  _hasPropertyInHierarchy(batchId, name) {\n    if (!this._hierarchy) {\n      return false;\n    }\n\n    const result = traverseHierarchy(this._hierarchy, batchId, (hierarchy, instanceIndex) => {\n      const classId = hierarchy.classIds[instanceIndex];\n      const instances = hierarchy.classes[classId].instances;\n      return defined(instances[name]);\n    });\n\n    return defined(result);\n  }\n\n  _getPropertyNamesInHierarchy(batchId, results) {\n    traverseHierarchy(this._hierarchy, batchId, (hierarchy, instanceIndex) => {\n      const classId = hierarchy.classIds[instanceIndex];\n      const instances = hierarchy.classes[classId].instances;\n      for (const name in instances) {\n        if (instances.hasOwnProperty(name)) {\n          if (results.indexOf(name) === -1) {\n            results.push(name);\n          }\n        }\n      }\n    });\n  }\n\n  _getHierarchyProperty(batchId, name) {\n    return traverseHierarchy(this._hierarchy, batchId, (hierarchy, instanceIndex) => {\n      const classId = hierarchy.classIds[instanceIndex];\n      const instanceClass = hierarchy.classes[classId];\n      const indexInClass = hierarchy.classIndexes[instanceIndex];\n      const propertyValues = instanceClass.instances[name];\n      if (defined(propertyValues)) {\n        if (defined(propertyValues.typedArray)) {\n          return this._getBinaryProperty(propertyValues, indexInClass);\n        }\n        return clone(propertyValues[indexInClass], true);\n      }\n      return null;\n    });\n  }\n\n  _setHierarchyProperty(batchTable, batchId, name, value) {\n    const result = traverseHierarchy(this._hierarchy, batchId, (hierarchy, instanceIndex) => {\n      const classId = hierarchy.classIds[instanceIndex];\n      const instanceClass = hierarchy.classes[classId];\n      const indexInClass = hierarchy.classIndexes[instanceIndex];\n      const propertyValues = instanceClass.instances[name];\n      if (defined(propertyValues)) {\n        assert(instanceIndex === batchId, `Inherited property \"${name}\" is read-only.`);\n        if (defined(propertyValues.typedArray)) {\n          this._setBinaryProperty(propertyValues, indexInClass, value);\n        } else {\n          propertyValues[indexInClass] = clone(value, true);\n        }\n        return true;\n      }\n      return false;\n    });\n    return defined(result);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}