{"ast":null,"code":"const TYPE_DEFINITIONS = {\n  number: {\n    validate(value, propType) {\n      return Number.isFinite(value) && (!('max' in propType) || value <= propType.max) && (!('min' in propType) || value >= propType.min);\n    }\n\n  },\n  array: {\n    validate(value, propType) {\n      return Array.isArray(value) || ArrayBuffer.isView(value);\n    }\n\n  }\n};\nexport function parsePropTypes(propDefs) {\n  const propTypes = {};\n\n  for (const propName in propDefs) {\n    const propDef = propDefs[propName];\n    const propType = parsePropType(propDef);\n    propTypes[propName] = propType;\n  }\n\n  return propTypes;\n}\n\nfunction parsePropType(propDef) {\n  let type = getTypeOf(propDef);\n\n  if (type === 'object') {\n    if (!propDef) {\n      return {\n        type: 'object',\n        value: null\n      };\n    }\n\n    if ('type' in propDef) {\n      return Object.assign({}, propDef, TYPE_DEFINITIONS[propDef.type]);\n    }\n\n    if (!('value' in propDef)) {\n      return {\n        type: 'object',\n        value: propDef\n      };\n    }\n\n    type = getTypeOf(propDef.value);\n    return Object.assign({\n      type\n    }, propDef, TYPE_DEFINITIONS[type]);\n  }\n\n  return Object.assign({\n    type,\n    value: propDef\n  }, TYPE_DEFINITIONS[type]);\n}\n\nfunction getTypeOf(value) {\n  if (Array.isArray(value) || ArrayBuffer.isView(value)) {\n    return 'array';\n  }\n\n  return typeof value;\n}","map":{"version":3,"sources":["../../../../src/lib/filters/prop-types.js"],"names":["TYPE_DEFINITIONS","number","validate","Number","value","propType","array","Array","ArrayBuffer","propTypes","propDef","propDefs","parsePropType","type","getTypeOf","Object"],"mappings":"AAAA,MAAMA,gBAAgB,GAAG;AACvBC,EAAAA,MAAM,EAAE;AACNC,IAAAA,QAAQ,CAAA,KAAA,EAAA,QAAA,EAAkB;AACxB,aACEC,MAAM,CAANA,QAAAA,CAAAA,KAAAA,MACC,EAAE,SAAF,QAAA,KAAwBC,KAAK,IAAIC,QAAQ,CAD1CF,GAAAA,MAEC,EAAE,SAAF,QAAA,KAAwBC,KAAK,IAAIC,QAAQ,CAH5C,GACEF,CADF;AAKD;;AAPK,GADe;AAUvBG,EAAAA,KAAK,EAAE;AACLJ,IAAAA,QAAQ,CAAA,KAAA,EAAA,QAAA,EAAkB;AACxB,aAAOK,KAAK,CAALA,OAAAA,CAAAA,KAAAA,KAAwBC,WAAW,CAAXA,MAAAA,CAA/B,KAA+BA,CAA/B;AACD;;AAHI;AAVgB,CAAzB;AAiBA,OAAO,SAAA,cAAA,CAAA,QAAA,EAAkC;AACvC,QAAMC,SAAS,GAAf,EAAA;;AACA,OAAK,MAAL,QAAA,IAAA,QAAA,EAAiC;AAC/B,UAAMC,OAAO,GAAGC,QAAQ,CAAxB,QAAwB,CAAxB;AACA,UAAMN,QAAQ,GAAGO,aAAa,CAA9B,OAA8B,CAA9B;AACAH,IAAAA,SAAS,CAATA,QAAS,CAATA,GAAAA,QAAAA;AACD;;AACD,SAAA,SAAA;AACD;;AAKD,SAAA,aAAA,CAAA,OAAA,EAAgC;AAC9B,MAAII,IAAI,GAAGC,SAAS,CAApB,OAAoB,CAApB;;AACA,MAAID,IAAI,KAAR,QAAA,EAAuB;AACrB,QAAI,CAAJ,OAAA,EAAc;AACZ,aAAO;AAACA,QAAAA,IAAI,EAAL,QAAA;AAAiBT,QAAAA,KAAK,EAAE;AAAxB,OAAP;AACD;;AACD,QAAI,UAAJ,OAAA,EAAuB;AACrB,aAAOW,MAAM,CAANA,MAAAA,CAAAA,EAAAA,EAAAA,OAAAA,EAA2Bf,gBAAgB,CAACU,OAAO,CAA1D,IAAkD,CAA3CK,CAAP;AACD;;AACD,QAAI,EAAE,WAAN,OAAI,CAAJ,EAA2B;AAEzB,aAAO;AAACF,QAAAA,IAAI,EAAL,QAAA;AAAiBT,QAAAA,KAAK,EAAEM;AAAxB,OAAP;AACD;;AACDG,IAAAA,IAAI,GAAGC,SAAS,CAACJ,OAAO,CAAxBG,KAAgB,CAAhBA;AACA,WAAO,MAAM,CAAN,MAAA,CAAc;AAACA,MAAAA;AAAD,KAAd,EAAA,OAAA,EAA+Bb,gBAAgB,CAAtD,IAAsD,CAA/C,CAAP;AACD;;AACD,SAAO,MAAM,CAAN,MAAA,CAAc;AAAA,IAAA,IAAA;AAAOI,IAAAA,KAAK,EAAEM;AAAd,GAAd,EAAsCV,gBAAgB,CAA7D,IAA6D,CAAtD,CAAP;AACD;;AAGD,SAAA,SAAA,CAAA,KAAA,EAA0B;AACxB,MAAIO,KAAK,CAALA,OAAAA,CAAAA,KAAAA,KAAwBC,WAAW,CAAXA,MAAAA,CAA5B,KAA4BA,CAA5B,EAAuD;AACrD,WAAA,OAAA;AACD;;AACD,SAAO,OAAP,KAAA;AACD","sourcesContent":["const TYPE_DEFINITIONS = {\n  number: {\n    validate(value, propType) {\n      return (\n        Number.isFinite(value) &&\n        (!('max' in propType) || value <= propType.max) &&\n        (!('min' in propType) || value >= propType.min)\n      );\n    }\n  },\n  array: {\n    validate(value, propType) {\n      return Array.isArray(value) || ArrayBuffer.isView(value);\n    }\n  }\n};\n\nexport function parsePropTypes(propDefs) {\n  const propTypes = {};\n  for (const propName in propDefs) {\n    const propDef = propDefs[propName];\n    const propType = parsePropType(propDef);\n    propTypes[propName] = propType;\n  }\n  return propTypes;\n}\n\n// Parses one property definition entry. Either contains:\n// * a valid prop type object ({type, ...})\n// * or just a default value, in which case type and name inference is used\nfunction parsePropType(propDef) {\n  let type = getTypeOf(propDef);\n  if (type === 'object') {\n    if (!propDef) {\n      return {type: 'object', value: null};\n    }\n    if ('type' in propDef) {\n      return Object.assign({}, propDef, TYPE_DEFINITIONS[propDef.type]);\n    }\n    if (!('value' in propDef)) {\n      // If no type and value this object is likely the value\n      return {type: 'object', value: propDef};\n    }\n    type = getTypeOf(propDef.value);\n    return Object.assign({type}, propDef, TYPE_DEFINITIONS[type]);\n  }\n  return Object.assign({type, value: propDef}, TYPE_DEFINITIONS[type]);\n}\n\n// improved version of javascript typeof that can distinguish arrays and null values\nfunction getTypeOf(value) {\n  if (Array.isArray(value) || ArrayBuffer.isView(value)) {\n    return 'array';\n  }\n  return typeof value;\n}\n"]},"metadata":{},"sourceType":"module"}