{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport BaseTableBatchAggregator from './base-table-batch-aggregator';\nimport RowTableBatchAggregator from './row-table-batch-aggregator';\nimport ColumnarTableBatchAggregator from './columnar-table-batch-aggregator';\nconst DEFAULT_OPTIONS = {\n  shape: 'array-row-table',\n  batchSize: 'auto',\n  batchDebounceMs: 0,\n  limit: 0,\n  _limitMB: 0\n};\nconst ERR_MESSAGE = 'TableBatchBuilder';\nexport default class TableBatchBuilder {\n  constructor(schema, options) {\n    _defineProperty(this, \"schema\", void 0);\n\n    _defineProperty(this, \"options\", void 0);\n\n    _defineProperty(this, \"aggregator\", null);\n\n    _defineProperty(this, \"batchCount\", 0);\n\n    _defineProperty(this, \"bytesUsed\", 0);\n\n    _defineProperty(this, \"isChunkComplete\", false);\n\n    _defineProperty(this, \"lastBatchEmittedMs\", Date.now());\n\n    _defineProperty(this, \"totalLength\", 0);\n\n    _defineProperty(this, \"totalBytes\", 0);\n\n    _defineProperty(this, \"rowBytes\", 0);\n\n    this.schema = schema;\n    this.options = { ...DEFAULT_OPTIONS,\n      ...options\n    };\n  }\n\n  limitReached() {\n    var _this$options, _this$options2;\n\n    if (Boolean((_this$options = this.options) === null || _this$options === void 0 ? void 0 : _this$options.limit) && this.totalLength >= this.options.limit) {\n      return true;\n    }\n\n    if (Boolean((_this$options2 = this.options) === null || _this$options2 === void 0 ? void 0 : _this$options2._limitMB) && this.totalBytes / 1e6 >= this.options._limitMB) {\n      return true;\n    }\n\n    return false;\n  }\n\n  addRow(row) {\n    if (this.limitReached()) {\n      return;\n    }\n\n    this.totalLength++;\n    this.rowBytes = this.rowBytes || this._estimateRowMB(row);\n    this.totalBytes += this.rowBytes;\n\n    if (Array.isArray(row)) {\n      this.addArrayRow(row);\n    } else {\n      this.addObjectRow(row);\n    }\n  }\n\n  addArrayRow(row) {\n    if (!this.aggregator) {\n      const TableBatchType = this._getTableBatchType();\n\n      this.aggregator = new TableBatchType(this.schema, this.options);\n    }\n\n    this.aggregator.addArrayRow(row);\n  }\n\n  addObjectRow(row) {\n    if (!this.aggregator) {\n      const TableBatchType = this._getTableBatchType();\n\n      this.aggregator = new TableBatchType(this.schema, this.options);\n    }\n\n    this.aggregator.addObjectRow(row);\n  }\n\n  chunkComplete(chunk) {\n    if (chunk instanceof ArrayBuffer) {\n      this.bytesUsed += chunk.byteLength;\n    }\n\n    if (typeof chunk === 'string') {\n      this.bytesUsed += chunk.length;\n    }\n\n    this.isChunkComplete = true;\n  }\n\n  getFullBatch(options) {\n    return this._isFull() ? this._getBatch(options) : null;\n  }\n\n  getFinalBatch(options) {\n    return this._getBatch(options);\n  }\n\n  _estimateRowMB(row) {\n    return Array.isArray(row) ? row.length * 8 : Object.keys(row).length * 8;\n  }\n\n  _isFull() {\n    if (!this.aggregator || this.aggregator.rowCount() === 0) {\n      return false;\n    }\n\n    if (this.options.batchSize === 'auto') {\n      if (!this.isChunkComplete) {\n        return false;\n      }\n    } else if (this.options.batchSize > this.aggregator.rowCount()) {\n      return false;\n    }\n\n    if (this.options.batchDebounceMs > Date.now() - this.lastBatchEmittedMs) {\n      return false;\n    }\n\n    this.isChunkComplete = false;\n    this.lastBatchEmittedMs = Date.now();\n    return true;\n  }\n\n  _getBatch(options) {\n    if (!this.aggregator) {\n      return null;\n    }\n\n    if (options !== null && options !== void 0 && options.bytesUsed) {\n      this.bytesUsed = options.bytesUsed;\n    }\n\n    const normalizedBatch = this.aggregator.getBatch();\n    normalizedBatch.count = this.batchCount;\n    normalizedBatch.bytesUsed = this.bytesUsed;\n    Object.assign(normalizedBatch, options);\n    this.batchCount++;\n    this.aggregator = null;\n    return normalizedBatch;\n  }\n\n  _getTableBatchType() {\n    switch (this.options.shape) {\n      case 'row-table':\n        return BaseTableBatchAggregator;\n\n      case 'array-row-table':\n      case 'object-row-table':\n        return RowTableBatchAggregator;\n\n      case 'columnar-table':\n        return ColumnarTableBatchAggregator;\n\n      case 'arrow-table':\n        if (!TableBatchBuilder.ArrowBatch) {\n          throw new Error(ERR_MESSAGE);\n        }\n\n        return TableBatchBuilder.ArrowBatch;\n\n      default:\n        throw new Error(ERR_MESSAGE);\n    }\n  }\n\n}\n\n_defineProperty(TableBatchBuilder, \"ArrowBatch\", void 0);","map":{"version":3,"sources":["../../../../src/lib/table/table-batch-builder.ts"],"names":["DEFAULT_OPTIONS","shape","batchSize","batchDebounceMs","limit","_limitMB","ERR_MESSAGE","TableBatchBuilder","Date","constructor","options","limitReached","Boolean","addRow","Array","addArrayRow","TableBatchType","addObjectRow","chunkComplete","chunk","getFullBatch","getFinalBatch","_estimateRowMB","row","Object","_isFull","_getBatch","normalizedBatch","_getTableBatchType"],"mappings":"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","sourcesContent":["import type {Schema} from '../schema';\nimport type {TableBatch} from '../../category/table';\nimport type {TableBatchAggregator, TableBatchConstructor} from './table-batch-aggregator';\nimport BaseTableBatchAggregator from './base-table-batch-aggregator';\nimport RowTableBatchAggregator from './row-table-batch-aggregator';\nimport ColumnarTableBatchAggregator from './columnar-table-batch-aggregator';\n\n// TODO define interface instead\ntype TableBatchBuilderOptions = {\n  shape: 'row-table' | 'array-row-table' | 'object-row-table' | 'columnar-table' | 'arrow-table';\n  batchSize?: number | 'auto';\n  batchDebounceMs?: number;\n  limit: number;\n  _limitMB: number;\n};\n\ntype GetBatchOptions = {\n  bytesUsed?: number;\n  [key: string]: any;\n};\n\nconst DEFAULT_OPTIONS: Required<TableBatchBuilderOptions> = {\n  shape: 'array-row-table',\n  batchSize: 'auto',\n  batchDebounceMs: 0,\n  limit: 0,\n  _limitMB: 0\n};\n\nconst ERR_MESSAGE = 'TableBatchBuilder';\n\n/** Incrementally builds batches from a stream of rows */\nexport default class TableBatchBuilder {\n  schema: Schema;\n  options: Required<TableBatchBuilderOptions>;\n\n  private aggregator: TableBatchAggregator | null = null;\n  private batchCount: number = 0;\n  private bytesUsed: number = 0;\n  private isChunkComplete: boolean = false;\n  private lastBatchEmittedMs: number = Date.now();\n  private totalLength: number = 0;\n  private totalBytes: number = 0;\n  private rowBytes: number = 0;\n\n  static ArrowBatch?: TableBatchConstructor;\n\n  constructor(schema: Schema, options?: TableBatchBuilderOptions) {\n    this.schema = schema;\n    this.options = {...DEFAULT_OPTIONS, ...options};\n  }\n\n  limitReached(): boolean {\n    if (Boolean(this.options?.limit) && this.totalLength >= this.options.limit) {\n      return true;\n    }\n    if (Boolean(this.options?._limitMB) && this.totalBytes / 1e6 >= this.options._limitMB) {\n      return true;\n    }\n    return false;\n  }\n\n  /** @deprecated Use addArrayRow or addObjectRow */\n  addRow(row: any[] | {[columnName: string]: any}): void {\n    if (this.limitReached()) {\n      return;\n    }\n    this.totalLength++;\n    this.rowBytes = this.rowBytes || this._estimateRowMB(row);\n    this.totalBytes += this.rowBytes;\n    if (Array.isArray(row)) {\n      this.addArrayRow(row);\n    } else {\n      this.addObjectRow(row);\n    }\n  }\n\n  /** Add one row to the batch */\n  protected addArrayRow(row: any[]) {\n    if (!this.aggregator) {\n      const TableBatchType = this._getTableBatchType();\n      this.aggregator = new TableBatchType(this.schema, this.options);\n    }\n    this.aggregator.addArrayRow(row);\n  }\n\n  /** Add one row to the batch */\n  protected addObjectRow(row: {[columnName: string]: any}): void {\n    if (!this.aggregator) {\n      const TableBatchType = this._getTableBatchType();\n      this.aggregator = new TableBatchType(this.schema, this.options);\n    }\n    this.aggregator.addObjectRow(row);\n  }\n\n  /** Mark an incoming raw memory chunk has completed */\n  chunkComplete(chunk: ArrayBuffer | string): void {\n    if (chunk instanceof ArrayBuffer) {\n      this.bytesUsed += chunk.byteLength;\n    }\n    if (typeof chunk === 'string') {\n      this.bytesUsed += chunk.length;\n    }\n    this.isChunkComplete = true;\n  }\n\n  getFullBatch(options?: GetBatchOptions): TableBatch | null {\n    return this._isFull() ? this._getBatch(options) : null;\n  }\n\n  getFinalBatch(options?: GetBatchOptions): TableBatch | null {\n    return this._getBatch(options);\n  }\n\n  // INTERNAL\n\n  _estimateRowMB(row) {\n    return Array.isArray(row) ? row.length * 8 : Object.keys(row).length * 8;\n  }\n\n  private _isFull(): boolean {\n    // No batch, not ready\n    if (!this.aggregator || this.aggregator.rowCount() === 0) {\n      return false;\n    }\n\n    // if batchSize === 'auto' we wait for chunk to complete\n    // if batchSize === number, ensure we have enough rows\n    if (this.options.batchSize === 'auto') {\n      if (!this.isChunkComplete) {\n        return false;\n      }\n    } else if (this.options.batchSize > this.aggregator.rowCount()) {\n      return false;\n    }\n\n    // Debounce batches\n    if (this.options.batchDebounceMs > Date.now() - this.lastBatchEmittedMs) {\n      return false;\n    }\n\n    // Emit batch\n    this.isChunkComplete = false;\n    this.lastBatchEmittedMs = Date.now();\n    return true;\n  }\n\n  /**\n   * bytesUsed can be set via chunkComplete or via getBatch*\n   */\n  private _getBatch(options?: GetBatchOptions): TableBatch | null {\n    if (!this.aggregator) {\n      return null;\n    }\n\n    // TODO - this can overly increment bytes used?\n    if (options?.bytesUsed) {\n      this.bytesUsed = options.bytesUsed;\n    }\n    const normalizedBatch = this.aggregator.getBatch() as TableBatch;\n    normalizedBatch.count = this.batchCount;\n    normalizedBatch.bytesUsed = this.bytesUsed;\n    Object.assign(normalizedBatch, options);\n\n    this.batchCount++;\n    this.aggregator = null;\n    return normalizedBatch;\n  }\n\n  private _getTableBatchType(): TableBatchConstructor {\n    switch (this.options.shape) {\n      case 'row-table':\n        return BaseTableBatchAggregator;\n      case 'array-row-table':\n      case 'object-row-table':\n        return RowTableBatchAggregator;\n      case 'columnar-table':\n        return ColumnarTableBatchAggregator;\n      case 'arrow-table':\n        if (!TableBatchBuilder.ArrowBatch) {\n          throw new Error(ERR_MESSAGE);\n        }\n        return TableBatchBuilder.ArrowBatch;\n      default:\n        throw new Error(ERR_MESSAGE);\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}