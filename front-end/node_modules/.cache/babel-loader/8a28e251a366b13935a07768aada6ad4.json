{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { getMeshBoundingBox } from '@loaders.gl/schema';\nimport { makeSchemaFromAttributes } from './utils/schema-attribute-utils';\nconst GEOMETRY_TYPE = {\n  TRIANGULAR_MESH: 0,\n  POINT_CLOUD: 1\n};\nconst DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP = {\n  POSITION: 'POSITION',\n  NORMAL: 'NORMAL',\n  COLOR: 'COLOR_0',\n  TEX_COORD: 'TEXCOORD_0'\n};\nconst DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP = {\n  1: Int8Array,\n  2: Uint8Array,\n  3: Int16Array,\n  4: Uint16Array,\n  5: Int32Array,\n  6: Uint32Array,\n  9: Float32Array\n};\nconst INDEX_ITEM_SIZE = 4;\nexport default class DracoParser {\n  constructor(draco) {\n    _defineProperty(this, \"draco\", void 0);\n\n    _defineProperty(this, \"decoder\", void 0);\n\n    _defineProperty(this, \"metadataQuerier\", void 0);\n\n    this.draco = draco;\n    this.decoder = new this.draco.Decoder();\n    this.metadataQuerier = new this.draco.MetadataQuerier();\n  }\n\n  destroy() {\n    this.draco.destroy(this.decoder);\n    this.draco.destroy(this.metadataQuerier);\n  }\n\n  parseSync(arrayBuffer) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const buffer = new this.draco.DecoderBuffer();\n    buffer.Init(new Int8Array(arrayBuffer), arrayBuffer.byteLength);\n\n    this._disableAttributeTransforms(options);\n\n    const geometry_type = this.decoder.GetEncodedGeometryType(buffer);\n    const dracoGeometry = geometry_type === this.draco.TRIANGULAR_MESH ? new this.draco.Mesh() : new this.draco.PointCloud();\n\n    try {\n      let dracoStatus;\n\n      switch (geometry_type) {\n        case this.draco.TRIANGULAR_MESH:\n          dracoStatus = this.decoder.DecodeBufferToMesh(buffer, dracoGeometry);\n          break;\n\n        case this.draco.POINT_CLOUD:\n          dracoStatus = this.decoder.DecodeBufferToPointCloud(buffer, dracoGeometry);\n          break;\n\n        default:\n          throw new Error('DRACO: Unknown geometry type.');\n      }\n\n      if (!dracoStatus.ok() || !dracoGeometry.ptr) {\n        const message = \"DRACO decompression failed: \".concat(dracoStatus.error_msg());\n        throw new Error(message);\n      }\n\n      const loaderData = this._getDracoLoaderData(dracoGeometry, geometry_type, options);\n\n      const geometry = this._getMeshData(dracoGeometry, loaderData, options);\n\n      const boundingBox = getMeshBoundingBox(geometry.attributes);\n      const schema = makeSchemaFromAttributes(geometry.attributes, loaderData, geometry.indices);\n      const data = {\n        loader: 'draco',\n        loaderData,\n        header: {\n          vertexCount: dracoGeometry.num_points(),\n          boundingBox\n        },\n        ...geometry,\n        schema\n      };\n      return data;\n    } finally {\n      this.draco.destroy(buffer);\n\n      if (dracoGeometry) {\n        this.draco.destroy(dracoGeometry);\n      }\n    }\n  }\n\n  _getDracoLoaderData(dracoGeometry, geometry_type, options) {\n    const metadata = this._getTopLevelMetadata(dracoGeometry);\n\n    const attributes = this._getDracoAttributes(dracoGeometry, options);\n\n    return {\n      geometry_type,\n      num_attributes: dracoGeometry.num_attributes(),\n      num_points: dracoGeometry.num_points(),\n      num_faces: dracoGeometry instanceof this.draco.Mesh ? dracoGeometry.num_faces() : 0,\n      metadata,\n      attributes\n    };\n  }\n\n  _getDracoAttributes(dracoGeometry, options) {\n    const dracoAttributes = {};\n\n    for (let attributeId = 0; attributeId < dracoGeometry.num_attributes(); attributeId++) {\n      const dracoAttribute = this.decoder.GetAttribute(dracoGeometry, attributeId);\n\n      const metadata = this._getAttributeMetadata(dracoGeometry, attributeId);\n\n      dracoAttributes[dracoAttribute.unique_id()] = {\n        unique_id: dracoAttribute.unique_id(),\n        attribute_type: dracoAttribute.attribute_type(),\n        data_type: dracoAttribute.data_type(),\n        num_components: dracoAttribute.num_components(),\n        byte_offset: dracoAttribute.byte_offset(),\n        byte_stride: dracoAttribute.byte_stride(),\n        normalized: dracoAttribute.normalized(),\n        attribute_index: attributeId,\n        metadata\n      };\n\n      const quantization = this._getQuantizationTransform(dracoAttribute, options);\n\n      if (quantization) {\n        dracoAttributes[dracoAttribute.unique_id()].quantization_transform = quantization;\n      }\n\n      const octahedron = this._getOctahedronTransform(dracoAttribute, options);\n\n      if (octahedron) {\n        dracoAttributes[dracoAttribute.unique_id()].octahedron_transform = octahedron;\n      }\n    }\n\n    return dracoAttributes;\n  }\n\n  _getMeshData(dracoGeometry, loaderData, options) {\n    const attributes = this._getMeshAttributes(loaderData, dracoGeometry, options);\n\n    const positionAttribute = attributes.POSITION;\n\n    if (!positionAttribute) {\n      throw new Error('DRACO: No position attribute found.');\n    }\n\n    if (dracoGeometry instanceof this.draco.Mesh) {\n      switch (options.topology) {\n        case 'triangle-strip':\n          return {\n            topology: 'triangle-strip',\n            mode: 4,\n            attributes,\n            indices: {\n              value: this._getTriangleStripIndices(dracoGeometry),\n              size: 1\n            }\n          };\n\n        case 'triangle-list':\n        default:\n          return {\n            topology: 'triangle-list',\n            mode: 5,\n            attributes,\n            indices: {\n              value: this._getTriangleListIndices(dracoGeometry),\n              size: 1\n            }\n          };\n      }\n    }\n\n    return {\n      topology: 'point-list',\n      mode: 0,\n      attributes\n    };\n  }\n\n  _getMeshAttributes(loaderData, dracoGeometry, options) {\n    const attributes = {};\n\n    for (const loaderAttribute of Object.values(loaderData.attributes)) {\n      const attributeName = this._deduceAttributeName(loaderAttribute, options);\n\n      loaderAttribute.name = attributeName;\n\n      const {\n        value,\n        size\n      } = this._getAttributeValues(dracoGeometry, loaderAttribute);\n\n      attributes[attributeName] = {\n        value,\n        size,\n        byteOffset: loaderAttribute.byte_offset,\n        byteStride: loaderAttribute.byte_stride,\n        normalized: loaderAttribute.normalized\n      };\n    }\n\n    return attributes;\n  }\n\n  _getTriangleListIndices(dracoGeometry) {\n    const numFaces = dracoGeometry.num_faces();\n    const numIndices = numFaces * 3;\n    const byteLength = numIndices * INDEX_ITEM_SIZE;\n\n    const ptr = this.draco._malloc(byteLength);\n\n    try {\n      this.decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr);\n      return new Uint32Array(this.draco.HEAPF32.buffer, ptr, numIndices).slice();\n    } finally {\n      this.draco._free(ptr);\n    }\n  }\n\n  _getTriangleStripIndices(dracoGeometry) {\n    const dracoArray = new this.draco.DracoInt32Array();\n\n    try {\n      this.decoder.GetTriangleStripsFromMesh(dracoGeometry, dracoArray);\n      return getUint32Array(dracoArray);\n    } finally {\n      this.draco.destroy(dracoArray);\n    }\n  }\n\n  _getAttributeValues(dracoGeometry, attribute) {\n    const TypedArrayCtor = DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP[attribute.data_type];\n    const numComponents = attribute.num_components;\n    const numPoints = dracoGeometry.num_points();\n    const numValues = numPoints * numComponents;\n    const byteLength = numValues * TypedArrayCtor.BYTES_PER_ELEMENT;\n    const dataType = getDracoDataType(this.draco, TypedArrayCtor);\n    let value;\n\n    const ptr = this.draco._malloc(byteLength);\n\n    try {\n      const dracoAttribute = this.decoder.GetAttribute(dracoGeometry, attribute.attribute_index);\n      this.decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, dracoAttribute, dataType, byteLength, ptr);\n      value = new TypedArrayCtor(this.draco.HEAPF32.buffer, ptr, numValues).slice();\n    } finally {\n      this.draco._free(ptr);\n    }\n\n    return {\n      value,\n      size: numComponents\n    };\n  }\n\n  _deduceAttributeName(attribute, options) {\n    const uniqueId = attribute.unique_id;\n\n    for (const [attributeName, attributeUniqueId] of Object.entries(options.extraAttributes || {})) {\n      if (attributeUniqueId === uniqueId) {\n        return attributeName;\n      }\n    }\n\n    const thisAttributeType = attribute.attribute_type;\n\n    for (const dracoAttributeConstant in DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP) {\n      const attributeType = this.draco[dracoAttributeConstant];\n\n      if (attributeType === thisAttributeType) {\n        return DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP[dracoAttributeConstant];\n      }\n    }\n\n    const entryName = options.attributeNameEntry || 'name';\n\n    if (attribute.metadata[entryName]) {\n      return attribute.metadata[entryName].string;\n    }\n\n    return \"CUSTOM_ATTRIBUTE_\".concat(uniqueId);\n  }\n\n  _getTopLevelMetadata(dracoGeometry) {\n    const dracoMetadata = this.decoder.GetMetadata(dracoGeometry);\n    return this._getDracoMetadata(dracoMetadata);\n  }\n\n  _getAttributeMetadata(dracoGeometry, attributeId) {\n    const dracoMetadata = this.decoder.GetAttributeMetadata(dracoGeometry, attributeId);\n    return this._getDracoMetadata(dracoMetadata);\n  }\n\n  _getDracoMetadata(dracoMetadata) {\n    if (!dracoMetadata || !dracoMetadata.ptr) {\n      return {};\n    }\n\n    const result = {};\n    const numEntries = this.metadataQuerier.NumEntries(dracoMetadata);\n\n    for (let entryIndex = 0; entryIndex < numEntries; entryIndex++) {\n      const entryName = this.metadataQuerier.GetEntryName(dracoMetadata, entryIndex);\n      result[entryName] = this._getDracoMetadataField(dracoMetadata, entryName);\n    }\n\n    return result;\n  }\n\n  _getDracoMetadataField(dracoMetadata, entryName) {\n    const dracoArray = new this.draco.DracoInt32Array();\n\n    try {\n      this.metadataQuerier.GetIntEntryArray(dracoMetadata, entryName, dracoArray);\n      const intArray = getInt32Array(dracoArray);\n      return {\n        int: this.metadataQuerier.GetIntEntry(dracoMetadata, entryName),\n        string: this.metadataQuerier.GetStringEntry(dracoMetadata, entryName),\n        double: this.metadataQuerier.GetDoubleEntry(dracoMetadata, entryName),\n        intArray\n      };\n    } finally {\n      this.draco.destroy(dracoArray);\n    }\n  }\n\n  _disableAttributeTransforms(options) {\n    const {\n      quantizedAttributes = [],\n      octahedronAttributes = []\n    } = options;\n    const skipAttributes = [...quantizedAttributes, ...octahedronAttributes];\n\n    for (const dracoAttributeName of skipAttributes) {\n      this.decoder.SkipAttributeTransform(this.draco[dracoAttributeName]);\n    }\n  }\n\n  _getQuantizationTransform(dracoAttribute, options) {\n    const {\n      quantizedAttributes = []\n    } = options;\n    const attribute_type = dracoAttribute.attribute_type();\n    const skip = quantizedAttributes.map(type => this.decoder[type]).includes(attribute_type);\n\n    if (skip) {\n      const transform = new this.draco.AttributeQuantizationTransform();\n\n      try {\n        if (transform.InitFromAttribute(dracoAttribute)) {\n          return {\n            quantization_bits: transform.quantization_bits(),\n            range: transform.range(),\n            min_values: new Float32Array([1, 2, 3]).map(i => transform.min_value(i))\n          };\n        }\n      } finally {\n        this.draco.destroy(transform);\n      }\n    }\n\n    return null;\n  }\n\n  _getOctahedronTransform(dracoAttribute, options) {\n    const {\n      octahedronAttributes = []\n    } = options;\n    const attribute_type = dracoAttribute.attribute_type();\n    const octahedron = octahedronAttributes.map(type => this.decoder[type]).includes(attribute_type);\n\n    if (octahedron) {\n      const transform = new this.draco.AttributeQuantizationTransform();\n\n      try {\n        if (transform.InitFromAttribute(dracoAttribute)) {\n          return {\n            quantization_bits: transform.quantization_bits()\n          };\n        }\n      } finally {\n        this.draco.destroy(transform);\n      }\n    }\n\n    return null;\n  }\n\n}\n\nfunction getDracoDataType(draco, attributeType) {\n  switch (attributeType) {\n    case Float32Array:\n      return draco.DT_FLOAT32;\n\n    case Int8Array:\n      return draco.DT_INT8;\n\n    case Int16Array:\n      return draco.DT_INT16;\n\n    case Int32Array:\n      return draco.DT_INT32;\n\n    case Uint8Array:\n      return draco.DT_UINT8;\n\n    case Uint16Array:\n      return draco.DT_UINT16;\n\n    case Uint32Array:\n      return draco.DT_UINT32;\n\n    default:\n      return draco.DT_INVALID;\n  }\n}\n\nfunction getInt32Array(dracoArray) {\n  const numValues = dracoArray.size();\n  const intArray = new Int32Array(numValues);\n\n  for (let i = 0; i < numValues; i++) {\n    intArray[i] = dracoArray.GetValue(i);\n  }\n\n  return intArray;\n}\n\nfunction getUint32Array(dracoArray) {\n  const numValues = dracoArray.size();\n  const intArray = new Int32Array(numValues);\n\n  for (let i = 0; i < numValues; i++) {\n    intArray[i] = dracoArray.GetValue(i);\n  }\n\n  return intArray;\n}","map":{"version":3,"sources":["../../../src/lib/draco-parser.ts"],"names":["GEOMETRY_TYPE","TRIANGULAR_MESH","POINT_CLOUD","DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP","POSITION","NORMAL","COLOR","TEX_COORD","DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP","Float32Array","INDEX_ITEM_SIZE","constructor","destroy","parseSync","options","buffer","arrayBuffer","geometry_type","dracoGeometry","dracoStatus","message","loaderData","geometry","boundingBox","getMeshBoundingBox","schema","makeSchemaFromAttributes","data","loader","header","vertexCount","_getDracoLoaderData","metadata","attributes","num_attributes","num_points","num_faces","_getDracoAttributes","dracoAttributes","attributeId","dracoAttribute","unique_id","attribute_type","data_type","num_components","byte_offset","byte_stride","normalized","attribute_index","quantization","octahedron","_getMeshData","positionAttribute","topology","mode","indices","value","size","_getMeshAttributes","Object","attributeName","loaderAttribute","byteOffset","byteStride","_getTriangleListIndices","numFaces","numIndices","byteLength","ptr","_getTriangleStripIndices","dracoArray","getUint32Array","_getAttributeValues","TypedArrayCtor","attribute","numComponents","numPoints","numValues","dataType","getDracoDataType","_deduceAttributeName","uniqueId","attributeUniqueId","thisAttributeType","attributeType","entryName","_getTopLevelMetadata","dracoMetadata","_getAttributeMetadata","_getDracoMetadata","result","numEntries","entryIndex","_getDracoMetadataField","intArray","getInt32Array","int","string","double","_disableAttributeTransforms","quantizedAttributes","octahedronAttributes","skipAttributes","_getQuantizationTransform","skip","type","transform","quantization_bits","range","min_values","i","_getOctahedronTransform","draco"],"mappings":"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","sourcesContent":["/* eslint-disable camelcase */\n\n// Draco types (input)\nimport type {\n  Draco3D,\n  Decoder,\n  Mesh,\n  PointCloud,\n  PointAttribute,\n  Metadata,\n  MetadataQuerier,\n  DracoInt32Array,\n  draco_DataType\n} from '../draco3d/draco3d-types';\n\n// Parsed data types (output)\nimport type {\n  TypedArray,\n  // standard mesh output data\n  MeshData,\n  MeshAttribute,\n  // standard mesh with draco metadata\n  DracoMeshData,\n  DracoLoaderData,\n  DracoAttribute,\n  DracoMetadataEntry,\n  DracoQuantizationTransform,\n  DracoOctahedronTransform\n} from './draco-types';\n\nimport {getMeshBoundingBox} from '@loaders.gl/schema';\nimport {makeSchemaFromAttributes} from './utils/schema-attribute-utils';\n\n/**\n * @param topology - How triangle indices should be generated (mesh only)\n * @param attributeNameEntry\n * @param extraAttributes\n * @param quantizedAttributes\n * @param octahedronAttributes\n */\nexport type DracoParseOptions = {\n  topology?: 'triangle-list' | 'triangle-strip';\n  attributeNameEntry?: string;\n  extraAttributes?: {[uniqueId: string]: number};\n  quantizedAttributes?: ('POSITION' | 'NORMAL' | 'COLOR' | 'TEX_COORD' | 'GENERIC')[];\n  octahedronAttributes?: ('POSITION' | 'NORMAL' | 'COLOR' | 'TEX_COORD' | 'GENERIC')[];\n};\n\n// @ts-ignore\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst GEOMETRY_TYPE = {\n  TRIANGULAR_MESH: 0,\n  POINT_CLOUD: 1\n};\n\n// Native Draco attribute names to GLTF attribute names.\nconst DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP = {\n  POSITION: 'POSITION',\n  NORMAL: 'NORMAL',\n  COLOR: 'COLOR_0',\n  TEX_COORD: 'TEXCOORD_0'\n};\n\nconst DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP = {\n  1: Int8Array,\n  2: Uint8Array,\n  3: Int16Array,\n  4: Uint16Array,\n  5: Int32Array,\n  6: Uint32Array,\n  9: Float32Array\n};\n\nconst INDEX_ITEM_SIZE = 4;\n\nexport default class DracoParser {\n  draco: Draco3D;\n  decoder: Decoder;\n  metadataQuerier: MetadataQuerier;\n\n  // draco - the draco decoder, either import `draco3d` or load dynamically\n  constructor(draco: Draco3D) {\n    this.draco = draco;\n    this.decoder = new this.draco.Decoder();\n    this.metadataQuerier = new this.draco.MetadataQuerier();\n  }\n\n  /**\n   * Destroy draco resources\n   */\n  destroy(): void {\n    this.draco.destroy(this.decoder);\n    this.draco.destroy(this.metadataQuerier);\n  }\n\n  /**\n   * NOTE: caller must call `destroyGeometry` on the return value after using it\n   * @param arrayBuffer\n   * @param options\n   */\n  parseSync(arrayBuffer: ArrayBuffer, options: DracoParseOptions = {}): DracoMeshData {\n    const buffer = new this.draco.DecoderBuffer();\n    buffer.Init(new Int8Array(arrayBuffer), arrayBuffer.byteLength);\n\n    this._disableAttributeTransforms(options);\n\n    const geometry_type = this.decoder.GetEncodedGeometryType(buffer);\n    const dracoGeometry =\n      geometry_type === this.draco.TRIANGULAR_MESH\n        ? new this.draco.Mesh()\n        : new this.draco.PointCloud();\n\n    try {\n      let dracoStatus;\n      switch (geometry_type) {\n        case this.draco.TRIANGULAR_MESH:\n          dracoStatus = this.decoder.DecodeBufferToMesh(buffer, dracoGeometry as Mesh);\n          break;\n\n        case this.draco.POINT_CLOUD:\n          dracoStatus = this.decoder.DecodeBufferToPointCloud(buffer, dracoGeometry);\n          break;\n\n        default:\n          throw new Error('DRACO: Unknown geometry type.');\n      }\n\n      if (!dracoStatus.ok() || !dracoGeometry.ptr) {\n        const message = `DRACO decompression failed: ${dracoStatus.error_msg()}`;\n        // console.error(message);\n        throw new Error(message);\n      }\n\n      const loaderData = this._getDracoLoaderData(dracoGeometry, geometry_type, options);\n\n      const geometry = this._getMeshData(dracoGeometry, loaderData, options);\n\n      const boundingBox = getMeshBoundingBox(geometry.attributes);\n\n      const schema = makeSchemaFromAttributes(geometry.attributes, loaderData, geometry.indices);\n\n      const data: DracoMeshData = {\n        loader: 'draco',\n        loaderData,\n        header: {\n          vertexCount: dracoGeometry.num_points(),\n          boundingBox\n        },\n        ...geometry,\n        schema\n      };\n      return data;\n    } finally {\n      this.draco.destroy(buffer);\n      if (dracoGeometry) {\n        this.draco.destroy(dracoGeometry);\n      }\n    }\n  }\n\n  // Draco specific \"loader data\"\n\n  /**\n   * Extract\n   * @param dracoGeometry\n   * @param geometry_type\n   * @param options\n   * @returns\n   */\n  _getDracoLoaderData(\n    dracoGeometry: Mesh | PointCloud,\n    geometry_type,\n    options: DracoParseOptions\n  ): DracoLoaderData {\n    const metadata = this._getTopLevelMetadata(dracoGeometry);\n    const attributes = this._getDracoAttributes(dracoGeometry, options);\n\n    return {\n      geometry_type,\n      num_attributes: dracoGeometry.num_attributes(),\n      num_points: dracoGeometry.num_points(),\n      num_faces: dracoGeometry instanceof this.draco.Mesh ? dracoGeometry.num_faces() : 0,\n      metadata,\n      attributes\n    };\n  }\n\n  /**\n   * Extract all draco provided information and metadata for each attribute\n   * @param dracoGeometry\n   * @param options\n   * @returns\n   */\n  _getDracoAttributes(\n    dracoGeometry: Mesh | PointCloud,\n    options: DracoParseOptions\n  ): {[unique_id: number]: DracoAttribute} {\n    const dracoAttributes: {[unique_id: number]: DracoAttribute} = {};\n\n    for (let attributeId = 0; attributeId < dracoGeometry.num_attributes(); attributeId++) {\n      // Note: Draco docs do not seem clear on `GetAttribute` ids just being a zero-based index,\n      // but it does seems to work this way\n      const dracoAttribute = this.decoder.GetAttribute(dracoGeometry, attributeId);\n\n      const metadata = this._getAttributeMetadata(dracoGeometry, attributeId);\n\n      dracoAttributes[dracoAttribute.unique_id()] = {\n        unique_id: dracoAttribute.unique_id(),\n        attribute_type: dracoAttribute.attribute_type(),\n        data_type: dracoAttribute.data_type(),\n        num_components: dracoAttribute.num_components(),\n\n        byte_offset: dracoAttribute.byte_offset(),\n        byte_stride: dracoAttribute.byte_stride(),\n        normalized: dracoAttribute.normalized(),\n        attribute_index: attributeId,\n\n        metadata\n      };\n\n      // Add transformation parameters for any attributes app wants untransformed\n      const quantization = this._getQuantizationTransform(dracoAttribute, options);\n      if (quantization) {\n        dracoAttributes[dracoAttribute.unique_id()].quantization_transform = quantization;\n      }\n\n      const octahedron = this._getOctahedronTransform(dracoAttribute, options);\n      if (octahedron) {\n        dracoAttributes[dracoAttribute.unique_id()].octahedron_transform = octahedron;\n      }\n    }\n\n    return dracoAttributes;\n  }\n\n  /**\n   * Get standard loaders.gl mesh category data\n   * Extracts the geometry from draco\n   * @param dracoGeometry\n   * @param options\n   */\n  _getMeshData(\n    dracoGeometry: Mesh | PointCloud,\n    loaderData: DracoLoaderData,\n    options: DracoParseOptions\n  ): MeshData {\n    const attributes = this._getMeshAttributes(loaderData, dracoGeometry, options);\n\n    const positionAttribute = attributes.POSITION;\n    if (!positionAttribute) {\n      throw new Error('DRACO: No position attribute found.');\n    }\n\n    // For meshes, we need indices to define the faces.\n    if (dracoGeometry instanceof this.draco.Mesh) {\n      switch (options.topology) {\n        case 'triangle-strip':\n          return {\n            topology: 'triangle-strip',\n            mode: 4, // GL.TRIANGLES\n            attributes,\n            indices: {\n              value: this._getTriangleStripIndices(dracoGeometry),\n              size: 1\n            }\n          };\n        case 'triangle-list':\n        default:\n          return {\n            topology: 'triangle-list',\n            mode: 5, // GL.TRIANGLE_STRIP\n            attributes,\n            indices: {\n              value: this._getTriangleListIndices(dracoGeometry),\n              size: 1\n            }\n          };\n      }\n    }\n\n    // PointCloud - must come last as Mesh inherits from PointCloud\n    return {\n      topology: 'point-list',\n      mode: 0, // GL.POINTS\n      attributes\n    };\n  }\n\n  _getMeshAttributes(\n    loaderData: DracoLoaderData,\n    dracoGeometry: Mesh | PointCloud,\n    options: DracoParseOptions\n  ): {[attributeName: string]: MeshAttribute} {\n    const attributes: {[key: string]: MeshAttribute} = {};\n\n    for (const loaderAttribute of Object.values(loaderData.attributes)) {\n      const attributeName = this._deduceAttributeName(loaderAttribute, options);\n      loaderAttribute.name = attributeName;\n      const {value, size} = this._getAttributeValues(dracoGeometry, loaderAttribute);\n      attributes[attributeName] = {\n        value,\n        size,\n        byteOffset: loaderAttribute.byte_offset,\n        byteStride: loaderAttribute.byte_stride,\n        normalized: loaderAttribute.normalized\n      };\n    }\n\n    return attributes;\n  }\n\n  // MESH INDICES EXTRACTION\n\n  /**\n   * For meshes, we need indices to define the faces.\n   * @param dracoGeometry\n   */\n  _getTriangleListIndices(dracoGeometry: Mesh) {\n    // Example on how to retrieve mesh and attributes.\n    const numFaces = dracoGeometry.num_faces();\n    const numIndices = numFaces * 3;\n    const byteLength = numIndices * INDEX_ITEM_SIZE;\n\n    const ptr = this.draco._malloc(byteLength);\n    try {\n      this.decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr);\n      return new Uint32Array(this.draco.HEAPF32.buffer, ptr, numIndices).slice();\n    } finally {\n      this.draco._free(ptr);\n    }\n  }\n\n  /**\n   * For meshes, we need indices to define the faces.\n   * @param dracoGeometry\n   */\n  _getTriangleStripIndices(dracoGeometry: Mesh) {\n    const dracoArray = new this.draco.DracoInt32Array();\n    try {\n      /* const numStrips = */ this.decoder.GetTriangleStripsFromMesh(dracoGeometry, dracoArray);\n      return getUint32Array(dracoArray);\n    } finally {\n      this.draco.destroy(dracoArray);\n    }\n  }\n\n  /**\n   *\n   * @param dracoGeometry\n   * @param dracoAttribute\n   * @param attributeName\n   */\n  _getAttributeValues(\n    dracoGeometry: Mesh | PointCloud,\n    attribute: DracoAttribute\n  ): {value: TypedArray; size: number} {\n    const TypedArrayCtor = DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP[attribute.data_type];\n    const numComponents = attribute.num_components;\n    const numPoints = dracoGeometry.num_points();\n    const numValues = numPoints * numComponents;\n\n    const byteLength = numValues * TypedArrayCtor.BYTES_PER_ELEMENT;\n    const dataType = getDracoDataType(this.draco, TypedArrayCtor);\n\n    let value: TypedArray;\n\n    const ptr = this.draco._malloc(byteLength);\n    try {\n      const dracoAttribute = this.decoder.GetAttribute(dracoGeometry, attribute.attribute_index);\n      this.decoder.GetAttributeDataArrayForAllPoints(\n        dracoGeometry,\n        dracoAttribute,\n        dataType,\n        byteLength,\n        ptr\n      );\n      value = new TypedArrayCtor(this.draco.HEAPF32.buffer, ptr, numValues).slice();\n    } finally {\n      this.draco._free(ptr);\n    }\n\n    return {value, size: numComponents};\n  }\n\n  // Attribute names\n\n  /** \n   * DRACO does not store attribute names - We need to deduce an attribute name\n   * for each attribute\n  _getAttributeNames(\n    dracoGeometry: Mesh | PointCloud,\n    options: DracoParseOptions\n  ): {[unique_id: number]: string} {\n    const attributeNames: {[unique_id: number]: string} = {};\n    for (let attributeId = 0; attributeId < dracoGeometry.num_attributes(); attributeId++) {\n      const dracoAttribute = this.decoder.GetAttribute(dracoGeometry, attributeId);\n      const attributeName = this._deduceAttributeName(dracoAttribute, options);\n      attributeNames[attributeName] = attributeName;\n    }\n    return attributeNames;\n  }\n   */\n\n  /**\n   * Deduce an attribute name.\n   * @note DRACO does not save attribute names, just general type (POSITION, COLOR)\n   * to help optimize compression. We generate GLTF compatible names for the Draco-recognized\n   * types\n   * @param attributeData\n   */\n  _deduceAttributeName(attribute: DracoAttribute, options: DracoParseOptions): string {\n    // Deduce name based on application provided map\n    const uniqueId = attribute.unique_id;\n    for (const [attributeName, attributeUniqueId] of Object.entries(\n      options.extraAttributes || {}\n    )) {\n      if (attributeUniqueId === uniqueId) {\n        return attributeName;\n      }\n    }\n\n    // Deduce name based on attribute type\n    const thisAttributeType = attribute.attribute_type;\n    for (const dracoAttributeConstant in DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP) {\n      const attributeType = this.draco[dracoAttributeConstant];\n      if (attributeType === thisAttributeType) {\n        // TODO - Return unique names if there multiple attributes per type\n        // (e.g. multiple TEX_COORDS or COLORS)\n        return DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP[dracoAttributeConstant];\n      }\n    }\n\n    // Look up in metadata\n    // TODO - shouldn't this have priority?\n    const entryName = options.attributeNameEntry || 'name';\n    if (attribute.metadata[entryName]) {\n      return attribute.metadata[entryName].string;\n    }\n\n    // Attribute of \"GENERIC\" type, we need to assign some name\n    return `CUSTOM_ATTRIBUTE_${uniqueId}`;\n  }\n\n  // METADATA EXTRACTION\n\n  /** Get top level metadata */\n  _getTopLevelMetadata(dracoGeometry: Mesh | PointCloud) {\n    const dracoMetadata = this.decoder.GetMetadata(dracoGeometry);\n    return this._getDracoMetadata(dracoMetadata);\n  }\n\n  /** Get per attribute metadata */\n  _getAttributeMetadata(dracoGeometry: Mesh | PointCloud, attributeId: number) {\n    const dracoMetadata = this.decoder.GetAttributeMetadata(dracoGeometry, attributeId);\n    return this._getDracoMetadata(dracoMetadata);\n  }\n\n  /**\n   * Extract metadata field values\n   * @param dracoMetadata\n   * @returns\n   */\n  _getDracoMetadata(dracoMetadata: Metadata): {[entry: string]: DracoMetadataEntry} {\n    // The not so wonderful world of undocumented Draco APIs :(\n    if (!dracoMetadata || !dracoMetadata.ptr) {\n      return {};\n    }\n    const result = {};\n    const numEntries = this.metadataQuerier.NumEntries(dracoMetadata);\n    for (let entryIndex = 0; entryIndex < numEntries; entryIndex++) {\n      const entryName = this.metadataQuerier.GetEntryName(dracoMetadata, entryIndex);\n      result[entryName] = this._getDracoMetadataField(dracoMetadata, entryName);\n    }\n    return result;\n  }\n\n  /**\n   * Extracts possible values for one metadata entry by name\n   * @param dracoMetadata\n   * @param entryName\n   */\n  _getDracoMetadataField(dracoMetadata: Metadata, entryName: string): DracoMetadataEntry {\n    const dracoArray = new this.draco.DracoInt32Array();\n    try {\n      // Draco metadata fields can hold int32 arrays\n      this.metadataQuerier.GetIntEntryArray(dracoMetadata, entryName, dracoArray);\n      const intArray = getInt32Array(dracoArray);\n      return {\n        int: this.metadataQuerier.GetIntEntry(dracoMetadata, entryName),\n        string: this.metadataQuerier.GetStringEntry(dracoMetadata, entryName),\n        double: this.metadataQuerier.GetDoubleEntry(dracoMetadata, entryName),\n        intArray\n      };\n    } finally {\n      this.draco.destroy(dracoArray);\n    }\n  }\n\n  // QUANTIZED ATTRIBUTE SUPPORT (NO DECOMPRESSION)\n\n  /** Skip transforms for specific attribute types */\n  _disableAttributeTransforms(options: DracoParseOptions) {\n    const {quantizedAttributes = [], octahedronAttributes = []} = options;\n    const skipAttributes = [...quantizedAttributes, ...octahedronAttributes];\n    for (const dracoAttributeName of skipAttributes) {\n      this.decoder.SkipAttributeTransform(this.draco[dracoAttributeName]);\n    }\n  }\n\n  /**\n   * Extract (and apply?) Position Transform\n   * @todo not used\n   */\n  _getQuantizationTransform(\n    dracoAttribute: PointAttribute,\n    options: DracoParseOptions\n  ): DracoQuantizationTransform | null {\n    const {quantizedAttributes = []} = options;\n    const attribute_type = dracoAttribute.attribute_type();\n    const skip = quantizedAttributes.map((type) => this.decoder[type]).includes(attribute_type);\n    if (skip) {\n      const transform = new this.draco.AttributeQuantizationTransform();\n      try {\n        if (transform.InitFromAttribute(dracoAttribute)) {\n          return {\n            quantization_bits: transform.quantization_bits(),\n            range: transform.range(),\n            min_values: new Float32Array([1, 2, 3]).map((i) => transform.min_value(i))\n          };\n        }\n      } finally {\n        this.draco.destroy(transform);\n      }\n    }\n    return null;\n  }\n\n  _getOctahedronTransform(\n    dracoAttribute: PointAttribute,\n    options: DracoParseOptions\n  ): DracoOctahedronTransform | null {\n    const {octahedronAttributes = []} = options;\n    const attribute_type = dracoAttribute.attribute_type();\n    const octahedron = octahedronAttributes\n      .map((type) => this.decoder[type])\n      .includes(attribute_type);\n    if (octahedron) {\n      const transform = new this.draco.AttributeQuantizationTransform();\n      try {\n        if (transform.InitFromAttribute(dracoAttribute)) {\n          return {\n            quantization_bits: transform.quantization_bits()\n          };\n        }\n      } finally {\n        this.draco.destroy(transform);\n      }\n    }\n    return null;\n  }\n\n  // HELPERS\n}\n\n/**\n * Get draco specific data type by TypedArray constructor type\n * @param attributeType\n * @returns draco specific data type\n */\nfunction getDracoDataType(draco: Draco3D, attributeType: any): draco_DataType {\n  switch (attributeType) {\n    case Float32Array:\n      return draco.DT_FLOAT32;\n    case Int8Array:\n      return draco.DT_INT8;\n    case Int16Array:\n      return draco.DT_INT16;\n    case Int32Array:\n      return draco.DT_INT32;\n    case Uint8Array:\n      return draco.DT_UINT8;\n    case Uint16Array:\n      return draco.DT_UINT16;\n    case Uint32Array:\n      return draco.DT_UINT32;\n    default:\n      return draco.DT_INVALID;\n  }\n}\n\n/**\n * Copy a Draco int32 array into a JS typed array\n */\nfunction getInt32Array(dracoArray: DracoInt32Array): Int32Array {\n  const numValues = dracoArray.size();\n  const intArray = new Int32Array(numValues);\n  for (let i = 0; i < numValues; i++) {\n    intArray[i] = dracoArray.GetValue(i);\n  }\n  return intArray;\n}\n\n/**\n * Copy a Draco int32 array into a JS typed array\n */\nfunction getUint32Array(dracoArray: DracoInt32Array): Int32Array {\n  const numValues = dracoArray.size();\n  const intArray = new Int32Array(numValues);\n  for (let i = 0; i < numValues; i++) {\n    intArray[i] = dracoArray.GetValue(i);\n  }\n  return intArray;\n}\n"]},"metadata":{},"sourceType":"module"}