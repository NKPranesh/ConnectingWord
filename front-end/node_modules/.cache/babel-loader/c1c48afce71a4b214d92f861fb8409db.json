{"ast":null,"code":"import { earcut } from '@math.gl/polygon';\nexport function featuresToBinary(features, firstPassData) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return fillArrays(features, firstPassData, {\n    numericPropKeys: options.numericPropKeys || extractNumericPropKeys(features),\n    PositionDataType: options.PositionDataType || Float32Array\n  });\n}\nexport const TEST_EXPORTS = {\n  extractNumericPropKeys,\n  fillArrays\n};\n\nfunction extractNumericPropKeys(features) {\n  const numericPropKeys = {};\n\n  for (const feature of features) {\n    if (feature.properties) {\n      for (const key in feature.properties) {\n        const numericSoFar = numericPropKeys[key];\n\n        if (numericSoFar || numericSoFar === undefined) {\n          const val = feature.properties[key];\n          numericPropKeys[key] = isNumeric(val);\n        }\n      }\n    }\n  }\n\n  return Object.keys(numericPropKeys).filter(k => numericPropKeys[k]);\n}\n\nfunction fillArrays(features) {\n  let firstPassData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const {\n    pointPositionsCount,\n    pointFeaturesCount,\n    linePositionsCount,\n    linePathsCount,\n    lineFeaturesCount,\n    polygonPositionsCount,\n    polygonObjectsCount,\n    polygonRingsCount,\n    polygonFeaturesCount\n  } = firstPassData;\n  const {\n    numericPropKeys,\n    PositionDataType = Float32Array\n  } = options;\n  const hasGlobalId = features[0] && 'id' in features[0];\n  const coordLength = 2;\n  const GlobalFeatureIdsDataType = features.length > 65535 ? Uint32Array : Uint16Array;\n  const points = {\n    positions: new PositionDataType(pointPositionsCount * coordLength),\n    globalFeatureIds: new GlobalFeatureIdsDataType(pointPositionsCount),\n    featureIds: pointFeaturesCount > 65535 ? new Uint32Array(pointPositionsCount) : new Uint16Array(pointPositionsCount),\n    numericProps: {},\n    properties: [],\n    fields: []\n  };\n  const lines = {\n    pathIndices: linePositionsCount > 65535 ? new Uint32Array(linePathsCount + 1) : new Uint16Array(linePathsCount + 1),\n    positions: new PositionDataType(linePositionsCount * coordLength),\n    globalFeatureIds: new GlobalFeatureIdsDataType(linePositionsCount),\n    featureIds: lineFeaturesCount > 65535 ? new Uint32Array(linePositionsCount) : new Uint16Array(linePositionsCount),\n    numericProps: {},\n    properties: [],\n    fields: []\n  };\n  const polygons = {\n    polygonIndices: polygonPositionsCount > 65535 ? new Uint32Array(polygonObjectsCount + 1) : new Uint16Array(polygonObjectsCount + 1),\n    primitivePolygonIndices: polygonPositionsCount > 65535 ? new Uint32Array(polygonRingsCount + 1) : new Uint16Array(polygonRingsCount + 1),\n    positions: new PositionDataType(polygonPositionsCount * coordLength),\n    triangles: [],\n    globalFeatureIds: new GlobalFeatureIdsDataType(polygonPositionsCount),\n    featureIds: polygonFeaturesCount > 65535 ? new Uint32Array(polygonPositionsCount) : new Uint16Array(polygonPositionsCount),\n    numericProps: {},\n    properties: [],\n    fields: []\n  };\n\n  for (const object of [points, lines, polygons]) {\n    for (const propName of numericPropKeys) {\n      object.numericProps[propName] = new Float32Array(object.positions.length / coordLength);\n    }\n  }\n\n  lines.pathIndices[linePathsCount] = linePositionsCount;\n  polygons.polygonIndices[polygonObjectsCount] = polygonPositionsCount;\n  polygons.primitivePolygonIndices[polygonRingsCount] = polygonPositionsCount;\n  const indexMap = {\n    pointPosition: 0,\n    pointFeature: 0,\n    linePosition: 0,\n    linePath: 0,\n    lineFeature: 0,\n    polygonPosition: 0,\n    polygonObject: 0,\n    polygonRing: 0,\n    polygonFeature: 0,\n    feature: 0\n  };\n\n  for (const feature of features) {\n    const geometry = feature.geometry;\n    const properties = feature.properties || {};\n\n    switch (geometry.type) {\n      case 'Point':\n      case 'MultiPoint':\n        handlePoint(geometry, points, indexMap, coordLength, properties);\n        points.properties.push(keepStringProperties(properties, numericPropKeys));\n\n        if (hasGlobalId) {\n          points.fields.push({\n            id: feature.id\n          });\n        }\n\n        indexMap.pointFeature++;\n        break;\n\n      case 'LineString':\n      case 'MultiLineString':\n        handleLineString(geometry, lines, indexMap, coordLength, properties);\n        lines.properties.push(keepStringProperties(properties, numericPropKeys));\n\n        if (hasGlobalId) {\n          lines.fields.push({\n            id: feature.id\n          });\n        }\n\n        indexMap.lineFeature++;\n        break;\n\n      case 'Polygon':\n      case 'MultiPolygon':\n        handlePolygon(geometry, polygons, indexMap, coordLength, properties);\n        polygons.properties.push(keepStringProperties(properties, numericPropKeys));\n\n        if (hasGlobalId) {\n          polygons.fields.push({\n            id: feature.id\n          });\n        }\n\n        indexMap.polygonFeature++;\n        break;\n\n      default:\n        throw new Error('Invalid geometry type');\n    }\n\n    indexMap.feature++;\n  }\n\n  return makeAccessorObjects(points, lines, polygons, coordLength);\n}\n\nfunction handlePoint(geometry, points, indexMap, coordLength, properties) {\n  points.positions.set(geometry.data, indexMap.pointPosition * coordLength);\n  const nPositions = geometry.data.length / coordLength;\n  fillNumericProperties(points, properties, indexMap.pointPosition, nPositions);\n  points.globalFeatureIds.fill(indexMap.feature, indexMap.pointPosition, indexMap.pointPosition + nPositions);\n  points.featureIds.fill(indexMap.pointFeature, indexMap.pointPosition, indexMap.pointPosition + nPositions);\n  indexMap.pointPosition += nPositions;\n}\n\nfunction handleLineString(geometry, lines, indexMap, coordLength, properties) {\n  lines.positions.set(geometry.data, indexMap.linePosition * coordLength);\n  const nPositions = geometry.data.length / coordLength;\n  fillNumericProperties(lines, properties, indexMap.linePosition, nPositions);\n  lines.globalFeatureIds.fill(indexMap.feature, indexMap.linePosition, indexMap.linePosition + nPositions);\n  lines.featureIds.fill(indexMap.lineFeature, indexMap.linePosition, indexMap.linePosition + nPositions);\n\n  for (let i = 0, il = geometry.lines.length; i < il; ++i) {\n    const start = geometry.lines[i];\n    const end = i === il - 1 ? geometry.data.length : geometry.lines[i + 1];\n    lines.pathIndices[indexMap.linePath++] = indexMap.linePosition;\n    indexMap.linePosition += (end - start) / coordLength;\n  }\n}\n\nfunction handlePolygon(geometry, polygons, indexMap, coordLength, properties) {\n  polygons.positions.set(geometry.data, indexMap.polygonPosition * coordLength);\n  const nPositions = geometry.data.length / coordLength;\n  fillNumericProperties(polygons, properties, indexMap.polygonPosition, nPositions);\n  polygons.globalFeatureIds.fill(indexMap.feature, indexMap.polygonPosition, indexMap.polygonPosition + nPositions);\n  polygons.featureIds.fill(indexMap.polygonFeature, indexMap.polygonPosition, indexMap.polygonPosition + nPositions);\n\n  for (let l = 0, ll = geometry.lines.length; l < ll; ++l) {\n    const startPosition = indexMap.polygonPosition;\n    polygons.polygonIndices[indexMap.polygonObject++] = startPosition;\n    const areas = geometry.areas[l];\n    const lines = geometry.lines[l];\n    const nextLines = geometry.lines[l + 1];\n\n    for (let i = 0, il = lines.length; i < il; ++i) {\n      const start = lines[i];\n      const end = i === il - 1 ? nextLines === undefined ? geometry.data.length : nextLines[0] : lines[i + 1];\n      polygons.primitivePolygonIndices[indexMap.polygonRing++] = indexMap.polygonPosition;\n      indexMap.polygonPosition += (end - start) / coordLength;\n    }\n\n    const endPosition = indexMap.polygonPosition;\n    triangulatePolygon(polygons, areas, lines, {\n      startPosition,\n      endPosition,\n      coordLength\n    });\n  }\n}\n\nfunction triangulatePolygon(polygons, areas, lines, _ref) {\n  let {\n    startPosition,\n    endPosition,\n    coordLength\n  } = _ref;\n  const start = startPosition * coordLength;\n  const end = endPosition * coordLength;\n  const polygonPositions = polygons.positions.subarray(start, end);\n  const offset = lines[0];\n  const holes = lines.slice(1).map(n => (n - offset) / coordLength);\n  const indices = earcut(polygonPositions, holes, coordLength, areas);\n\n  for (let t = 0, tl = indices.length; t < tl; ++t) {\n    polygons.triangles.push(startPosition + indices[t]);\n  }\n}\n\nfunction makeAccessorObjects(points, lines, polygons, coordLength) {\n  const returnObj = {\n    points: { ...points,\n      positions: {\n        value: points.positions,\n        size: coordLength\n      },\n      globalFeatureIds: {\n        value: points.globalFeatureIds,\n        size: 1\n      },\n      featureIds: {\n        value: points.featureIds,\n        size: 1\n      }\n    },\n    lines: { ...lines,\n      pathIndices: {\n        value: lines.pathIndices,\n        size: 1\n      },\n      positions: {\n        value: lines.positions,\n        size: coordLength\n      },\n      globalFeatureIds: {\n        value: lines.globalFeatureIds,\n        size: 1\n      },\n      featureIds: {\n        value: lines.featureIds,\n        size: 1\n      }\n    },\n    polygons: { ...polygons,\n      polygonIndices: {\n        value: polygons.polygonIndices,\n        size: 1\n      },\n      primitivePolygonIndices: {\n        value: polygons.primitivePolygonIndices,\n        size: 1\n      },\n      positions: {\n        value: polygons.positions,\n        size: coordLength\n      },\n      triangles: {\n        value: new Uint32Array(polygons.triangles),\n        size: 1\n      },\n      globalFeatureIds: {\n        value: polygons.globalFeatureIds,\n        size: 1\n      },\n      featureIds: {\n        value: polygons.featureIds,\n        size: 1\n      }\n    }\n  };\n\n  for (const geomType in returnObj) {\n    for (const numericProp in returnObj[geomType].numericProps) {\n      returnObj[geomType].numericProps[numericProp] = {\n        value: returnObj[geomType].numericProps[numericProp],\n        size: 1\n      };\n    }\n  }\n\n  return returnObj;\n}\n\nfunction fillNumericProperties(object, properties, index, length) {\n  for (const numericPropName in object.numericProps) {\n    if (numericPropName in properties) {\n      object.numericProps[numericPropName].fill(properties[numericPropName], index, index + length);\n    }\n  }\n}\n\nfunction keepStringProperties(properties, numericKeys) {\n  const props = {};\n\n  for (const key in properties) {\n    if (!numericKeys.includes(key)) {\n      props[key] = properties[key];\n    }\n  }\n\n  return props;\n}\n\nfunction isNumeric(x) {\n  return Number.isFinite(x);\n}","map":{"version":3,"sources":["../../../../src/lib/binary-vector-tile/features-to-binary.js"],"names":["options","fillArrays","numericPropKeys","extractNumericPropKeys","PositionDataType","Float32Array","TEST_EXPORTS","feature","numericSoFar","val","isNumeric","Object","k","firstPassData","polygonFeaturesCount","hasGlobalId","features","coordLength","GlobalFeatureIdsDataType","points","positions","pointPositionsCount","globalFeatureIds","featureIds","pointFeaturesCount","numericProps","properties","fields","lines","pathIndices","linePositionsCount","linePathsCount","lineFeaturesCount","polygons","polygonIndices","polygonPositionsCount","polygonObjectsCount","primitivePolygonIndices","polygonRingsCount","triangles","object","indexMap","pointPosition","pointFeature","linePosition","linePath","lineFeature","polygonPosition","polygonObject","polygonRing","polygonFeature","geometry","handlePoint","keepStringProperties","id","handleLineString","handlePolygon","makeAccessorObjects","nPositions","fillNumericProperties","i","il","start","end","l","ll","startPosition","areas","nextLines","endPosition","triangulatePolygon","polygonPositions","offset","holes","n","indices","earcut","t","tl","returnObj","value","size","numericPropName","index","props","numericKeys","Number"],"mappings":"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","sourcesContent":["// @ts-nocheck\nimport {earcut} from '@math.gl/polygon';\n\n/**\n * Convert binary features to flat binary arrays. Similar to\n * `geojsonToBinary` helper function, except that it expects\n * a binary representation of the feature data, which enables\n * 2X-3X speed increase in parse speed, compared to using\n * geoJSON. See `binary-vector-tile/VectorTileFeature` for\n * data format detais\n */\nexport function featuresToBinary(features, firstPassData, options = {}) {\n  return fillArrays(features, firstPassData, {\n    numericPropKeys: options.numericPropKeys || extractNumericPropKeys(features),\n    PositionDataType: options.PositionDataType || Float32Array\n  });\n}\n\nexport const TEST_EXPORTS = {\n  extractNumericPropKeys,\n  fillArrays\n};\n\n// Extracts properties that are always numeric\n// eslint-disable-next-line complexity, max-statements\nfunction extractNumericPropKeys(features) {\n  const numericPropKeys = {};\n  for (const feature of features) {\n    if (feature.properties) {\n      for (const key in feature.properties) {\n        // If property has not been seen before, or if property has been numeric\n        // in all previous features, check if numeric in this feature\n        // If not numeric, false is stored to prevent rechecking in the future\n        const numericSoFar = numericPropKeys[key];\n        // eslint-disable-next-line max-depth\n        if (numericSoFar || numericSoFar === undefined) {\n          const val = feature.properties[key];\n          numericPropKeys[key] = isNumeric(val);\n        }\n      }\n    }\n  }\n\n  return Object.keys(numericPropKeys).filter((k) => numericPropKeys[k]);\n}\n\n// Fills coordinates into pre-allocated typed arrays\n// eslint-disable-next-line complexity\nfunction fillArrays(features, firstPassData = {}, options = {}) {\n  const {\n    pointPositionsCount,\n    pointFeaturesCount,\n    linePositionsCount,\n    linePathsCount,\n    lineFeaturesCount,\n    polygonPositionsCount,\n    polygonObjectsCount,\n    polygonRingsCount,\n    polygonFeaturesCount\n  } = firstPassData;\n  const {numericPropKeys, PositionDataType = Float32Array} = options;\n  const hasGlobalId = features[0] && 'id' in features[0];\n  const coordLength = 2;\n  const GlobalFeatureIdsDataType = features.length > 65535 ? Uint32Array : Uint16Array;\n  const points = {\n    positions: new PositionDataType(pointPositionsCount * coordLength),\n    globalFeatureIds: new GlobalFeatureIdsDataType(pointPositionsCount),\n    featureIds:\n      pointFeaturesCount > 65535\n        ? new Uint32Array(pointPositionsCount)\n        : new Uint16Array(pointPositionsCount),\n    numericProps: {},\n    properties: [],\n    fields: []\n  };\n  const lines = {\n    pathIndices:\n      linePositionsCount > 65535\n        ? new Uint32Array(linePathsCount + 1)\n        : new Uint16Array(linePathsCount + 1),\n    positions: new PositionDataType(linePositionsCount * coordLength),\n    globalFeatureIds: new GlobalFeatureIdsDataType(linePositionsCount),\n    featureIds:\n      lineFeaturesCount > 65535\n        ? new Uint32Array(linePositionsCount)\n        : new Uint16Array(linePositionsCount),\n    numericProps: {},\n    properties: [],\n    fields: []\n  };\n  const polygons = {\n    polygonIndices:\n      polygonPositionsCount > 65535\n        ? new Uint32Array(polygonObjectsCount + 1)\n        : new Uint16Array(polygonObjectsCount + 1),\n    primitivePolygonIndices:\n      polygonPositionsCount > 65535\n        ? new Uint32Array(polygonRingsCount + 1)\n        : new Uint16Array(polygonRingsCount + 1),\n    positions: new PositionDataType(polygonPositionsCount * coordLength),\n    triangles: [],\n    globalFeatureIds: new GlobalFeatureIdsDataType(polygonPositionsCount),\n    featureIds:\n      polygonFeaturesCount > 65535\n        ? new Uint32Array(polygonPositionsCount)\n        : new Uint16Array(polygonPositionsCount),\n    numericProps: {},\n    properties: [],\n    fields: []\n  };\n\n  // Instantiate numeric properties arrays; one value per vertex\n  for (const object of [points, lines, polygons]) {\n    for (const propName of numericPropKeys) {\n      // If property has been numeric in all previous features in which the property existed, check\n      // if numeric in this feature\n      object.numericProps[propName] = new Float32Array(object.positions.length / coordLength);\n    }\n  }\n\n  // Set last element of path/polygon indices as positions length\n  lines.pathIndices[linePathsCount] = linePositionsCount;\n  polygons.polygonIndices[polygonObjectsCount] = polygonPositionsCount;\n  polygons.primitivePolygonIndices[polygonRingsCount] = polygonPositionsCount;\n\n  const indexMap = {\n    pointPosition: 0,\n    pointFeature: 0,\n    linePosition: 0,\n    linePath: 0,\n    lineFeature: 0,\n    polygonPosition: 0,\n    polygonObject: 0,\n    polygonRing: 0,\n    polygonFeature: 0,\n    feature: 0\n  };\n\n  for (const feature of features) {\n    const geometry = feature.geometry;\n    const properties = feature.properties || {};\n\n    switch (geometry.type) {\n      case 'Point':\n      case 'MultiPoint':\n        handlePoint(geometry, points, indexMap, coordLength, properties);\n        points.properties.push(keepStringProperties(properties, numericPropKeys));\n        if (hasGlobalId) {\n          points.fields.push({id: feature.id});\n        }\n        indexMap.pointFeature++;\n        break;\n      case 'LineString':\n      case 'MultiLineString':\n        handleLineString(geometry, lines, indexMap, coordLength, properties);\n        lines.properties.push(keepStringProperties(properties, numericPropKeys));\n        if (hasGlobalId) {\n          lines.fields.push({id: feature.id});\n        }\n        indexMap.lineFeature++;\n        break;\n      case 'Polygon':\n      case 'MultiPolygon':\n        handlePolygon(geometry, polygons, indexMap, coordLength, properties);\n        polygons.properties.push(keepStringProperties(properties, numericPropKeys));\n        if (hasGlobalId) {\n          polygons.fields.push({id: feature.id});\n        }\n        indexMap.polygonFeature++;\n        break;\n      default:\n        throw new Error('Invalid geometry type');\n    }\n\n    indexMap.feature++;\n  }\n\n  // Wrap each array in an accessor object with value and size keys\n  return makeAccessorObjects(points, lines, polygons, coordLength);\n}\n\n// Fills (Multi)Point coordinates into points object of arrays\nfunction handlePoint(geometry, points, indexMap, coordLength, properties) {\n  points.positions.set(geometry.data, indexMap.pointPosition * coordLength);\n\n  const nPositions = geometry.data.length / coordLength;\n  fillNumericProperties(points, properties, indexMap.pointPosition, nPositions);\n  points.globalFeatureIds.fill(\n    indexMap.feature,\n    indexMap.pointPosition,\n    indexMap.pointPosition + nPositions\n  );\n  points.featureIds.fill(\n    indexMap.pointFeature,\n    indexMap.pointPosition,\n    indexMap.pointPosition + nPositions\n  );\n\n  indexMap.pointPosition += nPositions;\n}\n\n// Fills (Multi)LineString coordinates into lines object of arrays\nfunction handleLineString(geometry, lines, indexMap, coordLength, properties) {\n  lines.positions.set(geometry.data, indexMap.linePosition * coordLength);\n\n  const nPositions = geometry.data.length / coordLength;\n  fillNumericProperties(lines, properties, indexMap.linePosition, nPositions);\n\n  lines.globalFeatureIds.fill(\n    indexMap.feature,\n    indexMap.linePosition,\n    indexMap.linePosition + nPositions\n  );\n  lines.featureIds.fill(\n    indexMap.lineFeature,\n    indexMap.linePosition,\n    indexMap.linePosition + nPositions\n  );\n\n  for (let i = 0, il = geometry.lines.length; i < il; ++i) {\n    // Extract range of data we are working with, defined by start\n    // and end indices (these index into the geometry.data array)\n    const start = geometry.lines[i];\n    const end =\n      i === il - 1\n        ? geometry.data.length // last line, so read to end of data\n        : geometry.lines[i + 1]; // start index for next line\n\n    lines.pathIndices[indexMap.linePath++] = indexMap.linePosition;\n    indexMap.linePosition += (end - start) / coordLength;\n  }\n}\n\n// Fills (Multi)Polygon coordinates into polygons object of arrays\nfunction handlePolygon(geometry, polygons, indexMap, coordLength, properties) {\n  polygons.positions.set(geometry.data, indexMap.polygonPosition * coordLength);\n\n  const nPositions = geometry.data.length / coordLength;\n  fillNumericProperties(polygons, properties, indexMap.polygonPosition, nPositions);\n  polygons.globalFeatureIds.fill(\n    indexMap.feature,\n    indexMap.polygonPosition,\n    indexMap.polygonPosition + nPositions\n  );\n  polygons.featureIds.fill(\n    indexMap.polygonFeature,\n    indexMap.polygonPosition,\n    indexMap.polygonPosition + nPositions\n  );\n\n  // Unlike Point & LineString geometry.lines is a 2D array\n  for (let l = 0, ll = geometry.lines.length; l < ll; ++l) {\n    const startPosition = indexMap.polygonPosition;\n    polygons.polygonIndices[indexMap.polygonObject++] = startPosition;\n\n    const areas = geometry.areas[l];\n    const lines = geometry.lines[l];\n    const nextLines = geometry.lines[l + 1];\n\n    for (let i = 0, il = lines.length; i < il; ++i) {\n      const start = lines[i];\n      const end =\n        i === il - 1\n          ? // last line, so either read to:\n            nextLines === undefined\n            ? geometry.data.length // end of data (no next lines)\n            : nextLines[0] // start of first line in nextLines\n          : lines[i + 1]; // start index for next line\n\n      polygons.primitivePolygonIndices[indexMap.polygonRing++] = indexMap.polygonPosition;\n      indexMap.polygonPosition += (end - start) / coordLength;\n    }\n\n    const endPosition = indexMap.polygonPosition;\n    triangulatePolygon(polygons, areas, lines, {startPosition, endPosition, coordLength});\n  }\n}\n\n/**\n * Triangulate polygon using earcut\n */\nfunction triangulatePolygon(polygons, areas, lines, {startPosition, endPosition, coordLength}) {\n  const start = startPosition * coordLength;\n  const end = endPosition * coordLength;\n\n  // Extract positions and holes for just this polygon\n  const polygonPositions = polygons.positions.subarray(start, end);\n\n  // Holes are referenced relative to outer polygon\n  const offset = lines[0];\n  const holes = lines.slice(1).map((n) => (n - offset) / coordLength);\n\n  // Compute triangulation\n  const indices = earcut(polygonPositions, holes, coordLength, areas);\n\n  // Indices returned by triangulation are relative to start\n  // of polygon, so we need to offset\n  for (let t = 0, tl = indices.length; t < tl; ++t) {\n    polygons.triangles.push(startPosition + indices[t]);\n  }\n}\n\n// Wrap each array in an accessor object with value and size keys\nfunction makeAccessorObjects(points, lines, polygons, coordLength) {\n  const returnObj = {\n    points: {\n      ...points,\n      positions: {value: points.positions, size: coordLength},\n      globalFeatureIds: {value: points.globalFeatureIds, size: 1},\n      featureIds: {value: points.featureIds, size: 1}\n    },\n    lines: {\n      ...lines,\n      pathIndices: {value: lines.pathIndices, size: 1},\n      positions: {value: lines.positions, size: coordLength},\n      globalFeatureIds: {value: lines.globalFeatureIds, size: 1},\n      featureIds: {value: lines.featureIds, size: 1}\n    },\n    polygons: {\n      ...polygons,\n      polygonIndices: {value: polygons.polygonIndices, size: 1},\n      primitivePolygonIndices: {value: polygons.primitivePolygonIndices, size: 1},\n      positions: {value: polygons.positions, size: coordLength},\n      triangles: {value: new Uint32Array(polygons.triangles), size: 1},\n      globalFeatureIds: {value: polygons.globalFeatureIds, size: 1},\n      featureIds: {value: polygons.featureIds, size: 1}\n    }\n  };\n\n  for (const geomType in returnObj) {\n    for (const numericProp in returnObj[geomType].numericProps) {\n      returnObj[geomType].numericProps[numericProp] = {\n        value: returnObj[geomType].numericProps[numericProp],\n        size: 1\n      };\n    }\n  }\n  return returnObj;\n}\n\n// Add numeric properties to object\nfunction fillNumericProperties(object, properties, index, length) {\n  for (const numericPropName in object.numericProps) {\n    if (numericPropName in properties) {\n      object.numericProps[numericPropName].fill(properties[numericPropName], index, index + length);\n    }\n  }\n}\n\n// Keep string properties in object\nfunction keepStringProperties(properties, numericKeys) {\n  const props = {};\n  for (const key in properties) {\n    if (!numericKeys.includes(key)) {\n      props[key] = properties[key];\n    }\n  }\n  return props;\n}\n\nfunction isNumeric(x) {\n  return Number.isFinite(x);\n}\n"]},"metadata":{},"sourceType":"module"}