{"ast":null,"code":"import { lerp } from 'math.gl';\nconst DEFAULT_INDICES = new Uint16Array([0, 2, 1, 0, 3, 2]);\nconst DEFAULT_TEX_COORDS = new Float32Array([0, 1, 0, 0, 1, 0, 1, 1]);\nexport default function createMesh(bounds, resolution) {\n  if (!resolution) {\n    return createQuad(bounds);\n  }\n\n  const maxXSpan = Math.max(Math.abs(bounds[0][0] - bounds[3][0]), Math.abs(bounds[1][0] - bounds[2][0]));\n  const maxYSpan = Math.max(Math.abs(bounds[1][1] - bounds[0][1]), Math.abs(bounds[2][1] - bounds[3][1]));\n  const uCount = Math.ceil(maxXSpan / resolution) + 1;\n  const vCount = Math.ceil(maxYSpan / resolution) + 1;\n  const vertexCount = (uCount - 1) * (vCount - 1) * 6;\n  const indices = new Uint32Array(vertexCount);\n  const texCoords = new Float32Array(uCount * vCount * 2);\n  const positions = new Float64Array(uCount * vCount * 3);\n  let vertex = 0;\n  let index = 0;\n\n  for (let u = 0; u < uCount; u++) {\n    const ut = u / (uCount - 1);\n\n    for (let v = 0; v < vCount; v++) {\n      const vt = v / (vCount - 1);\n      const p = interpolateQuad(bounds, ut, vt);\n      positions[vertex * 3 + 0] = p[0];\n      positions[vertex * 3 + 1] = p[1];\n      positions[vertex * 3 + 2] = p[2] || 0;\n      texCoords[vertex * 2 + 0] = ut;\n      texCoords[vertex * 2 + 1] = 1 - vt;\n\n      if (u > 0 && v > 0) {\n        indices[index++] = vertex - vCount;\n        indices[index++] = vertex - vCount - 1;\n        indices[index++] = vertex - 1;\n        indices[index++] = vertex - vCount;\n        indices[index++] = vertex - 1;\n        indices[index++] = vertex;\n      }\n\n      vertex++;\n    }\n  }\n\n  return {\n    vertexCount,\n    positions,\n    indices,\n    texCoords\n  };\n}\n\nfunction createQuad(bounds) {\n  const positions = new Float64Array(12);\n\n  for (let i = 0; i < bounds.length; i++) {\n    positions[i * 3 + 0] = bounds[i][0];\n    positions[i * 3 + 1] = bounds[i][1];\n    positions[i * 3 + 2] = bounds[i][2] || 0;\n  }\n\n  return {\n    vertexCount: 6,\n    positions,\n    indices: DEFAULT_INDICES,\n    texCoords: DEFAULT_TEX_COORDS\n  };\n}\n\nfunction interpolateQuad(quad, ut, vt) {\n  return lerp(lerp(quad[0], quad[1], vt), lerp(quad[3], quad[2], vt), ut);\n}","map":{"version":3,"sources":["../../../src/bitmap-layer/create-mesh.js"],"names":["DEFAULT_INDICES","DEFAULT_TEX_COORDS","createQuad","maxXSpan","Math","bounds","maxYSpan","uCount","vCount","vertexCount","indices","texCoords","positions","vertex","index","u","ut","v","vt","p","interpolateQuad","i","lerp","quad"],"mappings":"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","sourcesContent":["import {lerp} from 'math.gl';\n\nconst DEFAULT_INDICES = new Uint16Array([0, 2, 1, 0, 3, 2]);\nconst DEFAULT_TEX_COORDS = new Float32Array([0, 1, 0, 0, 1, 0, 1, 1]);\n\n/*\n  1 ---- 2\n  |      |\n  |      |\n  0 ---- 3\n*/\n/* eslint-disable max-statements */\nexport default function createMesh(bounds, resolution) {\n  if (!resolution) {\n    return createQuad(bounds);\n  }\n  const maxXSpan = Math.max(\n    Math.abs(bounds[0][0] - bounds[3][0]),\n    Math.abs(bounds[1][0] - bounds[2][0])\n  );\n  const maxYSpan = Math.max(\n    Math.abs(bounds[1][1] - bounds[0][1]),\n    Math.abs(bounds[2][1] - bounds[3][1])\n  );\n  const uCount = Math.ceil(maxXSpan / resolution) + 1;\n  const vCount = Math.ceil(maxYSpan / resolution) + 1;\n\n  const vertexCount = (uCount - 1) * (vCount - 1) * 6;\n  const indices = new Uint32Array(vertexCount);\n  const texCoords = new Float32Array(uCount * vCount * 2);\n  const positions = new Float64Array(uCount * vCount * 3);\n\n  // Tesselate\n  let vertex = 0;\n  let index = 0;\n  for (let u = 0; u < uCount; u++) {\n    const ut = u / (uCount - 1);\n    for (let v = 0; v < vCount; v++) {\n      const vt = v / (vCount - 1);\n      const p = interpolateQuad(bounds, ut, vt);\n\n      positions[vertex * 3 + 0] = p[0];\n      positions[vertex * 3 + 1] = p[1];\n      positions[vertex * 3 + 2] = p[2] || 0;\n\n      texCoords[vertex * 2 + 0] = ut;\n      texCoords[vertex * 2 + 1] = 1 - vt;\n\n      if (u > 0 && v > 0) {\n        indices[index++] = vertex - vCount;\n        indices[index++] = vertex - vCount - 1;\n        indices[index++] = vertex - 1;\n        indices[index++] = vertex - vCount;\n        indices[index++] = vertex - 1;\n        indices[index++] = vertex;\n      }\n\n      vertex++;\n    }\n  }\n  return {\n    vertexCount,\n    positions,\n    indices,\n    texCoords\n  };\n}\n\nfunction createQuad(bounds) {\n  const positions = new Float64Array(12);\n  // [[minX, minY], [minX, maxY], [maxX, maxY], [maxX, minY]]\n  for (let i = 0; i < bounds.length; i++) {\n    positions[i * 3 + 0] = bounds[i][0];\n    positions[i * 3 + 1] = bounds[i][1];\n    positions[i * 3 + 2] = bounds[i][2] || 0;\n  }\n\n  return {\n    vertexCount: 6,\n    positions,\n    indices: DEFAULT_INDICES,\n    texCoords: DEFAULT_TEX_COORDS\n  };\n}\n\nfunction interpolateQuad(quad, ut, vt) {\n  return lerp(lerp(quad[0], quad[1], vt), lerp(quad[3], quad[2], vt), ut);\n}\n"]},"metadata":{},"sourceType":"module"}