{"ast":null,"code":"const DEFAULT_CHUNK_SIZE = 256 * 1024;\nexport function* makeArrayBufferIterator(arrayBuffer) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    chunkSize = DEFAULT_CHUNK_SIZE\n  } = options;\n  let byteOffset = 0;\n\n  while (byteOffset < arrayBuffer.byteLength) {\n    const chunkByteLength = Math.min(arrayBuffer.byteLength - byteOffset, chunkSize);\n    const chunk = new ArrayBuffer(chunkByteLength);\n    const sourceArray = new Uint8Array(arrayBuffer, byteOffset, chunkByteLength);\n    const chunkArray = new Uint8Array(chunk);\n    chunkArray.set(sourceArray);\n    byteOffset += chunkByteLength;\n    yield chunk;\n  }\n}","map":{"version":3,"sources":["../../../../src/iterators/make-iterator/make-array-buffer-iterator.ts"],"names":["DEFAULT_CHUNK_SIZE","options","chunkSize","byteOffset","arrayBuffer","chunkByteLength","Math","chunk","sourceArray","chunkArray"],"mappings":"AAEA,MAAMA,kBAAkB,GAAG,MAA3B,IAAA;AAQA,OAAO,UAAA,uBAAA,CAAA,WAAA,EAGkB;AAAA,MADvBC,OACuB,uEAHlB,EAGkB;AACvB,QAAM;AAACC,IAAAA,SAAS,GAAGF;AAAb,MAAN,OAAA;AAEA,MAAIG,UAAU,GAAd,CAAA;;AAEA,SAAOA,UAAU,GAAGC,WAAW,CAA/B,UAAA,EAA4C;AAE1C,UAAMC,eAAe,GAAGC,IAAI,CAAJA,GAAAA,CAASF,WAAW,CAAXA,UAAAA,GAATE,UAAAA,EAAxB,SAAwBA,CAAxB;AACA,UAAMC,KAAK,GAAG,IAAA,WAAA,CAAd,eAAc,CAAd;AAGA,UAAMC,WAAW,GAAG,IAAA,UAAA,CAAA,WAAA,EAAA,UAAA,EAApB,eAAoB,CAApB;AACA,UAAMC,UAAU,GAAG,IAAA,UAAA,CAAnB,KAAmB,CAAnB;AACAA,IAAAA,UAAU,CAAVA,GAAAA,CAAAA,WAAAA;AAGAN,IAAAA,UAAU,IAAVA,eAAAA;AACA,UAAA,KAAA;AACD;AACF","sourcesContent":["import type {IteratorOptions} from './make-iterator';\n\nconst DEFAULT_CHUNK_SIZE = 256 * 1024;\n\n/**\n * Returns an iterator that breaks a big ArrayBuffer into chunks and yields them one-by-one\n * @param blob ArrayBuffer to iterate over\n * @param options\n * @param options.chunkSize\n */\nexport function* makeArrayBufferIterator(\n  arrayBuffer: ArrayBuffer,\n  options: IteratorOptions = {}\n): Iterable<ArrayBuffer> {\n  const {chunkSize = DEFAULT_CHUNK_SIZE} = options;\n\n  let byteOffset = 0;\n\n  while (byteOffset < arrayBuffer.byteLength) {\n    // Create a chunk of the right size\n    const chunkByteLength = Math.min(arrayBuffer.byteLength - byteOffset, chunkSize);\n    const chunk = new ArrayBuffer(chunkByteLength);\n\n    // Copy data from the big chunk\n    const sourceArray = new Uint8Array(arrayBuffer, byteOffset, chunkByteLength);\n    const chunkArray = new Uint8Array(chunk);\n    chunkArray.set(sourceArray);\n\n    // yield the chunk\n    byteOffset += chunkByteLength;\n    yield chunk;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}