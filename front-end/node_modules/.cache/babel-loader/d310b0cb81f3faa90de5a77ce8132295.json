{"ast":null,"code":"import { decomposeCompositeGLType } from '../webgl-utils/attribute-utils';\nimport { assert } from '../utils/assert';\nconst ERR_ARGUMENT = 'UniformBufferLayout illegal argument';\nconst GL_FLOAT = 0x1406;\nconst GL_INT = 0x1404;\nconst GL_UNSIGNED_INT = 0x1405;\nexport default class UniformBufferLayout {\n  constructor(layout) {\n    this.layout = {};\n    this.size = 0;\n\n    for (const key in layout) {\n      this._addUniform(key, layout[key]);\n    }\n\n    this.size += (4 - this.size % 4) % 4;\n    const data = new Float32Array(this.size);\n    this.typedArray = {\n      [GL_FLOAT]: data,\n      [GL_INT]: new Int32Array(data.buffer),\n      [GL_UNSIGNED_INT]: new Uint32Array(data.buffer)\n    };\n  }\n\n  getBytes() {\n    return this.size * 4;\n  }\n\n  getData() {\n    return this.typedArray[GL_FLOAT];\n  }\n\n  getSubData(index) {\n    let data;\n    let offset;\n\n    if (index === undefined) {\n      data = this.data;\n      offset = 0;\n    } else {\n      const begin = this.offsets[index];\n      const end = begin + this.sizes[index];\n      data = this.data.subarray(begin, end);\n      offset = begin * 4;\n    }\n\n    return {\n      data,\n      offset\n    };\n  }\n\n  setUniforms(values) {\n    for (const key in values) {\n      this._setValue(key, values[key]);\n    }\n\n    return this;\n  }\n\n  _setValue(key, value) {\n    const layout = this.layout[key];\n    assert(layout, 'UniformLayoutStd140 illegal argument');\n    const typedArray = this.typedArray[layout.type];\n\n    if (layout.size === 1) {\n      typedArray[layout.offset] = value;\n    } else {\n      typedArray.set(value, layout.offset);\n    }\n  }\n\n  _addUniform(key, uniformType) {\n    const typeAndComponents = decomposeCompositeGLType(uniformType);\n    assert(typeAndComponents, ERR_ARGUMENT);\n    const {\n      type,\n      components: count\n    } = typeAndComponents;\n    this.size = this._alignTo(this.size, count);\n    const offset = this.size;\n    this.size += count;\n    this.layout[key] = {\n      type,\n      size: count,\n      offset\n    };\n  }\n\n  _alignTo(size, count) {\n    switch (count) {\n      case 1:\n        return size;\n\n      case 2:\n        return size + size % 2;\n\n      default:\n        return size + (4 - size % 4) % 4;\n    }\n  }\n\n}","map":{"version":3,"sources":["../../../src/classes/uniform-buffer-layout.js"],"names":["ERR_ARGUMENT","GL_FLOAT","GL_INT","GL_UNSIGNED_INT","constructor","layout","data","getBytes","getData","getSubData","index","offset","begin","end","setUniforms","values","_setValue","assert","typedArray","_addUniform","typeAndComponents","decomposeCompositeGLType","components","count","size","_alignTo"],"mappings":"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","sourcesContent":["// @ts-nocheck\n\n/* eslint-disable camelcase */\nimport {decomposeCompositeGLType} from '../webgl-utils/attribute-utils';\nimport {assert} from '../utils/assert';\n\nconst ERR_ARGUMENT = 'UniformBufferLayout illegal argument';\n\n// Local constants - these will \"collapse\" during minification\nconst GL_FLOAT = 0x1406;\nconst GL_INT = 0x1404;\nconst GL_UNSIGNED_INT = 0x1405;\n\n// Std140 layout for uniforms\nexport default class UniformBufferLayout {\n  constructor(layout) {\n    this.layout = {};\n    this.size = 0;\n\n    // Add layout (type, size and offset) definitions for each uniform in the layout\n    for (const key in layout) {\n      this._addUniform(key, layout[key]);\n    }\n\n    this.size += (4 - (this.size % 4)) % 4;\n\n    // Allocate three typed arrays pointing at same memory\n    const data = new Float32Array(this.size);\n    this.typedArray = {\n      [GL_FLOAT]: data,\n      [GL_INT]: new Int32Array(data.buffer),\n      [GL_UNSIGNED_INT]: new Uint32Array(data.buffer)\n    };\n  }\n\n  // Get number of bytes needed for buffer allocation\n  getBytes() {\n    return this.size * 4;\n  }\n\n  // Get the current data as Float32Array, for bufferSubData\n  getData() {\n    return this.typedArray[GL_FLOAT];\n  }\n\n  // Get offset and data for one object (for bufferSubData)\n  getSubData(index) {\n    let data;\n    let offset;\n    if (index === undefined) {\n      data = this.data;\n      offset = 0;\n    } else {\n      const begin = this.offsets[index];\n      const end = begin + this.sizes[index];\n      data = this.data.subarray(begin, end);\n      offset = begin * 4;\n    }\n    return {data, offset};\n  }\n\n  // Set a map of values\n  setUniforms(values) {\n    for (const key in values) {\n      this._setValue(key, values[key]);\n    }\n    return this;\n  }\n\n  _setValue(key, value) {\n    const layout = this.layout[key];\n    assert(layout, 'UniformLayoutStd140 illegal argument');\n    const typedArray = this.typedArray[layout.type];\n    if (layout.size === 1) {\n      // single value -> just set it\n      typedArray[layout.offset] = value;\n    } else {\n      // vector/matrix -> copy the supplied (typed) array, starting from offset\n      typedArray.set(value, layout.offset);\n    }\n  }\n\n  _addUniform(key, uniformType) {\n    const typeAndComponents = decomposeCompositeGLType(uniformType);\n    assert(typeAndComponents, ERR_ARGUMENT);\n    const {type, components: count} = typeAndComponents;\n\n    // First, align (bump) current offset to an even multiple of current object (1, 2, 4)\n    this.size = this._alignTo(this.size, count);\n    // Use the aligned size as the offset of the current uniform.\n    const offset = this.size;\n    // Then, add our object's padded size ((1, 2, multiple of 4) to the current offset\n    this.size += count;\n\n    this.layout[key] = {type, size: count, offset};\n  }\n\n  // Align offset to 1, 2 or 4 elements (4, 8 or 16 bytes)\n  _alignTo(size, count) {\n    switch (count) {\n      case 1:\n        return size; // Pad upwards to even multiple of 2\n      case 2:\n        return size + (size % 2); // Pad upwards to even multiple of 2\n      default:\n        return size + ((4 - (size % 4)) % 4); // Pad upwards to even multiple of 4\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}