{"ast":null,"code":"import { decodeRGB565, GL } from '@loaders.gl/math';\nexport function normalize3DTileColorAttribute(tile, colors, batchTable) {\n  if (!colors && (!tile || !tile.batchIds || !batchTable)) {\n    return null;\n  }\n\n  const {\n    batchIds,\n    isRGB565,\n    pointCount\n  } = tile;\n\n  if (batchIds && batchTable) {\n    const colorArray = new Uint8ClampedArray(pointCount * 3);\n\n    for (let i = 0; i < pointCount; i++) {\n      const batchId = batchIds[i];\n      const dimensions = batchTable.getProperty(batchId, 'dimensions');\n      const color = dimensions.map(d => d * 255);\n      colorArray[i * 3] = color[0];\n      colorArray[i * 3 + 1] = color[1];\n      colorArray[i * 3 + 2] = color[2];\n    }\n\n    return {\n      type: GL.UNSIGNED_BYTE,\n      value: colorArray,\n      size: 3,\n      normalized: true\n    };\n  }\n\n  if (isRGB565) {\n    const colorArray = new Uint8ClampedArray(pointCount * 3);\n\n    for (let i = 0; i < pointCount; i++) {\n      const color = decodeRGB565(colors[i]);\n      colorArray[i * 3] = color[0];\n      colorArray[i * 3 + 1] = color[1];\n      colorArray[i * 3 + 2] = color[2];\n    }\n\n    return {\n      type: GL.UNSIGNED_BYTE,\n      value: colorArray,\n      size: 3,\n      normalized: true\n    };\n  }\n\n  if (colors && colors.length === pointCount * 3) {\n    return {\n      type: GL.UNSIGNED_BYTE,\n      value: colors,\n      size: 3,\n      normalized: true\n    };\n  }\n\n  return {\n    type: GL.UNSIGNED_BYTE,\n    value: colors,\n    size: 4,\n    normalized: true\n  };\n}","map":{"version":3,"sources":["../../../../../src/lib/parsers/helpers/normalize-3d-tile-colors.js"],"names":["tile","pointCount","batchIds","colorArray","i","batchId","dimensions","batchTable","color","d","type","GL","value","size","normalized","decodeRGB565","colors"],"mappings":"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","sourcesContent":["import {decodeRGB565, GL} from '@loaders.gl/math';\n\n/* eslint-disable complexity*/\nexport function normalize3DTileColorAttribute(tile, colors, batchTable) {\n  // no colors defined\n  if (!colors && (!tile || !tile.batchIds || !batchTable)) {\n    return null;\n  }\n\n  const {batchIds, isRGB565, pointCount} = tile;\n  // Batch table, look up colors in table\n  if (batchIds && batchTable) {\n    const colorArray = new Uint8ClampedArray(pointCount * 3);\n    for (let i = 0; i < pointCount; i++) {\n      const batchId = batchIds[i];\n      // TODO figure out what is `dimensions` used for\n      const dimensions = batchTable.getProperty(batchId, 'dimensions');\n      const color = dimensions.map((d) => d * 255);\n      colorArray[i * 3] = color[0];\n      colorArray[i * 3 + 1] = color[1];\n      colorArray[i * 3 + 2] = color[2];\n    }\n    return {\n      type: GL.UNSIGNED_BYTE,\n      value: colorArray,\n      size: 3,\n      normalized: true\n    };\n  }\n\n  // RGB565 case, convert to RGB\n  if (isRGB565) {\n    const colorArray = new Uint8ClampedArray(pointCount * 3);\n    for (let i = 0; i < pointCount; i++) {\n      const color = decodeRGB565(colors[i]);\n      colorArray[i * 3] = color[0];\n      colorArray[i * 3 + 1] = color[1];\n      colorArray[i * 3 + 2] = color[2];\n    }\n    return {\n      type: GL.UNSIGNED_BYTE,\n      value: colorArray,\n      size: 3,\n      normalized: true\n    };\n  }\n\n  // RGB case (tile.isTranslucent)\n  if (colors && colors.length === pointCount * 3) {\n    return {\n      type: GL.UNSIGNED_BYTE,\n      value: colors,\n      size: 3,\n      normalized: true\n    };\n  }\n\n  // DEFAULT: RGBA case\n  return {\n    type: GL.UNSIGNED_BYTE,\n    value: colors,\n    size: 4,\n    normalized: true\n  };\n}\n/* eslint-enable complexity*/\n"]},"metadata":{},"sourceType":"module"}