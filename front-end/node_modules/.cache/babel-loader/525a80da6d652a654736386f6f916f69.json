{"ast":null,"code":"import { padToNBytes, assert } from '@loaders.gl/loader-utils';\nconst MAGIC_glTF = 0x676c5446;\nconst GLB_FILE_HEADER_SIZE = 12;\nconst GLB_CHUNK_HEADER_SIZE = 8;\nconst GLB_CHUNK_TYPE_JSON = 0x4e4f534a;\nconst GLB_CHUNK_TYPE_BIN = 0x004e4942;\nconst GLB_CHUNK_TYPE_JSON_XVIZ_DEPRECATED = 0;\nconst GLB_CHUNK_TYPE_BIX_XVIZ_DEPRECATED = 1;\nconst GLB_V1_CONTENT_FORMAT_JSON = 0x0;\nconst LE = true;\n\nfunction getMagicString(dataView) {\n  let byteOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  return \"\".concat(String.fromCharCode(dataView.getUint8(byteOffset + 0))).concat(String.fromCharCode(dataView.getUint8(byteOffset + 1))).concat(String.fromCharCode(dataView.getUint8(byteOffset + 2))).concat(String.fromCharCode(dataView.getUint8(byteOffset + 3)));\n}\n\nexport function isGLB(arrayBuffer) {\n  let byteOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const dataView = new DataView(arrayBuffer);\n  const {\n    magic = MAGIC_glTF\n  } = options;\n  const magic1 = dataView.getUint32(byteOffset, false);\n  return magic1 === magic || magic1 === MAGIC_glTF;\n}\nexport default function parseGLBSync(glb, arrayBuffer) {\n  let byteOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  const dataView = new DataView(arrayBuffer);\n  const type = getMagicString(dataView, byteOffset + 0);\n  const version = dataView.getUint32(byteOffset + 4, LE);\n  const byteLength = dataView.getUint32(byteOffset + 8, LE);\n  Object.assign(glb, {\n    header: {\n      byteOffset,\n      byteLength,\n      hasBinChunk: false\n    },\n    type,\n    version,\n    json: {},\n    binChunks: []\n  });\n  byteOffset += GLB_FILE_HEADER_SIZE;\n\n  switch (glb.version) {\n    case 1:\n      return parseGLBV1(glb, dataView, byteOffset);\n\n    case 2:\n      return parseGLBV2(glb, dataView, byteOffset, options = {});\n\n    default:\n      throw new Error(\"Invalid GLB version \".concat(glb.version, \". Only supports v1 and v2.\"));\n  }\n}\n\nfunction parseGLBV1(glb, dataView, byteOffset) {\n  assert(glb.header.byteLength > GLB_FILE_HEADER_SIZE + GLB_CHUNK_HEADER_SIZE);\n  const contentLength = dataView.getUint32(byteOffset + 0, LE);\n  const contentFormat = dataView.getUint32(byteOffset + 4, LE);\n  byteOffset += GLB_CHUNK_HEADER_SIZE;\n  assert(contentFormat === GLB_V1_CONTENT_FORMAT_JSON);\n  parseJSONChunk(glb, dataView, byteOffset, contentLength);\n  byteOffset += contentLength;\n  byteOffset += parseBINChunk(glb, dataView, byteOffset, glb.header.byteLength);\n  return byteOffset;\n}\n\nfunction parseGLBV2(glb, dataView, byteOffset, options) {\n  assert(glb.header.byteLength > GLB_FILE_HEADER_SIZE + GLB_CHUNK_HEADER_SIZE);\n  parseGLBChunksSync(glb, dataView, byteOffset, options);\n  return byteOffset + glb.header.byteLength;\n}\n\nfunction parseGLBChunksSync(glb, dataView, byteOffset, options) {\n  while (byteOffset + 8 <= glb.header.byteLength) {\n    const chunkLength = dataView.getUint32(byteOffset + 0, LE);\n    const chunkFormat = dataView.getUint32(byteOffset + 4, LE);\n    byteOffset += GLB_CHUNK_HEADER_SIZE;\n\n    switch (chunkFormat) {\n      case GLB_CHUNK_TYPE_JSON:\n        parseJSONChunk(glb, dataView, byteOffset, chunkLength);\n        break;\n\n      case GLB_CHUNK_TYPE_BIN:\n        parseBINChunk(glb, dataView, byteOffset, chunkLength);\n        break;\n\n      case GLB_CHUNK_TYPE_JSON_XVIZ_DEPRECATED:\n        if (!options.strict) {\n          parseJSONChunk(glb, dataView, byteOffset, chunkLength);\n        }\n\n        break;\n\n      case GLB_CHUNK_TYPE_BIX_XVIZ_DEPRECATED:\n        if (!options.strict) {\n          parseBINChunk(glb, dataView, byteOffset, chunkLength);\n        }\n\n        break;\n\n      default:\n        break;\n    }\n\n    byteOffset += padToNBytes(chunkLength, 4);\n  }\n\n  return byteOffset;\n}\n\nfunction parseJSONChunk(glb, dataView, byteOffset, chunkLength) {\n  const jsonChunk = new Uint8Array(dataView.buffer, byteOffset, chunkLength);\n  const textDecoder = new TextDecoder('utf8');\n  const jsonText = textDecoder.decode(jsonChunk);\n  glb.json = JSON.parse(jsonText);\n  return padToNBytes(chunkLength, 4);\n}\n\nfunction parseBINChunk(glb, dataView, byteOffset, chunkLength) {\n  glb.header.hasBinChunk = true;\n  glb.binChunks.push({\n    byteOffset,\n    byteLength: chunkLength,\n    arrayBuffer: dataView.buffer\n  });\n  return padToNBytes(chunkLength, 4);\n}","map":{"version":3,"sources":["../../../../src/lib/parsers/parse-glb.ts"],"names":["MAGIC_glTF","GLB_FILE_HEADER_SIZE","GLB_CHUNK_HEADER_SIZE","GLB_CHUNK_TYPE_JSON","GLB_CHUNK_TYPE_BIN","GLB_CHUNK_TYPE_JSON_XVIZ_DEPRECATED","GLB_CHUNK_TYPE_BIX_XVIZ_DEPRECATED","GLB_V1_CONTENT_FORMAT_JSON","LE","byteOffset","String","dataView","options","magic","magic1","type","getMagicString","version","byteLength","Object","header","hasBinChunk","json","binChunks","glb","parseGLBV1","parseGLBV2","assert","contentLength","contentFormat","parseJSONChunk","parseBINChunk","parseGLBChunksSync","chunkLength","chunkFormat","padToNBytes","jsonChunk","textDecoder","jsonText","JSON","arrayBuffer","buffer"],"mappings":"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","sourcesContent":["/* eslint-disable camelcase, max-statements */\n// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#glb-file-format-specification\n// https://github.com/KhronosGroup/glTF/tree/master/extensions/1.0/Khronos/KHR_binary_glTF\nimport type {GLB} from '../types/glb-types';\nimport {padToNBytes, assert} from '@loaders.gl/loader-utils';\n\nexport type GLBParseOptions = {\n  magic?: number;\n  strict?: boolean;\n};\n\nconst MAGIC_glTF = 0x676c5446; // glTF in Big-Endian ASCII\n\nconst GLB_FILE_HEADER_SIZE = 12;\nconst GLB_CHUNK_HEADER_SIZE = 8;\n\nconst GLB_CHUNK_TYPE_JSON = 0x4e4f534a;\nconst GLB_CHUNK_TYPE_BIN = 0x004e4942;\nconst GLB_CHUNK_TYPE_JSON_XVIZ_DEPRECATED = 0; // DEPRECATED - Backward compatibility for old xviz files\nconst GLB_CHUNK_TYPE_BIX_XVIZ_DEPRECATED = 1; // DEPRECATED - Backward compatibility for old xviz files\n\nconst GLB_V1_CONTENT_FORMAT_JSON = 0x0;\n\nconst LE = true; // Binary GLTF is little endian.\n\nfunction getMagicString(dataView, byteOffset = 0) {\n  return `\\\n${String.fromCharCode(dataView.getUint8(byteOffset + 0))}\\\n${String.fromCharCode(dataView.getUint8(byteOffset + 1))}\\\n${String.fromCharCode(dataView.getUint8(byteOffset + 2))}\\\n${String.fromCharCode(dataView.getUint8(byteOffset + 3))}`;\n}\n\n// Check if a data view is a GLB\nexport function isGLB(\n  arrayBuffer: ArrayBuffer,\n  byteOffset: number = 0,\n  options: GLBParseOptions = {}\n): boolean {\n  const dataView = new DataView(arrayBuffer);\n  // Check that GLB Header starts with the magic number\n  const {magic = MAGIC_glTF} = options;\n  const magic1 = dataView.getUint32(byteOffset, false);\n  return magic1 === magic || magic1 === MAGIC_glTF;\n}\n\nexport default function parseGLBSync(\n  glb: GLB,\n  arrayBuffer: ArrayBuffer,\n  byteOffset: number = 0,\n  options: GLBParseOptions = {}\n) {\n  // Check that GLB Header starts with the magic number\n  const dataView = new DataView(arrayBuffer);\n\n  // Compare format with GLBLoader documentation\n  const type = getMagicString(dataView, byteOffset + 0);\n  const version = dataView.getUint32(byteOffset + 4, LE); // Version 2 of binary glTF container format\n  const byteLength = dataView.getUint32(byteOffset + 8, LE); // Total byte length of binary file\n\n  Object.assign(glb, {\n    // Put less important stuff in a header, to avoid clutter\n    header: {\n      byteOffset, // Byte offset into the initial arrayBuffer\n      byteLength,\n      hasBinChunk: false\n    },\n\n    type,\n    version,\n\n    json: {},\n    binChunks: []\n  } as GLB);\n\n  byteOffset += GLB_FILE_HEADER_SIZE;\n\n  switch (glb.version) {\n    case 1:\n      // eslint-disable-next-line\n      return parseGLBV1(glb, dataView, byteOffset);\n    case 2:\n      // eslint-disable-next-line\n      return parseGLBV2(glb, dataView, byteOffset, (options = {}));\n    default:\n      throw new Error(`Invalid GLB version ${glb.version}. Only supports v1 and v2.`);\n  }\n}\n\nfunction parseGLBV1(glb: GLB, dataView: DataView, byteOffset: number): number {\n  // Sanity: ensure file is big enough to hold at least the headers\n  assert(glb.header.byteLength > GLB_FILE_HEADER_SIZE + GLB_CHUNK_HEADER_SIZE);\n\n  // Explanation of GLB structure:\n  // https://cloud.githubusercontent.com/assets/3479527/22600725/36b87122-ea55-11e6-9d40-6fd42819fcab.png\n  const contentLength = dataView.getUint32(byteOffset + 0, LE); // Byte length of chunk\n  const contentFormat = dataView.getUint32(byteOffset + 4, LE); // Chunk format as uint32\n  byteOffset += GLB_CHUNK_HEADER_SIZE;\n\n  // GLB v1 only supports a single chunk type\n  assert(contentFormat === GLB_V1_CONTENT_FORMAT_JSON);\n\n  parseJSONChunk(glb, dataView, byteOffset, contentLength);\n  // No need to call the function padToBytes() from parseJSONChunk()\n  byteOffset += contentLength;\n  byteOffset += parseBINChunk(glb, dataView, byteOffset, glb.header.byteLength);\n\n  return byteOffset;\n}\n\nfunction parseGLBV2(\n  glb: GLB,\n  dataView: DataView,\n  byteOffset: number,\n  options: GLBParseOptions\n): number {\n  // Sanity: ensure file is big enough to hold at least the first chunk header\n  assert(glb.header.byteLength > GLB_FILE_HEADER_SIZE + GLB_CHUNK_HEADER_SIZE);\n\n  parseGLBChunksSync(glb, dataView, byteOffset, options);\n\n  return byteOffset + glb.header.byteLength;\n}\n\nfunction parseGLBChunksSync(\n  glb: GLB,\n  dataView: DataView,\n  byteOffset: number,\n  options: GLBParseOptions\n) {\n  // Per spec we must iterate over chunks, ignoring all except JSON and BIN\n  // Iterate as long as there is space left for another chunk header\n  while (byteOffset + 8 <= glb.header.byteLength) {\n    const chunkLength = dataView.getUint32(byteOffset + 0, LE); // Byte length of chunk\n    const chunkFormat = dataView.getUint32(byteOffset + 4, LE); // Chunk format as uint32\n    byteOffset += GLB_CHUNK_HEADER_SIZE;\n\n    // Per spec we must iterate over chunks, ignoring all except JSON and BIN\n    switch (chunkFormat) {\n      case GLB_CHUNK_TYPE_JSON:\n        parseJSONChunk(glb, dataView, byteOffset, chunkLength);\n        break;\n      case GLB_CHUNK_TYPE_BIN:\n        parseBINChunk(glb, dataView, byteOffset, chunkLength);\n        break;\n\n      // Backward compatibility for very old xviz files\n      case GLB_CHUNK_TYPE_JSON_XVIZ_DEPRECATED:\n        if (!options.strict) {\n          parseJSONChunk(glb, dataView, byteOffset, chunkLength);\n        }\n        break;\n      case GLB_CHUNK_TYPE_BIX_XVIZ_DEPRECATED:\n        if (!options.strict) {\n          parseBINChunk(glb, dataView, byteOffset, chunkLength);\n        }\n        break;\n\n      default:\n        // Ignore, per spec\n        // console.warn(`Unknown GLB chunk type`); // eslint-disable-line\n        break;\n    }\n\n    byteOffset += padToNBytes(chunkLength, 4);\n  }\n\n  return byteOffset;\n}\n\n// Parse a GLB JSON chunk\nfunction parseJSONChunk(glb: GLB, dataView: DataView, byteOffset: number, chunkLength: number) {\n  // 1. Create a \"view\" of the binary encoded JSON data inside the GLB\n  const jsonChunk = new Uint8Array(dataView.buffer, byteOffset, chunkLength);\n\n  // 2. Decode the JSON binary array into clear text\n  const textDecoder = new TextDecoder('utf8');\n  const jsonText = textDecoder.decode(jsonChunk);\n\n  // 3. Parse the JSON text into a JavaScript data structure\n  glb.json = JSON.parse(jsonText);\n\n  return padToNBytes(chunkLength, 4);\n}\n\n// Parse a GLB BIN chunk\nfunction parseBINChunk(glb: GLB, dataView, byteOffset, chunkLength) {\n  // Note: BIN chunk can be optional\n  glb.header.hasBinChunk = true;\n  glb.binChunks.push({\n    byteOffset,\n    byteLength: chunkLength,\n    arrayBuffer: dataView.buffer\n    // TODO - copy, or create typed array view?\n  });\n\n  return padToNBytes(chunkLength, 4);\n}\n"]},"metadata":{},"sourceType":"module"}