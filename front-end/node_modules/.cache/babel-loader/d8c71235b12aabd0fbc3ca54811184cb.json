{"ast":null,"code":"import Buffer from '../classes/buffer';\nimport { getKey } from '../webgl-utils/constants-to-keys';\nimport { getCompositeGLType } from '../webgl-utils/attribute-utils';\nimport { formatValue } from '../utils/format-value';\nexport function getDebugTableForVertexArray(_ref) {\n  let {\n    vertexArray,\n    header = 'Attributes'\n  } = _ref;\n\n  if (!vertexArray.configuration) {\n    return {};\n  }\n\n  const table = {};\n\n  if (vertexArray.elements) {\n    table.ELEMENT_ARRAY_BUFFER = getDebugTableRow(vertexArray, vertexArray.elements, null, header);\n  }\n\n  const attributes = vertexArray.values;\n\n  for (const attributeLocation in attributes) {\n    const info = vertexArray._getAttributeInfo(attributeLocation);\n\n    if (info) {\n      let rowHeader = `${attributeLocation}: ${info.name}`;\n      const accessor = vertexArray.accessors[info.location];\n\n      if (accessor) {\n        rowHeader = `${attributeLocation}: ${getGLSLDeclaration(info.name, accessor)}`;\n      }\n\n      table[rowHeader] = getDebugTableRow(vertexArray, attributes[attributeLocation], accessor, header);\n    }\n  }\n\n  return table;\n}\n\nfunction getDebugTableRow(vertexArray, attribute, accessor, header) {\n  const {\n    gl\n  } = vertexArray;\n\n  if (!attribute) {\n    return {\n      [header]: 'null',\n      'Format ': 'N/A'\n    };\n  }\n\n  let type = 'NOT PROVIDED';\n  let size = 1;\n  let verts = 0;\n  let bytes = 0;\n  let isInteger;\n  let marker;\n  let value;\n\n  if (accessor) {\n    type = accessor.type;\n    size = accessor.size;\n    type = String(type).replace('Array', '');\n    isInteger = type.indexOf('nt') !== -1;\n  }\n\n  if (attribute instanceof Buffer) {\n    const buffer = attribute;\n    const {\n      data,\n      changed\n    } = buffer.getDebugData();\n    marker = changed ? '*' : '';\n    value = data;\n    bytes = buffer.byteLength;\n    verts = bytes / data.BYTES_PER_ELEMENT / size;\n    let format;\n\n    if (accessor) {\n      const instanced = accessor.divisor > 0;\n      format = `${instanced ? 'I ' : 'P '} ${verts} (x${size}=${bytes} bytes ${getKey(gl, type)})`;\n    } else {\n      isInteger = true;\n      format = `${bytes} bytes`;\n    }\n\n    return {\n      [header]: `${marker}${formatValue(value, {\n        size,\n        isInteger\n      })}`,\n      'Format ': format\n    };\n  }\n\n  value = attribute;\n  size = attribute.length;\n  type = String(attribute.constructor.name).replace('Array', '');\n  isInteger = type.indexOf('nt') !== -1;\n  return {\n    [header]: `${formatValue(value, {\n      size,\n      isInteger\n    })} (constant)`,\n    'Format ': `${size}x${type} (constant)`\n  };\n}\n\nfunction getGLSLDeclaration(name, accessor) {\n  const {\n    type,\n    size\n  } = accessor;\n  const typeAndName = getCompositeGLType(type, size);\n  return typeAndName ? `${name} (${typeAndName.name})` : name;\n}","map":{"version":3,"sources":["../../../src/debug/debug-vertex-array.js"],"names":["header","vertexArray","table","getDebugTableRow","attributes","info","rowHeader","attributeLocation","name","accessor","getGLSLDeclaration","gl","type","size","verts","bytes","String","isInteger","attribute","buffer","changed","marker","value","data","instanced","format","getKey","formatValue","typeAndName","getCompositeGLType"],"mappings":"AAAA,OAAA,MAAA,MAAA,mBAAA;AACA,SAAA,MAAA,QAAA,kCAAA;AACA,SAAA,kBAAA,QAAA,gCAAA;AACA,SAAA,WAAA,QAAA,uBAAA;AAGA,OAAO,SAAA,2BAAA,OAA2E;AAAA,MAAtC;AAAA,IAAA,WAAA;AAAcA,IAAAA,MAAM,GAAG;AAAvB,GAAsC;;AAChF,MAAI,CAACC,WAAW,CAAhB,aAAA,EAAgC;AAC9B,WAAA,EAAA;AACD;;AAED,QAAMC,KAAK,GAAX,EAAA;;AAGA,MAAID,WAAW,CAAf,QAAA,EAA0B;AAExBC,IAAAA,KAAK,CAALA,oBAAAA,GAA6BC,gBAAgB,CAAA,WAAA,EAAcF,WAAW,CAAzB,QAAA,EAAA,IAAA,EAA7CC,MAA6C,CAA7CA;AACD;;AAGD,QAAME,UAAU,GAAGH,WAAW,CAA9B,MAAA;;AAEA,OAAK,MAAL,iBAAA,IAAA,UAAA,EAA4C;AAC1C,UAAMI,IAAI,GAAGJ,WAAW,CAAXA,iBAAAA,CAAb,iBAAaA,CAAb;;AACA,QAAA,IAAA,EAAU;AACR,UAAIK,SAAS,GAAI,GAAEC,iBAAkB,KAAIF,IAAI,CAACG,IAA9C,EAAA;AACA,YAAMC,QAAQ,GAAGR,WAAW,CAAXA,SAAAA,CAAsBI,IAAI,CAA3C,QAAiBJ,CAAjB;;AACA,UAAA,QAAA,EAAc;AACZK,QAAAA,SAAS,GAAI,GAAEC,iBAAkB,KAAIG,kBAAkB,CAACL,IAAI,CAAL,IAAA,EAAA,QAAA,CAAvDC,EAAAA;AACD;;AACDJ,MAAAA,KAAK,CAALA,SAAK,CAALA,GAAmBC,gBAAgB,CAAA,WAAA,EAEjCC,UAAU,CAFuB,iBAEvB,CAFuB,EAAA,QAAA,EAAnCF,MAAmC,CAAnCA;AAMD;AACF;;AAED,SAAA,KAAA;AACD;;AAGD,SAAA,gBAAA,CAAA,WAAA,EAAA,SAAA,EAAA,QAAA,EAAA,MAAA,EAAoE;AAClE,QAAM;AAACS,IAAAA;AAAD,MAAN,WAAA;;AAEA,MAAI,CAAJ,SAAA,EAAgB;AACd,WAAO;AACL,OAAA,MAAA,GADK,MAAA;AAEL,iBAAW;AAFN,KAAP;AAID;;AAED,MAAIC,IAAI,GAAR,cAAA;AACA,MAAIC,IAAI,GAAR,CAAA;AACA,MAAIC,KAAK,GAAT,CAAA;AACA,MAAIC,KAAK,GAAT,CAAA;AAEA,MAAA,SAAA;AACA,MAAA,MAAA;AACA,MAAA,KAAA;;AAEA,MAAA,QAAA,EAAc;AACZH,IAAAA,IAAI,GAAGH,QAAQ,CAAfG,IAAAA;AACAC,IAAAA,IAAI,GAAGJ,QAAQ,CAAfI,IAAAA;AAGAD,IAAAA,IAAI,GAAGI,MAAM,CAANA,IAAM,CAANA,CAAAA,OAAAA,CAAAA,OAAAA,EAAPJ,EAAOI,CAAPJ;AAGAK,IAAAA,SAAS,GAAGL,IAAI,CAAJA,OAAAA,CAAAA,IAAAA,MAAuB,CAAnCK,CAAAA;AACD;;AAED,MAAIC,SAAS,YAAb,MAAA,EAAiC;AAC/B,UAAMC,MAAM,GAAZ,SAAA;AAEA,UAAM;AAAA,MAAA,IAAA;AAAOC,MAAAA;AAAP,QAAkBD,MAAM,CAA9B,YAAwBA,EAAxB;AACAE,IAAAA,MAAM,GAAGD,OAAO,GAAA,GAAA,GAAhBC,EAAAA;AAEAC,IAAAA,KAAK,GAALA,IAAAA;AAEAP,IAAAA,KAAK,GAAGI,MAAM,CAAdJ,UAAAA;AAEAD,IAAAA,KAAK,GAAGC,KAAK,GAAGQ,IAAI,CAAZR,iBAAAA,GAARD,IAAAA;AAEA,QAAA,MAAA;;AAEA,QAAA,QAAA,EAAc;AACZ,YAAMU,SAAS,GAAGf,QAAQ,CAARA,OAAAA,GAAlB,CAAA;AACAgB,MAAAA,MAAM,GAAI,GAAED,SAAS,GAAA,IAAA,GAAU,IAAK,IAAGV,KAAM,MAAKD,IAAK,IAAGE,KAAM,UAASW,MAAM,CAAA,EAAA,EAAA,IAAA,CAA/ED,GAAAA;AAFF,KAAA,MAGO;AAELR,MAAAA,SAAS,GAATA,IAAAA;AACAQ,MAAAA,MAAM,GAAI,GAAEV,KAAZU,QAAAA;AACD;;AAED,WAAO;AACL,OAAA,MAAA,GAAW,GAAEJ,MAAO,GAAEM,WAAW,CAAA,KAAA,EAAQ;AAAA,QAAA,IAAA;AAAOV,QAAAA;AAAP,OAAR,CAD5B,EAAA;AAEL,iBAAWQ;AAFN,KAAP;AAID;;AAGDH,EAAAA,KAAK,GAALA,SAAAA;AACAT,EAAAA,IAAI,GAAGK,SAAS,CAAhBL,MAAAA;AAEAD,EAAAA,IAAI,GAAGI,MAAM,CAACE,SAAS,CAATA,WAAAA,CAAPF,IAAM,CAANA,CAAAA,OAAAA,CAAAA,OAAAA,EAAPJ,EAAOI,CAAPJ;AAEAK,EAAAA,SAAS,GAAGL,IAAI,CAAJA,OAAAA,CAAAA,IAAAA,MAAuB,CAAnCK,CAAAA;AAEA,SAAO;AACL,KAAA,MAAA,GAAW,GAAEU,WAAW,CAAA,KAAA,EAAQ;AAAA,MAAA,IAAA;AAAOV,MAAAA;AAAP,KAAR,CADnB,aAAA;AAEL,eAAY,GAAEJ,IAAK,IAAGD,IAAK;AAFtB,GAAP;AAID;;AAGD,SAAA,kBAAA,CAAA,IAAA,EAAA,QAAA,EAA4C;AAC1C,QAAM;AAAA,IAAA,IAAA;AAAOC,IAAAA;AAAP,MAAN,QAAA;AACA,QAAMe,WAAW,GAAGC,kBAAkB,CAAA,IAAA,EAAtC,IAAsC,CAAtC;AACA,SAAOD,WAAW,GAAI,GAAEpB,IAAK,KAAIoB,WAAW,CAACpB,IAA3B,GAAA,GAAlB,IAAA;AACD","sourcesContent":["import Buffer from '../classes/buffer';\nimport {getKey} from '../webgl-utils/constants-to-keys';\nimport {getCompositeGLType} from '../webgl-utils/attribute-utils';\nimport {formatValue} from '../utils/format-value';\n\n// Creates object suitable as input for console.table\nexport function getDebugTableForVertexArray({vertexArray, header = 'Attributes'}) {\n  if (!vertexArray.configuration) {\n    return {};\n  }\n\n  const table = {}; // {[header]: {}};\n\n  // Add index (elements) if available\n  if (vertexArray.elements) {\n    // const elements = Object.assign({size: 1}, vertexArray.elements);\n    table.ELEMENT_ARRAY_BUFFER = getDebugTableRow(vertexArray, vertexArray.elements, null, header);\n  }\n\n  // Add used attributes\n  const attributes = vertexArray.values;\n\n  for (const attributeLocation in attributes) {\n    const info = vertexArray._getAttributeInfo(attributeLocation);\n    if (info) {\n      let rowHeader = `${attributeLocation}: ${info.name}`;\n      const accessor = vertexArray.accessors[info.location];\n      if (accessor) {\n        rowHeader = `${attributeLocation}: ${getGLSLDeclaration(info.name, accessor)}`;\n      }\n      table[rowHeader] = getDebugTableRow(\n        vertexArray,\n        attributes[attributeLocation],\n        accessor,\n        header\n      );\n    }\n  }\n\n  return table;\n}\n\n/* eslint-disable max-statements */\nfunction getDebugTableRow(vertexArray, attribute, accessor, header) {\n  const {gl} = vertexArray;\n\n  if (!attribute) {\n    return {\n      [header]: 'null',\n      'Format ': 'N/A'\n    };\n  }\n\n  let type = 'NOT PROVIDED';\n  let size = 1;\n  let verts = 0;\n  let bytes = 0;\n\n  let isInteger;\n  let marker;\n  let value;\n\n  if (accessor) {\n    type = accessor.type;\n    size = accessor.size;\n\n    // Generate a type name by dropping Array from Float32Array etc.\n    type = String(type).replace('Array', '');\n\n    // Look for 'nt' to detect integer types, e.g. Int32Array, Uint32Array\n    isInteger = type.indexOf('nt') !== -1;\n  }\n\n  if (attribute instanceof Buffer) {\n    const buffer = attribute;\n\n    const {data, changed} = buffer.getDebugData();\n    marker = changed ? '*' : '';\n\n    value = data;\n    // @ts-ignore\n    bytes = buffer.byteLength;\n    // @ts-ignore\n    verts = bytes / data.BYTES_PER_ELEMENT / size;\n\n    let format;\n\n    if (accessor) {\n      const instanced = accessor.divisor > 0;\n      format = `${instanced ? 'I ' : 'P '} ${verts} (x${size}=${bytes} bytes ${getKey(gl, type)})`;\n    } else {\n      // element buffer\n      isInteger = true;\n      format = `${bytes} bytes`;\n    }\n\n    return {\n      [header]: `${marker}${formatValue(value, {size, isInteger})}`,\n      'Format ': format\n    };\n  }\n\n  // CONSTANT VALUE\n  value = attribute;\n  size = attribute.length;\n  // Generate a type name by dropping Array from Float32Array etc.\n  type = String(attribute.constructor.name).replace('Array', '');\n  // Look for 'nt' to detect integer types, e.g. Int32Array, Uint32Array\n  isInteger = type.indexOf('nt') !== -1;\n\n  return {\n    [header]: `${formatValue(value, {size, isInteger})} (constant)`,\n    'Format ': `${size}x${type} (constant)`\n  };\n}\n/* eslint-ensable max-statements */\n\nfunction getGLSLDeclaration(name, accessor) {\n  const {type, size} = accessor;\n  const typeAndName = getCompositeGLType(type, size);\n  return typeAndName ? `${name} (${typeAndName.name})` : name;\n}\n"]},"metadata":{},"sourceType":"module"}