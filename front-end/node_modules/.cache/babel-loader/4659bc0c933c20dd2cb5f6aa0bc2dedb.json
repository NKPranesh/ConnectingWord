{"ast":null,"code":"import Tile2DHeader from './tile-2d-header';\nimport { getTileIndices, tileToBoundingBox } from './utils';\nimport { RequestScheduler } from '@loaders.gl/loader-utils';\nimport { Matrix4 } from 'math.gl';\nconst TILE_STATE_UNKNOWN = 0;\nconst TILE_STATE_VISIBLE = 1;\nconst TILE_STATE_PLACEHOLDER = 3;\nconst TILE_STATE_HIDDEN = 4;\nconst TILE_STATE_SELECTED = 5;\nexport const STRATEGY_NEVER = 'never';\nexport const STRATEGY_REPLACE = 'no-overlap';\nexport const STRATEGY_DEFAULT = 'best-available';\nconst DEFAULT_CACHE_SCALE = 5;\nexport default class Tileset2D {\n  constructor(opts) {\n    this.opts = opts;\n\n    this.onTileLoad = tile => {\n      this.opts.onTileLoad(tile);\n\n      if (this.opts.maxCacheByteSize) {\n        this._cacheByteSize += tile.byteLength;\n\n        this._resizeCache();\n      }\n    };\n\n    this._requestScheduler = new RequestScheduler({\n      maxRequests: opts.maxRequests,\n      throttleRequests: opts.maxRequests > 0\n    });\n    this._cache = new Map();\n    this._tiles = [];\n    this._dirty = false;\n    this._cacheByteSize = 0;\n    this._viewport = null;\n    this._selectedTiles = null;\n    this._frameNumber = 0;\n    this.setOptions(opts);\n  }\n\n  get tiles() {\n    return this._tiles;\n  }\n\n  get selectedTiles() {\n    return this._selectedTiles;\n  }\n\n  get isLoaded() {\n    return this._selectedTiles.every(tile => tile.isLoaded);\n  }\n\n  setOptions(opts) {\n    Object.assign(this.opts, opts);\n\n    if (Number.isFinite(opts.maxZoom)) {\n      this._maxZoom = Math.floor(opts.maxZoom);\n    }\n\n    if (Number.isFinite(opts.minZoom)) {\n      this._minZoom = Math.ceil(opts.minZoom);\n    }\n  }\n\n  finalize() {\n    for (const tile of this._cache.values()) {\n      if (tile.isLoading) {\n        tile.abort();\n      }\n    }\n\n    this._cache.clear();\n\n    this._tiles = [];\n    this._selectedTiles = null;\n  }\n\n  reloadAll() {\n    for (const tileId of this._cache.keys()) {\n      const tile = this._cache.get(tileId);\n\n      if (!this._selectedTiles.includes(tile)) {\n        this._cache.delete(tileId);\n      } else {\n        tile.setNeedsReload();\n      }\n    }\n  }\n\n  update(viewport) {\n    let {\n      zRange,\n      modelMatrix\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const modelMatrixAsMatrix4 = new Matrix4(modelMatrix);\n    const isModelMatrixNew = !modelMatrixAsMatrix4.equals(this._modelMatrix);\n\n    if (!viewport.equals(this._viewport) || isModelMatrixNew) {\n      if (isModelMatrixNew) {\n        this._modelMatrixInverse = modelMatrix && modelMatrixAsMatrix4.clone().invert();\n        this._modelMatrix = modelMatrix && modelMatrixAsMatrix4;\n      }\n\n      this._viewport = viewport;\n      const tileIndices = this.getTileIndices({\n        viewport,\n        maxZoom: this._maxZoom,\n        minZoom: this._minZoom,\n        zRange,\n        modelMatrix: this._modelMatrix,\n        modelMatrixInverse: this._modelMatrixInverse\n      });\n      this._selectedTiles = tileIndices.map(index => this._getTile(index, true));\n\n      if (this._dirty) {\n        this._rebuildTree();\n      }\n    }\n\n    const changed = this.updateTileStates();\n\n    if (this._dirty) {\n      this._resizeCache();\n    }\n\n    if (changed) {\n      this._frameNumber++;\n    }\n\n    return this._frameNumber;\n  }\n\n  getTileIndices(_ref) {\n    let {\n      viewport,\n      maxZoom,\n      minZoom,\n      zRange,\n      modelMatrix,\n      modelMatrixInverse\n    } = _ref;\n    const {\n      tileSize,\n      extent,\n      zoomOffset\n    } = this.opts;\n    return getTileIndices({\n      viewport,\n      maxZoom,\n      minZoom,\n      zRange,\n      tileSize,\n      extent,\n      modelMatrix,\n      modelMatrixInverse,\n      zoomOffset\n    });\n  }\n\n  getTileMetadata(_ref2) {\n    let {\n      x,\n      y,\n      z\n    } = _ref2;\n    const {\n      tileSize\n    } = this.opts;\n    return {\n      bbox: tileToBoundingBox(this._viewport, x, y, z, tileSize)\n    };\n  }\n\n  getParentIndex(tileIndex) {\n    tileIndex.x = Math.floor(tileIndex.x / 2);\n    tileIndex.y = Math.floor(tileIndex.y / 2);\n    tileIndex.z -= 1;\n    return tileIndex;\n  }\n\n  updateTileStates() {\n    this._updateTileStates(this.selectedTiles);\n\n    const {\n      maxRequests\n    } = this.opts;\n    const abortCandidates = [];\n    let ongoingRequestCount = 0;\n    let changed = false;\n\n    for (const tile of this._cache.values()) {\n      const isVisible = Boolean(tile.state & TILE_STATE_VISIBLE);\n\n      if (tile.isVisible !== isVisible) {\n        changed = true;\n        tile.isVisible = isVisible;\n      }\n\n      tile.isSelected = tile.state === TILE_STATE_SELECTED;\n\n      if (tile.isLoading) {\n        ongoingRequestCount++;\n\n        if (!tile.isSelected) {\n          abortCandidates.push(tile);\n        }\n      }\n    }\n\n    if (maxRequests > 0) {\n      while (ongoingRequestCount > maxRequests && abortCandidates.length > 0) {\n        const tile = abortCandidates.shift();\n        tile.abort();\n        ongoingRequestCount--;\n      }\n    }\n\n    return changed;\n  }\n\n  _rebuildTree() {\n    const {\n      _cache\n    } = this;\n\n    for (const tile of _cache.values()) {\n      tile.parent = null;\n      tile.children.length = 0;\n    }\n\n    for (const tile of _cache.values()) {\n      const parent = this._getNearestAncestor(tile.x, tile.y, tile.z);\n\n      tile.parent = parent;\n\n      if (parent) {\n        parent.children.push(tile);\n      }\n    }\n  }\n\n  _updateTileStates(selectedTiles) {\n    const {\n      _cache\n    } = this;\n    const refinementStrategy = this.opts.refinementStrategy || STRATEGY_DEFAULT;\n\n    for (const tile of _cache.values()) {\n      tile.state = TILE_STATE_UNKNOWN;\n    }\n\n    for (const tile of selectedTiles) {\n      tile.state = TILE_STATE_SELECTED;\n    }\n\n    if (refinementStrategy === STRATEGY_NEVER) {\n      return;\n    }\n\n    for (const tile of selectedTiles) {\n      getPlaceholderInAncestors(tile, refinementStrategy);\n    }\n\n    for (const tile of selectedTiles) {\n      if (needsPlaceholder(tile)) {\n        getPlaceholderInChildren(tile);\n      }\n    }\n  }\n\n  _resizeCache() {\n    const {\n      _cache,\n      opts\n    } = this;\n    const maxCacheSize = opts.maxCacheSize || (opts.maxCacheByteSize ? Infinity : DEFAULT_CACHE_SCALE * this.selectedTiles.length);\n    const maxCacheByteSize = opts.maxCacheByteSize || Infinity;\n    const overflown = _cache.size > maxCacheSize || this._cacheByteSize > maxCacheByteSize;\n\n    if (overflown) {\n      for (const [tileId, tile] of _cache) {\n        if (!tile.isVisible) {\n          this._cacheByteSize -= opts.maxCacheByteSize ? tile.byteLength : 0;\n\n          _cache.delete(tileId);\n\n          this.opts.onTileUnload(tile);\n        }\n\n        if (_cache.size <= maxCacheSize && this._cacheByteSize <= maxCacheByteSize) {\n          break;\n        }\n      }\n\n      this._rebuildTree();\n\n      this._dirty = true;\n    }\n\n    if (this._dirty) {\n      this._tiles = Array.from(this._cache.values()).sort((t1, t2) => t1.z - t2.z);\n      this._dirty = false;\n    }\n  }\n\n  _getTile(_ref3, create) {\n    let {\n      x,\n      y,\n      z\n    } = _ref3;\n    const tileId = \"\".concat(x, \",\").concat(y, \",\").concat(z);\n\n    let tile = this._cache.get(tileId);\n\n    let needsReload = false;\n\n    if (!tile && create) {\n      tile = new Tile2DHeader({\n        x,\n        y,\n        z\n      });\n      Object.assign(tile, this.getTileMetadata(tile));\n      needsReload = true;\n\n      this._cache.set(tileId, tile);\n\n      this._dirty = true;\n    } else if (tile && tile.needsReload) {\n      needsReload = true;\n    }\n\n    if (needsReload) {\n      tile.loadData({\n        getData: this.opts.getTileData,\n        requestScheduler: this._requestScheduler,\n        onLoad: this.onTileLoad,\n        onError: this.opts.onTileError\n      });\n    }\n\n    return tile;\n  }\n\n  _getNearestAncestor(x, y, z) {\n    const {\n      _minZoom = 0\n    } = this;\n    let index = {\n      x,\n      y,\n      z\n    };\n\n    while (index.z > _minZoom) {\n      index = this.getParentIndex(index);\n\n      const parent = this._getTile(index);\n\n      if (parent) {\n        return parent;\n      }\n    }\n\n    return null;\n  }\n\n}\n\nfunction needsPlaceholder(tile) {\n  let t = tile;\n\n  while (t) {\n    if (t.state & TILE_STATE_VISIBLE === 0) {\n      return true;\n    }\n\n    if (t.isLoaded) {\n      return false;\n    }\n\n    t = t.parent;\n  }\n\n  return true;\n}\n\nfunction getPlaceholderInAncestors(tile, refinementStrategy) {\n  let parent;\n  let state = TILE_STATE_PLACEHOLDER;\n\n  while (parent = tile.parent) {\n    if (tile.isLoaded) {\n      state = TILE_STATE_HIDDEN;\n\n      if (refinementStrategy === STRATEGY_DEFAULT) {\n        return;\n      }\n    }\n\n    parent.state = Math.max(parent.state, state);\n    tile = parent;\n  }\n}\n\nfunction getPlaceholderInChildren(tile) {\n  for (const child of tile.children) {\n    child.state = Math.max(child.state, TILE_STATE_PLACEHOLDER);\n\n    if (!child.isLoaded) {\n      getPlaceholderInChildren(child);\n    }\n  }\n}","map":{"version":3,"sources":["../../../src/tile-layer/tileset-2d.js"],"names":["TILE_STATE_UNKNOWN","TILE_STATE_VISIBLE","TILE_STATE_PLACEHOLDER","TILE_STATE_HIDDEN","TILE_STATE_SELECTED","STRATEGY_NEVER","STRATEGY_REPLACE","STRATEGY_DEFAULT","DEFAULT_CACHE_SCALE","constructor","tile","maxRequests","opts","throttleRequests","tiles","selectedTiles","isLoaded","setOptions","Object","Number","Math","finalize","reloadAll","update","modelMatrix","modelMatrixAsMatrix4","isModelMatrixNew","viewport","tileIndices","maxZoom","minZoom","modelMatrixInverse","_modelMatrixInverse","index","changed","getTileIndices","zoomOffset","getTileMetadata","z","tileSize","bbox","tileToBoundingBox","getParentIndex","tileIndex","updateTileStates","abortCandidates","ongoingRequestCount","isVisible","Boolean","_rebuildTree","_cache","parent","_updateTileStates","refinementStrategy","getPlaceholderInAncestors","needsPlaceholder","getPlaceholderInChildren","_resizeCache","maxCacheSize","maxCacheByteSize","overflown","Array","t1","t2","_getTile","tileId","needsReload","getData","requestScheduler","onLoad","onError","onTileError","_getNearestAncestor","_minZoom","t","state","child"],"mappings":"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","sourcesContent":["import Tile2DHeader from './tile-2d-header';\nimport {getTileIndices, tileToBoundingBox} from './utils';\nimport {RequestScheduler} from '@loaders.gl/loader-utils';\nimport {Matrix4} from 'math.gl';\n\nconst TILE_STATE_UNKNOWN = 0;\nconst TILE_STATE_VISIBLE = 1;\n/*\n   show cached parent tile if children are loading\n   +-----------+       +-----+            +-----+-----+\n   |           |       |     |            |     |     |\n   |           |       |     |            |     |     |\n   |           |  -->  +-----+-----+  ->  +-----+-----+\n   |           |             |     |      |     |     |\n   |           |             |     |      |     |     |\n   +-----------+             +-----+      +-----+-----+\n\n   show cached children tiles when parent is loading\n   +-------+----       +------------\n   |       |           |\n   |       |           |\n   |       |           |\n   +-------+----  -->  |\n   |       |           |\n */\nconst TILE_STATE_PLACEHOLDER = 3;\nconst TILE_STATE_HIDDEN = 4;\n// tiles that should be displayed in the current viewport\nconst TILE_STATE_SELECTED = 5;\n\nexport const STRATEGY_NEVER = 'never';\nexport const STRATEGY_REPLACE = 'no-overlap';\nexport const STRATEGY_DEFAULT = 'best-available';\n\nconst DEFAULT_CACHE_SCALE = 5;\n\n/**\n * Manages loading and purging of tiles data. This class caches recently visited tiles\n * and only create new tiles if they are present.\n */\n\nexport default class Tileset2D {\n  /**\n   * Takes in a function that returns tile data, a cache size, and a max and a min zoom level.\n   * Cache size defaults to 5 * number of tiles in the current viewport\n   */\n  constructor(opts) {\n    this.opts = opts;\n\n    this.onTileLoad = tile => {\n      this.opts.onTileLoad(tile);\n      if (this.opts.maxCacheByteSize) {\n        this._cacheByteSize += tile.byteLength;\n        this._resizeCache();\n      }\n    };\n\n    this._requestScheduler = new RequestScheduler({\n      maxRequests: opts.maxRequests,\n      throttleRequests: opts.maxRequests > 0\n    });\n\n    // Maps tile id in string {z}-{x}-{y} to a Tile object\n    this._cache = new Map();\n    this._tiles = [];\n    this._dirty = false;\n    this._cacheByteSize = 0;\n\n    // Cache the last processed viewport\n    this._viewport = null;\n    this._selectedTiles = null;\n    this._frameNumber = 0;\n\n    this.setOptions(opts);\n  }\n\n  /* Public API */\n  get tiles() {\n    return this._tiles;\n  }\n\n  get selectedTiles() {\n    return this._selectedTiles;\n  }\n\n  get isLoaded() {\n    return this._selectedTiles.every(tile => tile.isLoaded);\n  }\n\n  setOptions(opts) {\n    Object.assign(this.opts, opts);\n    if (Number.isFinite(opts.maxZoom)) {\n      this._maxZoom = Math.floor(opts.maxZoom);\n    }\n    if (Number.isFinite(opts.minZoom)) {\n      this._minZoom = Math.ceil(opts.minZoom);\n    }\n  }\n\n  // Clean up any outstanding tile requests.\n  finalize() {\n    for (const tile of this._cache.values()) {\n      if (tile.isLoading) {\n        tile.abort();\n      }\n    }\n    this._cache.clear();\n    this._tiles = [];\n    this._selectedTiles = null;\n  }\n\n  reloadAll() {\n    for (const tileId of this._cache.keys()) {\n      const tile = this._cache.get(tileId);\n      if (!this._selectedTiles.includes(tile)) {\n        this._cache.delete(tileId);\n      } else {\n        tile.setNeedsReload();\n      }\n    }\n  }\n\n  /**\n   * Update the cache with the given viewport and model matrix and triggers callback onUpdate.\n   * @param {*} viewport\n   * @param {*} onUpdate\n   * @param {*} modelMatrix\n   */\n  update(viewport, {zRange, modelMatrix} = {}) {\n    const modelMatrixAsMatrix4 = new Matrix4(modelMatrix);\n    const isModelMatrixNew = !modelMatrixAsMatrix4.equals(this._modelMatrix);\n    if (!viewport.equals(this._viewport) || isModelMatrixNew) {\n      if (isModelMatrixNew) {\n        this._modelMatrixInverse = modelMatrix && modelMatrixAsMatrix4.clone().invert();\n        this._modelMatrix = modelMatrix && modelMatrixAsMatrix4;\n      }\n      this._viewport = viewport;\n      const tileIndices = this.getTileIndices({\n        viewport,\n        maxZoom: this._maxZoom,\n        minZoom: this._minZoom,\n        zRange,\n        modelMatrix: this._modelMatrix,\n        modelMatrixInverse: this._modelMatrixInverse\n      });\n      this._selectedTiles = tileIndices.map(index => this._getTile(index, true));\n\n      if (this._dirty) {\n        // Some new tiles are added\n        this._rebuildTree();\n      }\n    }\n\n    // Update tile states\n    const changed = this.updateTileStates();\n\n    if (this._dirty) {\n      // cache size is either the user defined maxSize or 5 * number of current tiles in the viewport.\n      this._resizeCache();\n    }\n\n    if (changed) {\n      this._frameNumber++;\n    }\n\n    return this._frameNumber;\n  }\n\n  /* Public interface for subclassing */\n\n  // Returns array of {x, y, z}\n  getTileIndices({viewport, maxZoom, minZoom, zRange, modelMatrix, modelMatrixInverse}) {\n    const {tileSize, extent, zoomOffset} = this.opts;\n    return getTileIndices({\n      viewport,\n      maxZoom,\n      minZoom,\n      zRange,\n      tileSize,\n      extent,\n      modelMatrix,\n      modelMatrixInverse,\n      zoomOffset\n    });\n  }\n\n  // Add custom metadata to tiles\n  getTileMetadata({x, y, z}) {\n    const {tileSize} = this.opts;\n    return {bbox: tileToBoundingBox(this._viewport, x, y, z, tileSize)};\n  }\n\n  // Returns {x, y, z} of the parent tile\n  getParentIndex(tileIndex) {\n    // Perf: mutate the input object to avoid GC\n    tileIndex.x = Math.floor(tileIndex.x / 2);\n    tileIndex.y = Math.floor(tileIndex.y / 2);\n    tileIndex.z -= 1;\n    return tileIndex;\n  }\n\n  // Returns true if any tile's visibility changed\n  updateTileStates() {\n    this._updateTileStates(this.selectedTiles);\n\n    const {maxRequests} = this.opts;\n\n    const abortCandidates = [];\n    let ongoingRequestCount = 0;\n    let changed = false;\n    for (const tile of this._cache.values()) {\n      const isVisible = Boolean(tile.state & TILE_STATE_VISIBLE);\n      if (tile.isVisible !== isVisible) {\n        changed = true;\n        tile.isVisible = isVisible;\n      }\n\n      // isSelected used in request scheduler\n      tile.isSelected = tile.state === TILE_STATE_SELECTED;\n\n      // Keep track of all the ongoing requests\n      if (tile.isLoading) {\n        ongoingRequestCount++;\n        if (!tile.isSelected) {\n          abortCandidates.push(tile);\n        }\n      }\n    }\n\n    if (maxRequests > 0) {\n      while (ongoingRequestCount > maxRequests && abortCandidates.length > 0) {\n        // There are too many ongoing requests, so abort some that are unselected\n        const tile = abortCandidates.shift();\n        tile.abort();\n        ongoingRequestCount--;\n      }\n    }\n\n    return changed;\n  }\n\n  /* Private methods */\n\n  // This needs to be called every time some tiles have been added/removed from cache\n  _rebuildTree() {\n    const {_cache} = this;\n\n    // Reset states\n    for (const tile of _cache.values()) {\n      tile.parent = null;\n      tile.children.length = 0;\n    }\n\n    // Rebuild tree\n    for (const tile of _cache.values()) {\n      const parent = this._getNearestAncestor(tile.x, tile.y, tile.z);\n      tile.parent = parent;\n      if (parent) {\n        parent.children.push(tile);\n      }\n    }\n  }\n\n  // A selected tile is always visible.\n  // Never show two overlapping tiles.\n  // If a selected tile is loading, try showing a cached ancester with the closest z\n  // If a selected tile is loading, and no ancester is shown - try showing cached\n  // descendants with the closest z\n  _updateTileStates(selectedTiles) {\n    const {_cache} = this;\n    const refinementStrategy = this.opts.refinementStrategy || STRATEGY_DEFAULT;\n\n    // Reset states\n    for (const tile of _cache.values()) {\n      tile.state = TILE_STATE_UNKNOWN;\n    }\n\n    // For all the selected && pending tiles:\n    // - pick the closest ancestor as placeholder\n    // - if no ancestor is visible, pick the closest children as placeholder\n    for (const tile of selectedTiles) {\n      tile.state = TILE_STATE_SELECTED;\n    }\n\n    if (refinementStrategy === STRATEGY_NEVER) {\n      return;\n    }\n    for (const tile of selectedTiles) {\n      getPlaceholderInAncestors(tile, refinementStrategy);\n    }\n    for (const tile of selectedTiles) {\n      if (needsPlaceholder(tile)) {\n        getPlaceholderInChildren(tile);\n      }\n    }\n  }\n\n  /**\n   * Clear tiles that are not visible when the cache is full\n   */\n  /* eslint-disable complexity */\n  _resizeCache() {\n    const {_cache, opts} = this;\n\n    const maxCacheSize =\n      opts.maxCacheSize ||\n      (opts.maxCacheByteSize ? Infinity : DEFAULT_CACHE_SCALE * this.selectedTiles.length);\n    const maxCacheByteSize = opts.maxCacheByteSize || Infinity;\n\n    const overflown = _cache.size > maxCacheSize || this._cacheByteSize > maxCacheByteSize;\n\n    if (overflown) {\n      for (const [tileId, tile] of _cache) {\n        if (!tile.isVisible) {\n          // delete tile\n          this._cacheByteSize -= opts.maxCacheByteSize ? tile.byteLength : 0;\n          _cache.delete(tileId);\n          this.opts.onTileUnload(tile);\n        }\n        if (_cache.size <= maxCacheSize && this._cacheByteSize <= maxCacheByteSize) {\n          break;\n        }\n      }\n      this._rebuildTree();\n      this._dirty = true;\n    }\n    if (this._dirty) {\n      this._tiles = Array.from(this._cache.values())\n        // sort by zoom level so that smaller tiles are displayed on top\n        .sort((t1, t2) => t1.z - t2.z);\n\n      this._dirty = false;\n    }\n  }\n  /* eslint-enable complexity */\n\n  _getTile({x, y, z}, create) {\n    const tileId = `${x},${y},${z}`;\n    let tile = this._cache.get(tileId);\n    let needsReload = false;\n\n    if (!tile && create) {\n      tile = new Tile2DHeader({x, y, z});\n      Object.assign(tile, this.getTileMetadata(tile));\n      needsReload = true;\n      this._cache.set(tileId, tile);\n      this._dirty = true;\n    } else if (tile && tile.needsReload) {\n      needsReload = true;\n    }\n    if (needsReload) {\n      tile.loadData({\n        getData: this.opts.getTileData,\n        requestScheduler: this._requestScheduler,\n        onLoad: this.onTileLoad,\n        onError: this.opts.onTileError\n      });\n    }\n\n    return tile;\n  }\n\n  _getNearestAncestor(x, y, z) {\n    const {_minZoom = 0} = this;\n    let index = {x, y, z};\n\n    while (index.z > _minZoom) {\n      index = this.getParentIndex(index);\n      const parent = this._getTile(index);\n      if (parent) {\n        return parent;\n      }\n    }\n    return null;\n  }\n}\n\n// A selected tile needs placeholder from its children if\n// - it is not loaded\n// - none of its ancestors is visible and loaded\nfunction needsPlaceholder(tile) {\n  let t = tile;\n  while (t) {\n    if (t.state & (TILE_STATE_VISIBLE === 0)) {\n      return true;\n    }\n    if (t.isLoaded) {\n      return false;\n    }\n    t = t.parent;\n  }\n  return true;\n}\n\nfunction getPlaceholderInAncestors(tile, refinementStrategy) {\n  let parent;\n  let state = TILE_STATE_PLACEHOLDER;\n  while ((parent = tile.parent)) {\n    if (tile.isLoaded) {\n      // If a tile is loaded, mark all its ancestors as hidden\n      state = TILE_STATE_HIDDEN;\n      if (refinementStrategy === STRATEGY_DEFAULT) {\n        return;\n      }\n    }\n    parent.state = Math.max(parent.state, state);\n    tile = parent;\n  }\n}\n\n// Recursively set children as placeholder\nfunction getPlaceholderInChildren(tile) {\n  for (const child of tile.children) {\n    child.state = Math.max(child.state, TILE_STATE_PLACEHOLDER);\n    if (!child.isLoaded) {\n      getPlaceholderInChildren(child);\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}