{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { Vector3, Matrix4 } from '@math.gl/core';\nimport { CullingVolume } from '@math.gl/culling';\nimport { load } from '@loaders.gl/core';\nimport { TILE_REFINEMENT, TILE_CONTENT_STATE, TILESET_TYPE } from '../constants';\nimport { createBoundingVolume } from './helpers/bounding-volume';\nimport { getTiles3DScreenSpaceError } from './helpers/tiles-3d-lod';\nimport { getI3ScreenSize } from './helpers/i3s-lod';\nimport { get3dTilesOptions } from './helpers/3d-tiles-options';\nimport TilesetTraverser from './traversers/tileset-traverser';\nconst scratchVector = new Vector3();\n\nfunction defined(x) {\n  return x !== undefined && x !== null;\n}\n\nexport default class TileHeader {\n  constructor(tileset, header, parentHeader) {\n    let extendedId = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';\n\n    _defineProperty(this, \"tileset\", void 0);\n\n    _defineProperty(this, \"header\", void 0);\n\n    _defineProperty(this, \"id\", void 0);\n\n    _defineProperty(this, \"url\", void 0);\n\n    _defineProperty(this, \"parent\", void 0);\n\n    _defineProperty(this, \"refine\", void 0);\n\n    _defineProperty(this, \"type\", void 0);\n\n    _defineProperty(this, \"contentUrl\", void 0);\n\n    _defineProperty(this, \"lodMetricType\", void 0);\n\n    _defineProperty(this, \"lodMetricValue\", void 0);\n\n    _defineProperty(this, \"boundingVolume\", void 0);\n\n    _defineProperty(this, \"content\", void 0);\n\n    _defineProperty(this, \"contentState\", void 0);\n\n    _defineProperty(this, \"gpuMemoryUsageInBytes\", void 0);\n\n    _defineProperty(this, \"children\", void 0);\n\n    _defineProperty(this, \"depth\", void 0);\n\n    _defineProperty(this, \"viewportIds\", void 0);\n\n    _defineProperty(this, \"transform\", void 0);\n\n    _defineProperty(this, \"userData\", void 0);\n\n    _defineProperty(this, \"computedTransform\", void 0);\n\n    _defineProperty(this, \"hasEmptyContent\", void 0);\n\n    _defineProperty(this, \"hasTilesetContent\", void 0);\n\n    _defineProperty(this, \"traverser\", void 0);\n\n    _defineProperty(this, \"_cacheNode\", void 0);\n\n    _defineProperty(this, \"_frameNumber\", void 0);\n\n    _defineProperty(this, \"_lodJudge\", void 0);\n\n    _defineProperty(this, \"_expireDate\", void 0);\n\n    _defineProperty(this, \"_expiredContent\", void 0);\n\n    _defineProperty(this, \"_shouldRefine\", void 0);\n\n    _defineProperty(this, \"_distanceToCamera\", void 0);\n\n    _defineProperty(this, \"_centerZDepth\", void 0);\n\n    _defineProperty(this, \"_screenSpaceError\", void 0);\n\n    _defineProperty(this, \"_visibilityPlaneMask\", void 0);\n\n    _defineProperty(this, \"_visible\", void 0);\n\n    _defineProperty(this, \"_inRequestVolume\", void 0);\n\n    _defineProperty(this, \"_stackLength\", void 0);\n\n    _defineProperty(this, \"_selectionDepth\", void 0);\n\n    _defineProperty(this, \"_touchedFrame\", void 0);\n\n    _defineProperty(this, \"_visitedFrame\", void 0);\n\n    _defineProperty(this, \"_selectedFrame\", void 0);\n\n    _defineProperty(this, \"_requestedFrame\", void 0);\n\n    _defineProperty(this, \"_priority\", void 0);\n\n    _defineProperty(this, \"_contentBoundingVolume\", void 0);\n\n    _defineProperty(this, \"_viewerRequestVolume\", void 0);\n\n    _defineProperty(this, \"_initialTransform\", void 0);\n\n    this.header = header;\n    this.tileset = tileset;\n    this.id = extendedId || header.id;\n    this.url = header.url;\n    this.parent = parentHeader;\n    this.refine = this._getRefine(header.refine);\n    this.type = header.type;\n    this.contentUrl = header.contentUrl;\n    this.lodMetricType = 'geometricError';\n    this.lodMetricValue = 0;\n    this.boundingVolume = null;\n    this.content = null;\n    this.contentState = TILE_CONTENT_STATE.UNLOADED;\n    this.gpuMemoryUsageInBytes = 0;\n    this.children = [];\n    this.hasEmptyContent = false;\n    this.hasTilesetContent = false;\n    this.depth = 0;\n    this.viewportIds = [];\n    this.userData = {};\n    this._priority = 0;\n    this._touchedFrame = 0;\n    this._visitedFrame = 0;\n    this._selectedFrame = 0;\n    this._requestedFrame = 0;\n    this._screenSpaceError = 0;\n    this._cacheNode = null;\n    this._frameNumber = null;\n    this._cacheNode = null;\n    this.traverser = new TilesetTraverser({});\n    this._shouldRefine = false;\n    this._distanceToCamera = 0;\n    this._centerZDepth = 0;\n    this._visible = undefined;\n    this._inRequestVolume = false;\n    this._stackLength = 0;\n    this._selectionDepth = 0;\n    this._initialTransform = new Matrix4();\n    this.transform = new Matrix4();\n\n    this._initializeLodMetric(header);\n\n    this._initializeTransforms(header);\n\n    this._initializeBoundingVolumes(header);\n\n    this._initializeContent(header);\n\n    this._initializeRenderingState(header);\n\n    this._lodJudge = null;\n    this._expireDate = null;\n    this._expiredContent = null;\n    Object.seal(this);\n  }\n\n  destroy() {\n    this.header = null;\n  }\n\n  isDestroyed() {\n    return this.header === null;\n  }\n\n  get selected() {\n    return this._selectedFrame === this.tileset._frameNumber;\n  }\n\n  get isVisible() {\n    return this._visible;\n  }\n\n  get isVisibleAndInRequestVolume() {\n    return this._visible && this._inRequestVolume;\n  }\n\n  get hasRenderContent() {\n    return !this.hasEmptyContent && !this.hasTilesetContent;\n  }\n\n  get hasChildren() {\n    return this.children.length > 0 || this.header.children && this.header.children.length > 0;\n  }\n\n  get contentReady() {\n    return this.contentState === TILE_CONTENT_STATE.READY || this.hasEmptyContent;\n  }\n\n  get contentAvailable() {\n    return Boolean(this.contentReady && this.hasRenderContent || this._expiredContent && !this.contentFailed);\n  }\n\n  get hasUnloadedContent() {\n    return this.hasRenderContent && this.contentUnloaded;\n  }\n\n  get contentUnloaded() {\n    return this.contentState === TILE_CONTENT_STATE.UNLOADED;\n  }\n\n  get contentExpired() {\n    return this.contentState === TILE_CONTENT_STATE.EXPIRED;\n  }\n\n  get contentFailed() {\n    return this.contentState === TILE_CONTENT_STATE.FAILED;\n  }\n\n  getScreenSpaceError(frameState, useParentLodMetric) {\n    switch (this.tileset.type) {\n      case TILESET_TYPE.I3S:\n        return getI3ScreenSize(this, frameState);\n\n      case TILESET_TYPE.TILES3D:\n        return getTiles3DScreenSpaceError(this, frameState, useParentLodMetric);\n\n      default:\n        throw new Error('Unsupported tileset type');\n    }\n  }\n\n  _getPriority() {\n    const traverser = this.tileset._traverser;\n    const {\n      skipLevelOfDetail\n    } = traverser.options;\n    const maySkipTile = this.refine === TILE_REFINEMENT.ADD || skipLevelOfDetail;\n\n    if (maySkipTile && !this.isVisible && this._visible !== undefined) {\n      return -1;\n    }\n\n    if (this.tileset._frameNumber - this._touchedFrame >= 1) {\n      return -1;\n    }\n\n    if (this.contentState === TILE_CONTENT_STATE.UNLOADED) {\n      return -1;\n    }\n\n    const parent = this.parent;\n    const useParentScreenSpaceError = parent && (!maySkipTile || this._screenSpaceError === 0.0 || parent.hasTilesetContent);\n    const screenSpaceError = useParentScreenSpaceError ? parent._screenSpaceError : this._screenSpaceError;\n    const rootScreenSpaceError = traverser.root ? traverser.root._screenSpaceError : 0.0;\n    return Math.max(rootScreenSpaceError - screenSpaceError, 0);\n  }\n\n  async loadContent() {\n    if (this.hasEmptyContent) {\n      return false;\n    }\n\n    if (this.content) {\n      return true;\n    }\n\n    const expired = this.contentExpired;\n\n    if (expired) {\n      this._expireDate = null;\n    }\n\n    this.contentState = TILE_CONTENT_STATE.LOADING;\n    const requestToken = await this.tileset._requestScheduler.scheduleRequest(this.id, this._getPriority.bind(this));\n\n    if (!requestToken) {\n      this.contentState = TILE_CONTENT_STATE.UNLOADED;\n      return false;\n    }\n\n    try {\n      const contentUrl = this.tileset.getTileUrl(this.contentUrl);\n      const loader = this.tileset.loader;\n      const options = { ...this.tileset.loadOptions,\n        [loader.id]: { ...this.tileset.loadOptions[loader.id],\n          isTileset: this.type === 'json',\n          ...this._getLoaderSpecificOptions(loader.id)\n        }\n      };\n      this.content = await load(contentUrl, loader, options);\n\n      if (this.tileset.options.contentLoader) {\n        await this.tileset.options.contentLoader(this);\n      }\n\n      if (this._isTileset()) {\n        this.tileset._initializeTileHeaders(this.content, this);\n      }\n\n      this.contentState = TILE_CONTENT_STATE.READY;\n\n      this._onContentLoaded();\n\n      return true;\n    } catch (error) {\n      this.contentState = TILE_CONTENT_STATE.FAILED;\n      throw error;\n    } finally {\n      requestToken.done();\n    }\n  }\n\n  unloadContent() {\n    if (this.content && this.content.destroy) {\n      this.content.destroy();\n    }\n\n    this.content = null;\n\n    if (this.header.content && this.header.content.destroy) {\n      this.header.content.destroy();\n    }\n\n    this.header.content = null;\n    this.contentState = TILE_CONTENT_STATE.UNLOADED;\n    return true;\n  }\n\n  updateVisibility(frameState, viewportIds) {\n    if (this._frameNumber === frameState.frameNumber) {\n      return;\n    }\n\n    const parent = this.parent;\n    const parentVisibilityPlaneMask = parent ? parent._visibilityPlaneMask : CullingVolume.MASK_INDETERMINATE;\n\n    if (this.tileset._traverser.options.updateTransforms) {\n      const parentTransform = parent ? parent.computedTransform : this.tileset.modelMatrix;\n\n      this._updateTransform(parentTransform);\n    }\n\n    this._distanceToCamera = this.distanceToTile(frameState);\n    this._screenSpaceError = this.getScreenSpaceError(frameState, false);\n    this._visibilityPlaneMask = this.visibility(frameState, parentVisibilityPlaneMask);\n    this._visible = this._visibilityPlaneMask !== CullingVolume.MASK_OUTSIDE;\n    this._inRequestVolume = this.insideViewerRequestVolume(frameState);\n    this._frameNumber = frameState.frameNumber;\n    this.viewportIds = viewportIds;\n  }\n\n  visibility(frameState, parentVisibilityPlaneMask) {\n    const {\n      cullingVolume\n    } = frameState;\n    const {\n      boundingVolume\n    } = this;\n    return cullingVolume.computeVisibilityWithPlaneMask(boundingVolume, parentVisibilityPlaneMask);\n  }\n\n  contentVisibility() {\n    return true;\n  }\n\n  distanceToTile(frameState) {\n    const boundingVolume = this.boundingVolume;\n    return Math.sqrt(Math.max(boundingVolume.distanceSquaredTo(frameState.camera.position), 0));\n  }\n\n  cameraSpaceZDepth(_ref) {\n    let {\n      camera\n    } = _ref;\n    const boundingVolume = this.boundingVolume;\n    scratchVector.subVectors(boundingVolume.center, camera.position);\n    return camera.direction.dot(scratchVector);\n  }\n\n  insideViewerRequestVolume(frameState) {\n    const viewerRequestVolume = this._viewerRequestVolume;\n    return !viewerRequestVolume || viewerRequestVolume.distanceSquaredTo(frameState.camera.position) <= 0;\n  }\n\n  updateExpiration() {\n    if (defined(this._expireDate) && this.contentReady && !this.hasEmptyContent) {\n      const now = Date.now();\n\n      if (Date.lessThan(this._expireDate, now)) {\n        this.contentState = TILE_CONTENT_STATE.EXPIRED;\n        this._expiredContent = this.content;\n      }\n    }\n  }\n\n  get extras() {\n    return this.header.extras;\n  }\n\n  _initializeLodMetric(header) {\n    if ('lodMetricType' in header) {\n      this.lodMetricType = header.lodMetricType;\n    } else {\n      this.lodMetricType = this.parent && this.parent.lodMetricType || this.tileset.lodMetricType;\n      console.warn(\"3D Tile: Required prop lodMetricType is undefined. Using parent lodMetricType\");\n    }\n\n    if ('lodMetricValue' in header) {\n      this.lodMetricValue = header.lodMetricValue;\n    } else {\n      this.lodMetricValue = this.parent && this.parent.lodMetricValue || this.tileset.lodMetricValue;\n      console.warn('3D Tile: Required prop lodMetricValue is undefined. Using parent lodMetricValue');\n    }\n  }\n\n  _initializeTransforms(tileHeader) {\n    this.transform = tileHeader.transform ? new Matrix4(tileHeader.transform) : new Matrix4();\n    const parent = this.parent;\n    const tileset = this.tileset;\n    const parentTransform = parent && parent.computedTransform ? parent.computedTransform.clone() : tileset.modelMatrix.clone();\n    this.computedTransform = new Matrix4(parentTransform).multiplyRight(this.transform);\n    const parentInitialTransform = parent && parent._initialTransform ? parent._initialTransform.clone() : new Matrix4();\n    this._initialTransform = new Matrix4(parentInitialTransform).multiplyRight(this.transform);\n  }\n\n  _initializeBoundingVolumes(tileHeader) {\n    this._contentBoundingVolume = null;\n    this._viewerRequestVolume = null;\n\n    this._updateBoundingVolume(tileHeader);\n  }\n\n  _initializeContent(tileHeader) {\n    this.content = {\n      _tileset: this.tileset,\n      _tile: this\n    };\n    this.hasEmptyContent = true;\n    this.contentState = TILE_CONTENT_STATE.UNLOADED;\n    this.hasTilesetContent = false;\n\n    if (tileHeader.contentUrl) {\n      this.content = null;\n      this.hasEmptyContent = false;\n    }\n  }\n\n  _initializeRenderingState(header) {\n    this.depth = header.level || (this.parent ? this.parent.depth + 1 : 0);\n    this._shouldRefine = false;\n    this._distanceToCamera = 0;\n    this._centerZDepth = 0;\n    this._screenSpaceError = 0;\n    this._visibilityPlaneMask = CullingVolume.MASK_INDETERMINATE;\n    this._visible = undefined;\n    this._inRequestVolume = false;\n    this._stackLength = 0;\n    this._selectionDepth = 0;\n    this._frameNumber = 0;\n    this._touchedFrame = 0;\n    this._visitedFrame = 0;\n    this._selectedFrame = 0;\n    this._requestedFrame = 0;\n    this._priority = 0.0;\n  }\n\n  _getRefine(refine) {\n    return refine || this.parent && this.parent.refine || TILE_REFINEMENT.REPLACE;\n  }\n\n  _isTileset() {\n    return this.contentUrl.indexOf('.json') !== -1;\n  }\n\n  _onContentLoaded() {\n    switch (this.content && this.content.type) {\n      case 'vctr':\n      case 'geom':\n        this.tileset._traverser.disableSkipLevelOfDetail = true;\n        break;\n\n      default:\n    }\n\n    if (this._isTileset()) {\n      this.hasTilesetContent = true;\n    }\n  }\n\n  _updateBoundingVolume(header) {\n    this.boundingVolume = createBoundingVolume(header.boundingVolume, this.computedTransform, this.boundingVolume);\n    const content = header.content;\n\n    if (!content) {\n      return;\n    }\n\n    if (content.boundingVolume) {\n      this._contentBoundingVolume = createBoundingVolume(content.boundingVolume, this.computedTransform, this._contentBoundingVolume);\n    }\n\n    if (header.viewerRequestVolume) {\n      this._viewerRequestVolume = createBoundingVolume(header.viewerRequestVolume, this.computedTransform, this._viewerRequestVolume);\n    }\n  }\n\n  _updateTransform() {\n    let parentTransform = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Matrix4();\n    const computedTransform = parentTransform.clone().multiplyRight(this.transform);\n    const didTransformChange = !computedTransform.equals(this.computedTransform);\n\n    if (!didTransformChange) {\n      return;\n    }\n\n    this.computedTransform = computedTransform;\n\n    this._updateBoundingVolume(this.header);\n  }\n\n  _getLoaderSpecificOptions(loaderId) {\n    switch (loaderId) {\n      case 'i3s':\n        return { ...this.tileset.options.i3s,\n          tile: this.header,\n          tileset: this.tileset.tileset,\n          isTileHeader: false\n        };\n\n      case '3d-tiles':\n      case 'cesium-ion':\n      default:\n        return get3dTilesOptions(this.tileset.tileset);\n    }\n  }\n\n}","map":{"version":3,"sources":["../../../src/tileset/tile-3d.ts"],"names":["scratchVector","x","constructor","extendedId","header","TILE_CONTENT_STATE","Object","destroy","isDestroyed","selected","isVisible","isVisibleAndInRequestVolume","hasRenderContent","hasChildren","contentReady","contentAvailable","Boolean","hasUnloadedContent","contentUnloaded","contentExpired","contentFailed","getScreenSpaceError","TILESET_TYPE","getI3ScreenSize","getTiles3DScreenSpaceError","_getPriority","traverser","skipLevelOfDetail","maySkipTile","TILE_REFINEMENT","parent","useParentScreenSpaceError","screenSpaceError","rootScreenSpaceError","Math","loadContent","expired","requestToken","contentUrl","loader","options","isTileset","load","unloadContent","updateVisibility","frameState","parentVisibilityPlaneMask","CullingVolume","parentTransform","visibility","cullingVolume","boundingVolume","contentVisibility","distanceToTile","cameraSpaceZDepth","camera","insideViewerRequestVolume","viewerRequestVolume","updateExpiration","defined","now","Date","extras","_initializeLodMetric","console","_initializeTransforms","tileHeader","tileset","parentInitialTransform","_initializeBoundingVolumes","_initializeContent","_tileset","_tile","_initializeRenderingState","_getRefine","refine","_isTileset","_onContentLoaded","_updateBoundingVolume","createBoundingVolume","content","_updateTransform","computedTransform","didTransformChange","_getLoaderSpecificOptions","tile","isTileHeader","get3dTilesOptions"],"mappings":"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","sourcesContent":["// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\nimport {Vector3, Matrix4} from '@math.gl/core';\nimport {CullingVolume} from '@math.gl/culling';\n\nimport {load} from '@loaders.gl/core';\nimport {TILE_REFINEMENT, TILE_CONTENT_STATE, TILESET_TYPE} from '../constants';\n\nimport {FrameState} from './helpers/frame-state';\nimport {createBoundingVolume} from './helpers/bounding-volume';\nimport {getTiles3DScreenSpaceError} from './helpers/tiles-3d-lod';\nimport {getI3ScreenSize} from './helpers/i3s-lod';\nimport {get3dTilesOptions} from './helpers/3d-tiles-options';\nimport TilesetTraverser from './traversers/tileset-traverser';\n\n// Note: circular dependency\nimport type Tileset3D from './tileset-3d';\n\nconst scratchVector = new Vector3();\n\nfunction defined(x) {\n  return x !== undefined && x !== null;\n}\n\n/**\n * @param tileset - Tileset3D instance\n * @param header - tile header - JSON loaded from a dataset\n * @param parentHeader - parent TileHeader instance\n * @param extendedId - optional ID to separate copies of a tile for different viewports.\n *                              const extendedId = `${tile.id}-${frameState.viewport.id}`;\n */\nexport type TileHeaderProps = {\n  tileset: Tileset3D;\n  header: Object;\n  parentHeader: TileHeader;\n  extendedId: string;\n};\n\n/**\n * A Tile3DHeader represents a tile as Tileset3D. When a tile is first created, its content is not loaded;\n * the content is loaded on-demand when needed based on the view.\n * Do not construct this directly, instead access tiles through {@link Tileset3D#tileVisible}.\n */\nexport default class TileHeader {\n  tileset: Tileset3D;\n  header: any;\n  id: string;\n  url: string;\n  parent: TileHeader;\n  refine: number;\n  type: string;\n  contentUrl: string;\n  lodMetricType: string;\n  lodMetricValue: number;\n  boundingVolume: any;\n  content: any;\n  contentState: any;\n  gpuMemoryUsageInBytes: number;\n  children: TileHeader[];\n  depth: number;\n  viewportIds: any[];\n  transform: Matrix4;\n\n  // Container to store application specific data\n  userData: {[key: string]: any};\n  computedTransform: any;\n  hasEmptyContent: boolean;\n  hasTilesetContent: boolean;\n\n  traverser: object;\n\n  // @ts-ignore\n  private _cacheNode: any;\n  private _frameNumber: any;\n  // TODO i3s specific, needs to remove\n  // @ts-ignore\n  private _lodJudge: any;\n  // TODO Cesium 3d tiles specific\n  private _expireDate: any;\n  private _expiredContent: any;\n  // @ts-ignore\n  private _shouldRefine: boolean;\n\n  // Members this are updated every frame for tree traversal and rendering optimizations:\n  // @ts-ignore\n  private _distanceToCamera: number;\n  // @ts-ignore\n  private _centerZDepth: number;\n  private _screenSpaceError: number;\n  private _visibilityPlaneMask: any;\n  private _visible?: boolean;\n  private _inRequestVolume: boolean;\n\n  // @ts-ignore\n  private _stackLength: number;\n  // @ts-ignore\n  private _selectionDepth: number;\n\n  // @ts-ignore\n  private _touchedFrame: number;\n  // @ts-ignore\n  private _visitedFrame: number;\n  private _selectedFrame: number;\n  // @ts-ignore\n  private _requestedFrame: number;\n\n  // @ts-ignore\n  private _priority: number;\n\n  private _contentBoundingVolume: any;\n  private _viewerRequestVolume: any;\n\n  _initialTransform: Matrix4;\n\n  /**\n   * @constructs\n   * Create a TileHeader instance\n   * @param tileset - Tileset3D instance\n   * @param header - tile header - JSON loaded from a dataset\n   * @param parentHeader - parent TileHeader instance\n   * @param extendedId - optional ID to separate copies of a tile for different viewports.\n   *    const extendedId = `${tile.id}-${frameState.viewport.id}`;\n   */\n  // eslint-disable-next-line max-statements\n  constructor(\n    tileset: Tileset3D,\n    header: {[key: string]: any},\n    parentHeader?: TileHeader,\n    extendedId = ''\n  ) {\n    // PUBLIC MEMBERS\n    // original tile data\n    this.header = header;\n\n    // The tileset containing this tile.\n    this.tileset = tileset;\n    this.id = extendedId || header.id;\n    this.url = header.url;\n\n    // This tile's parent or `undefined` if this tile is the root.\n    // @ts-ignore\n    this.parent = parentHeader;\n    this.refine = this._getRefine(header.refine);\n    this.type = header.type;\n    this.contentUrl = header.contentUrl;\n\n    // The error, in meters, introduced if this tile is rendered and its children are not.\n    this.lodMetricType = 'geometricError';\n    this.lodMetricValue = 0;\n\n    // Specifies the type of refine that is used when traversing this tile for rendering.\n    this.boundingVolume = null;\n\n    // The tile's content.  This represents the actual tile's payload,\n    // not the content's metadata in the tileset JSON file.\n    this.content = null;\n    this.contentState = TILE_CONTENT_STATE.UNLOADED;\n    this.gpuMemoryUsageInBytes = 0;\n\n    // The tile's children - an array of Tile3D objects.\n    this.children = [];\n\n    this.hasEmptyContent = false;\n    this.hasTilesetContent = false;\n\n    this.depth = 0;\n    this.viewportIds = [];\n\n    // Container to store application specific data\n    this.userData = {};\n\n    // PRIVATE MEMBERS\n    this._priority = 0;\n    this._touchedFrame = 0;\n    this._visitedFrame = 0;\n    this._selectedFrame = 0;\n    this._requestedFrame = 0;\n    this._screenSpaceError = 0;\n\n    this._cacheNode = null;\n    this._frameNumber = null;\n    this._cacheNode = null;\n\n    this.traverser = new TilesetTraverser({});\n    this._shouldRefine = false;\n    this._distanceToCamera = 0;\n    this._centerZDepth = 0;\n    this._visible = undefined;\n    this._inRequestVolume = false;\n    this._stackLength = 0;\n    this._selectionDepth = 0;\n    this._initialTransform = new Matrix4();\n    this.transform = new Matrix4();\n\n    this._initializeLodMetric(header);\n    this._initializeTransforms(header);\n    this._initializeBoundingVolumes(header);\n    this._initializeContent(header);\n    this._initializeRenderingState(header);\n\n    // TODO i3s specific, needs to remove\n    this._lodJudge = null;\n\n    // TODO Cesium 3d tiles specific\n    this._expireDate = null;\n    this._expiredContent = null;\n\n    Object.seal(this);\n  }\n\n  destroy() {\n    this.header = null;\n  }\n\n  isDestroyed() {\n    return this.header === null;\n  }\n\n  get selected() {\n    return this._selectedFrame === this.tileset._frameNumber;\n  }\n\n  get isVisible() {\n    return this._visible;\n  }\n\n  get isVisibleAndInRequestVolume() {\n    return this._visible && this._inRequestVolume;\n  }\n\n  /** Returns true if tile is not an empty tile and not an external tileset */\n  get hasRenderContent() {\n    return !this.hasEmptyContent && !this.hasTilesetContent;\n  }\n\n  /** Returns true if tile has children */\n  get hasChildren() {\n    return this.children.length > 0 || (this.header.children && this.header.children.length > 0);\n  }\n\n  /**\n   * Determines if the tile's content is ready. This is automatically `true` for\n   * tiles with empty content.\n   */\n  get contentReady() {\n    return this.contentState === TILE_CONTENT_STATE.READY || this.hasEmptyContent;\n  }\n\n  /**\n   * Determines if the tile has available content to render.  `true` if the tile's\n   * content is ready or if it has expired content this renders while new content loads; otherwise,\n   */\n  get contentAvailable() {\n    return Boolean(\n      (this.contentReady && this.hasRenderContent) || (this._expiredContent && !this.contentFailed)\n    );\n  }\n\n  /** Returns true if tile has renderable content but it's unloaded */\n  get hasUnloadedContent() {\n    return this.hasRenderContent && this.contentUnloaded;\n  }\n\n  /**\n   * Determines if the tile's content has not be requested. `true` if tile's\n   * content has not be requested; otherwise, `false`.\n   */\n  get contentUnloaded() {\n    return this.contentState === TILE_CONTENT_STATE.UNLOADED;\n  }\n\n  /**\n   * Determines if the tile's content is expired. `true` if tile's\n   * content is expired; otherwise, `false`.\n   */\n  get contentExpired() {\n    return this.contentState === TILE_CONTENT_STATE.EXPIRED;\n  }\n\n  // Determines if the tile's content failed to load.  `true` if the tile's\n  // content failed to load; otherwise, `false`.\n  get contentFailed() {\n    return this.contentState === TILE_CONTENT_STATE.FAILED;\n  }\n\n  /** Get the tile's screen space error. */\n  getScreenSpaceError(frameState, useParentLodMetric) {\n    switch (this.tileset.type) {\n      case TILESET_TYPE.I3S:\n        return getI3ScreenSize(this, frameState);\n      case TILESET_TYPE.TILES3D:\n        return getTiles3DScreenSpaceError(this, frameState, useParentLodMetric);\n      default:\n        // eslint-disable-next-line\n        throw new Error('Unsupported tileset type');\n    }\n  }\n\n  /*\n   * If skipLevelOfDetail is off try to load child tiles as soon as possible so that their parent can refine sooner.\n   * Tiles are prioritized by screen space error.\n   */\n  _getPriority() {\n    const traverser = this.tileset._traverser;\n    const {skipLevelOfDetail} = traverser.options;\n\n    /*\n     * Tiles that are outside of the camera's frustum could be skipped if we are in 'ADD' mode\n     * or if we are using 'Skip Traversal' in 'REPLACE' mode.\n     * Otherewise, all 'touched' child tiles have to be loaded and displayed,\n     * this may include tiles that are outide of the camera frustum (so that we can hide the parent tile).\n     */\n    const maySkipTile = this.refine === TILE_REFINEMENT.ADD || skipLevelOfDetail;\n\n    // Check if any reason to abort\n    if (maySkipTile && !this.isVisible && this._visible !== undefined) {\n      return -1;\n    }\n    // Condition used in `cancelOutOfViewRequests` function in CesiumJS/Cesium3DTileset.js\n    if (this.tileset._frameNumber - this._touchedFrame >= 1) {\n      return -1;\n    }\n    if (this.contentState === TILE_CONTENT_STATE.UNLOADED) {\n      return -1;\n    }\n\n    // Based on the priority function `getPriorityReverseScreenSpaceError` in CesiumJS. Scheduling priority is based on the parent's screen space error when possible.\n    const parent = this.parent;\n    const useParentScreenSpaceError =\n      parent && (!maySkipTile || this._screenSpaceError === 0.0 || parent.hasTilesetContent);\n    const screenSpaceError = useParentScreenSpaceError\n      ? parent._screenSpaceError\n      : this._screenSpaceError;\n\n    const rootScreenSpaceError = traverser.root ? traverser.root._screenSpaceError : 0.0;\n\n    // Map higher SSE to lower values (e.g. root tile is highest priority)\n    return Math.max(rootScreenSpaceError - screenSpaceError, 0);\n  }\n\n  /**\n   *  Requests the tile's content.\n   * The request may not be made if the Request Scheduler can't prioritize it.\n   */\n  // eslint-disable-next-line max-statements, complexity\n  async loadContent(): Promise<boolean> {\n    if (this.hasEmptyContent) {\n      return false;\n    }\n\n    if (this.content) {\n      return true;\n    }\n\n    const expired = this.contentExpired;\n\n    if (expired) {\n      this._expireDate = null;\n    }\n\n    this.contentState = TILE_CONTENT_STATE.LOADING;\n\n    const requestToken = await this.tileset._requestScheduler.scheduleRequest(\n      this.id,\n      this._getPriority.bind(this)\n    );\n\n    if (!requestToken) {\n      // cancelled\n      this.contentState = TILE_CONTENT_STATE.UNLOADED;\n      return false;\n    }\n\n    try {\n      const contentUrl = this.tileset.getTileUrl(this.contentUrl);\n      // The content can be a binary tile ot a JSON tileset\n      const loader = this.tileset.loader;\n      const options = {\n        ...this.tileset.loadOptions,\n        [loader.id]: {\n          ...this.tileset.loadOptions[loader.id],\n          isTileset: this.type === 'json',\n          ...this._getLoaderSpecificOptions(loader.id)\n        }\n      };\n\n      this.content = await load(contentUrl, loader, options);\n\n      if (this.tileset.options.contentLoader) {\n        await this.tileset.options.contentLoader(this);\n      }\n\n      if (this._isTileset()) {\n        // Add tile headers for the nested tilset's subtree\n        // Async update of the tree should be fine since there would never be edits to the same node\n        // TODO - we need to capture the child tileset's URL\n        this.tileset._initializeTileHeaders(this.content, this);\n      }\n\n      this.contentState = TILE_CONTENT_STATE.READY;\n      this._onContentLoaded();\n      return true;\n    } catch (error) {\n      // Tile is unloaded before the content finishes loading\n      this.contentState = TILE_CONTENT_STATE.FAILED;\n      throw error;\n    } finally {\n      requestToken.done();\n    }\n  }\n\n  // Unloads the tile's content.\n  unloadContent() {\n    if (this.content && this.content.destroy) {\n      this.content.destroy();\n    }\n    this.content = null;\n    if (this.header.content && this.header.content.destroy) {\n      this.header.content.destroy();\n    }\n    this.header.content = null;\n    this.contentState = TILE_CONTENT_STATE.UNLOADED;\n    return true;\n  }\n\n  /**\n   * Update the tile's visibility\n   * @param {Object} frameState - frame state for tile culling\n   * @param {string[]} viewportIds - a list of viewport ids that show this tile\n   * @return {void}\n   */\n  updateVisibility(frameState, viewportIds) {\n    if (this._frameNumber === frameState.frameNumber) {\n      // Return early if visibility has already been checked during the traversal.\n      // The visibility may have already been checked if the cullWithChildrenBounds optimization is used.\n      return;\n    }\n\n    const parent = this.parent;\n    const parentVisibilityPlaneMask = parent\n      ? parent._visibilityPlaneMask\n      : CullingVolume.MASK_INDETERMINATE;\n\n    if (this.tileset._traverser.options.updateTransforms) {\n      const parentTransform = parent ? parent.computedTransform : this.tileset.modelMatrix;\n      this._updateTransform(parentTransform);\n    }\n\n    this._distanceToCamera = this.distanceToTile(frameState);\n    this._screenSpaceError = this.getScreenSpaceError(frameState, false);\n    this._visibilityPlaneMask = this.visibility(frameState, parentVisibilityPlaneMask); // Use parent's plane mask to speed up visibility test\n    this._visible = this._visibilityPlaneMask !== CullingVolume.MASK_OUTSIDE;\n    this._inRequestVolume = this.insideViewerRequestVolume(frameState);\n\n    this._frameNumber = frameState.frameNumber;\n    this.viewportIds = viewportIds;\n  }\n\n  // Determines whether the tile's bounding volume intersects the culling volume.\n  // @param {FrameState} frameState The frame state.\n  // @param {Number} parentVisibilityPlaneMask The parent's plane mask to speed up the visibility check.\n  // @returns {Number} A plane mask as described above in {@link CullingVolume#computeVisibilityWithPlaneMask}.\n  visibility(frameState, parentVisibilityPlaneMask) {\n    const {cullingVolume} = frameState;\n    const {boundingVolume} = this;\n\n    // TODO Cesium specific - restore clippingPlanes\n    // const {clippingPlanes, clippingPlanesOriginMatrix} = tileset;\n    // if (clippingPlanes && clippingPlanes.enabled) {\n    //   const intersection = clippingPlanes.computeIntersectionWithBoundingVolume(\n    //     boundingVolume,\n    //     clippingPlanesOriginMatrix\n    //   );\n    //   this._isClipped = intersection !== Intersect.INSIDE;\n    //   if (intersection === Intersect.OUTSIDE) {\n    //     return CullingVolume.MASK_OUTSIDE;\n    //   }\n    // }\n\n    // return cullingVolume.computeVisibilityWithPlaneMask(boundingVolume, parentVisibilityPlaneMask);\n    return cullingVolume.computeVisibilityWithPlaneMask(boundingVolume, parentVisibilityPlaneMask);\n  }\n\n  // Assuming the tile's bounding volume intersects the culling volume, determines\n  // whether the tile's content's bounding volume intersects the culling volume.\n  // @param {FrameState} frameState The frame state.\n  // @returns {Intersect} The result of the intersection: the tile's content is completely outside, completely inside, or intersecting the culling volume.\n  contentVisibility() {\n    return true;\n\n    // TODO restore\n    /*\n    // Assumes the tile's bounding volume intersects the culling volume already, so\n    // just return Intersect.INSIDE if there is no content bounding volume.\n    if (!defined(this.contentBoundingVolume)) {\n      return Intersect.INSIDE;\n    }\n\n    if (this._visibilityPlaneMask === CullingVolume.MASK_INSIDE) {\n      // The tile's bounding volume is completely inside the culling volume so\n      // the content bounding volume must also be inside.\n      return Intersect.INSIDE;\n    }\n\n    // PERFORMANCE_IDEA: is it possible to burn less CPU on this test since we know the\n    // tile's (not the content's) bounding volume intersects the culling volume?\n    const cullingVolume = frameState.cullingVolume;\n    const boundingVolume = tile.contentBoundingVolume;\n\n    const tileset = this.tileset;\n    const clippingPlanes = tileset.clippingPlanes;\n    if (defined(clippingPlanes) && clippingPlanes.enabled) {\n      const intersection = clippingPlanes.computeIntersectionWithBoundingVolume(\n        boundingVolume,\n        tileset.clippingPlanesOriginMatrix\n      );\n      this._isClipped = intersection !== Intersect.INSIDE;\n      if (intersection === Intersect.OUTSIDE) {\n        return Intersect.OUTSIDE;\n      }\n    }\n\n    return cullingVolume.computeVisibility(boundingVolume);\n    */\n  }\n\n  /**\n   * Computes the (potentially approximate) distance from the closest point of the tile's bounding volume to the camera.\n   * @param frameState The frame state.\n   * @returns {Number} The distance, in meters, or zero if the camera is inside the bounding volume.\n   */\n  distanceToTile(frameState: FrameState): number {\n    const boundingVolume = this.boundingVolume;\n    return Math.sqrt(Math.max(boundingVolume.distanceSquaredTo(frameState.camera.position), 0));\n  }\n\n  /**\n   * Computes the tile's camera-space z-depth.\n   * @param frameState The frame state.\n   * @returns The distance, in meters.\n   */\n  cameraSpaceZDepth({camera}): number {\n    const boundingVolume = this.boundingVolume; // Gets the underlying OrientedBoundingBox or BoundingSphere\n    scratchVector.subVectors(boundingVolume.center, camera.position);\n    return camera.direction.dot(scratchVector);\n  }\n\n  /**\n   * Checks if the camera is inside the viewer request volume.\n   * @param {FrameState} frameState The frame state.\n   * @returns {Boolean} Whether the camera is inside the volume.\n   */\n  insideViewerRequestVolume(frameState: FrameState) {\n    const viewerRequestVolume = this._viewerRequestVolume;\n    return (\n      !viewerRequestVolume || viewerRequestVolume.distanceSquaredTo(frameState.camera.position) <= 0\n    );\n  }\n\n  // TODO Cesium specific\n\n  // Update whether the tile has expired.\n  updateExpiration() {\n    if (defined(this._expireDate) && this.contentReady && !this.hasEmptyContent) {\n      const now = Date.now();\n      // @ts-ignore Date.lessThan - replace with ms compare?\n      if (Date.lessThan(this._expireDate, now)) {\n        this.contentState = TILE_CONTENT_STATE.EXPIRED;\n        this._expiredContent = this.content;\n      }\n    }\n  }\n\n  get extras() {\n    return this.header.extras;\n  }\n\n  // INTERNAL METHODS\n\n  _initializeLodMetric(header) {\n    if ('lodMetricType' in header) {\n      this.lodMetricType = header.lodMetricType;\n    } else {\n      this.lodMetricType = (this.parent && this.parent.lodMetricType) || this.tileset.lodMetricType;\n      // eslint-disable-next-line\n      console.warn(`3D Tile: Required prop lodMetricType is undefined. Using parent lodMetricType`);\n    }\n\n    // This is used to compute screen space error, i.e., the error measured in pixels.\n    if ('lodMetricValue' in header) {\n      this.lodMetricValue = header.lodMetricValue;\n    } else {\n      this.lodMetricValue =\n        (this.parent && this.parent.lodMetricValue) || this.tileset.lodMetricValue;\n      // eslint-disable-next-line\n      console.warn(\n        '3D Tile: Required prop lodMetricValue is undefined. Using parent lodMetricValue'\n      );\n    }\n  }\n\n  _initializeTransforms(tileHeader) {\n    // The local transform of this tile.\n    this.transform = tileHeader.transform ? new Matrix4(tileHeader.transform) : new Matrix4();\n\n    const parent = this.parent;\n    const tileset = this.tileset;\n\n    const parentTransform =\n      parent && parent.computedTransform\n        ? parent.computedTransform.clone()\n        : tileset.modelMatrix.clone();\n    this.computedTransform = new Matrix4(parentTransform).multiplyRight(this.transform);\n\n    const parentInitialTransform =\n      parent && parent._initialTransform ? parent._initialTransform.clone() : new Matrix4();\n    this._initialTransform = new Matrix4(parentInitialTransform).multiplyRight(this.transform);\n  }\n\n  _initializeBoundingVolumes(tileHeader) {\n    this._contentBoundingVolume = null;\n    this._viewerRequestVolume = null;\n\n    this._updateBoundingVolume(tileHeader);\n  }\n\n  _initializeContent(tileHeader) {\n    // Empty tile by default\n    this.content = {_tileset: this.tileset, _tile: this};\n    this.hasEmptyContent = true;\n    this.contentState = TILE_CONTENT_STATE.UNLOADED;\n\n    // When `true`, the tile's content points to an external tileset.\n    // This is `false` until the tile's content is loaded.\n    this.hasTilesetContent = false;\n\n    if (tileHeader.contentUrl) {\n      this.content = null;\n      this.hasEmptyContent = false;\n    }\n  }\n\n  // TODO - remove anything not related to basic visibility detection\n  _initializeRenderingState(header) {\n    this.depth = header.level || (this.parent ? this.parent.depth + 1 : 0);\n    this._shouldRefine = false;\n\n    // Members this are updated every frame for tree traversal and rendering optimizations:\n    this._distanceToCamera = 0;\n    this._centerZDepth = 0;\n    this._screenSpaceError = 0;\n    this._visibilityPlaneMask = CullingVolume.MASK_INDETERMINATE;\n    this._visible = undefined;\n    this._inRequestVolume = false;\n\n    this._stackLength = 0;\n    this._selectionDepth = 0;\n\n    this._frameNumber = 0;\n    this._touchedFrame = 0;\n    this._visitedFrame = 0;\n    this._selectedFrame = 0;\n    this._requestedFrame = 0;\n\n    this._priority = 0.0;\n  }\n\n  _getRefine(refine) {\n    // Inherit from parent tile if omitted.\n    return refine || (this.parent && this.parent.refine) || TILE_REFINEMENT.REPLACE;\n  }\n\n  _isTileset() {\n    return this.contentUrl.indexOf('.json') !== -1;\n  }\n\n  _onContentLoaded() {\n    // Vector and Geometry tile rendering do not support the skip LOD optimization.\n    switch (this.content && this.content.type) {\n      case 'vctr':\n      case 'geom':\n        // @ts-ignore\n        this.tileset._traverser.disableSkipLevelOfDetail = true;\n        break;\n      default:\n    }\n\n    // The content may be tileset json\n    if (this._isTileset()) {\n      this.hasTilesetContent = true;\n    }\n  }\n\n  _updateBoundingVolume(header) {\n    // Update the bounding volumes\n    this.boundingVolume = createBoundingVolume(\n      header.boundingVolume,\n      this.computedTransform,\n      this.boundingVolume\n    );\n\n    const content = header.content;\n    if (!content) {\n      return;\n    }\n\n    // TODO Cesium specific\n    // Non-leaf tiles may have a content bounding-volume, which is a tight-fit bounding volume\n    // around only the features in the tile. This box is useful for culling for rendering,\n    // but not for culling for traversing the tree since it does not guarantee spatial coherence, i.e.,\n    // since it only bounds features in the tile, not the entire tile, children may be\n    // outside of this box.\n    if (content.boundingVolume) {\n      this._contentBoundingVolume = createBoundingVolume(\n        content.boundingVolume,\n        this.computedTransform,\n        this._contentBoundingVolume\n      );\n    }\n    if (header.viewerRequestVolume) {\n      this._viewerRequestVolume = createBoundingVolume(\n        header.viewerRequestVolume,\n        this.computedTransform,\n        this._viewerRequestVolume\n      );\n    }\n  }\n\n  // Update the tile's transform. The transform is applied to the tile's bounding volumes.\n  _updateTransform(parentTransform = new Matrix4()) {\n    const computedTransform = parentTransform.clone().multiplyRight(this.transform);\n    const didTransformChange = !computedTransform.equals(this.computedTransform);\n\n    if (!didTransformChange) {\n      return;\n    }\n\n    this.computedTransform = computedTransform;\n\n    this._updateBoundingVolume(this.header);\n  }\n\n  // Get options which are applicable only for the particular loader\n  _getLoaderSpecificOptions(loaderId) {\n    switch (loaderId) {\n      case 'i3s':\n        return {\n          ...this.tileset.options.i3s,\n          tile: this.header,\n          tileset: this.tileset.tileset,\n          isTileHeader: false\n        };\n      case '3d-tiles':\n      case 'cesium-ion':\n      default:\n        return get3dTilesOptions(this.tileset.tileset);\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}