{"ast":null,"code":"import { concatenateArrayBuffersAsync } from '@loaders.gl/loader-utils';\nimport { isResponse, isReadableStream, isAsyncIterable, isIterable, isIterator, isBlob, isBuffer } from '../../javascript-utils/is-type';\nimport { makeIterator } from '../../iterators/make-iterator/make-iterator';\nimport { checkResponse, makeResponse } from '../utils/response-utils';\nconst ERR_DATA = 'Cannot convert supplied data type';\nexport function getArrayBufferOrStringFromDataSync(data, loader, options) {\n  if (loader.text && typeof data === 'string') {\n    return data;\n  }\n\n  if (isBuffer(data)) {\n    data = data.buffer;\n  }\n\n  if (data instanceof ArrayBuffer) {\n    const arrayBuffer = data;\n\n    if (loader.text && !loader.binary) {\n      const textDecoder = new TextDecoder('utf8');\n      return textDecoder.decode(arrayBuffer);\n    }\n\n    return arrayBuffer;\n  }\n\n  if (ArrayBuffer.isView(data)) {\n    if (loader.text && !loader.binary) {\n      const textDecoder = new TextDecoder('utf8');\n      return textDecoder.decode(data);\n    }\n\n    let arrayBuffer = data.buffer;\n    const byteLength = data.byteLength || data.length;\n\n    if (data.byteOffset !== 0 || byteLength !== arrayBuffer.byteLength) {\n      arrayBuffer = arrayBuffer.slice(data.byteOffset, data.byteOffset + byteLength);\n    }\n\n    return arrayBuffer;\n  }\n\n  throw new Error(ERR_DATA);\n}\nexport async function getArrayBufferOrStringFromData(data, loader, options) {\n  const isArrayBuffer = data instanceof ArrayBuffer || ArrayBuffer.isView(data);\n\n  if (typeof data === 'string' || isArrayBuffer) {\n    return getArrayBufferOrStringFromDataSync(data, loader, options);\n  }\n\n  if (isBlob(data)) {\n    data = await makeResponse(data);\n  }\n\n  if (isResponse(data)) {\n    const response = data;\n    await checkResponse(response);\n    return loader.binary ? await response.arrayBuffer() : await response.text();\n  }\n\n  if (isReadableStream(data)) {\n    data = makeIterator(data, options);\n  }\n\n  if (isIterable(data) || isAsyncIterable(data)) {\n    return concatenateArrayBuffersAsync(data);\n  }\n\n  throw new Error(ERR_DATA);\n}\nexport async function getAsyncIterableFromData(data, options) {\n  if (isIterator(data)) {\n    return data;\n  }\n\n  if (isResponse(data)) {\n    const response = data;\n    await checkResponse(response);\n    const body = await response.body;\n    return makeIterator(body, options);\n  }\n\n  if (isBlob(data) || isReadableStream(data)) {\n    return makeIterator(data, options);\n  }\n\n  if (isAsyncIterable(data)) {\n    return data[Symbol.asyncIterator]();\n  }\n\n  return getIterableFromData(data);\n}\nexport async function getReadableStream(data) {\n  if (isReadableStream(data)) {\n    return data;\n  }\n\n  if (isResponse(data)) {\n    return data.body;\n  }\n\n  const response = await makeResponse(data);\n  return response.body;\n}\n\nfunction getIterableFromData(data) {\n  if (ArrayBuffer.isView(data)) {\n    return function* oneChunk() {\n      yield data.buffer;\n    }();\n  }\n\n  if (data instanceof ArrayBuffer) {\n    return function* oneChunk() {\n      yield data;\n    }();\n  }\n\n  if (isIterator(data)) {\n    return data;\n  }\n\n  if (isIterable(data)) {\n    return data[Symbol.iterator]();\n  }\n\n  throw new Error(ERR_DATA);\n}","map":{"version":3,"sources":["../../../../src/lib/loader-utils/get-data.ts"],"names":["ERR_DATA","loader","isBuffer","data","arrayBuffer","textDecoder","ArrayBuffer","byteLength","isArrayBuffer","getArrayBufferOrStringFromDataSync","isBlob","makeResponse","isResponse","response","checkResponse","isReadableStream","makeIterator","isIterable","isAsyncIterable","concatenateArrayBuffersAsync","isIterator","body","Symbol","getIterableFromData"],"mappings":"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","sourcesContent":["import type {\n  DataType,\n  SyncDataType,\n  BatchableDataType,\n  Loader,\n  LoaderOptions\n} from '@loaders.gl/loader-utils';\nimport {concatenateArrayBuffersAsync} from '@loaders.gl/loader-utils';\nimport {\n  isResponse,\n  isReadableStream,\n  isAsyncIterable,\n  isIterable,\n  isIterator,\n  isBlob,\n  isBuffer\n} from '../../javascript-utils/is-type';\nimport {makeIterator} from '../../iterators/make-iterator/make-iterator';\nimport {checkResponse, makeResponse} from '../utils/response-utils';\n\nconst ERR_DATA = 'Cannot convert supplied data type';\n\n// eslint-disable-next-line complexity\nexport function getArrayBufferOrStringFromDataSync(\n  data: SyncDataType,\n  loader: Loader,\n  options: LoaderOptions\n): ArrayBuffer | string {\n  if (loader.text && typeof data === 'string') {\n    return data;\n  }\n\n  if (isBuffer(data)) {\n    // @ts-ignore\n    data = data.buffer;\n  }\n\n  if (data instanceof ArrayBuffer) {\n    const arrayBuffer = data;\n    if (loader.text && !loader.binary) {\n      const textDecoder = new TextDecoder('utf8');\n      return textDecoder.decode(arrayBuffer);\n    }\n    return arrayBuffer;\n  }\n\n  // We may need to handle offsets\n  if (ArrayBuffer.isView(data)) {\n    // TextDecoder is invoked on typed arrays and will handle offsets\n    if (loader.text && !loader.binary) {\n      const textDecoder = new TextDecoder('utf8');\n      return textDecoder.decode(data);\n    }\n\n    let arrayBuffer = data.buffer;\n\n    // Since we are returning the underlying arrayBuffer, we must create a new copy\n    // if this typed array / Buffer is a partial view into the ArryayBuffer\n    // TODO - this is a potentially unnecessary copy\n    const byteLength = data.byteLength || data.length;\n    if (data.byteOffset !== 0 || byteLength !== arrayBuffer.byteLength) {\n      // console.warn(`loaders.gl copying arraybuffer of length ${byteLength}`);\n      arrayBuffer = arrayBuffer.slice(data.byteOffset, data.byteOffset + byteLength);\n    }\n    return arrayBuffer;\n  }\n\n  throw new Error(ERR_DATA);\n}\n\n// Convert async iterator to a promise\nexport async function getArrayBufferOrStringFromData(\n  data: DataType,\n  loader: Loader,\n  options: LoaderOptions\n): Promise<ArrayBuffer | string> {\n  const isArrayBuffer = data instanceof ArrayBuffer || ArrayBuffer.isView(data);\n  if (typeof data === 'string' || isArrayBuffer) {\n    return getArrayBufferOrStringFromDataSync(data as string | ArrayBuffer, loader, options);\n  }\n\n  // Blobs and files are FileReader compatible\n  if (isBlob(data)) {\n    data = await makeResponse(data);\n  }\n\n  if (isResponse(data)) {\n    const response = data as Response;\n    await checkResponse(response);\n    return loader.binary ? await response.arrayBuffer() : await response.text();\n  }\n\n  if (isReadableStream(data)) {\n    // @ts-expect-error TS2559 options type\n    data = makeIterator(data as ReadableStream, options);\n  }\n\n  if (isIterable(data) || isAsyncIterable(data)) {\n    // Assume arrayBuffer iterator - attempt to concatenate\n    return concatenateArrayBuffersAsync(data as AsyncIterable<ArrayBuffer>);\n  }\n\n  throw new Error(ERR_DATA);\n}\n\nexport async function getAsyncIterableFromData(\n  data: BatchableDataType,\n  options: LoaderOptions\n): Promise<AsyncIterable<ArrayBuffer> | Iterable<ArrayBuffer>> {\n  if (isIterator(data)) {\n    return data as AsyncIterable<ArrayBuffer>;\n  }\n\n  if (isResponse(data)) {\n    const response = data as Response;\n    // Note Since this function is not async, we currently can't load error message, just status\n    await checkResponse(response);\n    // TODO - bug in polyfill, body can be a Promise under Node.js\n    // eslint-disable-next-line @typescript-eslint/await-thenable\n    const body = await response.body;\n    // TODO - body can be null?\n    return makeIterator(body as ReadableStream<Uint8Array>, options as any);\n  }\n\n  if (isBlob(data) || isReadableStream(data)) {\n    return makeIterator(data as Blob | ReadableStream, options as any);\n  }\n\n  if (isAsyncIterable(data)) {\n    return data[Symbol.asyncIterator]();\n  }\n\n  return getIterableFromData(data);\n}\n\nexport async function getReadableStream(data: BatchableDataType): Promise<ReadableStream> {\n  if (isReadableStream(data)) {\n    return data as ReadableStream;\n  }\n  if (isResponse(data)) {\n    // @ts-ignore\n    return data.body;\n  }\n  const response = await makeResponse(data);\n  // @ts-ignore\n  return response.body;\n}\n\n// HELPERS\n\nfunction getIterableFromData(data) {\n  // generate an iterator that emits a single chunk\n  if (ArrayBuffer.isView(data)) {\n    return (function* oneChunk() {\n      yield data.buffer;\n    })();\n  }\n\n  if (data instanceof ArrayBuffer) {\n    return (function* oneChunk() {\n      yield data;\n    })();\n  }\n\n  if (isIterator(data)) {\n    return data;\n  }\n\n  if (isIterable(data)) {\n    return data[Symbol.iterator]();\n  }\n\n  throw new Error(ERR_DATA);\n}\n"]},"metadata":{},"sourceType":"module"}