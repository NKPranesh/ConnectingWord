{"ast":null,"code":"import UserTable from \"../data/usersTable.json\";\nlet nodes = [\"pranesh@gmail.com\", \"vamshi@gmail.com\", \"mahesh@gmail.com\", \"virat@gmail.com\", \"rohit@gmail.com\", \"tarak@gmail.com\", \"charan@gmail.com\"];\nlet graph = [[3, 5, 1], [0], [3, 6], [2, 4, 0], [3], [6, 0], [5, 2]];\n\nfunction printAllPaths(s, d) {\n  let isVisited = new Array(v);\n\n  for (let i = 0; i < v; i++) isVisited[i] = false;\n\n  let pathList = []; // add source to path[]\n\n  pathList.push(node[s]);\n  let pathLists = []; // Call recursive utility\n\n  pathLists.push(printAllPathsUtil(s, d, isVisited, pathList));\n  return pathLists;\n}\n\nfunction printAllPathsUtil(u, d, isVisited, localPathList) {\n  if (u == d) {\n    //document.write(localPathList+\"<br>\");\n    // if match found then no need to\n    // traverse more till depth\n    return localPathList;\n  } // Mark the current node\n\n\n  isVisited[u] = true; // Recur for all the vertices\n  // adjacent to current vertex\n\n  for (let i = 0; i < adjList[u].length; i++) {\n    if (!isVisited[adjList[u][i]]) {\n      // store current node\n      // in path[]\n      localPathList.push(node[adjList[u][i]]);\n      printAllPathsUtil(adjList[u][i], d, isVisited, localPathList); // remove current node\n      // in path[]\n\n      localPathList.splice(localPathList.indexOf(node[adjList[u][i]]), 1);\n    }\n  }\n\n  isVisited[u] = false;\n}\n\nconst GITlist = (source, destination) => {\n  return printAllPaths(nodes.indexOf(source), nodes.indexOf(destination));\n};\n\n_c = GITlist;\nexport default GITlist;\n\nvar _c;\n\n$RefreshReg$(_c, \"GITlist\");","map":{"version":3,"sources":["P:/projects/ConnectingWord/front-end/src/calc/GITfunc.js"],"names":["UserTable","nodes","graph","printAllPaths","s","d","isVisited","Array","v","i","pathList","push","node","pathLists","printAllPathsUtil","u","localPathList","adjList","length","splice","indexOf","GITlist","source","destination"],"mappings":"AAAA,OAASA,SAAT,MAAyB,yBAAzB;AACA,IAAIC,KAAK,GAAC,CAAC,mBAAD,EAAqB,kBAArB,EAAwC,kBAAxC,EAA2D,iBAA3D,EAA6E,iBAA7E,EAA+F,iBAA/F,EAAiH,kBAAjH,CAAV;AACA,IAAIC,KAAK,GAAC,CACN,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,CADM,EAEN,CAAC,CAAD,CAFM,EAGN,CAAC,CAAD,EAAG,CAAH,CAHM,EAIN,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,CAJM,EAKN,CAAC,CAAD,CALM,EAMN,CAAC,CAAD,EAAG,CAAH,CANM,EAON,CAAC,CAAD,EAAG,CAAH,CAPM,CAAV;;AAUA,SAASC,aAAT,CAAuBC,CAAvB,EAAyBC,CAAzB,EACA;AAEK,MAAIC,SAAS,GAAG,IAAIC,KAAJ,CAAUC,CAAV,CAAhB;;AACA,OAAI,IAAIC,CAAC,GAAC,CAAV,EAAYA,CAAC,GAACD,CAAd,EAAgBC,CAAC,EAAjB,EACIH,SAAS,CAACG,CAAD,CAAT,GAAa,KAAb;;AACD,MAAIC,QAAQ,GAAG,EAAf,CALR,CAOQ;;AACAA,EAAAA,QAAQ,CAACC,IAAT,CAAcC,IAAI,CAACR,CAAD,CAAlB;AACA,MAAIS,SAAS,GAAC,EAAd,CATR,CAUQ;;AACAA,EAAAA,SAAS,CAACF,IAAV,CAAeG,iBAAiB,CAACV,CAAD,EAAIC,CAAJ,EAAOC,SAAP,EAAkBI,QAAlB,CAAhC;AACA,SAAOG,SAAP;AACP;;AAGD,SAASC,iBAAT,CAA2BC,CAA3B,EAA6BV,CAA7B,EAA+BC,SAA/B,EAAyCU,aAAzC,EACA;AACI,MAAID,CAAC,IAAKV,CAAV,EAAc;AACN;AACA;AACA;AACA,WAAOW,aAAP;AACH,GANT,CAQQ;;;AACAV,EAAAA,SAAS,CAACS,CAAD,CAAT,GAAe,IAAf,CATR,CAWQ;AACA;;AACA,OAAK,IAAIN,CAAC,GAAC,CAAX,EAAaA,CAAC,GAAEQ,OAAO,CAACF,CAAD,CAAP,CAAWG,MAA3B,EAAkCT,CAAC,EAAnC,EAAuC;AACnC,QAAI,CAACH,SAAS,CAACW,OAAO,CAACF,CAAD,CAAP,CAAWN,CAAX,CAAD,CAAd,EAA+B;AAC3B;AACA;AACAO,MAAAA,aAAa,CAACL,IAAd,CAAmBC,IAAI,CAACK,OAAO,CAACF,CAAD,CAAP,CAAWN,CAAX,CAAD,CAAvB;AACAK,MAAAA,iBAAiB,CAACG,OAAO,CAACF,CAAD,CAAP,CAAWN,CAAX,CAAD,EAAgBJ,CAAhB,EACjBC,SADiB,EACNU,aADM,CAAjB,CAJ2B,CAO3B;AACA;;AACAA,MAAAA,aAAa,CAACG,MAAd,CAAqBH,aAAa,CAACI,OAAd,CACpBR,IAAI,CAACK,OAAO,CAACF,CAAD,CAAP,CAAWN,CAAX,CAAD,CADgB,CAArB,EACsB,CADtB;AAEH;AACJ;;AACDH,EAAAA,SAAS,CAACS,CAAD,CAAT,GAAe,KAAf;AACP;;AAED,MAAMM,OAAO,GAAG,CAACC,MAAD,EAAQC,WAAR,KAAwB;AACpC,SACIpB,aAAa,CAACF,KAAK,CAACmB,OAAN,CAAcE,MAAd,CAAD,EAAuBrB,KAAK,CAACmB,OAAN,CAAcG,WAAd,CAAvB,CADjB;AAGH,CAJD;;KAAMF,O;AAMN,eAAeA,OAAf","sourcesContent":["import   UserTable from  \"../data/usersTable.json\";\r\nlet nodes=[\"pranesh@gmail.com\",\"vamshi@gmail.com\",\"mahesh@gmail.com\",\"virat@gmail.com\",\"rohit@gmail.com\",\"tarak@gmail.com\",\"charan@gmail.com\"];\r\nlet graph=[\r\n    [3,5,1],\r\n    [0],\r\n    [3,6],\r\n    [2,4,0],\r\n    [3],\r\n    [6,0],\r\n    [5,2]\r\n];\r\n\r\nfunction printAllPaths(s,d)\r\n{\r\n\r\n     let isVisited = new Array(v);\r\n     for(let i=0;i<v;i++)\r\n         isVisited[i]=false;\r\n        let pathList = [];\r\n  \r\n        // add source to path[]\r\n        pathList.push(node[s]);\r\n        let pathLists=[]\r\n        // Call recursive utility\r\n        pathLists.push(printAllPathsUtil(s, d, isVisited, pathList));\r\n        return pathLists;\r\n}\r\n \r\n\r\nfunction printAllPathsUtil(u,d,isVisited,localPathList)\r\n{\r\n    if (u == (d)) {\r\n            //document.write(localPathList+\"<br>\");\r\n            // if match found then no need to\r\n            // traverse more till depth\r\n            return localPathList;\r\n        }\r\n  \r\n        // Mark the current node\r\n        isVisited[u] = true;\r\n  \r\n        // Recur for all the vertices\r\n        // adjacent to current vertex\r\n        for (let i=0;i< adjList[u].length;i++) {\r\n            if (!isVisited[adjList[u][i]]) {\r\n                // store current node\r\n                // in path[]\r\n                localPathList.push(node[adjList[u][i]]);\r\n                printAllPathsUtil(adjList[u][i], d,\r\n                isVisited, localPathList);\r\n  \r\n                // remove current node\r\n                // in path[]\r\n                localPathList.splice(localPathList.indexOf\r\n                (node[adjList[u][i]]),1);\r\n            }\r\n        }\r\n        isVisited[u] = false;\r\n}\r\n\r\nconst GITlist = (source,destination) => {\r\n    return (  \r\n        printAllPaths(nodes.indexOf(source),nodes.indexOf(destination))\r\n    );\r\n}\r\n \r\nexport default GITlist;"]},"metadata":{},"sourceType":"module"}