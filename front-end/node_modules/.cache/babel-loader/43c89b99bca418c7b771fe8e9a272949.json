{"ast":null,"code":"import Geometry from '../geometry/geometry';\nimport { uid } from '@luma.gl/webgl';\nexport default class SphereGeometry extends Geometry {\n  constructor() {\n    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const {\n      id = uid('sphere-geometry')\n    } = props;\n    const {\n      indices,\n      attributes\n    } = tesselateSphere(props);\n    super({ ...props,\n      id,\n      indices,\n      attributes: { ...attributes,\n        ...props.attributes\n      }\n    });\n  }\n\n}\n\nfunction tesselateSphere(props) {\n  const {\n    nlat = 10,\n    nlong = 10\n  } = props;\n  let {\n    radius = 1\n  } = props;\n  const startLat = 0;\n  const endLat = Math.PI;\n  const latRange = endLat - startLat;\n  const startLong = 0;\n  const endLong = 2 * Math.PI;\n  const longRange = endLong - startLong;\n  const numVertices = (nlat + 1) * (nlong + 1);\n\n  if (typeof radius === 'number') {\n    const value = radius;\n\n    radius = (n1, n2, n3, u, v) => value;\n  }\n\n  const positions = new Float32Array(numVertices * 3);\n  const normals = new Float32Array(numVertices * 3);\n  const texCoords = new Float32Array(numVertices * 2);\n  const IndexType = numVertices > 0xffff ? Uint32Array : Uint16Array;\n  const indices = new IndexType(nlat * nlong * 6);\n\n  for (let y = 0; y <= nlat; y++) {\n    for (let x = 0; x <= nlong; x++) {\n      const u = x / nlong;\n      const v = y / nlat;\n      const index = x + y * (nlong + 1);\n      const i2 = index * 2;\n      const i3 = index * 3;\n      const theta = longRange * u;\n      const phi = latRange * v;\n      const sinTheta = Math.sin(theta);\n      const cosTheta = Math.cos(theta);\n      const sinPhi = Math.sin(phi);\n      const cosPhi = Math.cos(phi);\n      const ux = cosTheta * sinPhi;\n      const uy = cosPhi;\n      const uz = sinTheta * sinPhi;\n      const r = radius(ux, uy, uz, u, v);\n      positions[i3 + 0] = r * ux;\n      positions[i3 + 1] = r * uy;\n      positions[i3 + 2] = r * uz;\n      normals[i3 + 0] = ux;\n      normals[i3 + 1] = uy;\n      normals[i3 + 2] = uz;\n      texCoords[i2 + 0] = u;\n      texCoords[i2 + 1] = 1 - v;\n    }\n  }\n\n  const numVertsAround = nlong + 1;\n\n  for (let x = 0; x < nlong; x++) {\n    for (let y = 0; y < nlat; y++) {\n      const index = (x * nlat + y) * 6;\n      indices[index + 0] = y * numVertsAround + x;\n      indices[index + 1] = y * numVertsAround + x + 1;\n      indices[index + 2] = (y + 1) * numVertsAround + x;\n      indices[index + 3] = (y + 1) * numVertsAround + x;\n      indices[index + 4] = y * numVertsAround + x + 1;\n      indices[index + 5] = (y + 1) * numVertsAround + x + 1;\n    }\n  }\n\n  return {\n    indices: {\n      size: 1,\n      value: indices\n    },\n    attributes: {\n      POSITION: {\n        size: 3,\n        value: positions\n      },\n      NORMAL: {\n        size: 3,\n        value: normals\n      },\n      TEXCOORD_0: {\n        size: 2,\n        value: texCoords\n      }\n    }\n  };\n}","map":{"version":3,"sources":["../../../src/geometries/sphere-geometry.js"],"names":["constructor","props","id","uid","attributes","tesselateSphere","nlat","nlong","radius","startLat","endLat","Math","latRange","startLong","endLong","longRange","numVertices","value","positions","normals","texCoords","IndexType","indices","y","x","u","v","index","i2","i3","theta","phi","sinTheta","cosTheta","sinPhi","cosPhi","ux","uy","uz","r","numVertsAround","size","POSITION","NORMAL","TEXCOORD_0"],"mappings":"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","sourcesContent":["import Geometry from '../geometry/geometry';\nimport {uid} from '@luma.gl/webgl';\n\nexport default class SphereGeometry extends Geometry {\n  constructor(props = {}) {\n    const {id = uid('sphere-geometry')} = props;\n    const {indices, attributes} = tesselateSphere(props);\n    super({\n      ...props,\n      id,\n      indices,\n      attributes: {...attributes, ...props.attributes}\n    });\n  }\n}\n\n// Primitives inspired by TDL http://code.google.com/p/webglsamples/,\n// copyright 2011 Google Inc. new BSD License\n// (http://www.opensource.org/licenses/bsd-license.php).\n/* eslint-disable max-statements, complexity */\nfunction tesselateSphere(props) {\n  const {nlat = 10, nlong = 10} = props;\n  let {radius = 1} = props;\n\n  const startLat = 0;\n  const endLat = Math.PI;\n  const latRange = endLat - startLat;\n  const startLong = 0;\n  const endLong = 2 * Math.PI;\n  const longRange = endLong - startLong;\n  const numVertices = (nlat + 1) * (nlong + 1);\n\n  if (typeof radius === 'number') {\n    const value = radius;\n    radius = (n1, n2, n3, u, v) => value;\n  }\n\n  const positions = new Float32Array(numVertices * 3);\n  const normals = new Float32Array(numVertices * 3);\n  const texCoords = new Float32Array(numVertices * 2);\n\n  const IndexType = numVertices > 0xffff ? Uint32Array : Uint16Array;\n  const indices = new IndexType(nlat * nlong * 6);\n\n  // Create positions, normals and texCoords\n  for (let y = 0; y <= nlat; y++) {\n    for (let x = 0; x <= nlong; x++) {\n      const u = x / nlong;\n      const v = y / nlat;\n\n      const index = x + y * (nlong + 1);\n      const i2 = index * 2;\n      const i3 = index * 3;\n\n      const theta = longRange * u;\n      const phi = latRange * v;\n      const sinTheta = Math.sin(theta);\n      const cosTheta = Math.cos(theta);\n      const sinPhi = Math.sin(phi);\n      const cosPhi = Math.cos(phi);\n      const ux = cosTheta * sinPhi;\n      const uy = cosPhi;\n      const uz = sinTheta * sinPhi;\n\n      const r = radius(ux, uy, uz, u, v);\n\n      positions[i3 + 0] = r * ux;\n      positions[i3 + 1] = r * uy;\n      positions[i3 + 2] = r * uz;\n\n      normals[i3 + 0] = ux;\n      normals[i3 + 1] = uy;\n      normals[i3 + 2] = uz;\n\n      texCoords[i2 + 0] = u;\n      texCoords[i2 + 1] = 1 - v;\n    }\n  }\n\n  // Create indices\n  const numVertsAround = nlong + 1;\n  for (let x = 0; x < nlong; x++) {\n    for (let y = 0; y < nlat; y++) {\n      const index = (x * nlat + y) * 6;\n\n      indices[index + 0] = y * numVertsAround + x;\n      indices[index + 1] = y * numVertsAround + x + 1;\n      indices[index + 2] = (y + 1) * numVertsAround + x;\n\n      indices[index + 3] = (y + 1) * numVertsAround + x;\n      indices[index + 4] = y * numVertsAround + x + 1;\n      indices[index + 5] = (y + 1) * numVertsAround + x + 1;\n    }\n  }\n\n  return {\n    indices: {size: 1, value: indices},\n    attributes: {\n      POSITION: {size: 3, value: positions},\n      NORMAL: {size: 3, value: normals},\n      TEXCOORD_0: {size: 2, value: texCoords}\n    }\n  };\n}\n"]},"metadata":{},"sourceType":"module"}