{"ast":null,"code":"import { ImageLoader } from '@loaders.gl/images';\nimport { parseJSON, sliceArrayBuffer } from '@loaders.gl/loader-utils';\nimport { assert } from '../utils/assert';\nimport { resolveUrl } from '../gltf-utils/resolve-url';\nimport { getTypedArrayForBufferView } from '../gltf-utils/get-typed-array';\nimport { decodeExtensions } from '../extensions/gltf-extensions';\nimport { normalizeGLTFV1 } from '../api/normalize-gltf-v1';\nimport { postProcessGLTF } from '../api/post-process-gltf';\nimport parseGLBSync, { isGLB } from './parse-glb';\nexport function isGLTF(arrayBuffer, options) {\n  const byteOffset = 0;\n  return isGLB(arrayBuffer, byteOffset, options);\n}\nexport async function parseGLTF(gltf, arrayBufferOrString) {\n  let byteOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  let options = arguments.length > 3 ? arguments[3] : undefined;\n  let context = arguments.length > 4 ? arguments[4] : undefined;\n\n  var _options$gltf, _options$gltf2, _options$gltf3, _options$gltf4;\n\n  parseGLTFContainerSync(gltf, arrayBufferOrString, byteOffset, options);\n  normalizeGLTFV1(gltf, {\n    normalize: options === null || options === void 0 ? void 0 : (_options$gltf = options.gltf) === null || _options$gltf === void 0 ? void 0 : _options$gltf.normalize\n  });\n  const promises = [];\n\n  if (options !== null && options !== void 0 && (_options$gltf2 = options.gltf) !== null && _options$gltf2 !== void 0 && _options$gltf2.loadBuffers && gltf.json.buffers) {\n    await loadBuffers(gltf, options, context);\n  }\n\n  if (options !== null && options !== void 0 && (_options$gltf3 = options.gltf) !== null && _options$gltf3 !== void 0 && _options$gltf3.loadImages) {\n    const promise = loadImages(gltf, options, context);\n    promises.push(promise);\n  }\n\n  const promise = decodeExtensions(gltf, options, context);\n  promises.push(promise);\n  await Promise.all(promises);\n  return options !== null && options !== void 0 && (_options$gltf4 = options.gltf) !== null && _options$gltf4 !== void 0 && _options$gltf4.postProcess ? postProcessGLTF(gltf, options) : gltf;\n}\n\nfunction parseGLTFContainerSync(gltf, data, byteOffset, options) {\n  if (options.uri) {\n    gltf.baseUri = options.uri;\n  }\n\n  if (data instanceof ArrayBuffer && !isGLB(data, byteOffset, options)) {\n    const textDecoder = new TextDecoder();\n    data = textDecoder.decode(data);\n  }\n\n  if (typeof data === 'string') {\n    gltf.json = parseJSON(data);\n  } else if (data instanceof ArrayBuffer) {\n    const glb = {};\n    byteOffset = parseGLBSync(glb, data, byteOffset, options.glb);\n    assert(glb.type === 'glTF', \"Invalid GLB magic string \".concat(glb.type));\n    gltf._glb = glb;\n    gltf.json = glb.json;\n  } else {\n    assert(false, 'GLTF: must be ArrayBuffer or string');\n  }\n\n  const buffers = gltf.json.buffers || [];\n  gltf.buffers = new Array(buffers.length).fill(null);\n\n  if (gltf._glb && gltf._glb.header.hasBinChunk) {\n    const {\n      binChunks\n    } = gltf._glb;\n    gltf.buffers[0] = {\n      arrayBuffer: binChunks[0].arrayBuffer,\n      byteOffset: binChunks[0].byteOffset,\n      byteLength: binChunks[0].byteLength\n    };\n  }\n\n  const images = gltf.json.images || [];\n  gltf.images = new Array(images.length).fill({});\n}\n\nasync function loadBuffers(gltf, options, context) {\n  for (let i = 0; i < gltf.json.buffers.length; ++i) {\n    const buffer = gltf.json.buffers[i];\n\n    if (buffer.uri) {\n      var _context$fetch, _response$arrayBuffer;\n\n      const {\n        fetch\n      } = context;\n      assert(fetch);\n      const uri = resolveUrl(buffer.uri, options);\n      const response = await (context === null || context === void 0 ? void 0 : (_context$fetch = context.fetch) === null || _context$fetch === void 0 ? void 0 : _context$fetch.call(context, uri));\n      const arrayBuffer = await (response === null || response === void 0 ? void 0 : (_response$arrayBuffer = response.arrayBuffer) === null || _response$arrayBuffer === void 0 ? void 0 : _response$arrayBuffer.call(response));\n      gltf.buffers[i] = {\n        arrayBuffer,\n        byteOffset: 0,\n        byteLength: arrayBuffer.byteLength\n      };\n      delete buffer.uri;\n    }\n  }\n}\n\nasync function loadImages(gltf, options, context) {\n  const images = gltf.json.images || [];\n  const promises = [];\n\n  for (let i = 0; i < images.length; ++i) {\n    promises.push(loadImage(gltf, images[i], i, options, context));\n  }\n\n  return await Promise.all(promises);\n}\n\nasync function loadImage(gltf, image, index, options, context) {\n  const {\n    fetch,\n    parse\n  } = context;\n  let arrayBuffer;\n\n  if (image.uri) {\n    const uri = resolveUrl(image.uri, options);\n    const response = await fetch(uri);\n    arrayBuffer = await response.arrayBuffer();\n  }\n\n  if (Number.isFinite(image.bufferView)) {\n    const array = getTypedArrayForBufferView(gltf.json, gltf.buffers, image.bufferView);\n    arrayBuffer = sliceArrayBuffer(array.buffer, array.byteOffset, array.byteLength);\n  }\n\n  assert(arrayBuffer, 'glTF image has no data');\n  const parsedImage = await parse(arrayBuffer, ImageLoader, {}, context);\n  gltf.images[index] = parsedImage;\n}","map":{"version":3,"sources":["../../../../src/lib/parsers/parse-gltf.ts"],"names":["byteOffset","isGLB","parseGLTFContainerSync","normalizeGLTFV1","normalize","options","promises","gltf","loadBuffers","promise","loadImages","decodeExtensions","Promise","postProcessGLTF","data","textDecoder","parseJSON","glb","parseGLBSync","assert","buffers","binChunks","arrayBuffer","byteLength","images","i","buffer","fetch","uri","resolveUrl","response","context","loadImage","parse","image","Number","array","getTypedArrayForBufferView","sliceArrayBuffer","parsedImage"],"mappings":"AAKA,SAAA,WAAA,QAAA,oBAAA;AACA,SAAA,SAAA,EAAA,gBAAA,QAAA,0BAAA;AACA,SAAA,MAAA,QAAA,iBAAA;AACA,SAAA,UAAA,QAAA,2BAAA;AACA,SAAA,0BAAA,QAAA,+BAAA;AACA,SAAA,gBAAA,QAAA,+BAAA;AACA,SAAA,eAAA,QAAA,0BAAA;AACA,SAAA,eAAA,QAAA,0BAAA;AACA,OAAA,YAAA,IAAA,KAAA,QAAA,aAAA;AAeA,OAAO,SAAA,MAAA,CAAA,WAAA,EAAA,OAAA,EAAgD;AACrD,QAAMA,UAAU,GAAhB,CAAA;AACA,SAAOC,KAAK,CAAA,WAAA,EAAA,UAAA,EAAZ,OAAY,CAAZ;AACD;AAED,OAAO,eAAA,SAAA,CAAA,IAAA,EAAA,mBAAA,EASL;AAAA,MANAD,UAMA,uEATK,CASL;AAAA,MATK,OASL;AAAA,MATK,OASL;;AAAA,MAAA,aAAA,EAAA,cAAA,EAAA,cAAA,EAAA,cAAA;;AACAE,EAAAA,sBAAsB,CAAA,IAAA,EAAA,mBAAA,EAAA,UAAA,EAAtBA,OAAsB,CAAtBA;AAEAC,EAAAA,eAAe,CAAA,IAAA,EAAO;AAACC,IAAAA,SAAS,EAAEC,OAAF,KAAA,IAAEA,IAAAA,OAAF,KAAA,KAAA,CAAEA,GAAF,KAAA,CAAEA,GAAF,CAAA,aAAA,GAAEA,OAAO,CAAT,IAAA,MAAA,IAAA,IAAA,aAAA,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAEA,aAAAA,CAAeD;AAA3B,GAAP,CAAfD;AAEA,QAAMG,QAAwB,GAA9B,EAAA;;AAGA,MAAID,OAAO,KAAPA,IAAAA,IAAAA,OAAO,KAAA,KAAPA,CAAAA,IAAAA,CAAAA,cAAAA,GAAAA,OAAO,CAAPA,IAAAA,MAAAA,IAAAA,IAAAA,cAAAA,KAAAA,KAAAA,CAAAA,IAAAA,cAAAA,CAAAA,WAAAA,IAA8BE,IAAI,CAAJA,IAAAA,CAAlC,OAAA,EAAqD;AACnD,UAAMC,WAAW,CAAA,IAAA,EAAA,OAAA,EAAjB,OAAiB,CAAjB;AACD;;AAED,MAAIH,OAAJ,KAAA,IAAIA,IAAAA,OAAJ,KAAA,KAAA,CAAIA,IAAJ,CAAA,cAAA,GAAIA,OAAO,CAAX,IAAA,MAAA,IAAIA,IAAJ,cAAA,KAAA,KAAA,CAAIA,IAAAA,cAAAA,CAAJ,UAAA,EAA+B;AAC7B,UAAMI,OAAO,GAAGC,UAAU,CAAA,IAAA,EAAA,OAAA,EAA1B,OAA0B,CAA1B;AACAJ,IAAAA,QAAQ,CAARA,IAAAA,CAAAA,OAAAA;AACD;;AAED,QAAMG,OAAO,GAAGE,gBAAgB,CAAA,IAAA,EAAA,OAAA,EAAhC,OAAgC,CAAhC;AACAL,EAAAA,QAAQ,CAARA,IAAAA,CAAAA,OAAAA;AAGA,QAAMM,OAAO,CAAPA,GAAAA,CAAN,QAAMA,CAAN;AAGA,SAAOP,OAAO,KAAPA,IAAAA,IAAAA,OAAO,KAAA,KAAPA,CAAAA,IAAAA,CAAAA,cAAAA,GAAAA,OAAO,CAAPA,IAAAA,MAAAA,IAAAA,IAAAA,cAAAA,KAAAA,KAAAA,CAAAA,IAAAA,cAAAA,CAAAA,WAAAA,GAA6BQ,eAAe,CAAA,IAAA,EAA5CR,OAA4C,CAA5CA,GAAP,IAAA;AACD;;AAGD,SAAA,sBAAA,CAAA,IAAA,EAAA,IAAA,EAAA,UAAA,EAAA,OAAA,EAAiE;AAE/D,MAAIA,OAAO,CAAX,GAAA,EAAiB;AACfE,IAAAA,IAAI,CAAJA,OAAAA,GAAeF,OAAO,CAAtBE,GAAAA;AACD;;AAGD,MAAIO,IAAI,YAAJA,WAAAA,IAA+B,CAACb,KAAK,CAAA,IAAA,EAAA,UAAA,EAAzC,OAAyC,CAAzC,EAAsE;AACpE,UAAMc,WAAW,GAAG,IAApB,WAAoB,EAApB;AACAD,IAAAA,IAAI,GAAGC,WAAW,CAAXA,MAAAA,CAAPD,IAAOC,CAAPD;AACD;;AAED,MAAI,OAAA,IAAA,KAAJ,QAAA,EAA8B;AAE5BP,IAAAA,IAAI,CAAJA,IAAAA,GAAYS,SAAS,CAArBT,IAAqB,CAArBA;AAFF,GAAA,MAGO,IAAIO,IAAI,YAAR,WAAA,EAAiC;AAEtC,UAAMG,GAAQ,GAAd,EAAA;AACAjB,IAAAA,UAAU,GAAGkB,YAAY,CAAA,GAAA,EAAA,IAAA,EAAA,UAAA,EAAwBb,OAAO,CAAxDL,GAAyB,CAAzBA;AAEAmB,IAAAA,MAAM,CAACF,GAAG,CAAHA,IAAAA,KAAD,MAAA,EAAA,4BAAA,MAAA,CAAkDA,GAAG,CAA3DE,IAAM,CAAA,CAANA;AAEAZ,IAAAA,IAAI,CAAJA,IAAAA,GAAAA,GAAAA;AACAA,IAAAA,IAAI,CAAJA,IAAAA,GAAYU,GAAG,CAAfV,IAAAA;AARK,GAAA,MASA;AACLY,IAAAA,MAAM,CAAA,KAAA,EAANA,qCAAM,CAANA;AACD;;AAID,QAAMC,OAAO,GAAGb,IAAI,CAAJA,IAAAA,CAAAA,OAAAA,IAAhB,EAAA;AACAA,EAAAA,IAAI,CAAJA,OAAAA,GAAe,IAAA,KAAA,CAAUa,OAAO,CAAjB,MAAA,EAAA,IAAA,CAAfb,IAAe,CAAfA;;AAGA,MAAIA,IAAI,CAAJA,IAAAA,IAAaA,IAAI,CAAJA,IAAAA,CAAAA,MAAAA,CAAjB,WAAA,EAA+C;AAC7C,UAAM;AAACc,MAAAA;AAAD,QAAcd,IAAI,CAAxB,IAAA;AACAA,IAAAA,IAAI,CAAJA,OAAAA,CAAAA,CAAAA,IAAkB;AAChBe,MAAAA,WAAW,EAAED,SAAS,CAATA,CAAS,CAATA,CADG,WAAA;AAEhBrB,MAAAA,UAAU,EAAEqB,SAAS,CAATA,CAAS,CAATA,CAFI,UAAA;AAGhBE,MAAAA,UAAU,EAAEF,SAAS,CAATA,CAAS,CAATA,CAAaE;AAHT,KAAlBhB;AASD;;AAGD,QAAMiB,MAAM,GAAGjB,IAAI,CAAJA,IAAAA,CAAAA,MAAAA,IAAf,EAAA;AACAA,EAAAA,IAAI,CAAJA,MAAAA,GAAc,IAAA,KAAA,CAAUiB,MAAM,CAAhB,MAAA,EAAA,IAAA,CAAdjB,EAAc,CAAdA;AACD;;AAGD,eAAA,WAAA,CAAA,IAAA,EAAA,OAAA,EAAA,OAAA,EAAkE;AAChE,OAAK,IAAIkB,CAAC,GAAV,CAAA,EAAgBA,CAAC,GAAGlB,IAAI,CAAJA,IAAAA,CAAAA,OAAAA,CAApB,MAAA,EAA8C,EAA9C,CAAA,EAAmD;AACjD,UAAMmB,MAAM,GAAGnB,IAAI,CAAJA,IAAAA,CAAAA,OAAAA,CAAf,CAAeA,CAAf;;AACA,QAAImB,MAAM,CAAV,GAAA,EAAgB;AAAA,UAAA,cAAA,EAAA,qBAAA;;AACd,YAAM;AAACC,QAAAA;AAAD,UAAN,OAAA;AACAR,MAAAA,MAAM,CAANA,KAAM,CAANA;AAEA,YAAMS,GAAG,GAAGC,UAAU,CAACH,MAAM,CAAP,GAAA,EAAtB,OAAsB,CAAtB;AACA,YAAMI,QAAQ,GAAG,OAAMC,OAAN,KAAA,IAAMA,IAAAA,OAAN,KAAA,KAAA,CAAMA,GAAN,KAAA,CAAMA,GAAN,CAAA,cAAA,GAAMA,OAAO,CAAb,KAAA,MAAA,IAAA,IAAA,cAAA,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAMA,cAAAA,CAAAA,IAAAA,CAAAA,OAAAA,EAAvB,GAAuBA,CAAN,CAAjB;AACA,YAAMT,WAAW,GAAG,OAAMQ,QAAN,KAAA,IAAMA,IAAAA,QAAN,KAAA,KAAA,CAAMA,GAAN,KAAA,CAAMA,GAAN,CAAA,qBAAA,GAAMA,QAAQ,CAAd,WAAA,MAAA,IAAA,IAAA,qBAAA,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAMA,qBAAAA,CAAAA,IAAAA,CAA1B,QAA0BA,CAAN,CAApB;AAEAvB,MAAAA,IAAI,CAAJA,OAAAA,CAAAA,CAAAA,IAAkB;AAAA,QAAA,WAAA;AAEhBP,QAAAA,UAAU,EAFM,CAAA;AAGhBuB,QAAAA,UAAU,EAAED,WAAW,CAACC;AAHR,OAAlBhB;AAMA,aAAOmB,MAAM,CAAb,GAAA;AACD;AACF;AACF;;AAED,eAAA,UAAA,CAAA,IAAA,EAAA,OAAA,EAAA,OAAA,EAAiE;AAC/D,QAAMF,MAAM,GAAGjB,IAAI,CAAJA,IAAAA,CAAAA,MAAAA,IAAf,EAAA;AAEA,QAAMD,QAAwB,GAA9B,EAAA;;AACA,OAAK,IAAImB,CAAC,GAAV,CAAA,EAAgBA,CAAC,GAAGD,MAAM,CAA1B,MAAA,EAAmC,EAAnC,CAAA,EAAwC;AACtClB,IAAAA,QAAQ,CAARA,IAAAA,CAAc0B,SAAS,CAAA,IAAA,EAAOR,MAAM,CAAb,CAAa,CAAb,EAAA,CAAA,EAAA,OAAA,EAAvBlB,OAAuB,CAAvBA;AACD;;AAED,SAAO,MAAMM,OAAO,CAAPA,GAAAA,CAAb,QAAaA,CAAb;AACD;;AAGD,eAAA,SAAA,CAAA,IAAA,EAAA,KAAA,EAAA,KAAA,EAAA,OAAA,EAAA,OAAA,EAAsF;AACpF,QAAM;AAAA,IAAA,KAAA;AAAQqB,IAAAA;AAAR,MAAN,OAAA;AAEA,MAAA,WAAA;;AAEA,MAAIC,KAAK,CAAT,GAAA,EAAe;AACb,UAAMN,GAAG,GAAGC,UAAU,CAACK,KAAK,CAAN,GAAA,EAAtB,OAAsB,CAAtB;AACA,UAAMJ,QAAQ,GAAG,MAAMH,KAAK,CAA5B,GAA4B,CAA5B;AACAL,IAAAA,WAAW,GAAG,MAAMQ,QAAQ,CAA5BR,WAAoBQ,EAApBR;AACD;;AAED,MAAIa,MAAM,CAANA,QAAAA,CAAgBD,KAAK,CAAzB,UAAIC,CAAJ,EAAuC;AACrC,UAAMC,KAAK,GAAGC,0BAA0B,CAAC9B,IAAI,CAAL,IAAA,EAAYA,IAAI,CAAhB,OAAA,EAA0B2B,KAAK,CAAvE,UAAwC,CAAxC;AACAZ,IAAAA,WAAW,GAAGgB,gBAAgB,CAACF,KAAK,CAAN,MAAA,EAAeA,KAAK,CAApB,UAAA,EAAiCA,KAAK,CAApEd,UAA8B,CAA9BA;AACD;;AAEDH,EAAAA,MAAM,CAAA,WAAA,EAANA,wBAAM,CAANA;AAGA,QAAMoB,WAAW,GAAG,MAAMN,KAAK,CAAA,WAAA,EAAA,WAAA,EAAA,EAAA,EAA/B,OAA+B,CAA/B;AAIA1B,EAAAA,IAAI,CAAJA,MAAAA,CAAAA,KAAAA,IAAAA,WAAAA;AACD","sourcesContent":["/* eslint-disable camelcase, max-statements, no-restricted-globals */\nimport type {LoaderContext} from '@loaders.gl/loader-utils';\nimport type {GLB} from '../types/glb-types';\nimport type {GLBParseOptions} from './parse-glb';\n\nimport {ImageLoader} from '@loaders.gl/images';\nimport {parseJSON, sliceArrayBuffer} from '@loaders.gl/loader-utils';\nimport {assert} from '../utils/assert';\nimport {resolveUrl} from '../gltf-utils/resolve-url';\nimport {getTypedArrayForBufferView} from '../gltf-utils/get-typed-array';\nimport {decodeExtensions} from '../extensions/gltf-extensions';\nimport {normalizeGLTFV1} from '../api/normalize-gltf-v1';\nimport {postProcessGLTF} from '../api/post-process-gltf';\nimport parseGLBSync, {isGLB} from './parse-glb';\n\nexport type GLTFParseOptions = {\n  excludeExtensions?: string[];\n  decompressMeshes?: boolean;\n  normalize?: boolean;\n  loadBuffers?: boolean;\n  loadImages?: boolean;\n  postProcess?: boolean;\n};\n\n// export type GLTFOptions = {\n//   gltf?: GLTFParseOptions;\n// };\n\nexport function isGLTF(arrayBuffer, options?): boolean {\n  const byteOffset = 0;\n  return isGLB(arrayBuffer, byteOffset, options);\n}\n\nexport async function parseGLTF(\n  gltf,\n  arrayBufferOrString,\n  byteOffset = 0,\n  options: {\n    gltf?: GLTFParseOptions;\n    glb?: GLBParseOptions;\n  },\n  context: LoaderContext\n) {\n  parseGLTFContainerSync(gltf, arrayBufferOrString, byteOffset, options);\n\n  normalizeGLTFV1(gltf, {normalize: options?.gltf?.normalize});\n\n  const promises: Promise<any>[] = [];\n\n  // Load linked buffers asynchronously and decodes base64 buffers in parallel\n  if (options?.gltf?.loadBuffers && gltf.json.buffers) {\n    await loadBuffers(gltf, options, context);\n  }\n\n  if (options?.gltf?.loadImages) {\n    const promise = loadImages(gltf, options, context);\n    promises.push(promise);\n  }\n\n  const promise = decodeExtensions(gltf, options, context);\n  promises.push(promise);\n\n  // Parallelize image loading and buffer loading/extension decoding\n  await Promise.all(promises);\n\n  // Post processing resolves indices to objects, buffers\n  return options?.gltf?.postProcess ? postProcessGLTF(gltf, options) : gltf;\n}\n\n// `data` - can be ArrayBuffer (GLB), ArrayBuffer (Binary JSON), String (JSON), or Object (parsed JSON)\nfunction parseGLTFContainerSync(gltf, data, byteOffset, options) {\n  // Initialize gltf container\n  if (options.uri) {\n    gltf.baseUri = options.uri;\n  }\n\n  // If data is binary and starting with magic bytes, assume binary JSON text, convert to string\n  if (data instanceof ArrayBuffer && !isGLB(data, byteOffset, options)) {\n    const textDecoder = new TextDecoder();\n    data = textDecoder.decode(data);\n  }\n\n  if (typeof data === 'string') {\n    // If string, try to parse as JSON\n    gltf.json = parseJSON(data);\n  } else if (data instanceof ArrayBuffer) {\n    // If still ArrayBuffer, parse as GLB container\n    const glb: GLB = {} as GLB;\n    byteOffset = parseGLBSync(glb, data, byteOffset, options.glb);\n\n    assert(glb.type === 'glTF', `Invalid GLB magic string ${glb.type}`);\n\n    gltf._glb = glb;\n    gltf.json = glb.json;\n  } else {\n    assert(false, 'GLTF: must be ArrayBuffer or string');\n  }\n\n  // Populate buffers\n  // Create an external buffers array to hold binary data\n  const buffers = gltf.json.buffers || [];\n  gltf.buffers = new Array(buffers.length).fill(null);\n\n  // Populates JSON and some bin chunk info\n  if (gltf._glb && gltf._glb.header.hasBinChunk) {\n    const {binChunks} = gltf._glb;\n    gltf.buffers[0] = {\n      arrayBuffer: binChunks[0].arrayBuffer,\n      byteOffset: binChunks[0].byteOffset,\n      byteLength: binChunks[0].byteLength\n    };\n\n    // TODO - this modifies JSON and is a post processing thing\n    // gltf.json.buffers[0].data = gltf.buffers[0].arrayBuffer;\n    // gltf.json.buffers[0].byteOffset = gltf.buffers[0].byteOffset;\n  }\n\n  // Populate images\n  const images = gltf.json.images || [];\n  gltf.images = new Array(images.length).fill({});\n}\n\n// Asynchronously fetch and parse buffers, store in buffers array outside of json\nasync function loadBuffers(gltf, options, context: LoaderContext) {\n  for (let i = 0; i < gltf.json.buffers.length; ++i) {\n    const buffer = gltf.json.buffers[i];\n    if (buffer.uri) {\n      const {fetch} = context;\n      assert(fetch);\n\n      const uri = resolveUrl(buffer.uri, options);\n      const response = await context?.fetch?.(uri);\n      const arrayBuffer = await response?.arrayBuffer?.();\n\n      gltf.buffers[i] = {\n        arrayBuffer,\n        byteOffset: 0,\n        byteLength: arrayBuffer.byteLength\n      };\n\n      delete buffer.uri;\n    }\n  }\n}\n\nasync function loadImages(gltf, options, context: LoaderContext) {\n  const images = gltf.json.images || [];\n\n  const promises: Promise<any>[] = [];\n  for (let i = 0; i < images.length; ++i) {\n    promises.push(loadImage(gltf, images[i], i, options, context));\n  }\n\n  return await Promise.all(promises);\n}\n\n// Asynchronously fetches and parses one image, store in images array outside of json\nasync function loadImage(gltf, image, index: number, options, context: LoaderContext) {\n  const {fetch, parse} = context;\n\n  let arrayBuffer;\n\n  if (image.uri) {\n    const uri = resolveUrl(image.uri, options);\n    const response = await fetch(uri);\n    arrayBuffer = await response.arrayBuffer();\n  }\n\n  if (Number.isFinite(image.bufferView)) {\n    const array = getTypedArrayForBufferView(gltf.json, gltf.buffers, image.bufferView);\n    arrayBuffer = sliceArrayBuffer(array.buffer, array.byteOffset, array.byteLength);\n  }\n\n  assert(arrayBuffer, 'glTF image has no data');\n\n  // Call `parse`\n  const parsedImage = await parse(arrayBuffer, ImageLoader, {}, context);\n  // TODO making sure ImageLoader is overridable by using array of loaders\n  // const parsedImage = await parse(arrayBuffer, [ImageLoader]);\n\n  gltf.images[index] = parsedImage;\n}\n"]},"metadata":{},"sourceType":"module"}