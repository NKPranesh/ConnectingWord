{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { assert } from '../../utils/assert';\nexport default class Schema {\n  constructor(fields, metadata) {\n    _defineProperty(this, \"fields\", void 0);\n\n    _defineProperty(this, \"metadata\", void 0);\n\n    assert(Array.isArray(fields));\n    checkNames(fields);\n    this.fields = fields;\n    this.metadata = metadata || new Map();\n  }\n\n  compareTo(other) {\n    if (this.metadata !== other.metadata) {\n      return false;\n    }\n\n    if (this.fields.length !== other.fields.length) {\n      return false;\n    }\n\n    for (let i = 0; i < this.fields.length; ++i) {\n      if (!this.fields[i].compareTo(other.fields[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  select() {\n    const nameMap = Object.create(null);\n\n    for (var _len = arguments.length, columnNames = new Array(_len), _key = 0; _key < _len; _key++) {\n      columnNames[_key] = arguments[_key];\n    }\n\n    for (const name of columnNames) {\n      nameMap[name] = true;\n    }\n\n    const selectedFields = this.fields.filter(field => nameMap[field.name]);\n    return new Schema(selectedFields, this.metadata);\n  }\n\n  selectAt() {\n    for (var _len2 = arguments.length, columnIndices = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      columnIndices[_key2] = arguments[_key2];\n    }\n\n    const selectedFields = columnIndices.map(index => this.fields[index]).filter(Boolean);\n    return new Schema(selectedFields, this.metadata);\n  }\n\n  assign(schemaOrFields) {\n    let fields;\n    let metadata = this.metadata;\n\n    if (schemaOrFields instanceof Schema) {\n      const otherSchema = schemaOrFields;\n      fields = otherSchema.fields;\n      metadata = mergeMaps(mergeMaps(new Map(), this.metadata), otherSchema.metadata);\n    } else {\n      fields = schemaOrFields;\n    }\n\n    const fieldMap = Object.create(null);\n\n    for (const field of this.fields) {\n      fieldMap[field.name] = field;\n    }\n\n    for (const field of fields) {\n      fieldMap[field.name] = field;\n    }\n\n    const mergedFields = Object.values(fieldMap);\n    return new Schema(mergedFields, metadata);\n  }\n\n}\n\nfunction checkNames(fields) {\n  const usedNames = {};\n\n  for (const field of fields) {\n    if (usedNames[field.name]) {\n      console.warn('Schema: duplicated field name', field.name, field);\n    }\n\n    usedNames[field.name] = true;\n  }\n}\n\nfunction mergeMaps(m1, m2) {\n  return new Map([...(m1 || new Map()), ...(m2 || new Map())]);\n}","map":{"version":3,"sources":["../../../../../src/lib/schema/impl/schema.ts"],"names":["constructor","assert","Array","checkNames","metadata","compareTo","other","i","select","nameMap","Object","selectedFields","field","selectAt","columnIndices","index","assign","schemaOrFields","otherSchema","fields","mergeMaps","fieldMap","mergedFields","usedNames","console","m1","m2"],"mappings":"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","sourcesContent":["import {assert} from '../../utils/assert';\nimport Field from './field';\n\nexport type SchemaMetadata = Map<string, any>;\n\n/**\n * ArrowJS `Schema` API-compatible class for row-based tables (returned from `DataTable`)\n * https://loaders.gl/arrowjs/docs/api-reference/schema\n */\nexport default class Schema {\n  fields: Field[];\n  // TODO - Arrow just allows Map<string, string>\n  metadata: SchemaMetadata;\n\n  constructor(fields: Field[], metadata?: SchemaMetadata) {\n    assert(Array.isArray(fields));\n    checkNames(fields);\n    // For kepler fields, create arrow compatible `Fields` that have kepler fields as `metadata`\n    this.fields = fields;\n    this.metadata = metadata || new Map();\n  }\n\n  // TODO - arrow only seems to compare fields, not metadata\n  compareTo(other: Schema): boolean {\n    if (this.metadata !== other.metadata) {\n      return false;\n    }\n    if (this.fields.length !== other.fields.length) {\n      return false;\n    }\n    for (let i = 0; i < this.fields.length; ++i) {\n      if (!this.fields[i].compareTo(other.fields[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  select(...columnNames: string[]): Schema {\n    // Ensure column names reference valid fields\n    const nameMap = Object.create(null);\n    for (const name of columnNames) {\n      nameMap[name] = true;\n    }\n    const selectedFields = this.fields.filter((field) => nameMap[field.name]);\n    return new Schema(selectedFields, this.metadata);\n  }\n\n  selectAt(...columnIndices: number[]): Schema {\n    // Ensure column indices reference valid fields\n    const selectedFields = columnIndices.map((index) => this.fields[index]).filter(Boolean);\n    return new Schema(selectedFields, this.metadata);\n  }\n\n  assign(schemaOrFields: Schema | Field[]): Schema {\n    let fields: Field[];\n    let metadata: SchemaMetadata = this.metadata;\n\n    if (schemaOrFields instanceof Schema) {\n      const otherSchema = schemaOrFields;\n      fields = otherSchema.fields;\n      metadata = mergeMaps(mergeMaps(new Map(), this.metadata), otherSchema.metadata);\n    } else {\n      fields = schemaOrFields;\n    }\n\n    // Create a merged list of fields, overwrite fields in place, new fields at end\n    const fieldMap: {[key: string]: Field} = Object.create(null);\n\n    for (const field of this.fields) {\n      fieldMap[field.name] = field;\n    }\n\n    for (const field of fields) {\n      fieldMap[field.name] = field;\n    }\n\n    const mergedFields = Object.values(fieldMap);\n\n    return new Schema(mergedFields, metadata);\n  }\n}\n\n// Warn if any duplicated field names\nfunction checkNames(fields) {\n  const usedNames = {};\n  for (const field of fields) {\n    if (usedNames[field.name]) {\n      // eslint-disable-next-line\n      console.warn('Schema: duplicated field name', field.name, field);\n    }\n    usedNames[field.name] = true;\n  }\n}\n\nfunction mergeMaps<T>(m1: T, m2: T): T {\n  // @ts-ignore\n  return new Map([...(m1 || new Map()), ...(m2 || new Map())]);\n}\n"]},"metadata":{},"sourceType":"module"}