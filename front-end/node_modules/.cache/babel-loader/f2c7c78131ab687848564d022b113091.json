{"ast":null,"code":"export function geojsonToBinary(features) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const firstPassData = firstPass(features);\n  return secondPass(features, firstPassData, {\n    coordLength: options.coordLength || firstPassData.coordLength,\n    numericPropKeys: options.numericPropKeys || firstPassData.numericPropKeys,\n    PositionDataType: options.PositionDataType || Float32Array\n  });\n}\nexport const TEST_EXPORTS = {\n  firstPass,\n  secondPass\n};\n\nfunction firstPass(features) {\n  let pointPositionsCount = 0;\n  let pointFeaturesCount = 0;\n  let linePositionsCount = 0;\n  let linePathsCount = 0;\n  let lineFeaturesCount = 0;\n  let polygonPositionsCount = 0;\n  let polygonObjectsCount = 0;\n  let polygonRingsCount = 0;\n  let polygonFeaturesCount = 0;\n  const coordLengths = new Set();\n  const numericPropKeys = {};\n\n  for (const feature of features) {\n    const geometry = feature.geometry;\n\n    switch (geometry.type) {\n      case 'Point':\n        pointFeaturesCount++;\n        pointPositionsCount++;\n        coordLengths.add(geometry.coordinates.length);\n        break;\n\n      case 'MultiPoint':\n        pointFeaturesCount++;\n        pointPositionsCount += geometry.coordinates.length;\n\n        for (const point of geometry.coordinates) {\n          coordLengths.add(point.length);\n        }\n\n        break;\n\n      case 'LineString':\n        lineFeaturesCount++;\n        linePositionsCount += geometry.coordinates.length;\n        linePathsCount++;\n\n        for (const coord of geometry.coordinates) {\n          coordLengths.add(coord.length);\n        }\n\n        break;\n\n      case 'MultiLineString':\n        lineFeaturesCount++;\n\n        for (const line of geometry.coordinates) {\n          linePositionsCount += line.length;\n          linePathsCount++;\n\n          for (const coord of line) {\n            coordLengths.add(coord.length);\n          }\n        }\n\n        break;\n\n      case 'Polygon':\n        polygonFeaturesCount++;\n        polygonObjectsCount++;\n        polygonRingsCount += geometry.coordinates.length;\n        polygonPositionsCount += flatten(geometry.coordinates).length;\n\n        for (const coord of flatten(geometry.coordinates)) {\n          coordLengths.add(coord.length);\n        }\n\n        break;\n\n      case 'MultiPolygon':\n        polygonFeaturesCount++;\n\n        for (const polygon of geometry.coordinates) {\n          polygonObjectsCount++;\n          polygonRingsCount += polygon.length;\n          polygonPositionsCount += flatten(polygon).length;\n\n          for (const coord of flatten(polygon)) {\n            coordLengths.add(coord.length);\n          }\n        }\n\n        break;\n\n      default:\n        throw new Error(\"Unsupported geometry type: \".concat(geometry.type));\n    }\n\n    if (feature.properties) {\n      for (const key in feature.properties) {\n        const val = feature.properties[key];\n        numericPropKeys[key] = numericPropKeys[key] || numericPropKeys[key] === undefined ? isNumeric(val) : numericPropKeys[key];\n      }\n    }\n  }\n\n  return {\n    coordLength: coordLengths.size > 0 ? Math.max(...coordLengths) : 2,\n    pointPositionsCount,\n    pointFeaturesCount,\n    linePositionsCount,\n    linePathsCount,\n    lineFeaturesCount,\n    polygonPositionsCount,\n    polygonObjectsCount,\n    polygonRingsCount,\n    polygonFeaturesCount,\n    numericPropKeys: Object.keys(numericPropKeys).filter(k => numericPropKeys[k])\n  };\n}\n\nfunction secondPass(features, firstPassData, options) {\n  const {\n    pointPositionsCount,\n    pointFeaturesCount,\n    linePositionsCount,\n    linePathsCount,\n    lineFeaturesCount,\n    polygonPositionsCount,\n    polygonObjectsCount,\n    polygonRingsCount,\n    polygonFeaturesCount\n  } = firstPassData;\n  const {\n    coordLength,\n    numericPropKeys,\n    PositionDataType = Float32Array\n  } = options;\n  const GlobalFeatureIdsDataType = features.length > 65535 ? Uint32Array : Uint16Array;\n  const points = {\n    positions: new PositionDataType(pointPositionsCount * coordLength),\n    globalFeatureIds: new GlobalFeatureIdsDataType(pointPositionsCount),\n    featureIds: pointFeaturesCount > 65535 ? new Uint32Array(pointPositionsCount) : new Uint16Array(pointPositionsCount),\n    numericProps: {},\n    properties: Array(),\n    fields: Array()\n  };\n  const lines = {\n    positions: new PositionDataType(linePositionsCount * coordLength),\n    pathIndices: linePositionsCount > 65535 ? new Uint32Array(linePathsCount + 1) : new Uint16Array(linePathsCount + 1),\n    globalFeatureIds: new GlobalFeatureIdsDataType(linePositionsCount),\n    featureIds: lineFeaturesCount > 65535 ? new Uint32Array(linePositionsCount) : new Uint16Array(linePositionsCount),\n    numericProps: {},\n    properties: Array(),\n    fields: Array()\n  };\n  const polygons = {\n    positions: new PositionDataType(polygonPositionsCount * coordLength),\n    polygonIndices: polygonPositionsCount > 65535 ? new Uint32Array(polygonObjectsCount + 1) : new Uint16Array(polygonObjectsCount + 1),\n    primitivePolygonIndices: polygonPositionsCount > 65535 ? new Uint32Array(polygonRingsCount + 1) : new Uint16Array(polygonRingsCount + 1),\n    globalFeatureIds: new GlobalFeatureIdsDataType(polygonPositionsCount),\n    featureIds: polygonFeaturesCount > 65535 ? new Uint32Array(polygonPositionsCount) : new Uint16Array(polygonPositionsCount),\n    numericProps: {},\n    properties: Array(),\n    fields: Array()\n  };\n\n  for (const object of [points, lines, polygons]) {\n    for (const propName of numericPropKeys || []) {\n      object.numericProps[propName] = new Float32Array(object.positions.length / coordLength);\n    }\n  }\n\n  lines.pathIndices[linePathsCount] = linePositionsCount;\n  polygons.polygonIndices[polygonObjectsCount] = polygonPositionsCount;\n  polygons.primitivePolygonIndices[polygonRingsCount] = polygonPositionsCount;\n  const indexMap = {\n    pointPosition: 0,\n    pointFeature: 0,\n    linePosition: 0,\n    linePath: 0,\n    lineFeature: 0,\n    polygonPosition: 0,\n    polygonObject: 0,\n    polygonRing: 0,\n    polygonFeature: 0,\n    feature: 0\n  };\n\n  for (const feature of features) {\n    const geometry = feature.geometry;\n    const properties = feature.properties || {};\n\n    switch (geometry.type) {\n      case 'Point':\n        handlePoint(geometry.coordinates, points, indexMap, coordLength, properties);\n        points.properties.push(keepStringProperties(properties, numericPropKeys));\n        indexMap.pointFeature++;\n        break;\n\n      case 'MultiPoint':\n        handleMultiPoint(geometry.coordinates, points, indexMap, coordLength, properties);\n        points.properties.push(keepStringProperties(properties, numericPropKeys));\n        indexMap.pointFeature++;\n        break;\n\n      case 'LineString':\n        handleLineString(geometry.coordinates, lines, indexMap, coordLength, properties);\n        lines.properties.push(keepStringProperties(properties, numericPropKeys));\n        indexMap.lineFeature++;\n        break;\n\n      case 'MultiLineString':\n        handleMultiLineString(geometry.coordinates, lines, indexMap, coordLength, properties);\n        lines.properties.push(keepStringProperties(properties, numericPropKeys));\n        indexMap.lineFeature++;\n        break;\n\n      case 'Polygon':\n        handlePolygon(geometry.coordinates, polygons, indexMap, coordLength, properties);\n        polygons.properties.push(keepStringProperties(properties, numericPropKeys));\n        indexMap.polygonFeature++;\n        break;\n\n      case 'MultiPolygon':\n        handleMultiPolygon(geometry.coordinates, polygons, indexMap, coordLength, properties);\n        polygons.properties.push(keepStringProperties(properties, numericPropKeys));\n        indexMap.polygonFeature++;\n        break;\n\n      default:\n        throw new Error('Invalid geometry type');\n    }\n\n    indexMap.feature++;\n  }\n\n  return makeAccessorObjects(points, lines, polygons, coordLength);\n}\n\nfunction handlePoint(coords, points, indexMap, coordLength, properties) {\n  points.positions.set(coords, indexMap.pointPosition * coordLength);\n  points.globalFeatureIds[indexMap.pointPosition] = indexMap.feature;\n  points.featureIds[indexMap.pointPosition] = indexMap.pointFeature;\n  fillNumericProperties(points, properties, indexMap.pointPosition, 1);\n  indexMap.pointPosition++;\n}\n\nfunction handleMultiPoint(coords, points, indexMap, coordLength, properties) {\n  for (const point of coords) {\n    handlePoint(point, points, indexMap, coordLength, properties);\n  }\n}\n\nfunction handleLineString(coords, lines, indexMap, coordLength, properties) {\n  lines.pathIndices[indexMap.linePath] = indexMap.linePosition;\n  indexMap.linePath++;\n  fillCoords(lines.positions, coords, indexMap.linePosition, coordLength);\n  const nPositions = coords.length;\n  fillNumericProperties(lines, properties, indexMap.linePosition, nPositions);\n  lines.globalFeatureIds.set(new Uint32Array(nPositions).fill(indexMap.feature), indexMap.linePosition);\n  lines.featureIds.set(new Uint32Array(nPositions).fill(indexMap.lineFeature), indexMap.linePosition);\n  indexMap.linePosition += nPositions;\n}\n\nfunction handleMultiLineString(coords, lines, indexMap, coordLength, properties) {\n  for (const line of coords) {\n    handleLineString(line, lines, indexMap, coordLength, properties);\n  }\n}\n\nfunction handlePolygon(coords, polygons, indexMap, coordLength, properties) {\n  polygons.polygonIndices[indexMap.polygonObject] = indexMap.polygonPosition;\n  indexMap.polygonObject++;\n\n  for (const ring of coords) {\n    polygons.primitivePolygonIndices[indexMap.polygonRing] = indexMap.polygonPosition;\n    indexMap.polygonRing++;\n    fillCoords(polygons.positions, ring, indexMap.polygonPosition, coordLength);\n    const nPositions = ring.length;\n    fillNumericProperties(polygons, properties, indexMap.polygonPosition, nPositions);\n    polygons.globalFeatureIds.set(new Uint32Array(nPositions).fill(indexMap.feature), indexMap.polygonPosition);\n    polygons.featureIds.set(new Uint32Array(nPositions).fill(indexMap.polygonFeature), indexMap.polygonPosition);\n    indexMap.polygonPosition += nPositions;\n  }\n}\n\nfunction handleMultiPolygon(coords, polygons, indexMap, coordLength, properties) {\n  for (const polygon of coords) {\n    handlePolygon(polygon, polygons, indexMap, coordLength, properties);\n  }\n}\n\nfunction makeAccessorObjects(points, lines, polygons, coordLength) {\n  const returnObj = {\n    points: { ...points,\n      positions: {\n        value: points.positions,\n        size: coordLength\n      },\n      globalFeatureIds: {\n        value: points.globalFeatureIds,\n        size: 1\n      },\n      featureIds: {\n        value: points.featureIds,\n        size: 1\n      },\n      type: 'Point'\n    },\n    lines: { ...lines,\n      pathIndices: {\n        value: lines.pathIndices,\n        size: 1\n      },\n      positions: {\n        value: lines.positions,\n        size: coordLength\n      },\n      globalFeatureIds: {\n        value: lines.globalFeatureIds,\n        size: 1\n      },\n      featureIds: {\n        value: lines.featureIds,\n        size: 1\n      },\n      type: 'LineString'\n    },\n    polygons: { ...polygons,\n      polygonIndices: {\n        value: polygons.polygonIndices,\n        size: 1\n      },\n      primitivePolygonIndices: {\n        value: polygons.primitivePolygonIndices,\n        size: 1\n      },\n      positions: {\n        value: polygons.positions,\n        size: coordLength\n      },\n      globalFeatureIds: {\n        value: polygons.globalFeatureIds,\n        size: 1\n      },\n      featureIds: {\n        value: polygons.featureIds,\n        size: 1\n      },\n      type: 'Polygon'\n    }\n  };\n\n  for (const geomType in returnObj) {\n    for (const numericProp in returnObj[geomType].numericProps) {\n      returnObj[geomType].numericProps[numericProp] = {\n        value: returnObj[geomType].numericProps[numericProp],\n        size: 1\n      };\n    }\n  }\n\n  return returnObj;\n}\n\nfunction fillNumericProperties(object, properties, index, length) {\n  for (const numericPropName in object.numericProps) {\n    if (numericPropName in properties) {\n      object.numericProps[numericPropName].set(new Array(length).fill(properties[numericPropName]), index);\n    }\n  }\n}\n\nfunction keepStringProperties(properties, numericKeys) {\n  const props = {};\n\n  for (const key in properties) {\n    if (!numericKeys.includes(key)) {\n      props[key] = properties[key];\n    }\n  }\n\n  return props;\n}\n\nfunction fillCoords(array, coords, startVertex, coordLength) {\n  let index = startVertex * coordLength;\n\n  for (const coord of coords) {\n    array.set(coord, index);\n    index += coordLength;\n  }\n}\n\nfunction flatten(arrays) {\n  return [].concat(...arrays);\n}\n\nfunction isNumeric(x) {\n  return Number.isFinite(x);\n}","map":{"version":3,"sources":["../../../src/lib/geojson-to-binary.ts"],"names":["options","firstPassData","firstPass","secondPass","coordLength","numericPropKeys","PositionDataType","Float32Array","TEST_EXPORTS","pointPositionsCount","pointFeaturesCount","linePositionsCount","linePathsCount","lineFeaturesCount","polygonPositionsCount","polygonObjectsCount","polygonRingsCount","polygonFeaturesCount","coordLengths","geometry","feature","point","coord","line","flatten","polygon","val","isNumeric","Math","Object","k","GlobalFeatureIdsDataType","features","points","positions","globalFeatureIds","featureIds","numericProps","properties","Array","fields","lines","pathIndices","polygons","polygonIndices","primitivePolygonIndices","object","indexMap","pointPosition","pointFeature","linePosition","linePath","lineFeature","polygonPosition","polygonObject","polygonRing","polygonFeature","handlePoint","keepStringProperties","handleMultiPoint","handleLineString","handleMultiLineString","handlePolygon","handleMultiPolygon","makeAccessorObjects","fillNumericProperties","fillCoords","nPositions","coords","ring","returnObj","value","size","type","numericPropName","props","numericKeys","index","startVertex","array","Number"],"mappings":"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","sourcesContent":["import {Feature, GeoJsonProperties} from '@loaders.gl/schema';\nimport type {BinaryFeatures} from '@loaders.gl/schema';\n\nexport type GeojsonToBinaryOptions = {\n  coordLength?: number;\n  numericPropKeys?: string[];\n  PositionDataType?: Function;\n};\n\n/** Convert GeoJSON features to flat binary arrays */\nexport function geojsonToBinary(\n  features: Feature[],\n  options: GeojsonToBinaryOptions = {}\n): BinaryFeatures {\n  const firstPassData = firstPass(features);\n  return secondPass(features, firstPassData, {\n    coordLength: options.coordLength || firstPassData.coordLength,\n    numericPropKeys: options.numericPropKeys || firstPassData.numericPropKeys,\n    PositionDataType: options.PositionDataType || Float32Array\n  });\n}\n\nexport const TEST_EXPORTS = {\n  firstPass,\n  secondPass\n};\n\ntype FirstPassData = {\n  coordLength: number;\n  numericPropKeys: string[];\n\n  pointPositionsCount: number;\n  pointFeaturesCount: number;\n  linePositionsCount: number;\n  linePathsCount: number;\n  lineFeaturesCount: number;\n  polygonPositionsCount: number;\n  polygonObjectsCount: number;\n  polygonRingsCount: number;\n  polygonFeaturesCount: number;\n};\n\n/**\n *  Initial scan over GeoJSON features\n *  Counts number of coordinates of each geometry type and\n *  keeps track of the max coordinate dimensions\n */\n// eslint-disable-next-line complexity, max-statements\nfunction firstPass(features: Feature[]): FirstPassData {\n  // Counts the number of _positions_, so [x, y, z] counts as one\n  let pointPositionsCount = 0;\n  let pointFeaturesCount = 0;\n  let linePositionsCount = 0;\n  let linePathsCount = 0;\n  let lineFeaturesCount = 0;\n  let polygonPositionsCount = 0;\n  let polygonObjectsCount = 0;\n  let polygonRingsCount = 0;\n  let polygonFeaturesCount = 0;\n  const coordLengths = new Set<number>();\n  const numericPropKeys = {};\n\n  for (const feature of features) {\n    const geometry = feature.geometry;\n    switch (geometry.type) {\n      case 'Point':\n        pointFeaturesCount++;\n        pointPositionsCount++;\n        coordLengths.add(geometry.coordinates.length);\n        break;\n      case 'MultiPoint':\n        pointFeaturesCount++;\n        pointPositionsCount += geometry.coordinates.length;\n        for (const point of geometry.coordinates) {\n          coordLengths.add(point.length);\n        }\n        break;\n      case 'LineString':\n        lineFeaturesCount++;\n        linePositionsCount += geometry.coordinates.length;\n        linePathsCount++;\n\n        for (const coord of geometry.coordinates) {\n          coordLengths.add(coord.length);\n        }\n        break;\n      case 'MultiLineString':\n        lineFeaturesCount++;\n        for (const line of geometry.coordinates) {\n          linePositionsCount += line.length;\n          linePathsCount++;\n\n          // eslint-disable-next-line max-depth\n          for (const coord of line) {\n            coordLengths.add(coord.length);\n          }\n        }\n        break;\n      case 'Polygon':\n        polygonFeaturesCount++;\n        polygonObjectsCount++;\n        polygonRingsCount += geometry.coordinates.length;\n        polygonPositionsCount += flatten(geometry.coordinates).length;\n\n        for (const coord of flatten(geometry.coordinates)) {\n          coordLengths.add(coord.length);\n        }\n        break;\n      case 'MultiPolygon':\n        polygonFeaturesCount++;\n        for (const polygon of geometry.coordinates) {\n          polygonObjectsCount++;\n          polygonRingsCount += polygon.length;\n          polygonPositionsCount += flatten(polygon).length;\n\n          // eslint-disable-next-line max-depth\n          for (const coord of flatten(polygon)) {\n            coordLengths.add(coord.length);\n          }\n        }\n        break;\n      default:\n        throw new Error(`Unsupported geometry type: ${geometry.type}`);\n    }\n\n    if (feature.properties) {\n      for (const key in feature.properties) {\n        const val = feature.properties[key];\n\n        // If property has not been seen before, or if property has been numeric\n        // in all previous features, check if numeric in this feature\n        // If not numeric, false is stored to prevent rechecking in the future\n        numericPropKeys[key] =\n          numericPropKeys[key] || numericPropKeys[key] === undefined\n            ? isNumeric(val)\n            : numericPropKeys[key];\n      }\n    }\n  }\n\n  return {\n    coordLength: coordLengths.size > 0 ? Math.max(...coordLengths) : 2,\n\n    pointPositionsCount,\n    pointFeaturesCount,\n    linePositionsCount,\n    linePathsCount,\n    lineFeaturesCount,\n    polygonPositionsCount,\n    polygonObjectsCount,\n    polygonRingsCount,\n    polygonFeaturesCount,\n\n    // Array of keys whose values are always numeric\n    numericPropKeys: Object.keys(numericPropKeys).filter((k) => numericPropKeys[k])\n  };\n}\n\n/**\n * Second scan over GeoJSON features\n * Fills coordinates into pre-allocated typed arrays\n */\n// eslint-disable-next-line complexity\nfunction secondPass(\n  features,\n  firstPassData: FirstPassData,\n  options: Required<GeojsonToBinaryOptions>\n) {\n  const {\n    pointPositionsCount,\n    pointFeaturesCount,\n    linePositionsCount,\n    linePathsCount,\n    lineFeaturesCount,\n    polygonPositionsCount,\n    polygonObjectsCount,\n    polygonRingsCount,\n    polygonFeaturesCount\n  } = firstPassData;\n  const {coordLength, numericPropKeys, PositionDataType = Float32Array} = options;\n  const GlobalFeatureIdsDataType = features.length > 65535 ? Uint32Array : Uint16Array;\n  const points = {\n    // @ts-ignore Typescript doesn't like dynamic constructors\n    positions: new PositionDataType(pointPositionsCount * coordLength),\n    globalFeatureIds: new GlobalFeatureIdsDataType(pointPositionsCount),\n    featureIds:\n      pointFeaturesCount > 65535\n        ? new Uint32Array(pointPositionsCount)\n        : new Uint16Array(pointPositionsCount),\n    numericProps: {},\n    properties: Array<any>(),\n    fields: Array<any>()\n  };\n  const lines = {\n    // @ts-ignore Typescript doesn't like dynamic constructors\n    positions: new PositionDataType(linePositionsCount * coordLength),\n    pathIndices:\n      linePositionsCount > 65535\n        ? new Uint32Array(linePathsCount + 1)\n        : new Uint16Array(linePathsCount + 1),\n    globalFeatureIds: new GlobalFeatureIdsDataType(linePositionsCount),\n    featureIds:\n      lineFeaturesCount > 65535\n        ? new Uint32Array(linePositionsCount)\n        : new Uint16Array(linePositionsCount),\n    numericProps: {},\n    properties: Array<any>(),\n    fields: Array<any>()\n  };\n  const polygons = {\n    // @ts-ignore Typescript doesn't like dynamic constructors\n    positions: new PositionDataType(polygonPositionsCount * coordLength),\n    polygonIndices:\n      polygonPositionsCount > 65535\n        ? new Uint32Array(polygonObjectsCount + 1)\n        : new Uint16Array(polygonObjectsCount + 1),\n    primitivePolygonIndices:\n      polygonPositionsCount > 65535\n        ? new Uint32Array(polygonRingsCount + 1)\n        : new Uint16Array(polygonRingsCount + 1),\n    globalFeatureIds: new GlobalFeatureIdsDataType(polygonPositionsCount),\n    featureIds:\n      polygonFeaturesCount > 65535\n        ? new Uint32Array(polygonPositionsCount)\n        : new Uint16Array(polygonPositionsCount),\n    numericProps: {},\n    properties: Array<any>(),\n    fields: Array<any>()\n  };\n\n  // Instantiate numeric properties arrays; one value per vertex\n  for (const object of [points, lines, polygons]) {\n    for (const propName of numericPropKeys || []) {\n      // If property has been numeric in all previous features in which the property existed, check\n      // if numeric in this feature\n      object.numericProps[propName] = new Float32Array(object.positions.length / coordLength);\n    }\n  }\n\n  // Set last element of path/polygon indices as positions length\n  lines.pathIndices[linePathsCount] = linePositionsCount;\n  polygons.polygonIndices[polygonObjectsCount] = polygonPositionsCount;\n  polygons.primitivePolygonIndices[polygonRingsCount] = polygonPositionsCount;\n\n  const indexMap = {\n    pointPosition: 0,\n    pointFeature: 0,\n    linePosition: 0,\n    linePath: 0,\n    lineFeature: 0,\n    polygonPosition: 0,\n    polygonObject: 0,\n    polygonRing: 0,\n    polygonFeature: 0,\n    feature: 0\n  };\n\n  for (const feature of features) {\n    const geometry = feature.geometry;\n    const properties: GeoJsonProperties = feature.properties || {};\n\n    switch (geometry.type) {\n      case 'Point':\n        handlePoint(geometry.coordinates, points, indexMap, coordLength, properties);\n        points.properties.push(keepStringProperties(properties, numericPropKeys));\n        indexMap.pointFeature++;\n        break;\n      case 'MultiPoint':\n        handleMultiPoint(geometry.coordinates, points, indexMap, coordLength, properties);\n        points.properties.push(keepStringProperties(properties, numericPropKeys));\n        indexMap.pointFeature++;\n        break;\n      case 'LineString':\n        handleLineString(geometry.coordinates, lines, indexMap, coordLength, properties);\n        lines.properties.push(keepStringProperties(properties, numericPropKeys));\n        indexMap.lineFeature++;\n        break;\n      case 'MultiLineString':\n        handleMultiLineString(geometry.coordinates, lines, indexMap, coordLength, properties);\n        lines.properties.push(keepStringProperties(properties, numericPropKeys));\n        indexMap.lineFeature++;\n        break;\n      case 'Polygon':\n        handlePolygon(geometry.coordinates, polygons, indexMap, coordLength, properties);\n        polygons.properties.push(keepStringProperties(properties, numericPropKeys));\n        indexMap.polygonFeature++;\n        break;\n      case 'MultiPolygon':\n        handleMultiPolygon(geometry.coordinates, polygons, indexMap, coordLength, properties);\n        polygons.properties.push(keepStringProperties(properties, numericPropKeys));\n        indexMap.polygonFeature++;\n        break;\n      default:\n        throw new Error('Invalid geometry type');\n    }\n\n    indexMap.feature++;\n  }\n\n  // Wrap each array in an accessor object with value and size keys\n  return makeAccessorObjects(points, lines, polygons, coordLength);\n}\n\n/** Fills Point coordinates into points object of arrays */\nfunction handlePoint(coords, points, indexMap, coordLength, properties) {\n  points.positions.set(coords, indexMap.pointPosition * coordLength);\n  points.globalFeatureIds[indexMap.pointPosition] = indexMap.feature;\n  points.featureIds[indexMap.pointPosition] = indexMap.pointFeature;\n\n  fillNumericProperties(points, properties, indexMap.pointPosition, 1);\n  indexMap.pointPosition++;\n}\n\n/** Fills MultiPoint coordinates into points object of arrays */\nfunction handleMultiPoint(coords, points, indexMap, coordLength, properties) {\n  for (const point of coords) {\n    handlePoint(point, points, indexMap, coordLength, properties);\n  }\n}\n\n/** Fills LineString coordinates into lines object of arrays */\nfunction handleLineString(coords, lines, indexMap, coordLength, properties) {\n  lines.pathIndices[indexMap.linePath] = indexMap.linePosition;\n  indexMap.linePath++;\n\n  fillCoords(lines.positions, coords, indexMap.linePosition, coordLength);\n\n  const nPositions = coords.length;\n  fillNumericProperties(lines, properties, indexMap.linePosition, nPositions);\n\n  lines.globalFeatureIds.set(\n    new Uint32Array(nPositions).fill(indexMap.feature),\n    indexMap.linePosition\n  );\n  lines.featureIds.set(\n    new Uint32Array(nPositions).fill(indexMap.lineFeature),\n    indexMap.linePosition\n  );\n  indexMap.linePosition += nPositions;\n}\n\n/** Fills MultiLineString coordinates into lines object of arrays */\nfunction handleMultiLineString(coords, lines, indexMap, coordLength, properties) {\n  for (const line of coords) {\n    handleLineString(line, lines, indexMap, coordLength, properties);\n  }\n}\n\n/** Fills Polygon coordinates into polygons object of arrays */\nfunction handlePolygon(coords, polygons, indexMap, coordLength, properties) {\n  polygons.polygonIndices[indexMap.polygonObject] = indexMap.polygonPosition;\n  indexMap.polygonObject++;\n\n  for (const ring of coords) {\n    polygons.primitivePolygonIndices[indexMap.polygonRing] = indexMap.polygonPosition;\n    indexMap.polygonRing++;\n\n    fillCoords(polygons.positions, ring, indexMap.polygonPosition, coordLength);\n\n    const nPositions = ring.length;\n    fillNumericProperties(polygons, properties, indexMap.polygonPosition, nPositions);\n\n    polygons.globalFeatureIds.set(\n      new Uint32Array(nPositions).fill(indexMap.feature),\n      indexMap.polygonPosition\n    );\n    polygons.featureIds.set(\n      new Uint32Array(nPositions).fill(indexMap.polygonFeature),\n      indexMap.polygonPosition\n    );\n    indexMap.polygonPosition += nPositions;\n  }\n}\n\n/** Fills MultiPolygon coordinates into polygons object of arrays */\nfunction handleMultiPolygon(coords, polygons, indexMap, coordLength, properties) {\n  for (const polygon of coords) {\n    handlePolygon(polygon, polygons, indexMap, coordLength, properties);\n  }\n}\n\n/** Wrap each array in an accessor object with value and size keys */\nfunction makeAccessorObjects(points, lines, polygons, coordLength): BinaryFeatures {\n  const returnObj = {\n    points: {\n      ...points,\n      positions: {value: points.positions, size: coordLength},\n      globalFeatureIds: {value: points.globalFeatureIds, size: 1},\n      featureIds: {value: points.featureIds, size: 1},\n      type: 'Point'\n    },\n    lines: {\n      ...lines,\n      pathIndices: {value: lines.pathIndices, size: 1},\n      positions: {value: lines.positions, size: coordLength},\n      globalFeatureIds: {value: lines.globalFeatureIds, size: 1},\n      featureIds: {value: lines.featureIds, size: 1},\n      type: 'LineString'\n    },\n    polygons: {\n      ...polygons,\n      polygonIndices: {value: polygons.polygonIndices, size: 1},\n      primitivePolygonIndices: {value: polygons.primitivePolygonIndices, size: 1},\n      positions: {value: polygons.positions, size: coordLength},\n      globalFeatureIds: {value: polygons.globalFeatureIds, size: 1},\n      featureIds: {value: polygons.featureIds, size: 1},\n      type: 'Polygon'\n    }\n  };\n\n  for (const geomType in returnObj) {\n    for (const numericProp in returnObj[geomType].numericProps) {\n      returnObj[geomType].numericProps[numericProp] = {\n        value: returnObj[geomType].numericProps[numericProp],\n        size: 1\n      };\n    }\n  }\n\n  return returnObj as unknown as BinaryFeatures;\n}\n\n/** Add numeric properties to object */\nfunction fillNumericProperties(object, properties, index, length) {\n  for (const numericPropName in object.numericProps) {\n    if (numericPropName in properties) {\n      object.numericProps[numericPropName].set(\n        new Array(length).fill(properties[numericPropName]),\n        index\n      );\n    }\n  }\n}\n\n/** Keep string properties in object */\nfunction keepStringProperties(properties, numericKeys: string[]): GeoJsonProperties {\n  const props = {};\n  for (const key in properties) {\n    if (!numericKeys.includes(key)) {\n      props[key] = properties[key];\n    }\n  }\n  return props;\n}\n\n/** @param coords is expected to be a list of arrays, each with length 2-3 */\nfunction fillCoords(array, coords, startVertex, coordLength): void {\n  let index = startVertex * coordLength;\n  for (const coord of coords) {\n    array.set(coord, index);\n    index += coordLength;\n  }\n}\n\n// TODO - how does this work? Different `coordinates` have different nesting\nfunction flatten(arrays): number[][] {\n  return [].concat(...arrays);\n}\n\nfunction isNumeric(x: any): boolean {\n  return Number.isFinite(x);\n}\n"]},"metadata":{},"sourceType":"module"}