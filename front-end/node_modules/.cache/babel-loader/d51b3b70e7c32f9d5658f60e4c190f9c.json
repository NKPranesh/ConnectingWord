{"ast":null,"code":"const SVG_DATA_URL_PATTERN = /^data:image\\/svg\\+xml/;\nconst SVG_URL_PATTERN = /\\.svg((\\?|#).*)?$/;\nexport function isSVG(url) {\n  return url && (SVG_DATA_URL_PATTERN.test(url) || SVG_URL_PATTERN.test(url));\n}\nexport function getBlobOrSVGDataUrl(arrayBuffer, url) {\n  if (isSVG(url)) {\n    const textDecoder = new TextDecoder();\n    let xmlText = textDecoder.decode(arrayBuffer);\n\n    try {\n      if (typeof unescape === 'function' && typeof encodeURIComponent === 'function') {\n        xmlText = unescape(encodeURIComponent(xmlText));\n      }\n    } catch (error) {\n      throw new Error(error.message);\n    }\n\n    const src = \"data:image/svg+xml;base64,\".concat(btoa(xmlText));\n    return src;\n  }\n\n  return getBlob(arrayBuffer, url);\n}\nexport function getBlob(arrayBuffer, url) {\n  if (isSVG(url)) {\n    throw new Error('SVG cannot be parsed directly to imagebitmap');\n  }\n\n  return new Blob([new Uint8Array(arrayBuffer)]);\n}","map":{"version":3,"sources":["../../../../src/lib/parsers/svg-utils.ts"],"names":["SVG_DATA_URL_PATTERN","SVG_URL_PATTERN","url","isSVG","textDecoder","xmlText","unescape","encodeURIComponent","error","src","btoa","getBlob"],"mappings":"AAGA,MAAMA,oBAAoB,GAA1B,uBAAA;AACA,MAAMC,eAAe,GAArB,mBAAA;AAEA,OAAO,SAAA,KAAA,CAAA,GAAA,EAAoB;AACzB,SAAOC,GAAG,KAAKF,oBAAoB,CAApBA,IAAAA,CAAAA,GAAAA,KAAkCC,eAAe,CAAfA,IAAAA,CAAjD,GAAiDA,CAAvC,CAAV;AACD;AAED,OAAO,SAAA,mBAAA,CAAA,WAAA,EAAA,GAAA,EAA+C;AACpD,MAAIE,KAAK,CAAT,GAAS,CAAT,EAAgB;AAEd,UAAMC,WAAW,GAAG,IAApB,WAAoB,EAApB;AACA,QAAIC,OAAO,GAAGD,WAAW,CAAXA,MAAAA,CAAd,WAAcA,CAAd;;AAEA,QAAI;AACF,UAAI,OAAA,QAAA,KAAA,UAAA,IAAkC,OAAA,kBAAA,KAAtC,UAAA,EAAgF;AAC9EC,QAAAA,OAAO,GAAGC,QAAQ,CAACC,kBAAkB,CAArCF,OAAqC,CAAnB,CAAlBA;AACD;AAHH,KAAA,CAIE,OAAA,KAAA,EAAc;AACd,YAAM,IAAA,KAAA,CAAWG,KAAD,CAAhB,OAAM,CAAN;AACD;;AAED,UAAMC,GAAG,GAAA,6BAAA,MAAA,CAAgCC,IAAI,CAA7C,OAA6C,CAApC,CAAT;AACA,WAAA,GAAA;AACD;;AACD,SAAOC,OAAO,CAAA,WAAA,EAAd,GAAc,CAAd;AACD;AAED,OAAO,SAAA,OAAA,CAAA,WAAA,EAAA,GAAA,EAAmC;AACxC,MAAIR,KAAK,CAAT,GAAS,CAAT,EAAgB;AAGd,UAAM,IAAA,KAAA,CAAN,8CAAM,CAAN;AACD;;AAED,SAAO,IAAA,IAAA,CAAS,CAAC,IAAA,UAAA,CAAjB,WAAiB,CAAD,CAAT,CAAP;AACD","sourcesContent":["// SVG parsing has limitations, e.g:\n// https://bugs.chromium.org/p/chromium/issues/detail?id=606319\n\nconst SVG_DATA_URL_PATTERN = /^data:image\\/svg\\+xml/;\nconst SVG_URL_PATTERN = /\\.svg((\\?|#).*)?$/;\n\nexport function isSVG(url) {\n  return url && (SVG_DATA_URL_PATTERN.test(url) || SVG_URL_PATTERN.test(url));\n}\n\nexport function getBlobOrSVGDataUrl(arrayBuffer, url) {\n  if (isSVG(url)) {\n    // Prepare a properly tagged data URL, and load using normal mechanism\n    const textDecoder = new TextDecoder();\n    let xmlText = textDecoder.decode(arrayBuffer);\n    // TODO Escape in browser to support e.g. Chinese characters\n    try {\n      if (typeof unescape === 'function' && typeof encodeURIComponent === 'function') {\n        xmlText = unescape(encodeURIComponent(xmlText));\n      }\n    } catch (error) {\n      throw new Error((error as Error).message);\n    }\n    // base64 encoding is safer. utf-8 fails in some browsers\n    const src = `data:image/svg+xml;base64,${btoa(xmlText)}`;\n    return src;\n  }\n  return getBlob(arrayBuffer, url);\n}\n\nexport function getBlob(arrayBuffer, url) {\n  if (isSVG(url)) {\n    // https://bugs.chromium.org/p/chromium/issues/detail?id=606319\n    // return new Blob([new Uint8Array(arrayBuffer)], {type: 'image/svg+xml'});\n    throw new Error('SVG cannot be parsed directly to imagebitmap');\n  }\n  // TODO - how to determine mime type? Param? Sniff here?\n  return new Blob([new Uint8Array(arrayBuffer)]); // MIME type not needed?\n}\n"]},"metadata":{},"sourceType":"module"}