{"ast":null,"code":"import Resource from './resource';\nimport { FEATURES, hasFeatures } from '../features';\nimport { isWebGL2 } from '@luma.gl/gltools';\nimport { assert } from '../utils/assert';\nconst GL_QUERY_RESULT = 0x8866;\nconst GL_QUERY_RESULT_AVAILABLE = 0x8867;\nconst GL_TIME_ELAPSED_EXT = 0x88bf;\nconst GL_GPU_DISJOINT_EXT = 0x8fbb;\nconst GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN = 0x8c88;\nconst GL_ANY_SAMPLES_PASSED = 0x8c2f;\nconst GL_ANY_SAMPLES_PASSED_CONSERVATIVE = 0x8d6a;\nexport default class Query extends Resource {\n  static isSupported(gl) {\n    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    const webgl2 = isWebGL2(gl);\n    const hasTimerQuery = hasFeatures(gl, FEATURES.TIMER_QUERY);\n    let supported = webgl2 || hasTimerQuery;\n\n    for (const key of opts) {\n      switch (key) {\n        case 'queries':\n          supported = supported && webgl2;\n          break;\n\n        case 'timers':\n          supported = supported && hasTimerQuery;\n          break;\n\n        default:\n          assert(false);\n      }\n    }\n\n    return supported;\n  }\n\n  constructor(gl) {\n    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super(gl, opts);\n    this.target = null;\n    this._queryPending = false;\n    this._pollingPromise = null;\n    Object.seal(this);\n  }\n\n  beginTimeElapsedQuery() {\n    return this.begin(GL_TIME_ELAPSED_EXT);\n  }\n\n  beginOcclusionQuery() {\n    let {\n      conservative = false\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return this.begin(conservative ? GL_ANY_SAMPLES_PASSED_CONSERVATIVE : GL_ANY_SAMPLES_PASSED);\n  }\n\n  beginTransformFeedbackQuery() {\n    return this.begin(GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN);\n  }\n\n  begin(target) {\n    if (this._queryPending) {\n      return this;\n    }\n\n    this.target = target;\n    this.gl2.beginQuery(this.target, this.handle);\n    return this;\n  }\n\n  end() {\n    if (this._queryPending) {\n      return this;\n    }\n\n    if (this.target) {\n      this.gl2.endQuery(this.target);\n      this.target = null;\n      this._queryPending = true;\n    }\n\n    return this;\n  }\n\n  isResultAvailable() {\n    if (!this._queryPending) {\n      return false;\n    }\n\n    const resultAvailable = this.gl2.getQueryParameter(this.handle, GL_QUERY_RESULT_AVAILABLE);\n\n    if (resultAvailable) {\n      this._queryPending = false;\n    }\n\n    return resultAvailable;\n  }\n\n  isTimerDisjoint() {\n    return this.gl2.getParameter(GL_GPU_DISJOINT_EXT);\n  }\n\n  getResult() {\n    return this.gl2.getQueryParameter(this.handle, GL_QUERY_RESULT);\n  }\n\n  getTimerMilliseconds() {\n    return this.getResult() / 1e6;\n  }\n\n  createPoll() {\n    let limit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Number.POSITIVE_INFINITY;\n\n    if (this._pollingPromise) {\n      return this._pollingPromise;\n    }\n\n    let counter = 0;\n    this._pollingPromise = new Promise((resolve, reject) => {\n      const poll = () => {\n        if (this.isResultAvailable()) {\n          resolve(this.getResult());\n          this._pollingPromise = null;\n        } else if (counter++ > limit) {\n          reject('Timed out');\n          this._pollingPromise = null;\n        } else {\n          requestAnimationFrame(poll);\n        }\n      };\n\n      requestAnimationFrame(poll);\n    });\n    return this._pollingPromise;\n  }\n\n  _createHandle() {\n    return Query.isSupported(this.gl) ? this.gl2.createQuery() : null;\n  }\n\n  _deleteHandle() {\n    this.gl2.deleteQuery(this.handle);\n  }\n\n}","map":{"version":3,"sources":["../../../src/classes/query.js"],"names":["GL_QUERY_RESULT","GL_QUERY_RESULT_AVAILABLE","GL_TIME_ELAPSED_EXT","GL_GPU_DISJOINT_EXT","GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN","GL_ANY_SAMPLES_PASSED","GL_ANY_SAMPLES_PASSED_CONSERVATIVE","isSupported","opts","webgl2","isWebGL2","hasTimerQuery","hasFeatures","FEATURES","supported","assert","constructor","Object","beginTimeElapsedQuery","beginOcclusionQuery","conservative","beginTransformFeedbackQuery","begin","end","isResultAvailable","resultAvailable","isTimerDisjoint","getResult","getTimerMilliseconds","createPoll","limit","Number","counter","poll","resolve","reject","requestAnimationFrame","_createHandle","Query","_deleteHandle"],"mappings":"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","sourcesContent":["// WebGL2 Query (also handles disjoint timer extensions)\nimport Resource from './resource';\nimport {FEATURES, hasFeatures} from '../features';\nimport {isWebGL2} from '@luma.gl/gltools';\nimport {assert} from '../utils/assert';\n\nconst GL_QUERY_RESULT = 0x8866; // Returns a GLuint containing the query result.\nconst GL_QUERY_RESULT_AVAILABLE = 0x8867; // whether query result is available.\n\nconst GL_TIME_ELAPSED_EXT = 0x88bf; // Elapsed time (in nanoseconds).\nconst GL_GPU_DISJOINT_EXT = 0x8fbb; // Whether GPU performed any disjoint operation.\n\nconst GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN = 0x8c88; // #primitives written to feedback buffers\nconst GL_ANY_SAMPLES_PASSED = 0x8c2f; // Occlusion query (if drawing passed depth test)\nconst GL_ANY_SAMPLES_PASSED_CONSERVATIVE = 0x8d6a; // Occlusion query less accurate/faster version\n\nexport default class Query extends Resource {\n  // Returns true if Query is supported by the WebGL implementation\n  // Can also check whether timestamp queries are available.\n  static isSupported(gl, opts = []) {\n    const webgl2 = isWebGL2(gl);\n\n    // Initial value\n    const hasTimerQuery = hasFeatures(gl, FEATURES.TIMER_QUERY);\n    let supported = webgl2 || hasTimerQuery;\n\n    for (const key of opts) {\n      switch (key) {\n        case 'queries':\n          supported = supported && webgl2;\n          break;\n        case 'timers':\n          supported = supported && hasTimerQuery;\n          break;\n        default:\n          assert(false);\n      }\n    }\n\n    return supported;\n  }\n\n  // Create a query class\n  constructor(gl, opts = {}) {\n    super(gl, opts);\n\n    this.target = null;\n    this._queryPending = false;\n    this._pollingPromise = null;\n\n    Object.seal(this);\n  }\n\n  // Shortcut for timer query (dependent on extension in both WebGL1 and 2)\n  // Measures GPU time delta between this call and a matching `end` call in the\n  // GPU instruction stream.\n  beginTimeElapsedQuery() {\n    return this.begin(GL_TIME_ELAPSED_EXT);\n  }\n\n  // Shortcut for occlusion queries\n  beginOcclusionQuery({conservative = false} = {}) {\n    return this.begin(conservative ? GL_ANY_SAMPLES_PASSED_CONSERVATIVE : GL_ANY_SAMPLES_PASSED);\n  }\n\n  // Shortcut for transformFeedbackQuery\n  beginTransformFeedbackQuery() {\n    return this.begin(GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN);\n  }\n\n  // Due to OpenGL API limitations, after calling `begin()` on one Query\n  // instance, `end()` must be called on that same instance before\n  // calling `begin()` on another query. While there can be multiple\n  // outstanding queries representing disjoint `begin()`/`end()` intervals.\n  // It is not possible to interleave or overlap `begin` and `end` calls.\n  begin(target) {\n    // Don't start a new query if one is already active.\n    if (this._queryPending) {\n      return this;\n    }\n\n    this.target = target;\n    this.gl2.beginQuery(this.target, this.handle);\n\n    return this;\n  }\n\n  // ends the current query\n  end() {\n    // Can't end a new query if the last one hasn't been resolved.\n    if (this._queryPending) {\n      return this;\n    }\n\n    if (this.target) {\n      this.gl2.endQuery(this.target);\n      this.target = null;\n      this._queryPending = true;\n    }\n    return this;\n  }\n\n  // Returns true if the query result is available\n  isResultAvailable() {\n    if (!this._queryPending) {\n      return false;\n    }\n\n    const resultAvailable = this.gl2.getQueryParameter(this.handle, GL_QUERY_RESULT_AVAILABLE);\n    if (resultAvailable) {\n      this._queryPending = false;\n    }\n    return resultAvailable;\n  }\n\n  // Timing query is disjoint, i.e. results are invalid\n  isTimerDisjoint() {\n    return this.gl2.getParameter(GL_GPU_DISJOINT_EXT);\n  }\n\n  // Returns query result.\n  getResult() {\n    return this.gl2.getQueryParameter(this.handle, GL_QUERY_RESULT);\n  }\n\n  // Returns the query result, converted to milliseconds to match JavaScript conventions.\n  getTimerMilliseconds() {\n    return this.getResult() / 1e6;\n  }\n\n  // Polls the query\n  createPoll(limit = Number.POSITIVE_INFINITY) {\n    if (this._pollingPromise) {\n      return this._pollingPromise;\n    }\n\n    let counter = 0;\n\n    this._pollingPromise = new Promise((resolve, reject) => {\n      const poll = () => {\n        if (this.isResultAvailable()) {\n          resolve(this.getResult());\n          this._pollingPromise = null;\n        } else if (counter++ > limit) {\n          reject('Timed out');\n          this._pollingPromise = null;\n        } else {\n          requestAnimationFrame(poll);\n        }\n      };\n\n      requestAnimationFrame(poll);\n    });\n\n    return this._pollingPromise;\n  }\n\n  _createHandle() {\n    return Query.isSupported(this.gl) ? this.gl2.createQuery() : null;\n  }\n\n  _deleteHandle() {\n    this.gl2.deleteQuery(this.handle);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}