{"ast":null,"code":"import { CompositeLayer, log } from '@deck.gl/core';\nimport { MVTLayer } from '@deck.gl/geo-layers';\nimport { GeoJsonLayer } from '@deck.gl/layers';\nimport { getData, getDataV2, API_VERSIONS } from '../api';\nimport { MAP_TYPES } from '../api/maps-api-common';\nimport { getDefaultCredentials } from '../config';\nconst defaultProps = {\n  data: null,\n  type: null,\n  onDataLoad: {\n    type: 'function',\n    value: data => {},\n    compare: false\n  },\n  onDataError: {\n    type: 'function',\n    value: null,\n    compare: false,\n    optional: true\n  },\n  credentials: null,\n  connection: null,\n  geoColumn: null,\n  columns: {\n    type: 'array',\n    value: null\n  }\n};\nexport default class CartoLayer extends CompositeLayer {\n  initializeState() {\n    this.state = {\n      data: null,\n      apiVersion: null\n    };\n  }\n\n  get isLoaded() {\n    return this.getSubLayers().length > 0 && super.isLoaded;\n  }\n\n  _checkProps(props) {\n    const {\n      type,\n      credentials,\n      connection,\n      geoColumn,\n      columns\n    } = props;\n    const localCreds = { ...getDefaultCredentials(),\n      ...credentials\n    };\n    const {\n      apiVersion\n    } = localCreds;\n    log.assert(Object.values(API_VERSIONS).includes(apiVersion), \"Invalid apiVersion \".concat(apiVersion, \". Use API_VERSIONS enum.\"));\n\n    if (apiVersion === API_VERSIONS.V1 || apiVersion === API_VERSIONS.V2) {\n      log.assert(type === MAP_TYPES.QUERY || type === MAP_TYPES.TILESET, \"Invalid type \".concat(type, \". Use type MAP_TYPES.QUERY or MAP_TYPES.TILESET for apiVersion \").concat(apiVersion));\n      log.assert(!connection, \"Connection prop is not supported for apiVersion \".concat(apiVersion));\n      log.assert(!geoColumn, \"geoColumn prop is not supported for apiVersion \".concat(apiVersion));\n      log.assert(!columns, \"columns prop is not supported for apiVersion \".concat(apiVersion));\n    } else if (apiVersion === API_VERSIONS.V3) {\n      log.assert(connection, 'Missing mandatory connection parameter');\n      log.assert(Object.values(MAP_TYPES).includes(type), \"Invalid type \".concat(type, \". Use MAP_TYPES enum.\"));\n\n      if (type !== MAP_TYPES.TABLE) {\n        log.assert(!geoColumn, \"geoColumn prop is only supported for type \".concat(MAP_TYPES.TABLE));\n        log.assert(!columns, \"columns prop is only supported for type \".concat(MAP_TYPES.TABLE));\n      }\n\n      if (columns) {\n        log.assert(Array.isArray(columns), 'columns prop must be an Array');\n      }\n    }\n  }\n\n  updateState(_ref) {\n    let {\n      props,\n      oldProps,\n      changeFlags\n    } = _ref;\n\n    this._checkProps(props);\n\n    const shouldUpdateData = changeFlags.dataChanged || props.connection !== oldProps.connection || props.geoColumn !== oldProps.geoColumn || JSON.stringify(props.columns) !== JSON.stringify(oldProps.columns) || props.type !== oldProps.type || JSON.stringify(props.credentials) !== JSON.stringify(oldProps.credentials);\n\n    if (shouldUpdateData) {\n      this.setState({\n        data: null,\n        apiVersion: null\n      });\n\n      this._updateData();\n    }\n  }\n\n  async _updateData() {\n    try {\n      const {\n        type,\n        data: source,\n        connection,\n        credentials,\n        geoColumn,\n        columns\n      } = this.props;\n      const localConfig = { ...getDefaultCredentials(),\n        ...credentials\n      };\n      const {\n        apiVersion\n      } = localConfig;\n      let data;\n\n      if (apiVersion === API_VERSIONS.V3) {\n        data = await getData({\n          type,\n          source,\n          connection,\n          credentials,\n          geoColumn,\n          columns\n        });\n      } else if (apiVersion === API_VERSIONS.V1 || apiVersion === API_VERSIONS.V2) {\n        data = await getDataV2({\n          type,\n          source,\n          credentials\n        });\n      } else {\n        log.assert(\"Unknow apiVersion \".concat(apiVersion, \". Use API_VERSIONS enum.\"));\n      }\n\n      this.setState({\n        data,\n        apiVersion\n      });\n      this.props.onDataLoad(data);\n    } catch (err) {\n      if (this.props.onDataError) {\n        this.props.onDataError(err);\n      } else {\n        throw err;\n      }\n    }\n  }\n\n  renderLayers() {\n    const {\n      data,\n      apiVersion\n    } = this.state;\n    const {\n      type\n    } = this.props;\n    if (!data) return null;\n    const {\n      updateTriggers\n    } = this.props;\n    let layer;\n\n    if (apiVersion === API_VERSIONS.V1 || apiVersion === API_VERSIONS.V2 || type === MAP_TYPES.TILESET) {\n      layer = MVTLayer;\n    } else {\n      layer = GeoJsonLayer;\n    }\n\n    const props = { ...this.props\n    };\n    delete props.data;\n    return new layer(props, this.getSubLayerProps({\n      id: \"carto-\".concat(layer.layerName),\n      data,\n      updateTriggers\n    }));\n  }\n\n}\nCartoLayer.layerName = 'CartoLayer';\nCartoLayer.defaultProps = defaultProps;","map":{"version":3,"sources":["../../../src/layers/carto-layer.js"],"names":["defaultProps","data","type","onDataLoad","value","compare","onDataError","optional","credentials","connection","geoColumn","columns","initializeState","apiVersion","isLoaded","_checkProps","localCreds","getDefaultCredentials","log","Object","API_VERSIONS","MAP_TYPES","Array","updateState","changeFlags","shouldUpdateData","props","oldProps","JSON","_updateData","localConfig","getData","getDataV2","renderLayers","updateTriggers","layer","id","CartoLayer"],"mappings":"AAAA,SAAA,cAAA,EAAA,GAAA,QAAA,eAAA;AACA,SAAA,QAAA,QAAA,qBAAA;AACA,SAAA,YAAA,QAAA,iBAAA;AACA,SAAA,OAAA,EAAA,SAAA,EAAA,YAAA,QAAA,QAAA;AACA,SAAA,SAAA,QAAA,wBAAA;AACA,SAAA,qBAAA,QAAA,WAAA;AAEA,MAAMA,YAAY,GAAG;AAEnBC,EAAAA,IAAI,EAFe,IAAA;AAInBC,EAAAA,IAAI,EAJe,IAAA;AAKnBC,EAAAA,UAAU,EAAE;AAACD,IAAAA,IAAI,EAAL,UAAA;AAAmBE,IAAAA,KAAK,EAAEH,IAAI,IAAI,CAAlC,CAAA;AAAsCI,IAAAA,OAAO,EAAE;AAA/C,GALO;AAMnBC,EAAAA,WAAW,EAAE;AAACJ,IAAAA,IAAI,EAAL,UAAA;AAAmBE,IAAAA,KAAK,EAAxB,IAAA;AAAgCC,IAAAA,OAAO,EAAvC,KAAA;AAAgDE,IAAAA,QAAQ,EAAE;AAA1D,GANM;AASnBC,EAAAA,WAAW,EATQ,IAAA;AAenBC,EAAAA,UAAU,EAfS,IAAA;AAkBnBC,EAAAA,SAAS,EAlBU,IAAA;AAqBnBC,EAAAA,OAAO,EAAE;AAACT,IAAAA,IAAI,EAAL,OAAA;AAAgBE,IAAAA,KAAK,EAAE;AAAvB;AArBU,CAArB;AAwBA,eAAe,MAAA,UAAA,SAAA,cAAA,CAAwC;AACrDQ,EAAAA,eAAe,GAAG;AAChB,SAAA,KAAA,GAAa;AACXX,MAAAA,IAAI,EADO,IAAA;AAEXY,MAAAA,UAAU,EAAE;AAFD,KAAb;AAID;;AAED,MAAIC,QAAJ,GAAe;AACb,WAAO,KAAA,YAAA,GAAA,MAAA,GAAA,CAAA,IAAkC,MAAzC,QAAA;AACD;;AAEDC,EAAAA,WAAW,CAAA,KAAA,EAAQ;AACjB,UAAM;AAAA,MAAA,IAAA;AAAA,MAAA,WAAA;AAAA,MAAA,UAAA;AAAA,MAAA,SAAA;AAA2CJ,MAAAA;AAA3C,QAAN,KAAA;AACA,UAAMK,UAAU,GAAG,EAAC,GAAGC,qBAAJ,EAAA;AAA6B,SAAGT;AAAhC,KAAnB;AACA,UAAM;AAACK,MAAAA;AAAD,QAAN,UAAA;AAEAK,IAAAA,GAAG,CAAHA,MAAAA,CACEC,MAAM,CAANA,MAAAA,CAAAA,YAAAA,EAAAA,QAAAA,CADFD,UACEC,CADFD,EAAAA,sBAAAA,MAAAA,CAAAA,UAAAA,EAAAA,0BAAAA,CAAAA;;AAKA,QAAIL,UAAU,KAAKO,YAAY,CAA3BP,EAAAA,IAAkCA,UAAU,KAAKO,YAAY,CAAjE,EAAA,EAAsE;AACpEF,MAAAA,GAAG,CAAHA,MAAAA,CACEhB,IAAI,KAAKmB,SAAS,CAAlBnB,KAAAA,IAA4BA,IAAI,KAAKmB,SAAS,CADhDH,OAAAA,EAAAA,gBAAAA,MAAAA,CAAAA,IAAAA,EAAAA,iEAAAA,EAAAA,MAAAA,CAAAA,UAAAA,CAAAA;AAIAA,MAAAA,GAAG,CAAHA,MAAAA,CAAW,CAAXA,UAAAA,EAAAA,mDAAAA,MAAAA,CAAAA,UAAAA,CAAAA;AACAA,MAAAA,GAAG,CAAHA,MAAAA,CAAW,CAAXA,SAAAA,EAAAA,kDAAAA,MAAAA,CAAAA,UAAAA,CAAAA;AACAA,MAAAA,GAAG,CAAHA,MAAAA,CAAW,CAAXA,OAAAA,EAAAA,gDAAAA,MAAAA,CAAAA,UAAAA,CAAAA;AAPF,KAAA,MAQO,IAAIL,UAAU,KAAKO,YAAY,CAA/B,EAAA,EAAoC;AACzCF,MAAAA,GAAG,CAAHA,MAAAA,CAAAA,UAAAA,EAAAA,wCAAAA;AACAA,MAAAA,GAAG,CAAHA,MAAAA,CACEC,MAAM,CAANA,MAAAA,CAAAA,SAAAA,EAAAA,QAAAA,CADFD,IACEC,CADFD,EAAAA,gBAAAA,MAAAA,CAAAA,IAAAA,EAAAA,uBAAAA,CAAAA;;AAIA,UAAIhB,IAAI,KAAKmB,SAAS,CAAtB,KAAA,EAA8B;AAC5BH,QAAAA,GAAG,CAAHA,MAAAA,CAAW,CAAXA,SAAAA,EAAAA,6CAAAA,MAAAA,CAAoEG,SAAS,CAA7EH,KAAAA,CAAAA;AACAA,QAAAA,GAAG,CAAHA,MAAAA,CAAW,CAAXA,OAAAA,EAAAA,2CAAAA,MAAAA,CAAgEG,SAAS,CAAzEH,KAAAA,CAAAA;AACD;;AACD,UAAA,OAAA,EAAa;AACXA,QAAAA,GAAG,CAAHA,MAAAA,CAAWI,KAAK,CAALA,OAAAA,CAAXJ,OAAWI,CAAXJ,EAAAA,+BAAAA;AACD;AACF;AACF;;AAEDK,EAAAA,WAAW,OAAiC;AAAA,QAAhC;AAAA,MAAA,KAAA;AAAA,MAAA,QAAA;AAAkBC,MAAAA;AAAlB,KAAgC;;AAC1C,SAAA,WAAA,CAAA,KAAA;;AACA,UAAMC,gBAAgB,GACpBD,WAAW,CAAXA,WAAAA,IACAE,KAAK,CAALA,UAAAA,KAAqBC,QAAQ,CAD7BH,UAAAA,IAEAE,KAAK,CAALA,SAAAA,KAAoBC,QAAQ,CAF5BH,SAAAA,IAGAI,IAAI,CAAJA,SAAAA,CAAeF,KAAK,CAApBE,OAAAA,MAAkCA,IAAI,CAAJA,SAAAA,CAAeD,QAAQ,CAHzDH,OAGkCI,CAHlCJ,IAIAE,KAAK,CAALA,IAAAA,KAAeC,QAAQ,CAJvBH,IAAAA,IAKAI,IAAI,CAAJA,SAAAA,CAAeF,KAAK,CAApBE,WAAAA,MAAsCA,IAAI,CAAJA,SAAAA,CAAeD,QAAQ,CAN/D,WAMwCC,CANxC;;AAQA,QAAA,gBAAA,EAAsB;AACpB,WAAA,QAAA,CAAc;AAAC3B,QAAAA,IAAI,EAAL,IAAA;AAAaY,QAAAA,UAAU,EAAE;AAAzB,OAAd;;AACA,WAAA,WAAA;AACD;AACF;;AAED,QAAMgB,WAAN,GAAoB;AAClB,QAAI;AACF,YAAM;AAAA,QAAA,IAAA;AAAO5B,QAAAA,IAAI,EAAX,MAAA;AAAA,QAAA,UAAA;AAAA,QAAA,WAAA;AAAA,QAAA,SAAA;AAAyDU,QAAAA;AAAzD,UAAoE,KAA1E,KAAA;AACA,YAAMmB,WAAW,GAAG,EAAC,GAAGb,qBAAJ,EAAA;AAA6B,WAAGT;AAAhC,OAApB;AACA,YAAM;AAACK,QAAAA;AAAD,UAAN,WAAA;AAEA,UAAA,IAAA;;AAEA,UAAIA,UAAU,KAAKO,YAAY,CAA/B,EAAA,EAAoC;AAClCnB,QAAAA,IAAI,GAAG,MAAM8B,OAAO,CAAC;AAAA,UAAA,IAAA;AAAA,UAAA,MAAA;AAAA,UAAA,UAAA;AAAA,UAAA,WAAA;AAAA,UAAA,SAAA;AAMnBpB,UAAAA;AANmB,SAAD,CAApBV;AADF,OAAA,MASO,IAAIY,UAAU,KAAKO,YAAY,CAA3BP,EAAAA,IAAkCA,UAAU,KAAKO,YAAY,CAAjE,EAAA,EAAsE;AAC3EnB,QAAAA,IAAI,GAAG,MAAM+B,SAAS,CAAC;AAAA,UAAA,IAAA;AAAA,UAAA,MAAA;AAAexB,UAAAA;AAAf,SAAD,CAAtBP;AADK,OAAA,MAEA;AACLiB,QAAAA,GAAG,CAAHA,MAAAA,CAAAA,qBAAAA,MAAAA,CAAAA,UAAAA,EAAAA,0BAAAA,CAAAA;AACD;;AAED,WAAA,QAAA,CAAc;AAAA,QAAA,IAAA;AAAOL,QAAAA;AAAP,OAAd;AACA,WAAA,KAAA,CAAA,UAAA,CAAA,IAAA;AAvBF,KAAA,CAwBE,OAAA,GAAA,EAAY;AACZ,UAAI,KAAA,KAAA,CAAJ,WAAA,EAA4B;AAC1B,aAAA,KAAA,CAAA,WAAA,CAAA,GAAA;AADF,OAAA,MAEO;AACL,cAAA,GAAA;AACD;AACF;AACF;;AAEDoB,EAAAA,YAAY,GAAG;AACb,UAAM;AAAA,MAAA,IAAA;AAAOpB,MAAAA;AAAP,QAAqB,KAA3B,KAAA;AACA,UAAM;AAACX,MAAAA;AAAD,QAAS,KAAf,KAAA;AAEA,QAAI,CAAJ,IAAA,EAAW,OAAA,IAAA;AAEX,UAAM;AAACgC,MAAAA;AAAD,QAAmB,KAAzB,KAAA;AAEA,QAAA,KAAA;;AAEA,QACErB,UAAU,KAAKO,YAAY,CAA3BP,EAAAA,IACAA,UAAU,KAAKO,YAAY,CAD3BP,EAAAA,IAEAX,IAAI,KAAKmB,SAAS,CAHpB,OAAA,EAIE;AACAc,MAAAA,KAAK,GAALA,QAAAA;AALF,KAAA,MAMO;AACLA,MAAAA,KAAK,GAALA,YAAAA;AACD;;AAED,UAAMT,KAAK,GAAG,EAAC,GAAG,KAAKA;AAAT,KAAd;AACA,WAAOA,KAAK,CAAZ,IAAA;AAGA,WAAO,IAAA,KAAA,CAAA,KAAA,EAEL,KAAA,gBAAA,CAAsB;AACpBU,MAAAA,EAAE,EAAA,SAAA,MAAA,CAAWD,KAAK,CADE,SAClB,CADkB;AAAA,MAAA,IAAA;AAGpBD,MAAAA;AAHoB,KAAtB,CAFK,CAAP;AAQD;;AAhIoD;AAmIvDG,UAAU,CAAVA,SAAAA,GAAAA,YAAAA;AACAA,UAAU,CAAVA,YAAAA,GAAAA,YAAAA","sourcesContent":["import {CompositeLayer, log} from '@deck.gl/core';\nimport {MVTLayer} from '@deck.gl/geo-layers';\nimport {GeoJsonLayer} from '@deck.gl/layers';\nimport {getData, getDataV2, API_VERSIONS} from '../api';\nimport {MAP_TYPES} from '../api/maps-api-common';\nimport {getDefaultCredentials} from '../config';\n\nconst defaultProps = {\n  // (String, required): data resource to load. table name, sql query or tileset name.\n  data: null,\n  // (Enum (MAP_TYPES), required)\n  type: null,\n  onDataLoad: {type: 'function', value: data => {}, compare: false},\n  onDataError: {type: 'function', value: null, compare: false, optional: true},\n\n  // override carto credentials for the layer, set to null to read from default\n  credentials: null,\n\n  /*********************/\n  /* API v3 PARAMETERS */\n  /**********************/\n  // (String, required): connection name at CARTO platform\n  connection: null,\n\n  // (String, optional): name of the `geo_column` in the CARTO platform. Use this override the default column ('geom'), from which the geometry information should be fetched.\n  geoColumn: null,\n\n  // (Array<String>, optional): names of columns to fetch. By default, all columns are fetched.\n  columns: {type: 'array', value: null}\n};\n\nexport default class CartoLayer extends CompositeLayer {\n  initializeState() {\n    this.state = {\n      data: null,\n      apiVersion: null\n    };\n  }\n\n  get isLoaded() {\n    return this.getSubLayers().length > 0 && super.isLoaded;\n  }\n\n  _checkProps(props) {\n    const {type, credentials, connection, geoColumn, columns} = props;\n    const localCreds = {...getDefaultCredentials(), ...credentials};\n    const {apiVersion} = localCreds;\n\n    log.assert(\n      Object.values(API_VERSIONS).includes(apiVersion),\n      `Invalid apiVersion ${apiVersion}. Use API_VERSIONS enum.`\n    );\n\n    if (apiVersion === API_VERSIONS.V1 || apiVersion === API_VERSIONS.V2) {\n      log.assert(\n        type === MAP_TYPES.QUERY || type === MAP_TYPES.TILESET,\n        `Invalid type ${type}. Use type MAP_TYPES.QUERY or MAP_TYPES.TILESET for apiVersion ${apiVersion}`\n      );\n      log.assert(!connection, `Connection prop is not supported for apiVersion ${apiVersion}`);\n      log.assert(!geoColumn, `geoColumn prop is not supported for apiVersion ${apiVersion}`);\n      log.assert(!columns, `columns prop is not supported for apiVersion ${apiVersion}`);\n    } else if (apiVersion === API_VERSIONS.V3) {\n      log.assert(connection, 'Missing mandatory connection parameter');\n      log.assert(\n        Object.values(MAP_TYPES).includes(type),\n        `Invalid type ${type}. Use MAP_TYPES enum.`\n      );\n      if (type !== MAP_TYPES.TABLE) {\n        log.assert(!geoColumn, `geoColumn prop is only supported for type ${MAP_TYPES.TABLE}`);\n        log.assert(!columns, `columns prop is only supported for type ${MAP_TYPES.TABLE}`);\n      }\n      if (columns) {\n        log.assert(Array.isArray(columns), 'columns prop must be an Array');\n      }\n    }\n  }\n\n  updateState({props, oldProps, changeFlags}) {\n    this._checkProps(props);\n    const shouldUpdateData =\n      changeFlags.dataChanged ||\n      props.connection !== oldProps.connection ||\n      props.geoColumn !== oldProps.geoColumn ||\n      JSON.stringify(props.columns) !== JSON.stringify(oldProps.columns) ||\n      props.type !== oldProps.type ||\n      JSON.stringify(props.credentials) !== JSON.stringify(oldProps.credentials);\n\n    if (shouldUpdateData) {\n      this.setState({data: null, apiVersion: null});\n      this._updateData();\n    }\n  }\n\n  async _updateData() {\n    try {\n      const {type, data: source, connection, credentials, geoColumn, columns} = this.props;\n      const localConfig = {...getDefaultCredentials(), ...credentials};\n      const {apiVersion} = localConfig;\n\n      let data;\n\n      if (apiVersion === API_VERSIONS.V3) {\n        data = await getData({\n          type,\n          source,\n          connection,\n          credentials,\n          geoColumn,\n          columns\n        });\n      } else if (apiVersion === API_VERSIONS.V1 || apiVersion === API_VERSIONS.V2) {\n        data = await getDataV2({type, source, credentials});\n      } else {\n        log.assert(`Unknow apiVersion ${apiVersion}. Use API_VERSIONS enum.`);\n      }\n\n      this.setState({data, apiVersion});\n      this.props.onDataLoad(data);\n    } catch (err) {\n      if (this.props.onDataError) {\n        this.props.onDataError(err);\n      } else {\n        throw err;\n      }\n    }\n  }\n\n  renderLayers() {\n    const {data, apiVersion} = this.state;\n    const {type} = this.props;\n\n    if (!data) return null;\n\n    const {updateTriggers} = this.props;\n\n    let layer;\n\n    if (\n      apiVersion === API_VERSIONS.V1 ||\n      apiVersion === API_VERSIONS.V2 ||\n      type === MAP_TYPES.TILESET\n    ) {\n      layer = MVTLayer;\n    } else {\n      layer = GeoJsonLayer;\n    }\n\n    const props = {...this.props};\n    delete props.data;\n\n    // eslint-disable-next-line new-cap\n    return new layer(\n      props,\n      this.getSubLayerProps({\n        id: `carto-${layer.layerName}`,\n        data,\n        updateTriggers\n      })\n    );\n  }\n}\n\nCartoLayer.layerName = 'CartoLayer';\nCartoLayer.defaultProps = defaultProps;\n"]},"metadata":{},"sourceType":"module"}