{"ast":null,"code":"import Resource from './resource';\nimport Texture from './texture';\nimport Framebuffer from './framebuffer';\nimport { parseUniformName, getUniformSetter } from './uniforms';\nimport { VertexShader, FragmentShader } from './shader';\nimport ProgramConfiguration from './program-configuration';\nimport { copyUniform, checkUniformValues } from './uniforms';\nimport { isWebGL2, assertWebGL2Context, withParameters, log } from '@luma.gl/gltools';\nimport { getKey } from '../webgl-utils/constants-to-keys';\nimport { getPrimitiveDrawMode } from '../webgl-utils/attribute-utils';\nimport { assert } from '../utils/assert';\nimport { uid } from '../utils/utils';\nconst LOG_PROGRAM_PERF_PRIORITY = 4;\nconst GL_SEPARATE_ATTRIBS = 0x8c8d;\nconst V6_DEPRECATED_METHODS = ['setVertexArray', 'setAttributes', 'setBuffers', 'unsetBuffers', 'use', 'getUniformCount', 'getUniformInfo', 'getUniformLocation', 'getUniformValue', 'getVarying', 'getFragDataLocation', 'getAttachedShaders', 'getAttributeCount', 'getAttributeLocation', 'getAttributeInfo'];\nexport default class Program extends Resource {\n  constructor(gl) {\n    let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super(gl, props);\n    this.stubRemovedMethods('Program', 'v6.0', V6_DEPRECATED_METHODS);\n    this._isCached = false;\n    this.initialize(props);\n    Object.seal(this);\n\n    this._setId(props.id);\n  }\n\n  initialize() {\n    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const {\n      hash,\n      vs,\n      fs,\n      varyings,\n      bufferMode = GL_SEPARATE_ATTRIBS\n    } = props;\n    this.hash = hash || '';\n    this.vs = typeof vs === 'string' ? new VertexShader(this.gl, {\n      id: `${props.id}-vs`,\n      source: vs\n    }) : vs;\n    this.fs = typeof fs === 'string' ? new FragmentShader(this.gl, {\n      id: `${props.id}-fs`,\n      source: fs\n    }) : fs;\n    assert(this.vs instanceof VertexShader);\n    assert(this.fs instanceof FragmentShader);\n    this.uniforms = {};\n    this._textureUniforms = {};\n\n    if (varyings && varyings.length > 0) {\n      assertWebGL2Context(this.gl);\n      this.varyings = varyings;\n      this.gl2.transformFeedbackVaryings(this.handle, varyings, bufferMode);\n    }\n\n    this._compileAndLink();\n\n    this._readUniformLocationsFromLinkedProgram();\n\n    this.configuration = new ProgramConfiguration(this);\n    return this.setProps(props);\n  }\n\n  delete() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (this._isCached) {\n      return this;\n    }\n\n    return super.delete(options);\n  }\n\n  setProps(props) {\n    if ('uniforms' in props) {\n      this.setUniforms(props.uniforms);\n    }\n\n    return this;\n  }\n\n  draw(_ref) {\n    let {\n      logPriority,\n      drawMode = 4,\n      vertexCount,\n      offset = 0,\n      start,\n      end,\n      isIndexed = false,\n      indexType = 5123,\n      instanceCount = 0,\n      isInstanced = instanceCount > 0,\n      vertexArray = null,\n      transformFeedback,\n      framebuffer,\n      parameters = {},\n      uniforms,\n      samplers\n    } = _ref;\n\n    if (uniforms || samplers) {\n      log.deprecated('Program.draw({uniforms})', 'Program.setUniforms(uniforms)')();\n      this.setUniforms(uniforms || {});\n    }\n\n    if (log.priority >= logPriority) {\n      const fb = framebuffer ? framebuffer.id : 'default';\n      const message = `mode=${getKey(this.gl, drawMode)} verts=${vertexCount} ` + `instances=${instanceCount} indexType=${getKey(this.gl, indexType)} ` + `isInstanced=${isInstanced} isIndexed=${isIndexed} ` + `Framebuffer=${fb}`;\n      log.log(logPriority, message)();\n    }\n\n    assert(vertexArray);\n    this.gl.useProgram(this.handle);\n\n    if (!this._areTexturesRenderable() || vertexCount === 0 || isInstanced && instanceCount === 0) {\n      return false;\n    }\n\n    vertexArray.bindForDraw(vertexCount, instanceCount, () => {\n      if (framebuffer !== undefined) {\n        parameters = Object.assign({}, parameters, {\n          framebuffer\n        });\n      }\n\n      if (transformFeedback) {\n        const primitiveMode = getPrimitiveDrawMode(drawMode);\n        transformFeedback.begin(primitiveMode);\n      }\n\n      this._bindTextures();\n\n      withParameters(this.gl, parameters, () => {\n        if (isIndexed && isInstanced) {\n          this.gl2.drawElementsInstanced(drawMode, vertexCount, indexType, offset, instanceCount);\n        } else if (isIndexed && isWebGL2(this.gl) && !isNaN(start) && !isNaN(end)) {\n          this.gl2.drawRangeElements(drawMode, start, end, vertexCount, indexType, offset);\n        } else if (isIndexed) {\n          this.gl.drawElements(drawMode, vertexCount, indexType, offset);\n        } else if (isInstanced) {\n          this.gl2.drawArraysInstanced(drawMode, offset, vertexCount, instanceCount);\n        } else {\n          this.gl.drawArrays(drawMode, offset, vertexCount);\n        }\n      });\n\n      if (transformFeedback) {\n        transformFeedback.end();\n      }\n    });\n    return true;\n  }\n\n  setUniforms() {\n    let uniforms = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (log.priority >= 2) {\n      checkUniformValues(uniforms, this.id, this._uniformSetters);\n    }\n\n    this.gl.useProgram(this.handle);\n\n    for (const uniformName in uniforms) {\n      const uniform = uniforms[uniformName];\n      const uniformSetter = this._uniformSetters[uniformName];\n\n      if (uniformSetter) {\n        let value = uniform;\n        let textureUpdate = false;\n\n        if (value instanceof Framebuffer) {\n          value = value.texture;\n        }\n\n        if (value instanceof Texture) {\n          textureUpdate = this.uniforms[uniformName] !== uniform;\n\n          if (textureUpdate) {\n            if (uniformSetter.textureIndex === undefined) {\n              uniformSetter.textureIndex = this._textureIndexCounter++;\n            }\n\n            const texture = value;\n            const {\n              textureIndex\n            } = uniformSetter;\n            texture.bind(textureIndex);\n            value = textureIndex;\n            this._textureUniforms[uniformName] = texture;\n          } else {\n            value = uniformSetter.textureIndex;\n          }\n        } else if (this._textureUniforms[uniformName]) {\n          delete this._textureUniforms[uniformName];\n        }\n\n        if (uniformSetter(value) || textureUpdate) {\n          copyUniform(this.uniforms, uniformName, uniform);\n        }\n      }\n    }\n\n    return this;\n  }\n\n  _areTexturesRenderable() {\n    let texturesRenderable = true;\n\n    for (const uniformName in this._textureUniforms) {\n      const texture = this._textureUniforms[uniformName];\n      texture.update();\n      texturesRenderable = texturesRenderable && texture.loaded;\n    }\n\n    return texturesRenderable;\n  }\n\n  _bindTextures() {\n    for (const uniformName in this._textureUniforms) {\n      const textureIndex = this._uniformSetters[uniformName].textureIndex;\n\n      this._textureUniforms[uniformName].bind(textureIndex);\n    }\n  }\n\n  _createHandle() {\n    return this.gl.createProgram();\n  }\n\n  _deleteHandle() {\n    this.gl.deleteProgram(this.handle);\n  }\n\n  _getOptionsFromHandle(handle) {\n    const shaderHandles = this.gl.getAttachedShaders(handle);\n    const opts = {};\n\n    for (const shaderHandle of shaderHandles) {\n      const type = this.gl.getShaderParameter(this.handle, 35663);\n\n      switch (type) {\n        case 35633:\n          opts.vs = new VertexShader({\n            handle: shaderHandle\n          });\n          break;\n\n        case 35632:\n          opts.fs = new FragmentShader({\n            handle: shaderHandle\n          });\n          break;\n\n        default:\n      }\n    }\n\n    return opts;\n  }\n\n  _getParameter(pname) {\n    return this.gl.getProgramParameter(this.handle, pname);\n  }\n\n  _setId(id) {\n    if (!id) {\n      const programName = this._getName();\n\n      this.id = uid(programName);\n    }\n  }\n\n  _getName() {\n    let programName = this.vs.getName() || this.fs.getName();\n    programName = programName.replace(/shader/i, '');\n    programName = programName ? `${programName}-program` : 'program';\n    return programName;\n  }\n\n  _compileAndLink() {\n    const {\n      gl\n    } = this;\n    gl.attachShader(this.handle, this.vs.handle);\n    gl.attachShader(this.handle, this.fs.handle);\n    log.time(LOG_PROGRAM_PERF_PRIORITY, `linkProgram for ${this._getName()}`)();\n    gl.linkProgram(this.handle);\n    log.timeEnd(LOG_PROGRAM_PERF_PRIORITY, `linkProgram for ${this._getName()}`)();\n\n    if (gl.debug || log.level > 0) {\n      const linked = gl.getProgramParameter(this.handle, 35714);\n\n      if (!linked) {\n        throw new Error(`Error linking: ${gl.getProgramInfoLog(this.handle)}`);\n      }\n\n      gl.validateProgram(this.handle);\n      const validated = gl.getProgramParameter(this.handle, 35715);\n\n      if (!validated) {\n        throw new Error(`Error validating: ${gl.getProgramInfoLog(this.handle)}`);\n      }\n    }\n  }\n\n  _readUniformLocationsFromLinkedProgram() {\n    const {\n      gl\n    } = this;\n    this._uniformSetters = {};\n    this._uniformCount = this._getParameter(35718);\n\n    for (let i = 0; i < this._uniformCount; i++) {\n      const info = this.gl.getActiveUniform(this.handle, i);\n      const {\n        name\n      } = parseUniformName(info.name);\n      let location = gl.getUniformLocation(this.handle, name);\n      this._uniformSetters[name] = getUniformSetter(gl, location, info);\n\n      if (info.size > 1) {\n        for (let l = 0; l < info.size; l++) {\n          location = gl.getUniformLocation(this.handle, `${name}[${l}]`);\n          this._uniformSetters[`${name}[${l}]`] = getUniformSetter(gl, location, info);\n        }\n      }\n    }\n\n    this._textureIndexCounter = 0;\n  }\n\n  getActiveUniforms(uniformIndices, pname) {\n    return this.gl2.getActiveUniforms(this.handle, uniformIndices, pname);\n  }\n\n  getUniformBlockIndex(blockName) {\n    return this.gl2.getUniformBlockIndex(this.handle, blockName);\n  }\n\n  getActiveUniformBlockParameter(blockIndex, pname) {\n    return this.gl2.getActiveUniformBlockParameter(this.handle, blockIndex, pname);\n  }\n\n  uniformBlockBinding(blockIndex, blockBinding) {\n    this.gl2.uniformBlockBinding(this.handle, blockIndex, blockBinding);\n  }\n\n}","map":{"version":3,"sources":["../../../src/classes/program.js"],"names":["LOG_PROGRAM_PERF_PRIORITY","GL_SEPARATE_ATTRIBS","V6_DEPRECATED_METHODS","constructor","props","Object","initialize","bufferMode","hash","id","source","vs","fs","assert","varyings","assertWebGL2Context","delete","options","setProps","draw","drawMode","offset","isIndexed","indexType","instanceCount","isInstanced","vertexArray","parameters","samplers","uniforms","log","fb","framebuffer","message","getKey","vertexCount","primitiveMode","getPrimitiveDrawMode","transformFeedback","withParameters","isWebGL2","isNaN","setUniforms","checkUniformValues","uniform","uniformSetter","value","textureUpdate","texture","textureIndex","copyUniform","_areTexturesRenderable","texturesRenderable","_bindTextures","_createHandle","_deleteHandle","_getOptionsFromHandle","shaderHandles","opts","type","handle","shaderHandle","_getParameter","_setId","programName","uid","_getName","_compileAndLink","gl","linked","validated","_readUniformLocationsFromLinkedProgram","i","info","name","parseUniformName","location","getUniformSetter","l","getActiveUniforms","getUniformBlockIndex","getActiveUniformBlockParameter","uniformBlockBinding"],"mappings":"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","sourcesContent":["import GL from '@luma.gl/constants';\n\nimport Resource from './resource';\nimport Texture from './texture';\nimport Framebuffer from './framebuffer';\nimport {parseUniformName, getUniformSetter} from './uniforms';\nimport {VertexShader, FragmentShader} from './shader';\nimport ProgramConfiguration from './program-configuration';\nimport {copyUniform, checkUniformValues} from './uniforms';\n\nimport {isWebGL2, assertWebGL2Context, withParameters, log} from '@luma.gl/gltools';\nimport {getKey} from '../webgl-utils/constants-to-keys';\nimport {getPrimitiveDrawMode} from '../webgl-utils/attribute-utils';\nimport {assert} from '../utils/assert';\nimport {uid} from '../utils/utils';\n\nconst LOG_PROGRAM_PERF_PRIORITY = 4;\n\nconst GL_SEPARATE_ATTRIBS = 0x8c8d;\n\nconst V6_DEPRECATED_METHODS = [\n  'setVertexArray',\n  'setAttributes',\n  'setBuffers',\n  'unsetBuffers',\n\n  'use',\n  'getUniformCount',\n  'getUniformInfo',\n  'getUniformLocation',\n  'getUniformValue',\n\n  'getVarying',\n  'getFragDataLocation',\n  'getAttachedShaders',\n  'getAttributeCount',\n  'getAttributeLocation',\n  'getAttributeInfo'\n];\n\nexport default class Program extends Resource {\n  constructor(gl, props = {}) {\n    super(gl, props);\n\n    this.stubRemovedMethods('Program', 'v6.0', V6_DEPRECATED_METHODS);\n\n    // Experimental flag to avoid deleting Program object while it is cached\n    this._isCached = false;\n\n    this.initialize(props);\n\n    Object.seal(this);\n\n    this._setId(props.id);\n  }\n\n  initialize(props = {}) {\n    const {hash, vs, fs, varyings, bufferMode = GL_SEPARATE_ATTRIBS} = props;\n\n    this.hash = hash || ''; // Used by ProgramManager\n\n    // Create shaders if needed\n    this.vs =\n      typeof vs === 'string' ? new VertexShader(this.gl, {id: `${props.id}-vs`, source: vs}) : vs;\n    this.fs =\n      typeof fs === 'string' ? new FragmentShader(this.gl, {id: `${props.id}-fs`, source: fs}) : fs;\n    assert(this.vs instanceof VertexShader);\n    assert(this.fs instanceof FragmentShader);\n\n    // uniforms\n    this.uniforms = {};\n\n    this._textureUniforms = {};\n\n    // Setup varyings if supplied\n    if (varyings && varyings.length > 0) {\n      assertWebGL2Context(this.gl);\n      this.varyings = varyings;\n      this.gl2.transformFeedbackVaryings(this.handle, varyings, bufferMode);\n    }\n\n    this._compileAndLink();\n    this._readUniformLocationsFromLinkedProgram();\n    this.configuration = new ProgramConfiguration(this);\n\n    return this.setProps(props);\n  }\n\n  delete(options = {}) {\n    if (this._isCached) {\n      // This object is cached, do not delete\n      return this;\n    }\n    return super.delete(options);\n  }\n\n  setProps(props) {\n    if ('uniforms' in props) {\n      this.setUniforms(props.uniforms);\n    }\n    return this;\n  }\n\n  // A good thing about the WebGL API is that there are so many ways to draw things ;)\n  // This function unifies those ways into a single call using common parameters with sane defaults\n  draw({\n    logPriority, // Probe log priority, enables Model to do more integrated logging\n\n    drawMode = GL.TRIANGLES,\n    vertexCount,\n    offset = 0,\n    start,\n    end,\n    isIndexed = false,\n    indexType = GL.UNSIGNED_SHORT,\n    instanceCount = 0,\n    isInstanced = instanceCount > 0,\n\n    vertexArray = null,\n    transformFeedback,\n    framebuffer,\n    parameters = {},\n\n    // Deprecated\n    uniforms,\n    samplers\n  }) {\n    if (uniforms || samplers) {\n      // DEPRECATED: v7.0 (deprecated earlier but warning not properly implemented)\n      log.deprecated('Program.draw({uniforms})', 'Program.setUniforms(uniforms)')();\n      this.setUniforms(uniforms || {});\n    }\n\n    if (log.priority >= logPriority) {\n      const fb = framebuffer ? framebuffer.id : 'default';\n      const message =\n        `mode=${getKey(this.gl, drawMode)} verts=${vertexCount} ` +\n        `instances=${instanceCount} indexType=${getKey(this.gl, indexType)} ` +\n        `isInstanced=${isInstanced} isIndexed=${isIndexed} ` +\n        `Framebuffer=${fb}`;\n      log.log(logPriority, message)();\n    }\n\n    // TODO - move vertex array binding and transform feedback binding to withParameters?\n    assert(vertexArray);\n\n    this.gl.useProgram(this.handle);\n\n    if (\n      // Note: async textures set as uniforms might still be loading.\n      // Now that all uniforms have been updated, check if any texture\n      // in the uniforms is not yet initialized, then we don't draw\n      !this._areTexturesRenderable() ||\n      // Avoid WebGL draw call when not rendering any data\n      vertexCount === 0 ||\n      (isInstanced && instanceCount === 0)\n    ) {\n      return false;\n    }\n\n    vertexArray.bindForDraw(vertexCount, instanceCount, () => {\n      if (framebuffer !== undefined) {\n        parameters = Object.assign({}, parameters, {framebuffer});\n      }\n\n      if (transformFeedback) {\n        const primitiveMode = getPrimitiveDrawMode(drawMode);\n        transformFeedback.begin(primitiveMode);\n      }\n\n      this._bindTextures();\n\n      withParameters(this.gl, parameters, () => {\n        // TODO - Use polyfilled WebGL2RenderingContext instead of ANGLE extension\n        if (isIndexed && isInstanced) {\n          this.gl2.drawElementsInstanced(drawMode, vertexCount, indexType, offset, instanceCount);\n        } else if (isIndexed && isWebGL2(this.gl) && !isNaN(start) && !isNaN(end)) {\n          this.gl2.drawRangeElements(drawMode, start, end, vertexCount, indexType, offset);\n        } else if (isIndexed) {\n          this.gl.drawElements(drawMode, vertexCount, indexType, offset);\n        } else if (isInstanced) {\n          this.gl2.drawArraysInstanced(drawMode, offset, vertexCount, instanceCount);\n        } else {\n          this.gl.drawArrays(drawMode, offset, vertexCount);\n        }\n      });\n\n      if (transformFeedback) {\n        transformFeedback.end();\n      }\n    });\n\n    return true;\n  }\n\n  setUniforms(uniforms = {}) {\n    if (log.priority >= 2) {\n      checkUniformValues(uniforms, this.id, this._uniformSetters);\n    }\n\n    this.gl.useProgram(this.handle);\n\n    for (const uniformName in uniforms) {\n      const uniform = uniforms[uniformName];\n      const uniformSetter = this._uniformSetters[uniformName];\n\n      if (uniformSetter) {\n        let value = uniform;\n        let textureUpdate = false;\n\n        if (value instanceof Framebuffer) {\n          value = value.texture;\n        }\n        if (value instanceof Texture) {\n          textureUpdate = this.uniforms[uniformName] !== uniform;\n\n          if (textureUpdate) {\n            // eslint-disable-next-line max-depth\n            if (uniformSetter.textureIndex === undefined) {\n              uniformSetter.textureIndex = this._textureIndexCounter++;\n            }\n\n            // Bind texture to index\n            const texture = value;\n            const {textureIndex} = uniformSetter;\n\n            texture.bind(textureIndex);\n            value = textureIndex;\n\n            this._textureUniforms[uniformName] = texture;\n          } else {\n            value = uniformSetter.textureIndex;\n          }\n        } else if (this._textureUniforms[uniformName]) {\n          delete this._textureUniforms[uniformName];\n        }\n\n        // NOTE(Tarek): uniformSetter returns whether\n        //   value had to be updated or not.\n        if (uniformSetter(value) || textureUpdate) {\n          copyUniform(this.uniforms, uniformName, uniform);\n        }\n      }\n    }\n\n    return this;\n  }\n\n  // PRIVATE METHODS\n\n  // Checks if all texture-values uniforms are renderable (i.e. loaded)\n  // Update a texture if needed (e.g. from video)\n  // Note: This is currently done before every draw call\n  _areTexturesRenderable() {\n    let texturesRenderable = true;\n\n    for (const uniformName in this._textureUniforms) {\n      const texture = this._textureUniforms[uniformName];\n      texture.update();\n      texturesRenderable = texturesRenderable && texture.loaded;\n    }\n\n    return texturesRenderable;\n  }\n\n  // Binds textures\n  // Note: This is currently done before every draw call\n  _bindTextures() {\n    for (const uniformName in this._textureUniforms) {\n      const textureIndex = this._uniformSetters[uniformName].textureIndex;\n      this._textureUniforms[uniformName].bind(textureIndex);\n    }\n  }\n\n  // RESOURCE METHODS\n\n  _createHandle() {\n    return this.gl.createProgram();\n  }\n\n  _deleteHandle() {\n    this.gl.deleteProgram(this.handle);\n  }\n\n  // Extract opts needed to initialize a `Program` from an independently created WebGLProgram handle\n  _getOptionsFromHandle(handle) {\n    const shaderHandles = this.gl.getAttachedShaders(handle);\n    const opts = {};\n    for (const shaderHandle of shaderHandles) {\n      const type = this.gl.getShaderParameter(this.handle, GL.SHADER_TYPE);\n      switch (type) {\n        case GL.VERTEX_SHADER:\n          // @ts-ignore\n          opts.vs = new VertexShader({handle: shaderHandle});\n          break;\n        case GL.FRAGMENT_SHADER:\n          // @ts-ignore\n          opts.fs = new FragmentShader({handle: shaderHandle});\n          break;\n        default:\n      }\n    }\n    return opts;\n  }\n\n  _getParameter(pname) {\n    return this.gl.getProgramParameter(this.handle, pname);\n  }\n\n  // If program is not named, name it after shader names\n  // TODO - this.id will already have been initialized\n  _setId(id) {\n    if (!id) {\n      const programName = this._getName();\n      this.id = uid(programName);\n    }\n  }\n\n  // Generate a default name for the program based on names of the shaders\n  _getName() {\n    let programName = this.vs.getName() || this.fs.getName();\n    programName = programName.replace(/shader/i, '');\n    programName = programName ? `${programName}-program` : 'program';\n    return programName;\n  }\n\n  _compileAndLink() {\n    const {gl} = this;\n    gl.attachShader(this.handle, this.vs.handle);\n    gl.attachShader(this.handle, this.fs.handle);\n    log.time(LOG_PROGRAM_PERF_PRIORITY, `linkProgram for ${this._getName()}`)();\n    gl.linkProgram(this.handle);\n    log.timeEnd(LOG_PROGRAM_PERF_PRIORITY, `linkProgram for ${this._getName()}`)();\n\n    // Avoid checking program linking error in production\n    // @ts-ignore\n    if (gl.debug || log.level > 0) {\n      const linked = gl.getProgramParameter(this.handle, gl.LINK_STATUS);\n      if (!linked) {\n        throw new Error(`Error linking: ${gl.getProgramInfoLog(this.handle)}`);\n      }\n\n      gl.validateProgram(this.handle);\n      const validated = gl.getProgramParameter(this.handle, gl.VALIDATE_STATUS);\n      if (!validated) {\n        throw new Error(`Error validating: ${gl.getProgramInfoLog(this.handle)}`);\n      }\n    }\n  }\n\n  // query uniform locations and build name to setter map.\n  // TODO - This overlaps with ProgramConfiguration?\n  _readUniformLocationsFromLinkedProgram() {\n    const {gl} = this;\n    this._uniformSetters = {};\n    this._uniformCount = this._getParameter(GL.ACTIVE_UNIFORMS);\n    for (let i = 0; i < this._uniformCount; i++) {\n      const info = this.gl.getActiveUniform(this.handle, i);\n      const {name} = parseUniformName(info.name);\n      let location = gl.getUniformLocation(this.handle, name);\n      this._uniformSetters[name] = getUniformSetter(gl, location, info);\n      if (info.size > 1) {\n        for (let l = 0; l < info.size; l++) {\n          location = gl.getUniformLocation(this.handle, `${name}[${l}]`);\n          this._uniformSetters[`${name}[${l}]`] = getUniformSetter(gl, location, info);\n        }\n      }\n    }\n    this._textureIndexCounter = 0;\n  }\n\n  // TO BE REMOVED in v7?\n\n  // Rretrieves information about active uniforms identifed by their indices (`uniformIndices`)\n  // https://\n  // developer.mozilla.org/en-US/docs/Web/API/WebGL2RenderingContext/getActiveUniforms\n  getActiveUniforms(uniformIndices, pname) {\n    return this.gl2.getActiveUniforms(this.handle, uniformIndices, pname);\n  }\n\n  // Retrieves the index of a uniform block\n  getUniformBlockIndex(blockName) {\n    return this.gl2.getUniformBlockIndex(this.handle, blockName);\n  }\n\n  // Retrieves information about an active uniform block (`blockIndex`)\n  // https://\n  // developer.mozilla.org/en-US/docs/Web/API/WebGL2RenderingContext/getActiveUniformBlockParameter\n  getActiveUniformBlockParameter(blockIndex, pname) {\n    return this.gl2.getActiveUniformBlockParameter(this.handle, blockIndex, pname);\n  }\n\n  // Binds a uniform block (`blockIndex`) to a specific binding point (`blockBinding`)\n  uniformBlockBinding(blockIndex, blockBinding) {\n    this.gl2.uniformBlockBinding(this.handle, blockIndex, blockBinding);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}