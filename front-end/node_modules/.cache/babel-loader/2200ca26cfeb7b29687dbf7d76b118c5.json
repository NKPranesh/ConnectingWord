{"ast":null,"code":"import { getPassthroughFS } from '@luma.gl/shadertools';\nimport BufferTransform from './buffer-transform';\nimport TextureTransform from './texture-transform';\nimport { isWebGL2 } from '@luma.gl/gltools';\nimport { assert, isObjectEmpty, getShaderVersion } from '@luma.gl/webgl';\nimport Model from '../lib/model';\nexport default class Transform {\n  static isSupported(gl) {\n    return isWebGL2(gl);\n  }\n\n  constructor(gl) {\n    let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.gl = gl;\n    this.model = null;\n    this.elementCount = 0;\n    this.bufferTransform = null;\n    this.textureTransform = null;\n    this.elementIDBuffer = null;\n\n    this._initialize(props);\n\n    Object.seal(this);\n  }\n\n  delete() {\n    const {\n      model,\n      bufferTransform,\n      textureTransform\n    } = this;\n\n    if (model) {\n      model.delete();\n    }\n\n    if (bufferTransform) {\n      bufferTransform.delete();\n    }\n\n    if (textureTransform) {\n      textureTransform.delete();\n    }\n  }\n\n  run() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const {\n      clearRenderTarget = true\n    } = opts;\n\n    const updatedOpts = this._updateDrawOptions(opts);\n\n    if (clearRenderTarget && updatedOpts.framebuffer) {\n      updatedOpts.framebuffer.clear({\n        color: true\n      });\n    }\n\n    this.model.transform(updatedOpts);\n  }\n\n  swap() {\n    let swapped = false;\n    const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);\n\n    for (const resourceTransform of resourceTransforms) {\n      swapped = swapped || resourceTransform.swap();\n    }\n\n    assert(swapped, 'Nothing to swap');\n  }\n\n  getBuffer() {\n    let varyingName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    return this.bufferTransform && this.bufferTransform.getBuffer(varyingName);\n  }\n\n  getData() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);\n\n    for (const resourceTransform of resourceTransforms) {\n      const data = resourceTransform.getData(opts);\n\n      if (data) {\n        return data;\n      }\n    }\n\n    return null;\n  }\n\n  getFramebuffer() {\n    return this.textureTransform && this.textureTransform.getFramebuffer();\n  }\n\n  update() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if ('elementCount' in opts) {\n      this.model.setVertexCount(opts.elementCount);\n    }\n\n    const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);\n\n    for (const resourceTransform of resourceTransforms) {\n      resourceTransform.update(opts);\n    }\n  }\n\n  _initialize() {\n    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const {\n      gl\n    } = this;\n\n    this._buildResourceTransforms(gl, props);\n\n    props = this._updateModelProps(props);\n    this.model = new Model(gl, Object.assign({}, props, {\n      fs: props.fs || getPassthroughFS({\n        version: getShaderVersion(props.vs)\n      }),\n      id: props.id || 'transform-model',\n      drawMode: props.drawMode || 0,\n      vertexCount: props.elementCount\n    }));\n    this.bufferTransform && this.bufferTransform.setupResources({\n      model: this.model\n    });\n  }\n\n  _updateModelProps(props) {\n    let updatedProps = Object.assign({}, props);\n    const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);\n\n    for (const resourceTransform of resourceTransforms) {\n      updatedProps = resourceTransform.updateModelProps(updatedProps);\n    }\n\n    return updatedProps;\n  }\n\n  _buildResourceTransforms(gl, props) {\n    if (canCreateBufferTransform(props)) {\n      this.bufferTransform = new BufferTransform(gl, props);\n    }\n\n    if (canCreateTextureTransform(props)) {\n      this.textureTransform = new TextureTransform(gl, props);\n    }\n\n    assert(this.bufferTransform || this.textureTransform, 'must provide source/feedback buffers or source/target textures');\n  }\n\n  _updateDrawOptions(opts) {\n    let updatedOpts = Object.assign({}, opts);\n    const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);\n\n    for (const resourceTransform of resourceTransforms) {\n      updatedOpts = Object.assign(updatedOpts, resourceTransform.getDrawOptions(updatedOpts));\n    }\n\n    return updatedOpts;\n  }\n\n}\n\nfunction canCreateBufferTransform(props) {\n  if (!isObjectEmpty(props.feedbackBuffers) || !isObjectEmpty(props.feedbackMap) || props.varyings && props.varyings.length > 0) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction canCreateTextureTransform(props) {\n  if (!isObjectEmpty(props._sourceTextures) || props._targetTexture || props._targetTextureVarying) {\n    return true;\n  }\n\n  return false;\n}","map":{"version":3,"sources":["../../../src/transform/transform.js"],"names":["isSupported","isWebGL2","constructor","props","Object","delete","textureTransform","model","bufferTransform","run","opts","clearRenderTarget","updatedOpts","color","swap","swapped","resourceTransforms","resourceTransform","assert","getBuffer","varyingName","getData","data","getFramebuffer","update","_initialize","gl","fs","getPassthroughFS","version","getShaderVersion","id","drawMode","vertexCount","elementCount","_updateModelProps","updatedProps","_buildResourceTransforms","canCreateBufferTransform","canCreateTextureTransform","_updateDrawOptions","isObjectEmpty"],"mappings":"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","sourcesContent":["import GL from '@luma.gl/constants';\nimport {getPassthroughFS} from '@luma.gl/shadertools';\nimport BufferTransform from './buffer-transform';\nimport TextureTransform from './texture-transform';\n\nimport {isWebGL2} from '@luma.gl/gltools';\nimport {assert, isObjectEmpty, getShaderVersion} from '@luma.gl/webgl';\nimport Model from '../lib/model';\n\n// takes source and target buffers/textures and setsup the pipeline\nexport default class Transform {\n  static isSupported(gl) {\n    // TODO : differentiate writting to buffer vs not\n    return isWebGL2(gl);\n  }\n\n  constructor(gl, props = {}) {\n    this.gl = gl;\n    this.model = null;\n    this.elementCount = 0;\n    this.bufferTransform = null;\n    this.textureTransform = null;\n    this.elementIDBuffer = null;\n    this._initialize(props);\n    Object.seal(this);\n  }\n\n  // Delete owned resources.\n  delete() {\n    const {model, bufferTransform, textureTransform} = this;\n    if (model) {\n      model.delete();\n    }\n    if (bufferTransform) {\n      bufferTransform.delete();\n    }\n    if (textureTransform) {\n      textureTransform.delete();\n    }\n  }\n\n  // Run one transform loop.\n  run(opts = {}) {\n    const {clearRenderTarget = true} = opts;\n\n    const updatedOpts = this._updateDrawOptions(opts);\n\n    if (clearRenderTarget && updatedOpts.framebuffer) {\n      updatedOpts.framebuffer.clear({color: true});\n    }\n\n    this.model.transform(updatedOpts);\n  }\n\n  // swap resources if a map is provided\n  swap() {\n    let swapped = false;\n    const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);\n    for (const resourceTransform of resourceTransforms) {\n      swapped = swapped || resourceTransform.swap();\n    }\n    assert(swapped, 'Nothing to swap');\n  }\n\n  // Return Buffer object for given varying name.\n  getBuffer(varyingName = null) {\n    return this.bufferTransform && this.bufferTransform.getBuffer(varyingName);\n  }\n\n  // Return data either from Buffer or from Texture\n  getData(opts = {}) {\n    const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);\n    for (const resourceTransform of resourceTransforms) {\n      // @ts-ignore\n      const data = resourceTransform.getData(opts);\n      if (data) {\n        return data;\n      }\n    }\n    return null;\n  }\n\n  // Return framebuffer object if rendering to textures\n  getFramebuffer() {\n    return this.textureTransform && this.textureTransform.getFramebuffer();\n  }\n\n  // Update some or all buffer/texture bindings.\n  update(opts = {}) {\n    if ('elementCount' in opts) {\n      // @ts-ignore TODO\n      this.model.setVertexCount(opts.elementCount);\n    }\n    const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);\n    for (const resourceTransform of resourceTransforms) {\n      resourceTransform.update(opts);\n    }\n  }\n\n  // Private\n\n  _initialize(props = {}) {\n    const {gl} = this;\n    this._buildResourceTransforms(gl, props);\n\n    props = this._updateModelProps(props);\n    this.model = new Model(\n      gl,\n      Object.assign({}, props, {\n        fs: props.fs || getPassthroughFS({version: getShaderVersion(props.vs)}),\n        id: props.id || 'transform-model',\n        drawMode: props.drawMode || GL.POINTS,\n        vertexCount: props.elementCount\n      })\n    );\n\n    /* eslint-disable no-unused-expressions */\n    this.bufferTransform && this.bufferTransform.setupResources({model: this.model});\n    /* eslint-enable no-unused-expressions */\n  }\n\n  _updateModelProps(props) {\n    let updatedProps = Object.assign({}, props);\n    const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);\n    for (const resourceTransform of resourceTransforms) {\n      updatedProps = resourceTransform.updateModelProps(updatedProps);\n    }\n    return updatedProps;\n  }\n\n  _buildResourceTransforms(gl, props) {\n    if (canCreateBufferTransform(props)) {\n      this.bufferTransform = new BufferTransform(gl, props);\n    }\n    if (canCreateTextureTransform(props)) {\n      this.textureTransform = new TextureTransform(gl, props);\n    }\n    assert(\n      this.bufferTransform || this.textureTransform,\n      'must provide source/feedback buffers or source/target textures'\n    );\n  }\n\n  _updateDrawOptions(opts) {\n    let updatedOpts = Object.assign({}, opts);\n    const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);\n    for (const resourceTransform of resourceTransforms) {\n      updatedOpts = Object.assign(updatedOpts, resourceTransform.getDrawOptions(updatedOpts));\n    }\n    return updatedOpts;\n  }\n}\n\n// Helper Methods\n\nfunction canCreateBufferTransform(props) {\n  if (\n    !isObjectEmpty(props.feedbackBuffers) ||\n    !isObjectEmpty(props.feedbackMap) ||\n    (props.varyings && props.varyings.length > 0)\n  ) {\n    return true;\n  }\n  return false;\n}\n\nfunction canCreateTextureTransform(props) {\n  if (\n    !isObjectEmpty(props._sourceTextures) ||\n    props._targetTexture ||\n    props._targetTextureVarying\n  ) {\n    return true;\n  }\n\n  return false;\n}\n"]},"metadata":{},"sourceType":"module"}