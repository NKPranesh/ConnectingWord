{"ast":null,"code":"import { isWebGL2, assertWebGL2Context, withParameters } from '@luma.gl/gltools';\nimport Texture from './texture';\nimport { DATA_FORMAT_CHANNELS, TYPE_SIZES } from './texture-formats';\nimport Buffer from './buffer';\nexport default class Texture3D extends Texture {\n  static isSupported(gl) {\n    return isWebGL2(gl);\n  }\n\n  constructor(gl) {\n    let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    assertWebGL2Context(gl);\n    props = Object.assign({\n      depth: 1\n    }, props, {\n      target: 32879,\n      unpackFlipY: false\n    });\n    super(gl, props);\n    this.initialize(props);\n    Object.seal(this);\n  }\n\n  setImageData(_ref) {\n    let {\n      level = 0,\n      dataFormat = 6408,\n      width,\n      height,\n      depth = 1,\n      border = 0,\n      format,\n      type = 5121,\n      offset = 0,\n      data,\n      parameters = {}\n    } = _ref;\n\n    this._trackDeallocatedMemory('Texture');\n\n    this.gl.bindTexture(this.target, this.handle);\n    withParameters(this.gl, parameters, () => {\n      if (ArrayBuffer.isView(data)) {\n        this.gl.texImage3D(this.target, level, dataFormat, width, height, depth, border, format, type, data);\n      }\n\n      if (data instanceof Buffer) {\n        this.gl.bindBuffer(35052, data.handle);\n        this.gl.texImage3D(this.target, level, dataFormat, width, height, depth, border, format, type, offset);\n      }\n    });\n\n    if (data && data.byteLength) {\n      this._trackAllocatedMemory(data.byteLength, 'Texture');\n    } else {\n      const channels = DATA_FORMAT_CHANNELS[this.dataFormat] || 4;\n      const channelSize = TYPE_SIZES[this.type] || 1;\n\n      this._trackAllocatedMemory(this.width * this.height * this.depth * channels * channelSize, 'Texture');\n    }\n\n    this.loaded = true;\n    return this;\n  }\n\n}","map":{"version":3,"sources":["../../../src/classes/texture-3d.js"],"names":["isSupported","isWebGL2","constructor","props","assertWebGL2Context","depth","target","unpackFlipY","Object","setImageData","level","dataFormat","border","type","offset","parameters","withParameters","ArrayBuffer","data","channels","DATA_FORMAT_CHANNELS","channelSize","TYPE_SIZES"],"mappings":"AACA,SAAA,QAAA,EAAA,mBAAA,EAAA,cAAA,QAAA,kBAAA;AACA,OAAA,OAAA,MAAA,WAAA;AACA,SAAA,oBAAA,EAAA,UAAA,QAAA,mBAAA;AACA,OAAA,MAAA,MAAA,UAAA;AAEA,eAAe,MAAA,SAAA,SAAA,OAAA,CAAgC;AAC7C,SAAOA,WAAP,CAAA,EAAA,EAAuB;AACrB,WAAOC,QAAQ,CAAf,EAAe,CAAf;AACD;;AAEDC,EAAAA,WAAW,CAAA,EAAA,EAAiB;AAAA,QAAZC,KAAY,uEAAjB,EAAiB;AAC1BC,IAAAA,mBAAmB,CAAnBA,EAAmB,CAAnBA;AACAD,IAAAA,KAAK,GAAG,MAAM,CAAN,MAAA,CAAc;AAACE,MAAAA,KAAK,EAAE;AAAR,KAAd,EAAA,KAAA,EAAiC;AAACC,MAAAA,MAAM,EAAP,KAAA;AAAwBC,MAAAA,WAAW,EAAE;AAArC,KAAjC,CAARJ;AACA,UAAA,EAAA,EAAA,KAAA;AACA,SAAA,UAAA,CAAA,KAAA;AAEAK,IAAAA,MAAM,CAANA,IAAAA,CAAAA,IAAAA;AACD;;AAGDC,EAAAA,YAAY,OAYT;AAAA,QAZU;AACXC,MAAAA,KAAK,GADM,CAAA;AAEXC,MAAAA,UAAU,GAFC,IAAA;AAAA,MAAA,KAAA;AAAA,MAAA,MAAA;AAKXN,MAAAA,KAAK,GALM,CAAA;AAMXO,MAAAA,MAAM,GANK,CAAA;AAAA,MAAA,MAAA;AAQXC,MAAAA,IAAI,GARO,IAAA;AASXC,MAAAA,MAAM,GATK,CAAA;AAAA,MAAA,IAAA;AAWXC,MAAAA,UAAU,GAAG;AAXF,KAYV;;AACD,SAAA,uBAAA,CAAA,SAAA;;AAEA,SAAA,EAAA,CAAA,WAAA,CAAoB,KAApB,MAAA,EAAiC,KAAjC,MAAA;AAEAC,IAAAA,cAAc,CAAC,KAAD,EAAA,EAAA,UAAA,EAAsB,MAAM;AACxC,UAAIC,WAAW,CAAXA,MAAAA,CAAJ,IAAIA,CAAJ,EAA8B;AAE5B,aAAA,EAAA,CAAA,UAAA,CACE,KADF,MAAA,EAAA,KAAA,EAAA,UAAA,EAAA,KAAA,EAAA,MAAA,EAAA,KAAA,EAAA,MAAA,EAAA,MAAA,EAAA,IAAA,EAAA,IAAA;AAYD;;AAED,UAAIC,IAAI,YAAR,MAAA,EAA4B;AAC1B,aAAA,EAAA,CAAA,UAAA,CAAA,KAAA,EAA2CA,IAAI,CAA/C,MAAA;AAEA,aAAA,EAAA,CAAA,UAAA,CACE,KADF,MAAA,EAAA,KAAA,EAAA,UAAA,EAAA,KAAA,EAAA,MAAA,EAAA,KAAA,EAAA,MAAA,EAAA,MAAA,EAAA,IAAA,EAAA,MAAA;AAYD;AAhCHF,KAAc,CAAdA;;AAmCA,QAAIE,IAAI,IAAIA,IAAI,CAAhB,UAAA,EAA6B;AAC3B,WAAA,qBAAA,CAA2BA,IAAI,CAA/B,UAAA,EAAA,SAAA;AADF,KAAA,MAEO;AAGL,YAAMC,QAAQ,GAAGC,oBAAoB,CAAC,KAArBA,UAAoB,CAApBA,IAAjB,CAAA;AAEA,YAAMC,WAAW,GAAGC,UAAU,CAAC,KAAXA,IAAU,CAAVA,IAApB,CAAA;;AAEA,WAAA,qBAAA,CACE,KAAA,KAAA,GAAa,KAAb,MAAA,GAA2B,KAA3B,KAAA,GAAA,QAAA,GADF,WAAA,EAAA,SAAA;AAID;;AAED,SAAA,MAAA,GAAA,IAAA;AAEA,WAAA,IAAA;AACD;;AArF4C","sourcesContent":["import GL from '@luma.gl/constants';\nimport {isWebGL2, assertWebGL2Context, withParameters} from '@luma.gl/gltools';\nimport Texture from './texture';\nimport {DATA_FORMAT_CHANNELS, TYPE_SIZES} from './texture-formats';\nimport Buffer from './buffer';\n\nexport default class Texture3D extends Texture {\n  static isSupported(gl) {\n    return isWebGL2(gl);\n  }\n\n  constructor(gl, props = {}) {\n    assertWebGL2Context(gl);\n    props = Object.assign({depth: 1}, props, {target: GL.TEXTURE_3D, unpackFlipY: false});\n    super(gl, props);\n    this.initialize(props);\n\n    Object.seal(this);\n  }\n\n  // Image 3D copies from Typed Array or WebGLBuffer\n  setImageData({\n    level = 0,\n    dataFormat = GL.RGBA,\n    width,\n    height,\n    depth = 1,\n    border = 0,\n    format,\n    type = GL.UNSIGNED_BYTE,\n    offset = 0,\n    data,\n    parameters = {}\n  }) {\n    this._trackDeallocatedMemory('Texture');\n\n    this.gl.bindTexture(this.target, this.handle);\n\n    withParameters(this.gl, parameters, () => {\n      if (ArrayBuffer.isView(data)) {\n        // @ts-ignore\n        this.gl.texImage3D(\n          this.target,\n          level,\n          dataFormat,\n          width,\n          height,\n          depth,\n          border,\n          format,\n          type,\n          data\n        );\n      }\n\n      if (data instanceof Buffer) {\n        this.gl.bindBuffer(GL.PIXEL_UNPACK_BUFFER, data.handle);\n        // @ts-ignore\n        this.gl.texImage3D(\n          this.target,\n          level,\n          dataFormat,\n          width,\n          height,\n          depth,\n          border,\n          format,\n          type,\n          offset\n        );\n      }\n    });\n\n    if (data && data.byteLength) {\n      this._trackAllocatedMemory(data.byteLength, 'Texture');\n    } else {\n      // NOTE(Tarek): Default to RGBA bytes\n      // @ts-ignore\n      const channels = DATA_FORMAT_CHANNELS[this.dataFormat] || 4;\n      // @ts-ignore\n      const channelSize = TYPE_SIZES[this.type] || 1;\n\n      this._trackAllocatedMemory(\n        this.width * this.height * this.depth * channels * channelSize,\n        'Texture'\n      );\n    }\n\n    this.loaded = true;\n\n    return this;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}