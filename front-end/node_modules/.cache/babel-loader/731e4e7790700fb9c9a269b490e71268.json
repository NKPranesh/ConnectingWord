{"ast":null,"code":"import { isWebGL } from '@luma.gl/gltools';\nimport ProgramManager from './program-manager';\nimport { Program, VertexArray, clear, TransformFeedback, Buffer, log, isObjectEmpty, uid, assert } from '@luma.gl/webgl';\nimport { getDebugTableForUniforms, getDebugTableForVertexArray, getDebugTableForProgramConfiguration } from '@luma.gl/webgl';\nimport { getBuffersFromGeometry } from './model-utils';\nconst LOG_DRAW_PRIORITY = 2;\nconst LOG_DRAW_TIMEOUT = 10000;\nconst ERR_MODEL_PARAMS = 'Model needs drawMode and vertexCount';\n\nconst NOOP = () => {};\n\nconst DRAW_PARAMS = {};\nexport default class Model {\n  constructor(gl) {\n    let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const {\n      id = uid('model')\n    } = props;\n    assert(isWebGL(gl));\n    this.id = id;\n    this.gl = gl;\n    this.id = props.id || uid('Model');\n    this.lastLogTime = 0;\n    this.animated = false;\n    this.initialize(props);\n  }\n\n  initialize(props) {\n    this.props = {};\n    this.programManager = props.programManager || ProgramManager.getDefaultProgramManager(this.gl);\n    this._programManagerState = -1;\n    this._managedProgram = false;\n    const {\n      program = null,\n      vs,\n      fs,\n      modules,\n      defines,\n      inject,\n      varyings,\n      bufferMode,\n      transpileToGLSL100\n    } = props;\n    this.programProps = {\n      program,\n      vs,\n      fs,\n      modules,\n      defines,\n      inject,\n      varyings,\n      bufferMode,\n      transpileToGLSL100\n    };\n    this.program = null;\n    this.vertexArray = null;\n    this._programDirty = true;\n    this.userData = {};\n    this.needsRedraw = true;\n    this._attributes = {};\n    this.attributes = {};\n    this.uniforms = {};\n    this.pickable = true;\n\n    this._checkProgram();\n\n    this.setUniforms(Object.assign({}, this.getModuleUniforms(props.moduleSettings)));\n    this.drawMode = props.drawMode !== undefined ? props.drawMode : 4;\n    this.vertexCount = props.vertexCount || 0;\n    this.geometryBuffers = {};\n    this.isInstanced = props.isInstanced || props.instanced || props.instanceCount > 0;\n\n    this._setModelProps(props);\n\n    this.geometry = {};\n    assert(this.drawMode !== undefined && Number.isFinite(this.vertexCount), ERR_MODEL_PARAMS);\n  }\n\n  setProps(props) {\n    this._setModelProps(props);\n  }\n\n  delete() {\n    for (const key in this._attributes) {\n      if (this._attributes[key] !== this.attributes[key]) {\n        this._attributes[key].delete();\n      }\n    }\n\n    if (this._managedProgram) {\n      this.programManager.release(this.program);\n      this._managedProgram = false;\n    }\n\n    this.vertexArray.delete();\n\n    this._deleteGeometryBuffers();\n  }\n\n  getDrawMode() {\n    return this.drawMode;\n  }\n\n  getVertexCount() {\n    return this.vertexCount;\n  }\n\n  getInstanceCount() {\n    return this.instanceCount;\n  }\n\n  getAttributes() {\n    return this.attributes;\n  }\n\n  getProgram() {\n    return this.program;\n  }\n\n  setProgram(props) {\n    const {\n      program,\n      vs,\n      fs,\n      modules,\n      defines,\n      inject,\n      varyings,\n      bufferMode,\n      transpileToGLSL100\n    } = props;\n    this.programProps = {\n      program,\n      vs,\n      fs,\n      modules,\n      defines,\n      inject,\n      varyings,\n      bufferMode,\n      transpileToGLSL100\n    };\n    this._programDirty = true;\n  }\n\n  getUniforms() {\n    return this.uniforms;\n  }\n\n  setDrawMode(drawMode) {\n    this.drawMode = drawMode;\n    return this;\n  }\n\n  setVertexCount(vertexCount) {\n    assert(Number.isFinite(vertexCount));\n    this.vertexCount = vertexCount;\n    return this;\n  }\n\n  setInstanceCount(instanceCount) {\n    assert(Number.isFinite(instanceCount));\n    this.instanceCount = instanceCount;\n    return this;\n  }\n\n  setGeometry(geometry) {\n    this.drawMode = geometry.drawMode;\n    this.vertexCount = geometry.getVertexCount();\n\n    this._deleteGeometryBuffers();\n\n    this.geometryBuffers = getBuffersFromGeometry(this.gl, geometry);\n    this.vertexArray.setAttributes(this.geometryBuffers);\n    return this;\n  }\n\n  setAttributes() {\n    let attributes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (isObjectEmpty(attributes)) {\n      return this;\n    }\n\n    const normalizedAttributes = {};\n\n    for (const name in attributes) {\n      const attribute = attributes[name];\n      normalizedAttributes[name] = attribute.getValue ? attribute.getValue() : attribute;\n    }\n\n    this.vertexArray.setAttributes(normalizedAttributes);\n    return this;\n  }\n\n  setUniforms() {\n    let uniforms = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    Object.assign(this.uniforms, uniforms);\n    return this;\n  }\n\n  getModuleUniforms(opts) {\n    this._checkProgram();\n\n    const getUniforms = this.programManager.getUniforms(this.program);\n\n    if (getUniforms) {\n      return getUniforms(opts);\n    }\n\n    return {};\n  }\n\n  updateModuleSettings(opts) {\n    const uniforms = this.getModuleUniforms(opts || {});\n    return this.setUniforms(uniforms);\n  }\n\n  clear(opts) {\n    clear(this.program.gl, opts);\n    return this;\n  }\n\n  draw() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    this._checkProgram();\n\n    const {\n      moduleSettings = null,\n      framebuffer,\n      uniforms = {},\n      attributes = {},\n      transformFeedback = this.transformFeedback,\n      parameters = {},\n      vertexArray = this.vertexArray\n    } = opts;\n    this.setAttributes(attributes);\n    this.updateModuleSettings(moduleSettings);\n    this.setUniforms(uniforms);\n    let logPriority;\n\n    if (log.priority >= LOG_DRAW_PRIORITY) {\n      logPriority = this._logDrawCallStart(LOG_DRAW_PRIORITY);\n    }\n\n    const drawParams = this.vertexArray.getDrawParams();\n    const {\n      isIndexed = drawParams.isIndexed,\n      indexType = drawParams.indexType,\n      indexOffset = drawParams.indexOffset,\n      vertexArrayInstanced = drawParams.isInstanced\n    } = this.props;\n\n    if (vertexArrayInstanced && !this.isInstanced) {\n      log.warn('Found instanced attributes on non-instanced model', this.id)();\n    }\n\n    const {\n      isInstanced,\n      instanceCount\n    } = this;\n    const {\n      onBeforeRender = NOOP,\n      onAfterRender = NOOP\n    } = this.props;\n    onBeforeRender();\n    this.program.setUniforms(this.uniforms);\n    const didDraw = this.program.draw(Object.assign(DRAW_PARAMS, opts, {\n      logPriority,\n      uniforms: null,\n      framebuffer,\n      parameters,\n      drawMode: this.getDrawMode(),\n      vertexCount: this.getVertexCount(),\n      vertexArray,\n      transformFeedback,\n      isIndexed,\n      indexType,\n      isInstanced,\n      instanceCount,\n      offset: isIndexed ? indexOffset : 0\n    }));\n    onAfterRender();\n\n    if (log.priority >= LOG_DRAW_PRIORITY) {\n      this._logDrawCallEnd(logPriority, vertexArray, framebuffer);\n    }\n\n    return didDraw;\n  }\n\n  transform() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const {\n      discard = true,\n      feedbackBuffers,\n      unbindModels = []\n    } = opts;\n    let {\n      parameters\n    } = opts;\n\n    if (feedbackBuffers) {\n      this._setFeedbackBuffers(feedbackBuffers);\n    }\n\n    if (discard) {\n      parameters = Object.assign({}, parameters, {\n        [35977]: discard\n      });\n    }\n\n    unbindModels.forEach(model => model.vertexArray.unbindBuffers());\n\n    try {\n      this.draw(Object.assign({}, opts, {\n        parameters\n      }));\n    } finally {\n      unbindModels.forEach(model => model.vertexArray.bindBuffers());\n    }\n\n    return this;\n  }\n\n  render() {\n    let uniforms = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    log.warn('Model.render() is deprecated. Use Model.setUniforms() and Model.draw()')();\n    return this.setUniforms(uniforms).draw();\n  }\n\n  _setModelProps(props) {\n    Object.assign(this.props, props);\n\n    if ('uniforms' in props) {\n      this.setUniforms(props.uniforms);\n    }\n\n    if ('pickable' in props) {\n      this.pickable = props.pickable;\n    }\n\n    if ('instanceCount' in props) {\n      this.instanceCount = props.instanceCount;\n    }\n\n    if ('geometry' in props) {\n      this.setGeometry(props.geometry);\n    }\n\n    if ('attributes' in props) {\n      this.setAttributes(props.attributes);\n    }\n\n    if ('_feedbackBuffers' in props) {\n      this._setFeedbackBuffers(props._feedbackBuffers);\n    }\n  }\n\n  _checkProgram() {\n    const needsUpdate = this._programDirty || this.programManager.stateHash !== this._programManagerState;\n\n    if (!needsUpdate) {\n      return;\n    }\n\n    let {\n      program\n    } = this.programProps;\n\n    if (program) {\n      this._managedProgram = false;\n    } else {\n      const {\n        vs,\n        fs,\n        modules,\n        inject,\n        defines,\n        varyings,\n        bufferMode,\n        transpileToGLSL100\n      } = this.programProps;\n      program = this.programManager.get({\n        vs,\n        fs,\n        modules,\n        inject,\n        defines,\n        varyings,\n        bufferMode,\n        transpileToGLSL100\n      });\n\n      if (this.program && this._managedProgram) {\n        this.programManager.release(this.program);\n      }\n\n      this._programManagerState = this.programManager.stateHash;\n      this._managedProgram = true;\n    }\n\n    assert(program instanceof Program, 'Model needs a program');\n    this._programDirty = false;\n\n    if (program === this.program) {\n      return;\n    }\n\n    this.program = program;\n\n    if (this.vertexArray) {\n      this.vertexArray.setProps({\n        program: this.program,\n        attributes: this.vertexArray.attributes\n      });\n    } else {\n      this.vertexArray = new VertexArray(this.gl, {\n        program: this.program\n      });\n    }\n\n    this.setUniforms(Object.assign({}, this.getModuleUniforms()));\n  }\n\n  _deleteGeometryBuffers() {\n    for (const name in this.geometryBuffers) {\n      const buffer = this.geometryBuffers[name][0] || this.geometryBuffers[name];\n\n      if (buffer instanceof Buffer) {\n        buffer.delete();\n      }\n    }\n  }\n\n  _setAnimationProps(animationProps) {\n    if (this.animated) {\n      assert(animationProps, 'Model.draw(): animated uniforms but no animationProps');\n    }\n  }\n\n  _setFeedbackBuffers() {\n    let feedbackBuffers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (isObjectEmpty(feedbackBuffers)) {\n      return this;\n    }\n\n    const {\n      gl\n    } = this.program;\n    this.transformFeedback = this.transformFeedback || new TransformFeedback(gl, {\n      program: this.program\n    });\n    this.transformFeedback.setBuffers(feedbackBuffers);\n    return this;\n  }\n\n  _logDrawCallStart(logLevel) {\n    const logDrawTimeout = logLevel > 3 ? 0 : LOG_DRAW_TIMEOUT;\n\n    if (Date.now() - this.lastLogTime < logDrawTimeout) {\n      return undefined;\n    }\n\n    this.lastLogTime = Date.now();\n    log.group(LOG_DRAW_PRIORITY, `>>> DRAWING MODEL ${this.id}`, {\n      collapsed: log.level <= 2\n    })();\n    return logLevel;\n  }\n\n  _logDrawCallEnd(logLevel, vertexArray, uniforms, framebuffer) {\n    if (logLevel === undefined) {\n      return;\n    }\n\n    const attributeTable = getDebugTableForVertexArray({\n      vertexArray,\n      header: `${this.id} attributes`,\n      attributes: this._attributes\n    });\n    const {\n      table: uniformTable,\n      unusedTable,\n      unusedCount\n    } = getDebugTableForUniforms({\n      header: `${this.id} uniforms`,\n      program: this.program,\n      uniforms: Object.assign({}, this.program.uniforms, uniforms)\n    });\n    const {\n      table: missingTable,\n      count: missingCount\n    } = getDebugTableForUniforms({\n      header: `${this.id} uniforms`,\n      program: this.program,\n      uniforms: Object.assign({}, this.program.uniforms, uniforms),\n      undefinedOnly: true\n    });\n\n    if (missingCount > 0) {\n      log.log('MISSING UNIFORMS', Object.keys(missingTable))();\n    }\n\n    if (unusedCount > 0) {\n      log.log('UNUSED UNIFORMS', Object.keys(unusedTable))();\n    }\n\n    const configTable = getDebugTableForProgramConfiguration(this.vertexArray.configuration);\n    log.table(logLevel, attributeTable)();\n    log.table(logLevel, uniformTable)();\n    log.table(logLevel + 1, configTable)();\n\n    if (framebuffer) {\n      framebuffer.log({\n        logLevel: LOG_DRAW_PRIORITY,\n        message: `Rendered to ${framebuffer.id}`\n      });\n    }\n\n    log.groupEnd(LOG_DRAW_PRIORITY, `>>> DRAWING MODEL ${this.id}`)();\n  }\n\n}","map":{"version":3,"sources":["../../../src/lib/model.js"],"names":["LOG_DRAW_PRIORITY","LOG_DRAW_TIMEOUT","ERR_MODEL_PARAMS","NOOP","DRAW_PARAMS","constructor","props","id","uid","assert","isWebGL","initialize","ProgramManager","program","transpileToGLSL100","Object","Number","setProps","delete","getDrawMode","getVertexCount","getInstanceCount","getAttributes","getProgram","setProgram","getUniforms","setDrawMode","setVertexCount","setInstanceCount","setGeometry","geometry","getBuffersFromGeometry","setAttributes","attributes","isObjectEmpty","normalizedAttributes","attribute","setUniforms","uniforms","getModuleUniforms","updateModuleSettings","opts","clear","draw","moduleSettings","transformFeedback","parameters","vertexArray","log","logPriority","drawParams","isIndexed","indexType","indexOffset","vertexArrayInstanced","isInstanced","instanceCount","onBeforeRender","onAfterRender","didDraw","drawMode","vertexCount","offset","transform","discard","unbindModels","model","render","_setModelProps","_checkProgram","needsUpdate","_deleteGeometryBuffers","buffer","_setAnimationProps","_setFeedbackBuffers","feedbackBuffers","gl","_logDrawCallStart","logDrawTimeout","logLevel","Date","collapsed","_logDrawCallEnd","attributeTable","getDebugTableForVertexArray","header","_attributes","table","unusedCount","getDebugTableForUniforms","count","missingCount","undefinedOnly","configTable","getDebugTableForProgramConfiguration","framebuffer","message"],"mappings":"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","sourcesContent":["/* eslint-disable complexity */\n\nimport GL from '@luma.gl/constants';\nimport {isWebGL} from '@luma.gl/gltools';\nimport ProgramManager from './program-manager';\nimport {\n  Program,\n  VertexArray,\n  clear,\n  TransformFeedback,\n  Buffer,\n  log,\n  isObjectEmpty,\n  uid,\n  assert\n} from '@luma.gl/webgl';\nimport {\n  getDebugTableForUniforms,\n  getDebugTableForVertexArray,\n  getDebugTableForProgramConfiguration\n} from '@luma.gl/webgl';\nimport {getBuffersFromGeometry} from './model-utils';\n\nconst LOG_DRAW_PRIORITY = 2;\nconst LOG_DRAW_TIMEOUT = 10000;\n\nconst ERR_MODEL_PARAMS = 'Model needs drawMode and vertexCount';\n\nconst NOOP = () => {};\nconst DRAW_PARAMS = {};\n\nexport default class Model {\n  constructor(gl, props = {}) {\n    // Deduce a helpful id\n    const {id = uid('model')} = props;\n    assert(isWebGL(gl));\n    this.id = id;\n    this.gl = gl;\n    this.id = props.id || uid('Model');\n    this.lastLogTime = 0; // TODO - move to probe.gl\n    this.animated = false;\n    this.initialize(props);\n  }\n\n  initialize(props) {\n    this.props = {};\n\n    this.programManager = props.programManager || ProgramManager.getDefaultProgramManager(this.gl);\n    this._programManagerState = -1;\n    this._managedProgram = false;\n\n    const {\n      program = null,\n      vs,\n      fs,\n      modules,\n      defines,\n      inject,\n      varyings,\n      bufferMode,\n      transpileToGLSL100\n    } = props;\n\n    this.programProps = {\n      program,\n      vs,\n      fs,\n      modules,\n      defines,\n      inject,\n      varyings,\n      bufferMode,\n      transpileToGLSL100\n    };\n    this.program = null;\n    this.vertexArray = null;\n    this._programDirty = true;\n\n    // Initialize state\n    this.userData = {};\n    this.needsRedraw = true;\n\n    // Attributes and buffers\n    // Model manages auto Buffer creation from typed arrays\n    this._attributes = {}; // All attributes\n    this.attributes = {}; // User defined attributes\n\n    // Model manages uniform animation\n    this.uniforms = {};\n\n    // picking options\n    this.pickable = true;\n\n    this._checkProgram();\n\n    this.setUniforms(\n      Object.assign(\n        {},\n        this.getModuleUniforms(props.moduleSettings) // Get unforms for supplied parameters\n      )\n    );\n\n    this.drawMode = props.drawMode !== undefined ? props.drawMode : GL.TRIANGLES;\n    this.vertexCount = props.vertexCount || 0;\n\n    // Track buffers created by setGeometry\n    this.geometryBuffers = {};\n\n    // geometry might have set drawMode and vertexCount\n    this.isInstanced = props.isInstanced || props.instanced || props.instanceCount > 0;\n\n    this._setModelProps(props);\n\n    // TODO - just to unbreak deck.gl 7.0-beta, remove as soon as updated\n    this.geometry = {};\n\n    // assert(program || program instanceof Program);\n    assert(this.drawMode !== undefined && Number.isFinite(this.vertexCount), ERR_MODEL_PARAMS);\n  }\n\n  setProps(props) {\n    this._setModelProps(props);\n  }\n\n  delete() {\n    // delete all attributes created by this model\n    // TODO - should buffer deletes be handled by vertex array?\n    for (const key in this._attributes) {\n      if (this._attributes[key] !== this.attributes[key]) {\n        this._attributes[key].delete();\n      }\n    }\n\n    if (this._managedProgram) {\n      this.programManager.release(this.program);\n      this._managedProgram = false;\n    }\n\n    this.vertexArray.delete();\n\n    this._deleteGeometryBuffers();\n  }\n\n  // GETTERS\n\n  getDrawMode() {\n    return this.drawMode;\n  }\n\n  getVertexCount() {\n    return this.vertexCount;\n  }\n\n  getInstanceCount() {\n    return this.instanceCount;\n  }\n\n  getAttributes() {\n    return this.attributes;\n  }\n\n  getProgram() {\n    return this.program;\n  }\n\n  setProgram(props) {\n    const {\n      program,\n      vs,\n      fs,\n      modules,\n      defines,\n      inject,\n      varyings,\n      bufferMode,\n      transpileToGLSL100\n    } = props;\n    this.programProps = {\n      program,\n      vs,\n      fs,\n      modules,\n      defines,\n      inject,\n      varyings,\n      bufferMode,\n      transpileToGLSL100\n    };\n    this._programDirty = true;\n  }\n\n  getUniforms() {\n    return this.uniforms;\n  }\n\n  // SETTERS\n\n  setDrawMode(drawMode) {\n    this.drawMode = drawMode;\n    return this;\n  }\n\n  setVertexCount(vertexCount) {\n    assert(Number.isFinite(vertexCount));\n    this.vertexCount = vertexCount;\n    return this;\n  }\n\n  setInstanceCount(instanceCount) {\n    assert(Number.isFinite(instanceCount));\n    this.instanceCount = instanceCount;\n    return this;\n  }\n\n  setGeometry(geometry) {\n    this.drawMode = geometry.drawMode;\n    this.vertexCount = geometry.getVertexCount();\n\n    this._deleteGeometryBuffers();\n\n    this.geometryBuffers = getBuffersFromGeometry(this.gl, geometry);\n    this.vertexArray.setAttributes(this.geometryBuffers);\n    return this;\n  }\n\n  setAttributes(attributes = {}) {\n    // Avoid setting needsRedraw if no attributes\n    if (isObjectEmpty(attributes)) {\n      return this;\n    }\n\n    const normalizedAttributes = {};\n    for (const name in attributes) {\n      const attribute = attributes[name];\n      // The `getValue` call provides support for deck.gl `Attribute` class\n      // TODO - remove once deck refactoring completes\n      normalizedAttributes[name] = attribute.getValue ? attribute.getValue() : attribute;\n    }\n\n    this.vertexArray.setAttributes(normalizedAttributes);\n    return this;\n  }\n\n  // TODO - should actually set the uniforms\n  setUniforms(uniforms = {}) {\n    Object.assign(this.uniforms, uniforms);\n\n    return this;\n  }\n\n  getModuleUniforms(opts) {\n    this._checkProgram();\n\n    const getUniforms = this.programManager.getUniforms(this.program);\n\n    if (getUniforms) {\n      return getUniforms(opts);\n    }\n\n    return {};\n  }\n\n  updateModuleSettings(opts) {\n    const uniforms = this.getModuleUniforms(opts || {});\n    return this.setUniforms(uniforms);\n  }\n\n  // DRAW CALLS\n\n  clear(opts) {\n    clear(this.program.gl, opts);\n    return this;\n  }\n\n  draw(opts = {}) {\n    // Lazy update program and vertex array\n    this._checkProgram();\n\n    const {\n      moduleSettings = null,\n      framebuffer,\n      uniforms = {},\n      attributes = {},\n      transformFeedback = this.transformFeedback,\n      parameters = {},\n      vertexArray = this.vertexArray\n    } = opts;\n\n    // Update model with any just provided attributes, settings or uniforms\n    this.setAttributes(attributes);\n    this.updateModuleSettings(moduleSettings);\n    this.setUniforms(uniforms);\n\n    let logPriority;\n\n    if (log.priority >= LOG_DRAW_PRIORITY) {\n      logPriority = this._logDrawCallStart(LOG_DRAW_PRIORITY);\n    }\n\n    const drawParams = this.vertexArray.getDrawParams();\n    const {\n      isIndexed = drawParams.isIndexed,\n      indexType = drawParams.indexType,\n      indexOffset = drawParams.indexOffset,\n      vertexArrayInstanced = drawParams.isInstanced\n    } = this.props;\n\n    if (vertexArrayInstanced && !this.isInstanced) {\n      log.warn('Found instanced attributes on non-instanced model', this.id)();\n    }\n\n    const {isInstanced, instanceCount} = this;\n\n    const {onBeforeRender = NOOP, onAfterRender = NOOP} = this.props;\n\n    onBeforeRender();\n\n    this.program.setUniforms(this.uniforms);\n\n    const didDraw = this.program.draw(\n      Object.assign(DRAW_PARAMS, opts, {\n        logPriority,\n        uniforms: null, // Already set (may contain \"function values\" not understood by Program)\n        framebuffer,\n        parameters,\n        drawMode: this.getDrawMode(),\n        vertexCount: this.getVertexCount(),\n        vertexArray,\n        transformFeedback,\n        isIndexed,\n        indexType,\n        isInstanced,\n        instanceCount,\n        offset: isIndexed ? indexOffset : 0\n      })\n    );\n\n    onAfterRender();\n\n    if (log.priority >= LOG_DRAW_PRIORITY) {\n      this._logDrawCallEnd(logPriority, vertexArray, framebuffer);\n    }\n\n    return didDraw;\n  }\n\n  // Draw call for transform feedback\n  transform(opts = {}) {\n    const {discard = true, feedbackBuffers, unbindModels = []} = opts;\n\n    let {parameters} = opts;\n\n    if (feedbackBuffers) {\n      this._setFeedbackBuffers(feedbackBuffers);\n    }\n\n    if (discard) {\n      parameters = Object.assign({}, parameters, {[GL.RASTERIZER_DISCARD]: discard});\n    }\n\n    unbindModels.forEach(model => model.vertexArray.unbindBuffers());\n    try {\n      this.draw(Object.assign({}, opts, {parameters}));\n    } finally {\n      unbindModels.forEach(model => model.vertexArray.bindBuffers());\n    }\n\n    return this;\n  }\n\n  // DEPRECATED METHODS\n\n  render(uniforms = {}) {\n    log.warn('Model.render() is deprecated. Use Model.setUniforms() and Model.draw()')();\n    return this.setUniforms(uniforms).draw();\n  }\n\n  // PRIVATE METHODS\n\n  _setModelProps(props) {\n    Object.assign(this.props, props);\n\n    if ('uniforms' in props) {\n      this.setUniforms(props.uniforms);\n    }\n\n    if ('pickable' in props) {\n      this.pickable = props.pickable;\n    }\n\n    if ('instanceCount' in props) {\n      this.instanceCount = props.instanceCount;\n    }\n    if ('geometry' in props) {\n      this.setGeometry(props.geometry);\n    }\n\n    // webgl settings\n    if ('attributes' in props) {\n      this.setAttributes(props.attributes);\n    }\n    if ('_feedbackBuffers' in props) {\n      this._setFeedbackBuffers(props._feedbackBuffers);\n    }\n  }\n\n  _checkProgram() {\n    const needsUpdate =\n      this._programDirty || this.programManager.stateHash !== this._programManagerState;\n\n    if (!needsUpdate) {\n      return;\n    }\n\n    let {program} = this.programProps;\n\n    if (program) {\n      this._managedProgram = false;\n    } else {\n      const {\n        vs,\n        fs,\n        modules,\n        inject,\n        defines,\n        varyings,\n        bufferMode,\n        transpileToGLSL100\n      } = this.programProps;\n      program = this.programManager.get({\n        vs,\n        fs,\n        modules,\n        inject,\n        defines,\n        varyings,\n        bufferMode,\n        transpileToGLSL100\n      });\n      if (this.program && this._managedProgram) {\n        this.programManager.release(this.program);\n      }\n      this._programManagerState = this.programManager.stateHash;\n      this._managedProgram = true;\n    }\n\n    assert(program instanceof Program, 'Model needs a program');\n\n    this._programDirty = false;\n\n    if (program === this.program) {\n      return;\n    }\n\n    this.program = program;\n\n    if (this.vertexArray) {\n      // @ts-ignore TODO\n      this.vertexArray.setProps({program: this.program, attributes: this.vertexArray.attributes});\n    } else {\n      this.vertexArray = new VertexArray(this.gl, {program: this.program});\n    }\n\n    // Make sure we have some reasonable default uniforms in place\n    this.setUniforms(\n      Object.assign(\n        {},\n        this.getModuleUniforms() // Get all default uniforms,\n      )\n    );\n  }\n\n  _deleteGeometryBuffers() {\n    for (const name in this.geometryBuffers) {\n      // Buffer is raw value (for indices) or first element of [buffer, accessor] pair\n      const buffer = this.geometryBuffers[name][0] || this.geometryBuffers[name];\n      if (buffer instanceof Buffer) {\n        buffer.delete();\n      }\n    }\n  }\n\n  // Updates (evaluates) all function valued uniforms based on a new set of animationProps\n  // experimental\n  _setAnimationProps(animationProps) {\n    if (this.animated) {\n      assert(animationProps, 'Model.draw(): animated uniforms but no animationProps');\n      // const animatedUniforms = this._evaluateAnimateUniforms(animationProps);\n      // Object.assign(this.uniforms, animatedUniforms);\n    }\n  }\n\n  // Transform Feedback\n\n  _setFeedbackBuffers(feedbackBuffers = {}) {\n    // Avoid setting needsRedraw if no feedbackBuffers\n    if (isObjectEmpty(feedbackBuffers)) {\n      return this;\n    }\n\n    const {gl} = this.program;\n    this.transformFeedback =\n      this.transformFeedback ||\n      new TransformFeedback(gl, {\n        program: this.program\n      });\n\n    this.transformFeedback.setBuffers(feedbackBuffers);\n    return this;\n  }\n\n  _logDrawCallStart(logLevel) {\n    const logDrawTimeout = logLevel > 3 ? 0 : LOG_DRAW_TIMEOUT;\n    if (Date.now() - this.lastLogTime < logDrawTimeout) {\n      return undefined;\n    }\n\n    this.lastLogTime = Date.now();\n\n    log.group(LOG_DRAW_PRIORITY, `>>> DRAWING MODEL ${this.id}`, {collapsed: log.level <= 2})();\n\n    return logLevel;\n  }\n\n  _logDrawCallEnd(logLevel, vertexArray, uniforms, framebuffer) {\n    // HACK: logLevel === undefined means logDrawCallStart didn't run\n    if (logLevel === undefined) {\n      return;\n    }\n\n    const attributeTable = getDebugTableForVertexArray({\n      vertexArray,\n      header: `${this.id} attributes`,\n      // @ts-ignore\n      attributes: this._attributes\n    });\n\n    const {table: uniformTable, unusedTable, unusedCount} = getDebugTableForUniforms({\n      header: `${this.id} uniforms`,\n      program: this.program,\n      uniforms: Object.assign({}, this.program.uniforms, uniforms)\n    });\n\n    // log missing uniforms\n    const {table: missingTable, count: missingCount} = getDebugTableForUniforms({\n      header: `${this.id} uniforms`,\n      program: this.program,\n      uniforms: Object.assign({}, this.program.uniforms, uniforms),\n      undefinedOnly: true\n    });\n\n    if (missingCount > 0) {\n      log.log('MISSING UNIFORMS', Object.keys(missingTable))();\n      // log.table(logLevel, missingTable)();\n    }\n    if (unusedCount > 0) {\n      log.log('UNUSED UNIFORMS', Object.keys(unusedTable))();\n      // log.log(logLevel, 'Unused uniforms ', unusedTable)();\n    }\n\n    const configTable = getDebugTableForProgramConfiguration(this.vertexArray.configuration);\n\n    log.table(logLevel, attributeTable)();\n\n    log.table(logLevel, uniformTable)();\n\n    log.table(logLevel + 1, configTable)();\n\n    if (framebuffer) {\n      framebuffer.log({logLevel: LOG_DRAW_PRIORITY, message: `Rendered to ${framebuffer.id}`});\n    }\n\n    log.groupEnd(LOG_DRAW_PRIORITY, `>>> DRAWING MODEL ${this.id}`)();\n  }\n}\n"]},"metadata":{},"sourceType":"module"}