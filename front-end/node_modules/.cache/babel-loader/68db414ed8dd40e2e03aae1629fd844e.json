{"ast":null,"code":"import { assert } from '@luma.gl/webgl';\nimport { combineInjects, getQualifierDetails, typeToChannelSuffix } from '@luma.gl/shadertools';\nconst SAMPLER_UNIFORM_PREFIX = 'transform_uSampler_';\nconst SIZE_UNIFORM_PREFIX = 'transform_uSize_';\nconst VS_POS_VARIABLE = 'transform_position';\nexport function updateForTextures(_ref) {\n  let {\n    vs,\n    sourceTextureMap,\n    targetTextureVarying,\n    targetTexture\n  } = _ref;\n  const texAttributeNames = Object.keys(sourceTextureMap);\n  let sourceCount = texAttributeNames.length;\n  let targetTextureType = null;\n  const samplerTextureMap = {};\n  let updatedVs = vs;\n  let finalInject = {};\n\n  if (sourceCount > 0 || targetTextureVarying) {\n    const vsLines = updatedVs.split('\\n');\n    const updateVsLines = vsLines.slice();\n    vsLines.forEach((line, index, lines) => {\n      if (sourceCount > 0) {\n        const updated = processAttributeDefinition(line, sourceTextureMap);\n\n        if (updated) {\n          const {\n            updatedLine,\n            inject\n          } = updated;\n          updateVsLines[index] = updatedLine;\n          finalInject = combineInjects([finalInject, inject]);\n          Object.assign(samplerTextureMap, updated.samplerTextureMap);\n          sourceCount--;\n        }\n      }\n\n      if (targetTextureVarying && !targetTextureType) {\n        targetTextureType = getVaryingType(line, targetTextureVarying);\n      }\n    });\n\n    if (targetTextureVarying) {\n      assert(targetTexture);\n      const sizeName = `${SIZE_UNIFORM_PREFIX}${targetTextureVarying}`;\n      const uniformDeclaration = `uniform vec2 ${sizeName};\\n`;\n      const posInstructions = `\\\n     vec2 ${VS_POS_VARIABLE} = transform_getPos(${sizeName});\n     gl_Position = vec4(${VS_POS_VARIABLE}, 0, 1.);\\n`;\n      const inject = {\n        'vs:#decl': uniformDeclaration,\n        'vs:#main-start': posInstructions\n      };\n      finalInject = combineInjects([finalInject, inject]);\n    }\n\n    updatedVs = updateVsLines.join('\\n');\n  }\n\n  return {\n    vs: updatedVs,\n    targetTextureType,\n    inject: finalInject,\n    samplerTextureMap\n  };\n}\nexport function getSizeUniforms(_ref2) {\n  let {\n    sourceTextureMap,\n    targetTextureVarying,\n    targetTexture\n  } = _ref2;\n  const uniforms = {};\n  let width;\n  let height;\n\n  if (targetTextureVarying) {\n    ({\n      width,\n      height\n    } = targetTexture);\n    uniforms[`${SIZE_UNIFORM_PREFIX}${targetTextureVarying}`] = [width, height];\n  }\n\n  for (const textureName in sourceTextureMap) {\n    ({\n      width,\n      height\n    } = sourceTextureMap[textureName]);\n    uniforms[`${SIZE_UNIFORM_PREFIX}${textureName}`] = [width, height];\n  }\n\n  return uniforms;\n}\n\nfunction getAttributeDefinition(line) {\n  return getQualifierDetails(line, ['attribute', 'in']);\n}\n\nfunction getSamplerDeclerations(textureName) {\n  const samplerName = `${SAMPLER_UNIFORM_PREFIX}${textureName}`;\n  const sizeName = `${SIZE_UNIFORM_PREFIX}${textureName}`;\n  const uniformDeclerations = `\\\n  uniform sampler2D ${samplerName};\n  uniform vec2 ${sizeName};`;\n  return {\n    samplerName,\n    sizeName,\n    uniformDeclerations\n  };\n}\n\nexport function getVaryingType(line, varying) {\n  const qualaiferDetails = getQualifierDetails(line, ['varying', 'out']);\n\n  if (!qualaiferDetails) {\n    return null;\n  }\n\n  return qualaiferDetails.name === varying ? qualaiferDetails.type : null;\n}\nexport function processAttributeDefinition(line, textureMap) {\n  const samplerTextureMap = {};\n  const attributeData = getAttributeDefinition(line);\n\n  if (!attributeData) {\n    return null;\n  }\n\n  const {\n    type,\n    name\n  } = attributeData;\n\n  if (name && textureMap[name]) {\n    const updatedLine = `\\// ${line} => Replaced by Transform with a sampler`;\n    const {\n      samplerName,\n      sizeName,\n      uniformDeclerations\n    } = getSamplerDeclerations(name);\n    const channels = typeToChannelSuffix(type);\n    const sampleInstruction = `  ${type} ${name} = transform_getInput(${samplerName}, ${sizeName}).${channels};\\n`;\n    samplerTextureMap[samplerName] = name;\n    const inject = {\n      'vs:#decl': uniformDeclerations,\n      'vs:#main-start': sampleInstruction\n    };\n    return {\n      updatedLine,\n      inject,\n      samplerTextureMap\n    };\n  }\n\n  return null;\n}","map":{"version":3,"sources":["../../../src/transform/transform-shader-utils.js"],"names":["SAMPLER_UNIFORM_PREFIX","SIZE_UNIFORM_PREFIX","VS_POS_VARIABLE","targetTexture","texAttributeNames","Object","sourceCount","targetTextureType","samplerTextureMap","updatedVs","finalInject","vsLines","updateVsLines","updated","processAttributeDefinition","inject","combineInjects","targetTextureVarying","getVaryingType","assert","sizeName","uniformDeclaration","posInstructions","vs","uniforms","height","sourceTextureMap","textureName","getQualifierDetails","samplerName","uniformDeclerations","qualaiferDetails","attributeData","getAttributeDefinition","name","textureMap","updatedLine","line","getSamplerDeclerations","channels","typeToChannelSuffix","sampleInstruction","type"],"mappings":"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","sourcesContent":["import {assert} from '@luma.gl/webgl';\nimport {combineInjects, getQualifierDetails, typeToChannelSuffix} from '@luma.gl/shadertools';\n\nconst SAMPLER_UNIFORM_PREFIX = 'transform_uSampler_';\nconst SIZE_UNIFORM_PREFIX = 'transform_uSize_';\nconst VS_POS_VARIABLE = 'transform_position';\n\n// Scan provided vertex shader\n// for each texture attribute, inject sampler instructions and build uniforms for sampler\n// for texture target, get varying type and inject position instruction\nexport function updateForTextures({vs, sourceTextureMap, targetTextureVarying, targetTexture}) {\n  const texAttributeNames = Object.keys(sourceTextureMap);\n  let sourceCount = texAttributeNames.length;\n  let targetTextureType = null;\n  const samplerTextureMap = {};\n  let updatedVs = vs;\n  let finalInject = {};\n\n  if (sourceCount > 0 || targetTextureVarying) {\n    const vsLines = updatedVs.split('\\n');\n    const updateVsLines = vsLines.slice();\n    vsLines.forEach((line, index, lines) => {\n      // TODO add early exit\n      if (sourceCount > 0) {\n        const updated = processAttributeDefinition(line, sourceTextureMap);\n        if (updated) {\n          const {updatedLine, inject} = updated;\n          updateVsLines[index] = updatedLine;\n          // sampleInstructions.push(sampleInstruction);\n          finalInject = combineInjects([finalInject, inject]);\n          Object.assign(samplerTextureMap, updated.samplerTextureMap);\n          sourceCount--;\n        }\n      }\n      if (targetTextureVarying && !targetTextureType) {\n        targetTextureType = getVaryingType(line, targetTextureVarying);\n      }\n    });\n\n    if (targetTextureVarying) {\n      assert(targetTexture);\n      const sizeName = `${SIZE_UNIFORM_PREFIX}${targetTextureVarying}`;\n\n      const uniformDeclaration = `uniform vec2 ${sizeName};\\n`;\n      const posInstructions = `\\\n     vec2 ${VS_POS_VARIABLE} = transform_getPos(${sizeName});\n     gl_Position = vec4(${VS_POS_VARIABLE}, 0, 1.);\\n`;\n      const inject = {\n        'vs:#decl': uniformDeclaration,\n        'vs:#main-start': posInstructions\n      };\n      finalInject = combineInjects([finalInject, inject]);\n    }\n    updatedVs = updateVsLines.join('\\n');\n  }\n  return {\n    // updated vertex shader (commented texture attribute definition)\n    vs: updatedVs,\n    // type (float, vec2, vec3 of vec4) target texture varying\n    targetTextureType,\n    // required vertex and fragment shader injects\n    inject: finalInject,\n    // map of sampler name to texture name, can be used to set attributes\n    // usefull when swapping textures, as source and destination texture change when swap is called.\n    samplerTextureMap\n  };\n}\n\n// builds and returns an object contaning size uniform for each texture\nexport function getSizeUniforms({sourceTextureMap, targetTextureVarying, targetTexture}) {\n  const uniforms = {};\n  let width;\n  let height;\n  if (targetTextureVarying) {\n    ({width, height} = targetTexture);\n    uniforms[`${SIZE_UNIFORM_PREFIX}${targetTextureVarying}`] = [width, height];\n  }\n  for (const textureName in sourceTextureMap) {\n    ({width, height} = sourceTextureMap[textureName]);\n    uniforms[`${SIZE_UNIFORM_PREFIX}${textureName}`] = [width, height];\n  }\n  return uniforms;\n}\n\n// Checks if provided line is defining an attribute, if so returns details otherwise null\nfunction getAttributeDefinition(line) {\n  return getQualifierDetails(line, ['attribute', 'in']);\n}\n\nfunction getSamplerDeclerations(textureName) {\n  const samplerName = `${SAMPLER_UNIFORM_PREFIX}${textureName}`;\n  const sizeName = `${SIZE_UNIFORM_PREFIX}${textureName}`;\n  const uniformDeclerations = `\\\n  uniform sampler2D ${samplerName};\n  uniform vec2 ${sizeName};`;\n  return {samplerName, sizeName, uniformDeclerations};\n}\n\n// Return size (float, vec2 etc) of a given varying, null if doens't exist.\nexport function getVaryingType(line, varying) {\n  const qualaiferDetails = getQualifierDetails(line, ['varying', 'out']);\n  if (!qualaiferDetails) {\n    return null;\n  }\n  return qualaiferDetails.name === varying ? qualaiferDetails.type : null;\n}\n\n// build required definitions, sample instructions for each texture attribute\nexport function processAttributeDefinition(line, textureMap) {\n  const samplerTextureMap = {};\n  const attributeData = getAttributeDefinition(line);\n  if (!attributeData) {\n    return null;\n  }\n  const {type, name} = attributeData;\n  if (name && textureMap[name]) {\n    // eslint-disable-next-line no-useless-escape\n    const updatedLine = `\\// ${line} => Replaced by Transform with a sampler`;\n    const {samplerName, sizeName, uniformDeclerations} = getSamplerDeclerations(name);\n\n    const channels = typeToChannelSuffix(type);\n    const sampleInstruction = `  ${type} ${name} = transform_getInput(${samplerName}, ${sizeName}).${channels};\\n`;\n\n    samplerTextureMap[samplerName] = name;\n    const inject = {\n      'vs:#decl': uniformDeclerations,\n      'vs:#main-start': sampleInstruction\n    };\n\n    // samplerNameMap\n    return {\n      // update vertex shader line.\n      updatedLine,\n      // inject object with sampler instructions.\n      inject,\n      // sampler name to texture name map\n      samplerTextureMap\n    };\n  }\n  return null;\n}\n"]},"metadata":{},"sourceType":"module"}