{"ast":null,"code":"import { Transform } from '@luma.gl/core';\nimport GPUInterpolationTransition from '../../transitions/gpu-interpolation-transition';\nimport GPUSpringTransition from '../../transitions/gpu-spring-transition';\nimport log from '../../utils/log';\nconst TRANSITION_TYPES = {\n  interpolation: GPUInterpolationTransition,\n  spring: GPUSpringTransition\n};\nexport default class AttributeTransitionManager {\n  constructor(gl, _ref) {\n    let {\n      id,\n      timeline\n    } = _ref;\n    this.id = id;\n    this.gl = gl;\n    this.timeline = timeline;\n    this.transitions = {};\n    this.needsRedraw = false;\n    this.numInstances = 1;\n    this.isSupported = Transform.isSupported(gl);\n  }\n\n  finalize() {\n    for (const attributeName in this.transitions) {\n      this._removeTransition(attributeName);\n    }\n  }\n\n  update(_ref2) {\n    let {\n      attributes,\n      transitions,\n      numInstances\n    } = _ref2;\n    this.numInstances = numInstances || 1;\n\n    for (const attributeName in attributes) {\n      const attribute = attributes[attributeName];\n      const settings = attribute.getTransitionSetting(transitions);\n      if (!settings) continue;\n\n      this._updateAttribute(attributeName, attribute, settings);\n    }\n\n    for (const attributeName in this.transitions) {\n      const attribute = attributes[attributeName];\n\n      if (!attribute || !attribute.getTransitionSetting(transitions)) {\n        this._removeTransition(attributeName);\n      }\n    }\n  }\n\n  hasAttribute(attributeName) {\n    const transition = this.transitions[attributeName];\n    return transition && transition.inProgress;\n  }\n\n  getAttributes() {\n    const animatedAttributes = {};\n\n    for (const attributeName in this.transitions) {\n      const transition = this.transitions[attributeName];\n\n      if (transition.inProgress) {\n        animatedAttributes[attributeName] = transition.attributeInTransition;\n      }\n    }\n\n    return animatedAttributes;\n  }\n\n  run() {\n    if (!this.isSupported || this.numInstances === 0) {\n      return false;\n    }\n\n    for (const attributeName in this.transitions) {\n      const updated = this.transitions[attributeName].update();\n\n      if (updated) {\n        this.needsRedraw = true;\n      }\n    }\n\n    const needsRedraw = this.needsRedraw;\n    this.needsRedraw = false;\n    return needsRedraw;\n  }\n\n  _removeTransition(attributeName) {\n    this.transitions[attributeName].cancel();\n    delete this.transitions[attributeName];\n  }\n\n  _updateAttribute(attributeName, attribute, settings) {\n    const transition = this.transitions[attributeName];\n    let isNew = !transition || transition.type !== settings.type;\n\n    if (isNew) {\n      if (!this.isSupported) {\n        log.warn(\"WebGL2 not supported by this browser. Transition for \".concat(attributeName, \" is disabled.\"))();\n        return;\n      }\n\n      if (transition) {\n        this._removeTransition(attributeName);\n      }\n\n      const TransitionType = TRANSITION_TYPES[settings.type];\n\n      if (TransitionType) {\n        this.transitions[attributeName] = new TransitionType({\n          attribute,\n          timeline: this.timeline,\n          gl: this.gl\n        });\n      } else {\n        log.error(\"unsupported transition type '\".concat(settings.type, \"'\"))();\n        isNew = false;\n      }\n    }\n\n    if (isNew || attribute.needsRedraw()) {\n      this.needsRedraw = true;\n      this.transitions[attributeName].start(settings, this.numInstances);\n    }\n  }\n\n}","map":{"version":3,"sources":["../../../../src/lib/attribute/attribute-transition-manager.js"],"names":["TRANSITION_TYPES","interpolation","spring","GPUSpringTransition","constructor","timeline","Transform","finalize","update","numInstances","attribute","attributes","settings","hasAttribute","transition","getAttributes","animatedAttributes","run","updated","needsRedraw","_removeTransition","_updateAttribute","isNew","log","TransitionType","gl"],"mappings":"AAAA,SAAA,SAAA,QAAA,eAAA;AACA,OAAA,0BAAA,MAAA,gDAAA;AACA,OAAA,mBAAA,MAAA,yCAAA;AACA,OAAA,GAAA,MAAA,iBAAA;AAEA,MAAMA,gBAAgB,GAAG;AACvBC,EAAAA,aAAa,EADU,0BAAA;AAEvBC,EAAAA,MAAM,EAAEC;AAFe,CAAzB;AAKA,eAAe,MAAA,0BAAA,CAAiC;AAC9CC,EAAAA,WAAW,CAAA,EAAA,QAAqB;AAAA,QAAhB;AAAA,MAAA,EAAA;AAAKC,MAAAA;AAAL,KAAgB;AAC9B,SAAA,EAAA,GAAA,EAAA;AACA,SAAA,EAAA,GAAA,EAAA;AACA,SAAA,QAAA,GAAA,QAAA;AAEA,SAAA,WAAA,GAAA,EAAA;AACA,SAAA,WAAA,GAAA,KAAA;AACA,SAAA,YAAA,GAAA,CAAA;AAEA,SAAA,WAAA,GAAmBC,SAAS,CAATA,WAAAA,CAAnB,EAAmBA,CAAnB;AACD;;AAEDC,EAAAA,QAAQ,GAAG;AACT,SAAK,MAAL,aAAA,IAA4B,KAA5B,WAAA,EAA8C;AAC5C,WAAA,iBAAA,CAAA,aAAA;AACD;AACF;;AAMDC,EAAAA,MAAM,QAA0C;AAAA,QAAzC;AAAA,MAAA,UAAA;AAAA,MAAA,WAAA;AAA0BC,MAAAA;AAA1B,KAAyC;AAE9C,SAAA,YAAA,GAAoBA,YAAY,IAAhC,CAAA;;AAEA,SAAK,MAAL,aAAA,IAAA,UAAA,EAAwC;AACtC,YAAMC,SAAS,GAAGC,UAAU,CAA5B,aAA4B,CAA5B;AACA,YAAMC,QAAQ,GAAGF,SAAS,CAATA,oBAAAA,CAAjB,WAAiBA,CAAjB;AAGA,UAAI,CAAJ,QAAA,EAAe;;AACf,WAAA,gBAAA,CAAA,aAAA,EAAA,SAAA,EAAA,QAAA;AACD;;AAED,SAAK,MAAL,aAAA,IAA4B,KAA5B,WAAA,EAA8C;AAC5C,YAAMA,SAAS,GAAGC,UAAU,CAA5B,aAA4B,CAA5B;;AACA,UAAI,CAAA,SAAA,IAAc,CAACD,SAAS,CAATA,oBAAAA,CAAnB,WAAmBA,CAAnB,EAAgE;AAE9D,aAAA,iBAAA,CAAA,aAAA;AACD;AACF;AACF;;AAGDG,EAAAA,YAAY,CAAA,aAAA,EAAgB;AAC1B,UAAMC,UAAU,GAAG,KAAA,WAAA,CAAnB,aAAmB,CAAnB;AACA,WAAOA,UAAU,IAAIA,UAAU,CAA/B,UAAA;AACD;;AAGDC,EAAAA,aAAa,GAAG;AACd,UAAMC,kBAAkB,GAAxB,EAAA;;AAEA,SAAK,MAAL,aAAA,IAA4B,KAA5B,WAAA,EAA8C;AAC5C,YAAMF,UAAU,GAAG,KAAA,WAAA,CAAnB,aAAmB,CAAnB;;AACA,UAAIA,UAAU,CAAd,UAAA,EAA2B;AACzBE,QAAAA,kBAAkB,CAAlBA,aAAkB,CAAlBA,GAAoCF,UAAU,CAA9CE,qBAAAA;AACD;AACF;;AAED,WAAA,kBAAA;AACD;;AAKDC,EAAAA,GAAG,GAAG;AACJ,QAAI,CAAC,KAAD,WAAA,IAAqB,KAAA,YAAA,KAAzB,CAAA,EAAkD;AAChD,aAAA,KAAA;AACD;;AAED,SAAK,MAAL,aAAA,IAA4B,KAA5B,WAAA,EAA8C;AAC5C,YAAMC,OAAO,GAAG,KAAA,WAAA,CAAA,aAAA,EAAhB,MAAgB,EAAhB;;AACA,UAAA,OAAA,EAAa;AACX,aAAA,WAAA,GAAA,IAAA;AACD;AACF;;AAED,UAAMC,WAAW,GAAG,KAApB,WAAA;AACA,SAAA,WAAA,GAAA,KAAA;AACA,WAAA,WAAA;AACD;;AAIDC,EAAAA,iBAAiB,CAAA,aAAA,EAAgB;AAC/B,SAAA,WAAA,CAAA,aAAA,EAAA,MAAA;AACA,WAAO,KAAA,WAAA,CAAP,aAAO,CAAP;AACD;;AAIDC,EAAAA,gBAAgB,CAAA,aAAA,EAAA,SAAA,EAAA,QAAA,EAAqC;AACnD,UAAMP,UAAU,GAAG,KAAA,WAAA,CAAnB,aAAmB,CAAnB;AAMA,QAAIQ,KAAK,GAAG,CAAA,UAAA,IAAeR,UAAU,CAAVA,IAAAA,KAAoBF,QAAQ,CAAvD,IAAA;;AACA,QAAA,KAAA,EAAW;AACT,UAAI,CAAC,KAAL,WAAA,EAAuB;AACrBW,QAAAA,GAAG,CAAHA,IAAAA,CAAAA,wDAAAA,MAAAA,CAAAA,aAAAA,EAAAA,eAAAA,CAAAA;AAGA;AACD;;AAED,UAAA,UAAA,EAAgB;AACd,aAAA,iBAAA,CAAA,aAAA;AACD;;AAED,YAAMC,cAAc,GAAGxB,gBAAgB,CAACY,QAAQ,CAAhD,IAAuC,CAAvC;;AACA,UAAA,cAAA,EAAoB;AAClB,aAAA,WAAA,CAAA,aAAA,IAAkC,IAAA,cAAA,CAAmB;AAAA,UAAA,SAAA;AAEnDP,UAAAA,QAAQ,EAAE,KAFyC,QAAA;AAGnDoB,UAAAA,EAAE,EAAE,KAAKA;AAH0C,SAAnB,CAAlC;AADF,OAAA,MAMO;AACLF,QAAAA,GAAG,CAAHA,KAAAA,CAAAA,gCAAAA,MAAAA,CAA0CX,QAAQ,CAAlDW,IAAAA,EAAAA,GAAAA,CAAAA;AACAD,QAAAA,KAAK,GAALA,KAAAA;AACD;AACF;;AAED,QAAIA,KAAK,IAAIZ,SAAS,CAAtB,WAAaA,EAAb,EAAsC;AACpC,WAAA,WAAA,GAAA,IAAA;AACA,WAAA,WAAA,CAAA,aAAA,EAAA,KAAA,CAAA,QAAA,EAAgD,KAAhD,YAAA;AACD;AACF;;AAnI6C","sourcesContent":["import {Transform} from '@luma.gl/core';\nimport GPUInterpolationTransition from '../../transitions/gpu-interpolation-transition';\nimport GPUSpringTransition from '../../transitions/gpu-spring-transition';\nimport log from '../../utils/log';\n\nconst TRANSITION_TYPES = {\n  interpolation: GPUInterpolationTransition,\n  spring: GPUSpringTransition\n};\n\nexport default class AttributeTransitionManager {\n  constructor(gl, {id, timeline}) {\n    this.id = id;\n    this.gl = gl;\n    this.timeline = timeline;\n\n    this.transitions = {};\n    this.needsRedraw = false;\n    this.numInstances = 1;\n\n    this.isSupported = Transform.isSupported(gl);\n  }\n\n  finalize() {\n    for (const attributeName in this.transitions) {\n      this._removeTransition(attributeName);\n    }\n  }\n\n  /* Public methods */\n\n  // Called when attribute manager updates\n  // Check the latest attributes for updates.\n  update({attributes, transitions, numInstances}) {\n    // Transform class will crash if elementCount is 0\n    this.numInstances = numInstances || 1;\n\n    for (const attributeName in attributes) {\n      const attribute = attributes[attributeName];\n      const settings = attribute.getTransitionSetting(transitions);\n\n      // this attribute might not support transitions?\n      if (!settings) continue; // eslint-disable-line no-continue\n      this._updateAttribute(attributeName, attribute, settings);\n    }\n\n    for (const attributeName in this.transitions) {\n      const attribute = attributes[attributeName];\n      if (!attribute || !attribute.getTransitionSetting(transitions)) {\n        // Animated attribute has been removed\n        this._removeTransition(attributeName);\n      }\n    }\n  }\n\n  // Returns `true` if attribute is transition-enabled\n  hasAttribute(attributeName) {\n    const transition = this.transitions[attributeName];\n    return transition && transition.inProgress;\n  }\n\n  // Get all the animated attributes\n  getAttributes() {\n    const animatedAttributes = {};\n\n    for (const attributeName in this.transitions) {\n      const transition = this.transitions[attributeName];\n      if (transition.inProgress) {\n        animatedAttributes[attributeName] = transition.attributeInTransition;\n      }\n    }\n\n    return animatedAttributes;\n  }\n\n  /* eslint-disable max-statements */\n  // Called every render cycle, run transform feedback\n  // Returns `true` if anything changes\n  run() {\n    if (!this.isSupported || this.numInstances === 0) {\n      return false;\n    }\n\n    for (const attributeName in this.transitions) {\n      const updated = this.transitions[attributeName].update();\n      if (updated) {\n        this.needsRedraw = true;\n      }\n    }\n\n    const needsRedraw = this.needsRedraw;\n    this.needsRedraw = false;\n    return needsRedraw;\n  }\n  /* eslint-enable max-statements */\n\n  /* Private methods */\n  _removeTransition(attributeName) {\n    this.transitions[attributeName].cancel();\n    delete this.transitions[attributeName];\n  }\n\n  // Check an attributes for updates\n  // Returns a transition object if a new transition is triggered.\n  _updateAttribute(attributeName, attribute, settings) {\n    const transition = this.transitions[attributeName];\n    // an attribute can change transition type when it updates\n    // let's remove the transition when that happens so we can create the new transition type\n    // TODO: when switching transition types, make sure to carry over the attribute's\n    // previous buffers, currentLength, startIndices, etc, to be used as the starting point\n    // for the next transition\n    let isNew = !transition || transition.type !== settings.type;\n    if (isNew) {\n      if (!this.isSupported) {\n        log.warn(\n          `WebGL2 not supported by this browser. Transition for ${attributeName} is disabled.`\n        )();\n        return;\n      }\n\n      if (transition) {\n        this._removeTransition(attributeName);\n      }\n\n      const TransitionType = TRANSITION_TYPES[settings.type];\n      if (TransitionType) {\n        this.transitions[attributeName] = new TransitionType({\n          attribute,\n          timeline: this.timeline,\n          gl: this.gl\n        });\n      } else {\n        log.error(`unsupported transition type '${settings.type}'`)();\n        isNew = false;\n      }\n    }\n\n    if (isNew || attribute.needsRedraw()) {\n      this.needsRedraw = true;\n      this.transitions[attributeName].start(settings, this.numInstances);\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}