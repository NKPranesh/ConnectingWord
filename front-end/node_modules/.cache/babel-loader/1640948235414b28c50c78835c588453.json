{"ast":null,"code":"import { assembleShaders } from '@luma.gl/shadertools';\nimport { Program } from '@luma.gl/webgl';\nexport default class ProgramManager {\n  static getDefaultProgramManager(gl) {\n    gl.luma = gl.luma || {};\n    gl.luma.defaultProgramManager = gl.luma.defaultProgramManager || new ProgramManager(gl);\n    return gl.luma.defaultProgramManager;\n  }\n\n  constructor(gl) {\n    this.gl = gl;\n    this._programCache = {};\n    this._getUniforms = {};\n    this._registeredModules = {};\n    this._hookFunctions = [];\n    this._defaultModules = [];\n    this._hashes = {};\n    this._hashCounter = 0;\n    this.stateHash = 0;\n    this._useCounts = {};\n  }\n\n  addDefaultModule(module) {\n    if (!this._defaultModules.find(m => m.name === module.name)) {\n      this._defaultModules.push(module);\n    }\n\n    this.stateHash++;\n  }\n\n  removeDefaultModule(module) {\n    const moduleName = typeof module === 'string' ? module : module.name;\n    this._defaultModules = this._defaultModules.filter(m => m.name !== moduleName);\n    this.stateHash++;\n  }\n\n  addShaderHook(hook, opts) {\n    if (opts) {\n      hook = Object.assign(opts, {\n        hook\n      });\n    }\n\n    this._hookFunctions.push(hook);\n\n    this.stateHash++;\n  }\n\n  get() {\n    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const {\n      vs = '',\n      fs = '',\n      defines = {},\n      inject = {},\n      varyings = [],\n      bufferMode = 0x8c8d,\n      transpileToGLSL100 = false\n    } = props;\n\n    const modules = this._getModuleList(props.modules);\n\n    const vsHash = this._getHash(vs);\n\n    const fsHash = this._getHash(fs);\n\n    const moduleHashes = modules.map(m => this._getHash(m.name)).sort();\n    const varyingHashes = varyings.map(v => this._getHash(v));\n    const defineKeys = Object.keys(defines).sort();\n    const injectKeys = Object.keys(inject).sort();\n    const defineHashes = [];\n    const injectHashes = [];\n\n    for (const key of defineKeys) {\n      defineHashes.push(this._getHash(key));\n      defineHashes.push(this._getHash(defines[key]));\n    }\n\n    for (const key of injectKeys) {\n      injectHashes.push(this._getHash(key));\n      injectHashes.push(this._getHash(inject[key]));\n    }\n\n    const hash = `${vsHash}/${fsHash}D${defineHashes.join('/')}M${moduleHashes.join('/')}I${injectHashes.join('/')}V${varyingHashes.join('/')}H${this.stateHash}B${bufferMode}${transpileToGLSL100 ? 'T' : ''}`;\n\n    if (!this._programCache[hash]) {\n      const assembled = assembleShaders(this.gl, {\n        vs,\n        fs,\n        modules,\n        inject,\n        defines,\n        hookFunctions: this._hookFunctions,\n        transpileToGLSL100\n      });\n      this._programCache[hash] = new Program(this.gl, {\n        hash,\n        vs: assembled.vs,\n        fs: assembled.fs,\n        varyings,\n        bufferMode\n      });\n\n      this._getUniforms[hash] = assembled.getUniforms || (x => {});\n\n      this._useCounts[hash] = 0;\n    }\n\n    this._useCounts[hash]++;\n    return this._programCache[hash];\n  }\n\n  getUniforms(program) {\n    return this._getUniforms[program.hash] || null;\n  }\n\n  release(program) {\n    const hash = program.hash;\n    this._useCounts[hash]--;\n\n    if (this._useCounts[hash] === 0) {\n      this._programCache[hash].delete();\n\n      delete this._programCache[hash];\n      delete this._getUniforms[hash];\n      delete this._useCounts[hash];\n    }\n  }\n\n  _getHash(key) {\n    if (this._hashes[key] === undefined) {\n      this._hashes[key] = this._hashCounter++;\n    }\n\n    return this._hashes[key];\n  }\n\n  _getModuleList() {\n    let appModules = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    const modules = new Array(this._defaultModules.length + appModules.length);\n    const seen = {};\n    let count = 0;\n\n    for (let i = 0, len = this._defaultModules.length; i < len; ++i) {\n      const module = this._defaultModules[i];\n      const name = module.name;\n      modules[count++] = module;\n      seen[name] = true;\n    }\n\n    for (let i = 0, len = appModules.length; i < len; ++i) {\n      const module = appModules[i];\n      const name = module.name;\n\n      if (!seen[name]) {\n        modules[count++] = module;\n        seen[name] = true;\n      }\n    }\n\n    modules.length = count;\n    return modules;\n  }\n\n}","map":{"version":3,"sources":["../../../src/lib/program-manager.js"],"names":["getDefaultProgramManager","gl","constructor","addDefaultModule","m","module","removeDefaultModule","moduleName","addShaderHook","hook","get","props","vs","fs","defines","inject","varyings","bufferMode","transpileToGLSL100","modules","vsHash","fsHash","moduleHashes","varyingHashes","v","defineKeys","Object","injectKeys","defineHashes","injectHashes","hash","stateHash","assembled","assembleShaders","hookFunctions","x","getUniforms","program","release","_getHash","_getModuleList","appModules","seen","count","i","len","name"],"mappings":"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","sourcesContent":["import {assembleShaders} from '@luma.gl/shadertools';\nimport {Program} from '@luma.gl/webgl';\n\nexport default class ProgramManager {\n  static getDefaultProgramManager(gl) {\n    gl.luma = gl.luma || {};\n    gl.luma.defaultProgramManager = gl.luma.defaultProgramManager || new ProgramManager(gl);\n\n    return gl.luma.defaultProgramManager;\n  }\n\n  constructor(gl) {\n    this.gl = gl;\n\n    this._programCache = {};\n    this._getUniforms = {};\n    this._registeredModules = {}; // TODO: Remove? This isn't used anywhere in luma.gl\n    this._hookFunctions = [];\n    this._defaultModules = [];\n\n    this._hashes = {};\n    this._hashCounter = 0;\n    this.stateHash = 0; // Used change hashing if hooks are modified\n    this._useCounts = {};\n  }\n\n  addDefaultModule(module) {\n    if (!this._defaultModules.find(m => m.name === module.name)) {\n      this._defaultModules.push(module);\n    }\n\n    this.stateHash++;\n  }\n\n  removeDefaultModule(module) {\n    const moduleName = typeof module === 'string' ? module : module.name;\n    this._defaultModules = this._defaultModules.filter(m => m.name !== moduleName);\n    this.stateHash++;\n  }\n\n  addShaderHook(hook, opts) {\n    if (opts) {\n      hook = Object.assign(opts, {hook});\n    }\n\n    this._hookFunctions.push(hook);\n\n    this.stateHash++;\n  }\n\n  get(props = {}) {\n    const {\n      vs = '',\n      fs = '',\n      defines = {},\n      inject = {},\n      varyings = [],\n      bufferMode = 0x8c8d,\n      transpileToGLSL100 = false\n    } = props; // varyings/bufferMode for xform feedback, 0x8c8d = SEPARATE_ATTRIBS\n\n    const modules = this._getModuleList(props.modules); // Combine with default modules\n\n    const vsHash = this._getHash(vs);\n    const fsHash = this._getHash(fs);\n    const moduleHashes = modules.map(m => this._getHash(m.name)).sort();\n    const varyingHashes = varyings.map(v => this._getHash(v));\n\n    const defineKeys = Object.keys(defines).sort();\n    const injectKeys = Object.keys(inject).sort();\n    const defineHashes = [];\n    const injectHashes = [];\n\n    for (const key of defineKeys) {\n      defineHashes.push(this._getHash(key));\n      defineHashes.push(this._getHash(defines[key]));\n    }\n\n    for (const key of injectKeys) {\n      injectHashes.push(this._getHash(key));\n      injectHashes.push(this._getHash(inject[key]));\n    }\n\n    const hash = `${vsHash}/${fsHash}D${defineHashes.join('/')}M${moduleHashes.join(\n      '/'\n    )}I${injectHashes.join('/')}V${varyingHashes.join('/')}H${this.stateHash}B${bufferMode}${\n      transpileToGLSL100 ? 'T' : ''\n    }`;\n\n    if (!this._programCache[hash]) {\n      const assembled = assembleShaders(this.gl, {\n        vs,\n        fs,\n        modules,\n        inject,\n        defines,\n        hookFunctions: this._hookFunctions,\n        transpileToGLSL100\n      });\n\n      this._programCache[hash] = new Program(this.gl, {\n        hash,\n        vs: assembled.vs,\n        fs: assembled.fs,\n        varyings,\n        bufferMode\n      });\n\n      this._getUniforms[hash] = assembled.getUniforms || (x => {});\n      this._useCounts[hash] = 0;\n    }\n\n    this._useCounts[hash]++;\n\n    return this._programCache[hash];\n  }\n\n  getUniforms(program) {\n    return this._getUniforms[program.hash] || null;\n  }\n\n  release(program) {\n    const hash = program.hash;\n    this._useCounts[hash]--;\n\n    if (this._useCounts[hash] === 0) {\n      this._programCache[hash].delete();\n      delete this._programCache[hash];\n      delete this._getUniforms[hash];\n      delete this._useCounts[hash];\n    }\n  }\n\n  _getHash(key) {\n    if (this._hashes[key] === undefined) {\n      this._hashes[key] = this._hashCounter++;\n    }\n\n    return this._hashes[key];\n  }\n\n  // Dedup and combine with default modules\n  _getModuleList(appModules = []) {\n    const modules = new Array(this._defaultModules.length + appModules.length);\n    const seen = {};\n    let count = 0;\n\n    for (let i = 0, len = this._defaultModules.length; i < len; ++i) {\n      const module = this._defaultModules[i];\n      const name = module.name;\n      modules[count++] = module;\n      seen[name] = true;\n    }\n\n    for (let i = 0, len = appModules.length; i < len; ++i) {\n      const module = appModules[i];\n      const name = module.name;\n      if (!seen[name]) {\n        modules[count++] = module;\n        seen[name] = true;\n      }\n    }\n\n    modules.length = count;\n\n    return modules;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}