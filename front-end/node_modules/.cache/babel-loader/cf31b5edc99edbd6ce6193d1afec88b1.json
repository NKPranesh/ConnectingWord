{"ast":null,"code":"import { CullingVolume, Plane, AxisAlignedBoundingBox, makeOrientedBoundingBoxFromPoints } from '@math.gl/culling';\nimport { lngLatToWorld } from '@math.gl/web-mercator';\nimport { osmTile2lngLat } from './utils';\nconst TILE_SIZE = 512;\nconst MAX_MAPS = 3;\nconst REF_POINTS_5 = [[0.5, 0.5], [0, 0], [0, 1], [1, 0], [1, 1]];\nconst REF_POINTS_9 = REF_POINTS_5.concat([[0, 0.5], [0.5, 0], [1, 0.5], [0.5, 1]]);\nconst REF_POINTS_11 = REF_POINTS_9.concat([[0.25, 0.5], [0.75, 0.5]]);\n\nclass OSMNode {\n  constructor(x, y, z) {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n  }\n\n  get children() {\n    if (!this._children) {\n      const x = this.x * 2;\n      const y = this.y * 2;\n      const z = this.z + 1;\n      this._children = [new OSMNode(x, y, z), new OSMNode(x, y + 1, z), new OSMNode(x + 1, y, z), new OSMNode(x + 1, y + 1, z)];\n    }\n\n    return this._children;\n  }\n\n  update(params) {\n    const {\n      viewport,\n      cullingVolume,\n      elevationBounds,\n      minZ,\n      maxZ,\n      bounds,\n      offset,\n      project\n    } = params;\n    const boundingVolume = this.getBoundingVolume(elevationBounds, offset, project);\n\n    if (bounds && !this.insideBounds(bounds)) {\n      return false;\n    }\n\n    const isInside = cullingVolume.computeVisibility(boundingVolume);\n\n    if (isInside < 0) {\n      return false;\n    }\n\n    if (!this.childVisible) {\n      let {\n        z\n      } = this;\n\n      if (z < maxZ && z >= minZ) {\n        const distance = boundingVolume.distanceTo(viewport.cameraPosition) * viewport.scale / viewport.height;\n        z += Math.floor(Math.log2(distance));\n      }\n\n      if (z >= maxZ) {\n        this.selected = true;\n        return true;\n      }\n    }\n\n    this.selected = false;\n    this.childVisible = true;\n\n    for (const child of this.children) {\n      child.update(params);\n    }\n\n    return true;\n  }\n\n  getSelected() {\n    let result = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n    if (this.selected) {\n      result.push(this);\n    }\n\n    if (this._children) {\n      for (const node of this._children) {\n        node.getSelected(result);\n      }\n    }\n\n    return result;\n  }\n\n  insideBounds(_ref) {\n    let [minX, minY, maxX, maxY] = _ref;\n    const scale = Math.pow(2, this.z);\n    const extent = TILE_SIZE / scale;\n    return this.x * extent < maxX && this.y * extent < maxY && (this.x + 1) * extent > minX && (this.y + 1) * extent > minY;\n  }\n\n  getBoundingVolume(zRange, worldOffset, project) {\n    if (project) {\n      const refPoints = this.z < 1 ? REF_POINTS_11 : this.z < 2 ? REF_POINTS_9 : REF_POINTS_5;\n      const refPointPositions = [];\n\n      for (const p of refPoints) {\n        const lngLat = osmTile2lngLat(this.x + p[0], this.y + p[1], this.z);\n        lngLat[2] = zRange[0];\n        refPointPositions.push(project(lngLat));\n\n        if (zRange[0] !== zRange[1]) {\n          lngLat[2] = zRange[1];\n          refPointPositions.push(project(lngLat));\n        }\n      }\n\n      return makeOrientedBoundingBoxFromPoints(refPointPositions);\n    }\n\n    const scale = Math.pow(2, this.z);\n    const extent = TILE_SIZE / scale;\n    const originX = this.x * extent + worldOffset * TILE_SIZE;\n    const originY = TILE_SIZE - (this.y + 1) * extent;\n    return new AxisAlignedBoundingBox([originX, originY, zRange[0]], [originX + extent, originY + extent, zRange[1]]);\n  }\n\n}\n\nexport function getOSMTileIndices(viewport, maxZ, zRange, bounds) {\n  const project = viewport.resolution ? viewport.projectPosition : null;\n  const planes = Object.values(viewport.getFrustumPlanes()).map(_ref2 => {\n    let {\n      normal,\n      distance\n    } = _ref2;\n    return new Plane(normal.clone().negate(), distance);\n  });\n  const cullingVolume = new CullingVolume(planes);\n  const unitsPerMeter = viewport.distanceScales.unitsPerMeter[2];\n  const elevationMin = zRange && zRange[0] * unitsPerMeter || 0;\n  const elevationMax = zRange && zRange[1] * unitsPerMeter || 0;\n  const minZ = viewport.pitch <= 60 ? maxZ : 0;\n\n  if (bounds) {\n    const [minLng, minLat, maxLng, maxLat] = bounds;\n    const topLeft = lngLatToWorld([minLng, maxLat]);\n    const bottomRight = lngLatToWorld([maxLng, minLat]);\n    bounds = [topLeft[0], TILE_SIZE - topLeft[1], bottomRight[0], TILE_SIZE - bottomRight[1]];\n  }\n\n  const root = new OSMNode(0, 0, 0);\n  const traversalParams = {\n    viewport,\n    project,\n    cullingVolume,\n    elevationBounds: [elevationMin, elevationMax],\n    minZ,\n    maxZ,\n    bounds,\n    offset: 0\n  };\n  root.update(traversalParams);\n\n  if (viewport.subViewports && viewport.subViewports.length > 1) {\n    traversalParams.offset = -1;\n\n    while (root.update(traversalParams)) {\n      if (--traversalParams.offset < -MAX_MAPS) {\n        break;\n      }\n    }\n\n    traversalParams.offset = 1;\n\n    while (root.update(traversalParams)) {\n      if (++traversalParams.offset > MAX_MAPS) {\n        break;\n      }\n    }\n  }\n\n  return root.getSelected();\n}","map":{"version":3,"sources":["../../../src/tile-layer/tile-2d-traversal.js"],"names":["TILE_SIZE","MAX_MAPS","REF_POINTS_5","REF_POINTS_9","REF_POINTS_11","constructor","children","x","y","z","update","project","boundingVolume","bounds","isInside","cullingVolume","distance","viewport","Math","child","getSelected","result","node","insideBounds","scale","extent","getBoundingVolume","refPoints","refPointPositions","lngLat","osmTile2lngLat","p","zRange","makeOrientedBoundingBoxFromPoints","originX","worldOffset","originY","planes","Object","normal","unitsPerMeter","elevationMin","elevationMax","minZ","topLeft","lngLatToWorld","bottomRight","root","traversalParams","elevationBounds","offset"],"mappings":"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","sourcesContent":["/* eslint-disable complexity */\nimport {\n  CullingVolume,\n  Plane,\n  AxisAlignedBoundingBox,\n  makeOrientedBoundingBoxFromPoints\n} from '@math.gl/culling';\nimport {lngLatToWorld} from '@math.gl/web-mercator';\nimport {osmTile2lngLat} from './utils';\n\nconst TILE_SIZE = 512;\n// number of world copies to check\nconst MAX_MAPS = 3;\n// for calculating bounding volume of a tile in a non-web-mercator viewport\nconst REF_POINTS_5 = [[0.5, 0.5], [0, 0], [0, 1], [1, 0], [1, 1]]; // 4 corners and center\nconst REF_POINTS_9 = REF_POINTS_5.concat([[0, 0.5], [0.5, 0], [1, 0.5], [0.5, 1]]); // 4 corners, center and 4 mid points\nconst REF_POINTS_11 = REF_POINTS_9.concat([[0.25, 0.5], [0.75, 0.5]]); // 2 additional points on equator for top tile\n\nclass OSMNode {\n  constructor(x, y, z) {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n  }\n\n  get children() {\n    if (!this._children) {\n      const x = this.x * 2;\n      const y = this.y * 2;\n      const z = this.z + 1;\n      this._children = [\n        new OSMNode(x, y, z),\n        new OSMNode(x, y + 1, z),\n        new OSMNode(x + 1, y, z),\n        new OSMNode(x + 1, y + 1, z)\n      ];\n    }\n    return this._children;\n  }\n\n  update(params) {\n    const {viewport, cullingVolume, elevationBounds, minZ, maxZ, bounds, offset, project} = params;\n    const boundingVolume = this.getBoundingVolume(elevationBounds, offset, project);\n\n    // First, check if this tile is visible\n    if (bounds && !this.insideBounds(bounds)) {\n      return false;\n    }\n\n    const isInside = cullingVolume.computeVisibility(boundingVolume);\n    if (isInside < 0) {\n      return false;\n    }\n\n    // Avoid loading overlapping tiles - if a descendant is requested, do not request the ancester\n    if (!this.childVisible) {\n      let {z} = this;\n      if (z < maxZ && z >= minZ) {\n        // Adjust LOD\n        // If the tile is far enough from the camera, accept a lower zoom level\n        const distance =\n          (boundingVolume.distanceTo(viewport.cameraPosition) * viewport.scale) / viewport.height;\n        z += Math.floor(Math.log2(distance));\n      }\n      if (z >= maxZ) {\n        // LOD is acceptable\n        this.selected = true;\n        return true;\n      }\n    }\n\n    // LOD is not enough, recursively test child tiles\n    this.selected = false;\n    this.childVisible = true;\n    for (const child of this.children) {\n      child.update(params);\n    }\n    return true;\n  }\n\n  getSelected(result = []) {\n    if (this.selected) {\n      result.push(this);\n    }\n    if (this._children) {\n      for (const node of this._children) {\n        node.getSelected(result);\n      }\n    }\n    return result;\n  }\n\n  insideBounds([minX, minY, maxX, maxY]) {\n    const scale = Math.pow(2, this.z);\n    const extent = TILE_SIZE / scale;\n\n    return (\n      this.x * extent < maxX &&\n      this.y * extent < maxY &&\n      (this.x + 1) * extent > minX &&\n      (this.y + 1) * extent > minY\n    );\n  }\n\n  getBoundingVolume(zRange, worldOffset, project) {\n    if (project) {\n      // Custom projection\n      // Estimate bounding box from sample points\n      // At low zoom level we need more samples to calculate the bounding volume correctly\n      const refPoints = this.z < 1 ? REF_POINTS_11 : this.z < 2 ? REF_POINTS_9 : REF_POINTS_5;\n\n      // Convert from tile-relative coordinates to common space\n      const refPointPositions = [];\n      for (const p of refPoints) {\n        const lngLat = osmTile2lngLat(this.x + p[0], this.y + p[1], this.z);\n        lngLat[2] = zRange[0];\n        refPointPositions.push(project(lngLat));\n\n        if (zRange[0] !== zRange[1]) {\n          // Account for the elevation volume\n          lngLat[2] = zRange[1];\n          refPointPositions.push(project(lngLat));\n        }\n      }\n\n      return makeOrientedBoundingBoxFromPoints(refPointPositions);\n    }\n\n    // Use WebMercator projection\n    const scale = Math.pow(2, this.z);\n    const extent = TILE_SIZE / scale;\n    const originX = this.x * extent + worldOffset * TILE_SIZE;\n    // deck's common space is y-flipped\n    const originY = TILE_SIZE - (this.y + 1) * extent;\n\n    return new AxisAlignedBoundingBox(\n      [originX, originY, zRange[0]],\n      [originX + extent, originY + extent, zRange[1]]\n    );\n  }\n}\n\nexport function getOSMTileIndices(viewport, maxZ, zRange, bounds) {\n  const project = viewport.resolution ? viewport.projectPosition : null;\n\n  // Get the culling volume of the current camera\n  const planes = Object.values(viewport.getFrustumPlanes()).map(\n    ({normal, distance}) => new Plane(normal.clone().negate(), distance)\n  );\n  const cullingVolume = new CullingVolume(planes);\n\n  // Project zRange from meters to common space\n  const unitsPerMeter = viewport.distanceScales.unitsPerMeter[2];\n  const elevationMin = (zRange && zRange[0] * unitsPerMeter) || 0;\n  const elevationMax = (zRange && zRange[1] * unitsPerMeter) || 0;\n\n  // Always load at the current zoom level if pitch is small\n  const minZ = viewport.pitch <= 60 ? maxZ : 0;\n\n  // Map extent to OSM position\n  if (bounds) {\n    const [minLng, minLat, maxLng, maxLat] = bounds;\n    const topLeft = lngLatToWorld([minLng, maxLat]);\n    const bottomRight = lngLatToWorld([maxLng, minLat]);\n    bounds = [topLeft[0], TILE_SIZE - topLeft[1], bottomRight[0], TILE_SIZE - bottomRight[1]];\n  }\n\n  const root = new OSMNode(0, 0, 0);\n  const traversalParams = {\n    viewport,\n    project,\n    cullingVolume,\n    elevationBounds: [elevationMin, elevationMax],\n    minZ,\n    maxZ,\n    bounds,\n    // num. of worlds from the center. For repeated maps\n    offset: 0\n  };\n\n  root.update(traversalParams);\n\n  if (viewport.subViewports && viewport.subViewports.length > 1) {\n    // Check worlds in repeated maps\n    traversalParams.offset = -1;\n    while (root.update(traversalParams)) {\n      if (--traversalParams.offset < -MAX_MAPS) {\n        break;\n      }\n    }\n    traversalParams.offset = 1;\n    while (root.update(traversalParams)) {\n      if (++traversalParams.offset > MAX_MAPS) {\n        break;\n      }\n    }\n  }\n\n  return root.getSelected();\n}\n"]},"metadata":{},"sourceType":"module"}