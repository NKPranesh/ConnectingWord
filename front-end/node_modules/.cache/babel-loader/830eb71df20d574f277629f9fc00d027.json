{"ast":null,"code":"import { makeStringIterator } from './make-string-iterator';\nimport { makeArrayBufferIterator } from './make-array-buffer-iterator';\nimport { makeBlobIterator } from './make-blob-iterator';\nimport { makeStreamIterator } from './make-stream-iterator';\nimport { isBlob, isReadableStream, isResponse } from '../../javascript-utils/is-type';\nexport function makeIterator(data, options) {\n  if (typeof data === 'string') {\n    return makeStringIterator(data, options);\n  }\n\n  if (data instanceof ArrayBuffer) {\n    return makeArrayBufferIterator(data, options);\n  }\n\n  if (isBlob(data)) {\n    return makeBlobIterator(data, options);\n  }\n\n  if (isReadableStream(data)) {\n    return makeStreamIterator(data, options);\n  }\n\n  if (isResponse(data)) {\n    const response = data;\n    return makeStreamIterator(response.body, options);\n  }\n\n  throw new Error('makeIterator');\n}","map":{"version":3,"sources":["../../../../src/iterators/make-iterator/make-iterator.ts"],"names":["makeStringIterator","data","makeArrayBufferIterator","isBlob","makeBlobIterator","isReadableStream","makeStreamIterator","isResponse","response"],"mappings":"AAEA,SAAA,kBAAA,QAAA,wBAAA;AACA,SAAA,uBAAA,QAAA,8BAAA;AACA,SAAA,gBAAA,QAAA,sBAAA;AAEA,SAAA,kBAAA,QAAA,wBAAA;AACA,SAAA,MAAA,EAAA,gBAAA,EAAA,UAAA,QAAA,gCAAA;AAiBA,OAAO,SAAA,YAAA,CAAA,IAAA,EAAA,OAAA,EAG+C;AACpD,MAAI,OAAA,IAAA,KAAJ,QAAA,EAA8B;AAE5B,WAAOA,kBAAkB,CAAA,IAAA,EAAzB,OAAyB,CAAzB;AACD;;AACD,MAAIC,IAAI,YAAR,WAAA,EAAiC;AAC/B,WAAOC,uBAAuB,CAAA,IAAA,EAA9B,OAA8B,CAA9B;AACD;;AACD,MAAIC,MAAM,CAAV,IAAU,CAAV,EAAkB;AAChB,WAAOC,gBAAgB,CAAA,IAAA,EAAvB,OAAuB,CAAvB;AACD;;AACD,MAAIC,gBAAgB,CAApB,IAAoB,CAApB,EAA4B;AAC1B,WAAOC,kBAAkB,CAAA,IAAA,EAAzB,OAAyB,CAAzB;AACD;;AACD,MAAIC,UAAU,CAAd,IAAc,CAAd,EAAsB;AACpB,UAAMC,QAAQ,GAAd,IAAA;AACA,WAAOF,kBAAkB,CAACE,QAAQ,CAAT,IAAA,EAAzB,OAAyB,CAAzB;AACD;;AACD,QAAM,IAAA,KAAA,CAAN,cAAM,CAAN;AACD","sourcesContent":["import type {ReadStream} from 'fs';\n\nimport {makeStringIterator} from './make-string-iterator';\nimport {makeArrayBufferIterator} from './make-array-buffer-iterator';\nimport {makeBlobIterator} from './make-blob-iterator';\nimport type {StreamIteratorOptions} from './make-stream-iterator';\nimport {makeStreamIterator} from './make-stream-iterator';\nimport {isBlob, isReadableStream, isResponse} from '../../javascript-utils/is-type';\n\n/**\n * @param [options.chunkSize]\n */\nexport type IteratorOptions = StreamIteratorOptions & {\n  chunkSize?: number;\n};\n\n/**\n * Returns an iterator that breaks its input into chunks and yields them one-by-one.\n * @param data\n * @param options\n * @returns\n * This function can e.g. be used to enable data sources that can only be read atomically\n * (such as `Blob` and `File` via `FileReader`) to still be parsed in batches.\n */\nexport function makeIterator(\n  data: ArrayBuffer | string | Blob | Response | ReadableStream | ReadStream,\n  options?: IteratorOptions\n): AsyncIterable<ArrayBuffer> | Iterable<ArrayBuffer> {\n  if (typeof data === 'string') {\n    // Note: Converts string chunks to binary\n    return makeStringIterator(data, options);\n  }\n  if (data instanceof ArrayBuffer) {\n    return makeArrayBufferIterator(data, options);\n  }\n  if (isBlob(data)) {\n    return makeBlobIterator(data as Blob, options);\n  }\n  if (isReadableStream(data)) {\n    return makeStreamIterator(data as ReadableStream, options);\n  }\n  if (isResponse(data)) {\n    const response = data as Response;\n    return makeStreamIterator(response.body as ReadableStream, options);\n  }\n  throw new Error('makeIterator');\n}\n"]},"metadata":{},"sourceType":"module"}