{"ast":null,"code":"export function getMeshSize(attributes) {\n  let size = 0;\n\n  for (const attributeName in attributes) {\n    const attribute = attributes[attributeName];\n\n    if (ArrayBuffer.isView(attribute)) {\n      size += attribute.byteLength * attribute.BYTES_PER_ELEMENT;\n    }\n  }\n\n  return size;\n}\nexport function getMeshBoundingBox(attributes) {\n  let minX = Infinity;\n  let minY = Infinity;\n  let minZ = Infinity;\n  let maxX = -Infinity;\n  let maxY = -Infinity;\n  let maxZ = -Infinity;\n  const positions = attributes.POSITION ? attributes.POSITION.value : [];\n  const len = positions && positions.length;\n\n  for (let i = 0; i < len; i += 3) {\n    const x = positions[i];\n    const y = positions[i + 1];\n    const z = positions[i + 2];\n    minX = x < minX ? x : minX;\n    minY = y < minY ? y : minY;\n    minZ = z < minZ ? z : minZ;\n    maxX = x > maxX ? x : maxX;\n    maxY = y > maxY ? y : maxY;\n    maxZ = z > maxZ ? z : maxZ;\n  }\n\n  return [[minX, minY, minZ], [maxX, maxY, maxZ]];\n}","map":{"version":3,"sources":["../../../../src/category/mesh/mesh-utils.ts"],"names":["size","attribute","attributes","ArrayBuffer","minX","minY","minZ","maxX","maxY","maxZ","positions","len","i","x","y","z"],"mappings":"AAwBA,OAAO,SAAA,WAAA,CAAA,UAAA,EAAsD;AAC3D,MAAIA,IAAI,GAAR,CAAA;;AACA,OAAK,MAAL,aAAA,IAAA,UAAA,EAAwC;AACtC,UAAMC,SAAS,GAAGC,UAAU,CAA5B,aAA4B,CAA5B;;AACA,QAAIC,WAAW,CAAXA,MAAAA,CAAJ,SAAIA,CAAJ,EAAmC;AAEjCH,MAAAA,IAAI,IAAIC,SAAS,CAATA,UAAAA,GAAuBA,SAAS,CAAxCD,iBAAAA;AACD;AACF;;AACD,SAAA,IAAA;AACD;AAQD,OAAO,SAAA,kBAAA,CAAA,UAAA,EAAiE;AACtE,MAAII,IAAI,GAAR,QAAA;AACA,MAAIC,IAAI,GAAR,QAAA;AACA,MAAIC,IAAI,GAAR,QAAA;AACA,MAAIC,IAAI,GAAG,CAAX,QAAA;AACA,MAAIC,IAAI,GAAG,CAAX,QAAA;AACA,MAAIC,IAAI,GAAG,CAAX,QAAA;AAEA,QAAMC,SAAS,GAAGR,UAAU,CAAVA,QAAAA,GAAsBA,UAAU,CAAVA,QAAAA,CAAtBA,KAAAA,GAAlB,EAAA;AACA,QAAMS,GAAG,GAAGD,SAAS,IAAIA,SAAS,CAAlC,MAAA;;AAEA,OAAK,IAAIE,CAAC,GAAV,CAAA,EAAgBA,CAAC,GAAjB,GAAA,EAAyBA,CAAC,IAA1B,CAAA,EAAiC;AAC/B,UAAMC,CAAC,GAAGH,SAAS,CAAnB,CAAmB,CAAnB;AACA,UAAMI,CAAC,GAAGJ,SAAS,CAACE,CAAC,GAArB,CAAmB,CAAnB;AACA,UAAMG,CAAC,GAAGL,SAAS,CAACE,CAAC,GAArB,CAAmB,CAAnB;AAEAR,IAAAA,IAAI,GAAGS,CAAC,GAADA,IAAAA,GAAAA,CAAAA,GAAPT,IAAAA;AACAC,IAAAA,IAAI,GAAGS,CAAC,GAADA,IAAAA,GAAAA,CAAAA,GAAPT,IAAAA;AACAC,IAAAA,IAAI,GAAGS,CAAC,GAADA,IAAAA,GAAAA,CAAAA,GAAPT,IAAAA;AAEAC,IAAAA,IAAI,GAAGM,CAAC,GAADA,IAAAA,GAAAA,CAAAA,GAAPN,IAAAA;AACAC,IAAAA,IAAI,GAAGM,CAAC,GAADA,IAAAA,GAAAA,CAAAA,GAAPN,IAAAA;AACAC,IAAAA,IAAI,GAAGM,CAAC,GAADA,IAAAA,GAAAA,CAAAA,GAAPN,IAAAA;AACD;;AACD,SAAO,CACL,CAAA,IAAA,EAAA,IAAA,EADK,IACL,CADK,EAEL,CAAA,IAAA,EAAA,IAAA,EAFF,IAEE,CAFK,CAAP;AAID","sourcesContent":["// Mesh category utilities\n// TODO - move to mesh category module, or to math.gl/geometry module\nimport {TypedArray} from '../../types';\n\ntype Attribute = {\n  size?: number;\n  type?: number;\n  normalized?: boolean;\n  value: TypedArray;\n};\n\ntype TypedArrays = {[key: string]: TypedArray};\nexport type Attributes = {[key: string]: Attribute};\n\n/**\n * Holds an axis aligned bounding box\n * TODO - make sure AxisAlignedBoundingBox in math.gl/culling understands this format (or change this format)\n */\ntype BoundingBox = [[number, number, number], [number, number, number]];\n\n/**\n * Get number of vertices in mesh\n * @param attributes\n */\nexport function getMeshSize(attributes: TypedArrays): number {\n  let size = 0;\n  for (const attributeName in attributes) {\n    const attribute = attributes[attributeName];\n    if (ArrayBuffer.isView(attribute)) {\n      // @ts-ignore DataView doesn't have BYTES_PER_ELEMENT\n      size += attribute.byteLength * attribute.BYTES_PER_ELEMENT;\n    }\n  }\n  return size;\n}\n\n/**\n * Get the (axis aligned) bounding box of a mesh\n * @param attributes\n * @returns array of two vectors representing the axis aligned bounding box\n */\n// eslint-disable-next-line complexity\nexport function getMeshBoundingBox(attributes: Attributes): BoundingBox {\n  let minX = Infinity;\n  let minY = Infinity;\n  let minZ = Infinity;\n  let maxX = -Infinity;\n  let maxY = -Infinity;\n  let maxZ = -Infinity;\n\n  const positions = attributes.POSITION ? attributes.POSITION.value : [];\n  const len = positions && positions.length;\n\n  for (let i = 0; i < len; i += 3) {\n    const x = positions[i];\n    const y = positions[i + 1];\n    const z = positions[i + 2];\n\n    minX = x < minX ? x : minX;\n    minY = y < minY ? y : minY;\n    minZ = z < minZ ? z : minZ;\n\n    maxX = x > maxX ? x : maxX;\n    maxY = y > maxY ? y : maxY;\n    maxZ = z > maxZ ? z : maxZ;\n  }\n  return [\n    [minX, minY, minZ],\n    [maxX, maxY, maxZ]\n  ];\n}\n"]},"metadata":{},"sourceType":"module"}