{"ast":null,"code":"import { assertWebGLContext, log } from '@luma.gl/gltools';\nimport { parseGLSLCompilerError, getShaderName } from '../glsl-utils';\nimport { assert } from '../utils/assert';\nimport { uid } from '../utils/utils';\nimport Resource from './resource';\nconst ERR_SOURCE = 'Shader: GLSL source code must be a JavaScript string';\nexport class Shader extends Resource {\n  static getTypeName(shaderType) {\n    switch (shaderType) {\n      case 35633:\n        return 'vertex-shader';\n\n      case 35632:\n        return 'fragment-shader';\n\n      default:\n        assert(false);\n        return 'unknown';\n    }\n  }\n\n  constructor(gl, props) {\n    assertWebGLContext(gl);\n    assert(typeof props.source === 'string', ERR_SOURCE);\n    const id = getShaderName(props.source, null) || props.id || uid(`unnamed ${Shader.getTypeName(props.shaderType)}`);\n    super(gl, {\n      id\n    });\n    this.shaderType = props.shaderType;\n    this.source = props.source;\n    this.initialize(props);\n  }\n\n  initialize(_ref) {\n    let {\n      source\n    } = _ref;\n    const shaderName = getShaderName(source, null);\n\n    if (shaderName) {\n      this.id = uid(shaderName);\n    }\n\n    this._compile(source);\n  }\n\n  getParameter(pname) {\n    return this.gl.getShaderParameter(this.handle, pname);\n  }\n\n  toString() {\n    return `${Shader.getTypeName(this.shaderType)}:${this.id}`;\n  }\n\n  getName() {\n    return getShaderName(this.source) || 'unnamed-shader';\n  }\n\n  getSource() {\n    return this.gl.getShaderSource(this.handle);\n  }\n\n  getTranslatedSource() {\n    const extension = this.gl.getExtension('WEBGL_debug_shaders');\n    return extension ? extension.getTranslatedShaderSource(this.handle) : 'No translated source available. WEBGL_debug_shaders not implemented';\n  }\n\n  _compile() {\n    let source = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.source;\n\n    if (!source.startsWith('#version ')) {\n      source = `#version 100\\n${source}`;\n    }\n\n    this.source = source;\n    this.gl.shaderSource(this.handle, this.source);\n    this.gl.compileShader(this.handle);\n    const compileStatus = this.getParameter(35713);\n\n    if (!compileStatus) {\n      const infoLog = this.gl.getShaderInfoLog(this.handle);\n      const {\n        shaderName,\n        errors,\n        warnings\n      } = parseGLSLCompilerError(infoLog, this.source, this.shaderType, this.id);\n      log.error(`GLSL compilation errors in ${shaderName}\\n${errors}`)();\n      log.warn(`GLSL compilation warnings in ${shaderName}\\n${warnings}`)();\n      throw new Error(`GLSL compilation errors in ${shaderName}`);\n    }\n  }\n\n  _deleteHandle() {\n    this.gl.deleteShader(this.handle);\n  }\n\n  _getOptsFromHandle() {\n    return {\n      type: this.getParameter(35663),\n      source: this.getSource()\n    };\n  }\n\n}\nexport class VertexShader extends Shader {\n  constructor(gl, props) {\n    if (typeof props === 'string') {\n      props = {\n        source: props\n      };\n    }\n\n    super(gl, Object.assign({}, props, {\n      shaderType: 35633\n    }));\n  }\n\n  _createHandle() {\n    return this.gl.createShader(35633);\n  }\n\n}\nexport class FragmentShader extends Shader {\n  constructor(gl, props) {\n    if (typeof props === 'string') {\n      props = {\n        source: props\n      };\n    }\n\n    super(gl, Object.assign({}, props, {\n      shaderType: 35632\n    }));\n  }\n\n  _createHandle() {\n    return this.gl.createShader(35632);\n  }\n\n}","map":{"version":3,"sources":["../../../src/classes/shader.js"],"names":["ERR_SOURCE","getTypeName","assert","constructor","assertWebGLContext","props","id","getShaderName","uid","Shader","initialize","source","shaderName","getParameter","toString","getName","getSource","getTranslatedSource","extension","_compile","compileStatus","infoLog","warnings","parseGLSLCompilerError","log","errors","_deleteHandle","_getOptsFromHandle","type","shaderType","_createHandle"],"mappings":"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","sourcesContent":["import GL from '@luma.gl/constants';\nimport {assertWebGLContext, log} from '@luma.gl/gltools';\nimport {parseGLSLCompilerError, getShaderName} from '../glsl-utils';\nimport {assert} from '../utils/assert';\nimport {uid} from '../utils/utils';\nimport Resource from './resource';\n\nconst ERR_SOURCE = 'Shader: GLSL source code must be a JavaScript string';\n\n// For now this is an internal class\nexport class Shader extends Resource {\n  static getTypeName(shaderType) {\n    switch (shaderType) {\n      case GL.VERTEX_SHADER:\n        return 'vertex-shader';\n      case GL.FRAGMENT_SHADER:\n        return 'fragment-shader';\n      default:\n        assert(false);\n        return 'unknown';\n    }\n  }\n\n  /* eslint-disable max-statements */\n  constructor(gl, props) {\n    assertWebGLContext(gl);\n\n    // Validate arguments\n    assert(typeof props.source === 'string', ERR_SOURCE);\n\n    // Deduce an id, from shader source, or supplied id, or shader type\n    const id =\n      getShaderName(props.source, null) ||\n      props.id ||\n      uid(`unnamed ${Shader.getTypeName(props.shaderType)}`);\n\n    super(gl, {id});\n\n    this.shaderType = props.shaderType;\n    this.source = props.source;\n\n    this.initialize(props);\n  }\n\n  initialize({source}) {\n    const shaderName = getShaderName(source, null);\n    if (shaderName) {\n      this.id = uid(shaderName);\n    }\n    this._compile(source);\n  }\n\n  // Accessors\n\n  getParameter(pname) {\n    return this.gl.getShaderParameter(this.handle, pname);\n  }\n\n  toString() {\n    return `${Shader.getTypeName(this.shaderType)}:${this.id}`;\n  }\n\n  getName() {\n    return getShaderName(this.source) || 'unnamed-shader';\n  }\n\n  getSource() {\n    return this.gl.getShaderSource(this.handle);\n  }\n\n  // Debug method - Returns translated source if available\n  getTranslatedSource() {\n    const extension = this.gl.getExtension('WEBGL_debug_shaders');\n    return extension\n      ? extension.getTranslatedShaderSource(this.handle)\n      : 'No translated source available. WEBGL_debug_shaders not implemented';\n  }\n\n  // PRIVATE METHODS\n  _compile(source = this.source) {\n    if (!source.startsWith('#version ')) {\n      source = `#version 100\\n${source}`;\n    }\n    this.source = source;\n    this.gl.shaderSource(this.handle, this.source);\n    this.gl.compileShader(this.handle);\n\n    // TODO - For performance reasons, avoid checking shader compilation errors on production?\n    // TODO - Load log even when no error reported, to catch warnings?\n    // https://gamedev.stackexchange.com/questions/30429/how-to-detect-glsl-warnings\n    const compileStatus = this.getParameter(GL.COMPILE_STATUS);\n    if (!compileStatus) {\n      const infoLog = this.gl.getShaderInfoLog(this.handle);\n      const {shaderName, errors, warnings} = parseGLSLCompilerError(\n        infoLog,\n        this.source,\n        this.shaderType,\n        this.id\n      );\n      log.error(`GLSL compilation errors in ${shaderName}\\n${errors}`)();\n      log.warn(`GLSL compilation warnings in ${shaderName}\\n${warnings}`)();\n      throw new Error(`GLSL compilation errors in ${shaderName}`);\n    }\n  }\n\n  _deleteHandle() {\n    this.gl.deleteShader(this.handle);\n  }\n\n  _getOptsFromHandle() {\n    return {\n      type: this.getParameter(GL.SHADER_TYPE),\n      source: this.getSource()\n    };\n  }\n}\n\nexport class VertexShader extends Shader {\n  constructor(gl, props) {\n    // Signature: new VertexShader(gl, source)\n    if (typeof props === 'string') {\n      props = {source: props};\n    }\n    super(gl, Object.assign({}, props, {shaderType: GL.VERTEX_SHADER}));\n  }\n\n  // PRIVATE METHODS\n  _createHandle() {\n    return this.gl.createShader(GL.VERTEX_SHADER);\n  }\n}\n\nexport class FragmentShader extends Shader {\n  constructor(gl, props) {\n    // Signature: new FragmentShader(gl, source)\n    if (typeof props === 'string') {\n      props = {source: props};\n    }\n\n    super(gl, Object.assign({}, props, {shaderType: GL.FRAGMENT_SHADER}));\n  }\n\n  // PRIVATE METHODS\n  _createHandle() {\n    return this.gl.createShader(GL.FRAGMENT_SHADER);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}