{"ast":null,"code":"import { COORDINATE_SYSTEM, PROJECTION_MODE } from '../../lib/constants';\nimport project from '../project/project';\nimport { Vector3, Matrix4 } from 'math.gl';\nimport memoize from '../../utils/memoize';\nimport { pixelsToWorld } from '@math.gl/web-mercator';\nconst vs = \"\\nconst int max_lights = 2;\\nuniform mat4 shadow_uViewProjectionMatrices[max_lights];\\nuniform vec4 shadow_uProjectCenters[max_lights];\\nuniform bool shadow_uDrawShadowMap;\\nuniform bool shadow_uUseShadowMap;\\nuniform int shadow_uLightId;\\nuniform float shadow_uLightCount;\\n\\nvarying vec3 shadow_vPosition[max_lights];\\n\\nvec4 shadow_setVertexPosition(vec4 position_commonspace) {\\n  if (shadow_uDrawShadowMap) {\\n    return project_common_position_to_clipspace(position_commonspace, shadow_uViewProjectionMatrices[shadow_uLightId], shadow_uProjectCenters[shadow_uLightId]);\\n  }\\n  if (shadow_uUseShadowMap) {\\n    for (int i = 0; i < max_lights; i++) {\\n      if(i < int(shadow_uLightCount)) {\\n        vec4 shadowMap_position = project_common_position_to_clipspace(position_commonspace, shadow_uViewProjectionMatrices[i], shadow_uProjectCenters[i]);\\n        shadow_vPosition[i] = (shadowMap_position.xyz / shadowMap_position.w + 1.0) / 2.0;\\n      }\\n    }\\n  }\\n  return gl_Position;\\n}\\n\";\nconst fs = \"\\nconst int max_lights = 2;\\nuniform bool shadow_uDrawShadowMap;\\nuniform bool shadow_uUseShadowMap;\\nuniform sampler2D shadow_uShadowMap0;\\nuniform sampler2D shadow_uShadowMap1;\\nuniform vec4 shadow_uColor;\\nuniform float shadow_uLightCount;\\n\\nvarying vec3 shadow_vPosition[max_lights];\\n\\nconst vec4 bitPackShift = vec4(1.0, 255.0, 65025.0, 16581375.0);\\nconst vec4 bitUnpackShift = 1.0 / bitPackShift;\\nconst vec4 bitMask = vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0,  0.0);\\n\\nfloat shadow_getShadowWeight(vec3 position, sampler2D shadowMap) {\\n  vec4 rgbaDepth = texture2D(shadowMap, position.xy);\\n\\n  float z = dot(rgbaDepth, bitUnpackShift);\\n  return smoothstep(0.001, 0.01, position.z - z);\\n}\\n\\nvec4 shadow_filterShadowColor(vec4 color) {\\n  if (shadow_uDrawShadowMap) {\\n    vec4 rgbaDepth = fract(gl_FragCoord.z * bitPackShift);\\n    rgbaDepth -= rgbaDepth.gbaa * bitMask;\\n    return rgbaDepth;\\n  }\\n  if (shadow_uUseShadowMap) {\\n    float shadowAlpha = 0.0;\\n    shadowAlpha += shadow_getShadowWeight(shadow_vPosition[0], shadow_uShadowMap0);\\n    if(shadow_uLightCount > 1.0) {\\n      shadowAlpha += shadow_getShadowWeight(shadow_vPosition[1], shadow_uShadowMap1);\\n    }\\n    shadowAlpha *= shadow_uColor.a / shadow_uLightCount;\\n    float blendedAlpha = shadowAlpha + color.a * (1.0 - shadowAlpha);\\n\\n    return vec4(\\n      mix(color.rgb, shadow_uColor.rgb, shadowAlpha / blendedAlpha),\\n      blendedAlpha\\n    );\\n  }\\n  return color;\\n}\\n\";\nconst getMemoizedViewportCenterPosition = memoize(getViewportCenterPosition);\nconst getMemoizedViewProjectionMatrices = memoize(getViewProjectionMatrices);\nconst DEFAULT_SHADOW_COLOR = [0, 0, 0, 1.0];\nconst VECTOR_TO_POINT_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0];\n\nfunction screenToCommonSpace(xyz, pixelUnprojectionMatrix) {\n  const [x, y, z] = xyz;\n  const coord = pixelsToWorld([x, y, z], pixelUnprojectionMatrix);\n\n  if (Number.isFinite(z)) {\n    return coord;\n  }\n\n  return [coord[0], coord[1], 0];\n}\n\nfunction getViewportCenterPosition(_ref) {\n  let {\n    viewport,\n    center\n  } = _ref;\n  return new Matrix4(viewport.viewProjectionMatrix).invert().transform(center);\n}\n\nfunction getViewProjectionMatrices(_ref2) {\n  let {\n    viewport,\n    shadowMatrices\n  } = _ref2;\n  const projectionMatrices = [];\n  const pixelUnprojectionMatrix = viewport.pixelUnprojectionMatrix;\n  const farZ = viewport.isGeospatial ? undefined : 1;\n  const corners = [[0, 0, farZ], [viewport.width, 0, farZ], [0, viewport.height, farZ], [viewport.width, viewport.height, farZ], [0, 0, -1], [viewport.width, 0, -1], [0, viewport.height, -1], [viewport.width, viewport.height, -1]].map(pixel => screenToCommonSpace(pixel, pixelUnprojectionMatrix));\n\n  for (const shadowMatrix of shadowMatrices) {\n    const viewMatrix = shadowMatrix.clone().translate(new Vector3(viewport.center).negate());\n    const positions = corners.map(corner => viewMatrix.transform(corner));\n    const projectionMatrix = new Matrix4().ortho({\n      left: Math.min(...positions.map(position => position[0])),\n      right: Math.max(...positions.map(position => position[0])),\n      bottom: Math.min(...positions.map(position => position[1])),\n      top: Math.max(...positions.map(position => position[1])),\n      near: Math.min(...positions.map(position => -position[2])),\n      far: Math.max(...positions.map(position => -position[2]))\n    });\n    projectionMatrices.push(projectionMatrix.multiplyRight(shadowMatrix));\n  }\n\n  return projectionMatrices;\n}\n\nfunction createShadowUniforms() {\n  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const uniforms = {\n    shadow_uDrawShadowMap: Boolean(opts.drawToShadowMap),\n    shadow_uUseShadowMap: opts.shadowMaps ? opts.shadowMaps.length > 0 : false,\n    shadow_uColor: opts.shadowColor || DEFAULT_SHADOW_COLOR,\n    shadow_uLightId: opts.shadowLightId || 0,\n    shadow_uLightCount: opts.shadowMatrices.length\n  };\n  const center = getMemoizedViewportCenterPosition({\n    viewport: opts.viewport,\n    center: context.project_uCenter\n  });\n  const projectCenters = [];\n  const viewProjectionMatrices = getMemoizedViewProjectionMatrices({\n    shadowMatrices: opts.shadowMatrices,\n    viewport: opts.viewport\n  }).slice();\n\n  for (let i = 0; i < opts.shadowMatrices.length; i++) {\n    const viewProjectionMatrix = viewProjectionMatrices[i];\n    const viewProjectionMatrixCentered = viewProjectionMatrix.clone().translate(new Vector3(opts.viewport.center).negate());\n\n    if (context.project_uCoordinateSystem === COORDINATE_SYSTEM.LNGLAT && context.project_uProjectionMode === PROJECTION_MODE.WEB_MERCATOR) {\n      viewProjectionMatrices[i] = viewProjectionMatrixCentered;\n      projectCenters[i] = center;\n    } else {\n      viewProjectionMatrices[i] = viewProjectionMatrix.clone().multiplyRight(VECTOR_TO_POINT_MATRIX);\n      projectCenters[i] = viewProjectionMatrixCentered.transform(center);\n    }\n  }\n\n  for (let i = 0; i < viewProjectionMatrices.length; i++) {\n    uniforms[\"shadow_uViewProjectionMatrices[\".concat(i, \"]\")] = viewProjectionMatrices[i];\n    uniforms[\"shadow_uProjectCenters[\".concat(i, \"]\")] = projectCenters[i];\n\n    if (opts.shadowMaps && opts.shadowMaps.length > 0) {\n      uniforms[\"shadow_uShadowMap\".concat(i)] = opts.shadowMaps[i];\n    } else {\n      uniforms[\"shadow_uShadowMap\".concat(i)] = opts.dummyShadowMap;\n    }\n  }\n\n  return uniforms;\n}\n\nexport default {\n  name: 'shadow',\n  dependencies: [project],\n  vs,\n  fs,\n  inject: {\n    'vs:DECKGL_FILTER_GL_POSITION': \"\\n    position = shadow_setVertexPosition(geometry.position);\\n    \",\n    'fs:DECKGL_FILTER_COLOR': \"\\n    color = shadow_filterShadowColor(color);\\n    \"\n  },\n  getUniforms: function () {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (opts.drawToShadowMap || opts.shadowMaps && opts.shadowMaps.length > 0) {\n      const {\n        shadowEnabled = true\n      } = opts;\n      return shadowEnabled && opts.shadowMatrices && opts.shadowMatrices.length > 0 ? createShadowUniforms(opts, context) : {\n        shadow_uDrawShadowMap: false,\n        shadow_uUseShadowMap: false\n      };\n    }\n\n    return {};\n  }\n};","map":{"version":3,"sources":["../../../../src/shaderlib/shadow/shadow.js"],"names":["vs","fs","getMemoizedViewportCenterPosition","memoize","getMemoizedViewProjectionMatrices","DEFAULT_SHADOW_COLOR","VECTOR_TO_POINT_MATRIX","coord","pixelsToWorld","Number","center","viewport","shadowMatrices","projectionMatrices","pixelUnprojectionMatrix","farZ","corners","pixel","screenToCommonSpace","viewMatrix","shadowMatrix","positions","corner","projectionMatrix","left","Math","position","right","bottom","top","near","far","opts","context","uniforms","shadow_uDrawShadowMap","Boolean","shadow_uUseShadowMap","shadow_uColor","shadow_uLightId","shadow_uLightCount","length","project_uCenter","projectCenters","viewProjectionMatrices","i","viewProjectionMatrix","viewProjectionMatrixCentered","COORDINATE_SYSTEM","PROJECTION_MODE","name","dependencies","inject","getUniforms","shadowEnabled","createShadowUniforms"],"mappings":"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","sourcesContent":["// Copyright (c) 2015-2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nimport {COORDINATE_SYSTEM, PROJECTION_MODE} from '../../lib/constants';\nimport project from '../project/project';\nimport {Vector3, Matrix4} from 'math.gl';\nimport memoize from '../../utils/memoize';\nimport {pixelsToWorld} from '@math.gl/web-mercator';\n\nconst vs = `\nconst int max_lights = 2;\nuniform mat4 shadow_uViewProjectionMatrices[max_lights];\nuniform vec4 shadow_uProjectCenters[max_lights];\nuniform bool shadow_uDrawShadowMap;\nuniform bool shadow_uUseShadowMap;\nuniform int shadow_uLightId;\nuniform float shadow_uLightCount;\n\nvarying vec3 shadow_vPosition[max_lights];\n\nvec4 shadow_setVertexPosition(vec4 position_commonspace) {\n  if (shadow_uDrawShadowMap) {\n    return project_common_position_to_clipspace(position_commonspace, shadow_uViewProjectionMatrices[shadow_uLightId], shadow_uProjectCenters[shadow_uLightId]);\n  }\n  if (shadow_uUseShadowMap) {\n    for (int i = 0; i < max_lights; i++) {\n      if(i < int(shadow_uLightCount)) {\n        vec4 shadowMap_position = project_common_position_to_clipspace(position_commonspace, shadow_uViewProjectionMatrices[i], shadow_uProjectCenters[i]);\n        shadow_vPosition[i] = (shadowMap_position.xyz / shadowMap_position.w + 1.0) / 2.0;\n      }\n    }\n  }\n  return gl_Position;\n}\n`;\n\nconst fs = `\nconst int max_lights = 2;\nuniform bool shadow_uDrawShadowMap;\nuniform bool shadow_uUseShadowMap;\nuniform sampler2D shadow_uShadowMap0;\nuniform sampler2D shadow_uShadowMap1;\nuniform vec4 shadow_uColor;\nuniform float shadow_uLightCount;\n\nvarying vec3 shadow_vPosition[max_lights];\n\nconst vec4 bitPackShift = vec4(1.0, 255.0, 65025.0, 16581375.0);\nconst vec4 bitUnpackShift = 1.0 / bitPackShift;\nconst vec4 bitMask = vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0,  0.0);\n\nfloat shadow_getShadowWeight(vec3 position, sampler2D shadowMap) {\n  vec4 rgbaDepth = texture2D(shadowMap, position.xy);\n\n  float z = dot(rgbaDepth, bitUnpackShift);\n  return smoothstep(0.001, 0.01, position.z - z);\n}\n\nvec4 shadow_filterShadowColor(vec4 color) {\n  if (shadow_uDrawShadowMap) {\n    vec4 rgbaDepth = fract(gl_FragCoord.z * bitPackShift);\n    rgbaDepth -= rgbaDepth.gbaa * bitMask;\n    return rgbaDepth;\n  }\n  if (shadow_uUseShadowMap) {\n    float shadowAlpha = 0.0;\n    shadowAlpha += shadow_getShadowWeight(shadow_vPosition[0], shadow_uShadowMap0);\n    if(shadow_uLightCount > 1.0) {\n      shadowAlpha += shadow_getShadowWeight(shadow_vPosition[1], shadow_uShadowMap1);\n    }\n    shadowAlpha *= shadow_uColor.a / shadow_uLightCount;\n    float blendedAlpha = shadowAlpha + color.a * (1.0 - shadowAlpha);\n\n    return vec4(\n      mix(color.rgb, shadow_uColor.rgb, shadowAlpha / blendedAlpha),\n      blendedAlpha\n    );\n  }\n  return color;\n}\n`;\n\nconst getMemoizedViewportCenterPosition = memoize(getViewportCenterPosition);\nconst getMemoizedViewProjectionMatrices = memoize(getViewProjectionMatrices);\n\nconst DEFAULT_SHADOW_COLOR = [0, 0, 0, 1.0];\nconst VECTOR_TO_POINT_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0];\n\nfunction screenToCommonSpace(xyz, pixelUnprojectionMatrix) {\n  const [x, y, z] = xyz;\n  const coord = pixelsToWorld([x, y, z], pixelUnprojectionMatrix);\n\n  if (Number.isFinite(z)) {\n    return coord;\n  }\n  return [coord[0], coord[1], 0];\n}\n\nfunction getViewportCenterPosition({viewport, center}) {\n  return new Matrix4(viewport.viewProjectionMatrix).invert().transform(center);\n}\n\nfunction getViewProjectionMatrices({viewport, shadowMatrices}) {\n  const projectionMatrices = [];\n  const pixelUnprojectionMatrix = viewport.pixelUnprojectionMatrix;\n  const farZ = viewport.isGeospatial ? undefined : 1;\n  const corners = [\n    [0, 0, farZ], // top left ground\n    [viewport.width, 0, farZ], // top right ground\n    [0, viewport.height, farZ], // bottom left ground\n    [viewport.width, viewport.height, farZ], // bottom right ground\n    [0, 0, -1], // top left near\n    [viewport.width, 0, -1], // top right near\n    [0, viewport.height, -1], // bottom left near\n    [viewport.width, viewport.height, -1] // bottom right near\n  ].map(pixel => screenToCommonSpace(pixel, pixelUnprojectionMatrix));\n\n  for (const shadowMatrix of shadowMatrices) {\n    const viewMatrix = shadowMatrix.clone().translate(new Vector3(viewport.center).negate());\n    const positions = corners.map(corner => viewMatrix.transform(corner));\n    const projectionMatrix = new Matrix4().ortho({\n      left: Math.min(...positions.map(position => position[0])),\n      right: Math.max(...positions.map(position => position[0])),\n      bottom: Math.min(...positions.map(position => position[1])),\n      top: Math.max(...positions.map(position => position[1])),\n      near: Math.min(...positions.map(position => -position[2])),\n      far: Math.max(...positions.map(position => -position[2]))\n    });\n    projectionMatrices.push(projectionMatrix.multiplyRight(shadowMatrix));\n  }\n  return projectionMatrices;\n}\n\nfunction createShadowUniforms(opts = {}, context = {}) {\n  const uniforms = {\n    shadow_uDrawShadowMap: Boolean(opts.drawToShadowMap),\n    shadow_uUseShadowMap: opts.shadowMaps ? opts.shadowMaps.length > 0 : false,\n    shadow_uColor: opts.shadowColor || DEFAULT_SHADOW_COLOR,\n    shadow_uLightId: opts.shadowLightId || 0,\n    shadow_uLightCount: opts.shadowMatrices.length\n  };\n\n  const center = getMemoizedViewportCenterPosition({\n    viewport: opts.viewport,\n    center: context.project_uCenter\n  });\n\n  const projectCenters = [];\n  const viewProjectionMatrices = getMemoizedViewProjectionMatrices({\n    shadowMatrices: opts.shadowMatrices,\n    viewport: opts.viewport\n  }).slice();\n\n  for (let i = 0; i < opts.shadowMatrices.length; i++) {\n    const viewProjectionMatrix = viewProjectionMatrices[i];\n    const viewProjectionMatrixCentered = viewProjectionMatrix\n      .clone()\n      .translate(new Vector3(opts.viewport.center).negate());\n\n    if (\n      context.project_uCoordinateSystem === COORDINATE_SYSTEM.LNGLAT &&\n      context.project_uProjectionMode === PROJECTION_MODE.WEB_MERCATOR\n    ) {\n      viewProjectionMatrices[i] = viewProjectionMatrixCentered;\n      projectCenters[i] = center;\n    } else {\n      viewProjectionMatrices[i] = viewProjectionMatrix\n        .clone()\n        .multiplyRight(VECTOR_TO_POINT_MATRIX);\n      projectCenters[i] = viewProjectionMatrixCentered.transform(center);\n    }\n  }\n\n  for (let i = 0; i < viewProjectionMatrices.length; i++) {\n    uniforms[`shadow_uViewProjectionMatrices[${i}]`] = viewProjectionMatrices[i];\n    uniforms[`shadow_uProjectCenters[${i}]`] = projectCenters[i];\n\n    if (opts.shadowMaps && opts.shadowMaps.length > 0) {\n      uniforms[`shadow_uShadowMap${i}`] = opts.shadowMaps[i];\n    } else {\n      uniforms[`shadow_uShadowMap${i}`] = opts.dummyShadowMap;\n    }\n  }\n  return uniforms;\n}\n\nexport default {\n  name: 'shadow',\n  dependencies: [project],\n  vs,\n  fs,\n  inject: {\n    'vs:DECKGL_FILTER_GL_POSITION': `\n    position = shadow_setVertexPosition(geometry.position);\n    `,\n    'fs:DECKGL_FILTER_COLOR': `\n    color = shadow_filterShadowColor(color);\n    `\n  },\n  getUniforms: (opts = {}, context = {}) => {\n    if (opts.drawToShadowMap || (opts.shadowMaps && opts.shadowMaps.length > 0)) {\n      const {shadowEnabled = true} = opts;\n      return shadowEnabled && opts.shadowMatrices && opts.shadowMatrices.length > 0\n        ? createShadowUniforms(opts, context)\n        : {\n            shadow_uDrawShadowMap: false,\n            shadow_uUseShadowMap: false\n          };\n    }\n    return {};\n  }\n};\n"]},"metadata":{},"sourceType":"module"}