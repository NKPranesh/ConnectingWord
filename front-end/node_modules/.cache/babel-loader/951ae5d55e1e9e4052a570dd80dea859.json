{"ast":null,"code":"export function dirname(url) {\n  const slashIndex = url && url.lastIndexOf('/');\n  return slashIndex >= 0 ? url.substr(0, slashIndex) : '';\n}\nexport function join() {\n  for (var _len = arguments.length, parts = new Array(_len), _key = 0; _key < _len; _key++) {\n    parts[_key] = arguments[_key];\n  }\n\n  const separator = '/';\n  parts = parts.map((part, index) => {\n    if (index) {\n      part = part.replace(new RegExp(\"^\".concat(separator)), '');\n    }\n\n    if (index !== parts.length - 1) {\n      part = part.replace(new RegExp(\"\".concat(separator, \"$\")), '');\n    }\n\n    return part;\n  });\n  return parts.join(separator);\n}","map":{"version":3,"sources":["../../../../src/lib/path-utils/path.ts"],"names":["slashIndex","url","separator","parts","part","index"],"mappings":"AAMA,OAAO,SAAA,OAAA,CAAA,GAAA,EAAsC;AAC3C,QAAMA,UAAU,GAAGC,GAAG,IAAIA,GAAG,CAAHA,WAAAA,CAA1B,GAA0BA,CAA1B;AACA,SAAOD,UAAU,IAAVA,CAAAA,GAAkBC,GAAG,CAAHA,MAAAA,CAAAA,CAAAA,EAAlBD,UAAkBC,CAAlBD,GAAP,EAAA;AACD;AAMD,OAAO,SAAA,IAAA,GAA0C;AAAA,oCAA1C,KAA0C;AAA1C,IAAA,KAA0C;AAAA;;AAC/C,QAAME,SAAS,GAAf,GAAA;AACAC,EAAAA,KAAK,GAAG,KAAK,CAAL,GAAA,CAAU,CAAA,IAAA,EAAA,KAAA,KAAiB;AACjC,QAAA,KAAA,EAAW;AACTC,MAAAA,IAAI,GAAGA,IAAI,CAAJA,OAAAA,CAAa,IAAA,MAAA,CAAA,IAAA,MAAA,CAAbA,SAAa,CAAA,CAAbA,EAAPA,EAAOA,CAAPA;AACD;;AACD,QAAIC,KAAK,KAAKF,KAAK,CAALA,MAAAA,GAAd,CAAA,EAAgC;AAC9BC,MAAAA,IAAI,GAAGA,IAAI,CAAJA,OAAAA,CAAa,IAAA,MAAA,CAAA,GAAA,MAAA,CAAA,SAAA,EAAbA,GAAa,CAAA,CAAbA,EAAPA,EAAOA,CAAPA;AACD;;AACD,WAAA,IAAA;AAPFD,GAAQ,CAARA;AASA,SAAOA,KAAK,CAALA,IAAAA,CAAP,SAAOA,CAAP;AACD","sourcesContent":["// Beginning of a minimal implementation of the Node.js path API, that doesn't pull in big polyfills.\n\n/**\n * Replacement for Node.js path.dirname\n * @param url\n */\nexport function dirname(url: string): string {\n  const slashIndex = url && url.lastIndexOf('/');\n  return slashIndex >= 0 ? url.substr(0, slashIndex as number) : '';\n}\n\n/**\n * Replacement for Node.js path.join\n * @param parts\n */\nexport function join(...parts: string[]): string {\n  const separator = '/';\n  parts = parts.map((part, index) => {\n    if (index) {\n      part = part.replace(new RegExp(`^${separator}`), '');\n    }\n    if (index !== parts.length - 1) {\n      part = part.replace(new RegExp(`${separator}$`), '');\n    }\n    return part;\n  });\n  return parts.join(separator);\n}\n"]},"metadata":{},"sourceType":"module"}