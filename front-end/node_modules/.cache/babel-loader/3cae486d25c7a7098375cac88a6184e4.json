{"ast":null,"code":"import { Model, Texture2D, Framebuffer, isWebGL2 } from '@luma.gl/core';\nconst AGGREGATE_VS = \"#define SHADER_NAME data-filter-vertex-shader\\n\\n#ifdef FLOAT_TARGET\\n  attribute float filterIndices;\\n  attribute float filterPrevIndices;\\n#else\\n  attribute vec2 filterIndices;\\n  attribute vec2 filterPrevIndices;\\n#endif\\n\\nvarying vec4 vColor;\\nconst float component = 1.0 / 255.0;\\n\\nvoid main() {\\n  #ifdef FLOAT_TARGET\\n    dataFilter_value *= float(filterIndices != filterPrevIndices);\\n    gl_Position = vec4(0.0, 0.0, 0.0, 1.0);\\n    vColor = vec4(0.0, 0.0, 0.0, 1.0);\\n  #else\\n    // Float texture is not supported: pack result into 4 channels x 256 px x 64px\\n    dataFilter_value *= float(filterIndices.x != filterPrevIndices.x);\\n    float col = filterIndices.x;\\n    float row = filterIndices.y * 4.0;\\n    float channel = floor(row);\\n    row = fract(row);\\n    vColor = component * vec4(bvec4(channel == 0.0, channel == 1.0, channel == 2.0, channel == 3.0));\\n    gl_Position = vec4(col * 2.0 - 1.0, row * 2.0 - 1.0, 0.0, 1.0);\\n  #endif\\n  gl_PointSize = 1.0;\\n}\\n\";\nconst AGGREGATE_FS = \"#define SHADER_NAME data-filter-fragment-shader\\nprecision highp float;\\n\\nvarying vec4 vColor;\\n\\nvoid main() {\\n  if (dataFilter_value < 0.5) {\\n    discard;\\n  }\\n  gl_FragColor = vColor;\\n}\\n\";\nexport function supportsFloatTarget(gl) {\n  return gl.getExtension('EXT_float_blend') && (gl.getExtension('EXT_color_buffer_float') || gl.getExtension('WEBGL_color_buffer_float'));\n}\nexport function getFramebuffer(gl, useFloatTarget) {\n  if (useFloatTarget) {\n    return new Framebuffer(gl, {\n      width: 1,\n      height: 1,\n      attachments: {\n        [36064]: new Texture2D(gl, {\n          format: isWebGL2(gl) ? 34836 : 6408,\n          type: 5126,\n          mipmaps: false\n        })\n      }\n    });\n  }\n\n  return new Framebuffer(gl, {\n    width: 256,\n    height: 64,\n    depth: false\n  });\n}\nexport function getModel(gl, shaderOptions, useFloatTarget) {\n  shaderOptions.defines.NON_INSTANCED_MODEL = 1;\n\n  if (useFloatTarget) {\n    shaderOptions.defines.FLOAT_TARGET = 1;\n  }\n\n  return new Model(gl, {\n    id: 'data-filter-aggregation-model',\n    vertexCount: 1,\n    isInstanced: false,\n    drawMode: 0,\n    vs: AGGREGATE_VS,\n    fs: AGGREGATE_FS,\n    ...shaderOptions\n  });\n}\nexport const parameters = {\n  blend: true,\n  blendFunc: [1, 1, 1, 1],\n  blendEquation: [32774, 32774],\n  depthTest: false\n};","map":{"version":3,"sources":["../../../src/data-filter/aggregator.js"],"names":["AGGREGATE_VS","AGGREGATE_FS","gl","width","height","attachments","format","isWebGL2","type","mipmaps","depth","shaderOptions","id","vertexCount","isInstanced","drawMode","vs","fs","parameters","blend","blendFunc","blendEquation","depthTest"],"mappings":"AAAA,SAAA,KAAA,EAAA,SAAA,EAAA,WAAA,EAAA,QAAA,QAAA,eAAA;AAGA,MAAMA,YAAY,GAAlB,29BAAA;AAiCA,MAAMC,YAAY,GAAlB,qMAAA;AAcA,OAAO,SAAA,mBAAA,CAAA,EAAA,EAAiC;AAEtC,SACEC,EAAE,CAAFA,YAAAA,CAAAA,iBAAAA,MAECA,EAAE,CAAFA,YAAAA,CAAAA,wBAAAA,KAECA,EAAE,CAAFA,YAAAA,CALJ,0BAKIA,CAJFA,CADF;AAOD;AAGD,OAAO,SAAA,cAAA,CAAA,EAAA,EAAA,cAAA,EAA4C;AACjD,MAAA,cAAA,EAAoB;AAClB,WAAO,IAAA,WAAA,CAAA,EAAA,EAAoB;AACzBC,MAAAA,KAAK,EADoB,CAAA;AAEzBC,MAAAA,MAAM,EAFmB,CAAA;AAGzBC,MAAAA,WAAW,EAAE;AACX,SAAA,KAAA,GAAwB,IAAA,SAAA,CAAA,EAAA,EAAkB;AACxCC,UAAAA,MAAM,EAAEC,QAAQ,CAARA,EAAQ,CAARA,GAAAA,KAAAA,GADgC,IAAA;AAExCC,UAAAA,IAAI,EAFoC,IAAA;AAGxCC,UAAAA,OAAO,EAAE;AAH+B,SAAlB;AADb;AAHY,KAApB,CAAP;AAWD;;AACD,SAAO,IAAA,WAAA,CAAA,EAAA,EAAoB;AACzBN,IAAAA,KAAK,EADoB,GAAA;AAEzBC,IAAAA,MAAM,EAFmB,EAAA;AAGzBM,IAAAA,KAAK,EAAE;AAHkB,GAApB,CAAP;AAKD;AAGD,OAAO,SAAA,QAAA,CAAA,EAAA,EAAA,aAAA,EAAA,cAAA,EAAqD;AAC1DC,EAAAA,aAAa,CAAbA,OAAAA,CAAAA,mBAAAA,GAAAA,CAAAA;;AACA,MAAA,cAAA,EAAoB;AAClBA,IAAAA,aAAa,CAAbA,OAAAA,CAAAA,YAAAA,GAAAA,CAAAA;AACD;;AAED,SAAO,IAAA,KAAA,CAAA,EAAA,EAAc;AACnBC,IAAAA,EAAE,EADiB,+BAAA;AAEnBC,IAAAA,WAAW,EAFQ,CAAA;AAGnBC,IAAAA,WAAW,EAHQ,KAAA;AAInBC,IAAAA,QAAQ,EAJW,CAAA;AAKnBC,IAAAA,EAAE,EALiB,YAAA;AAMnBC,IAAAA,EAAE,EANiB,YAAA;AAOnB,OAAGN;AAPgB,GAAd,CAAP;AASD;AAED,OAAO,MAAMO,UAAU,GAAG;AACxBC,EAAAA,KAAK,EADmB,IAAA;AAExBC,EAAAA,SAAS,EAAE,CAAA,CAAA,EAAA,CAAA,EAAA,CAAA,EAFa,CAEb,CAFa;AAGxBC,EAAAA,aAAa,EAAE,CAAA,KAAA,EAHS,KAGT,CAHS;AAIxBC,EAAAA,SAAS,EAAE;AAJa,CAAnB","sourcesContent":["import {Model, Texture2D, Framebuffer, isWebGL2} from '@luma.gl/core';\r\nimport GL from '@luma.gl/constants';\r\n\r\nconst AGGREGATE_VS = `\\\r\n#define SHADER_NAME data-filter-vertex-shader\r\n\r\n#ifdef FLOAT_TARGET\r\n  attribute float filterIndices;\r\n  attribute float filterPrevIndices;\r\n#else\r\n  attribute vec2 filterIndices;\r\n  attribute vec2 filterPrevIndices;\r\n#endif\r\n\r\nvarying vec4 vColor;\r\nconst float component = 1.0 / 255.0;\r\n\r\nvoid main() {\r\n  #ifdef FLOAT_TARGET\r\n    dataFilter_value *= float(filterIndices != filterPrevIndices);\r\n    gl_Position = vec4(0.0, 0.0, 0.0, 1.0);\r\n    vColor = vec4(0.0, 0.0, 0.0, 1.0);\r\n  #else\r\n    // Float texture is not supported: pack result into 4 channels x 256 px x 64px\r\n    dataFilter_value *= float(filterIndices.x != filterPrevIndices.x);\r\n    float col = filterIndices.x;\r\n    float row = filterIndices.y * 4.0;\r\n    float channel = floor(row);\r\n    row = fract(row);\r\n    vColor = component * vec4(bvec4(channel == 0.0, channel == 1.0, channel == 2.0, channel == 3.0));\r\n    gl_Position = vec4(col * 2.0 - 1.0, row * 2.0 - 1.0, 0.0, 1.0);\r\n  #endif\r\n  gl_PointSize = 1.0;\r\n}\r\n`;\r\n\r\nconst AGGREGATE_FS = `\\\r\n#define SHADER_NAME data-filter-fragment-shader\r\nprecision highp float;\r\n\r\nvarying vec4 vColor;\r\n\r\nvoid main() {\r\n  if (dataFilter_value < 0.5) {\r\n    discard;\r\n  }\r\n  gl_FragColor = vColor;\r\n}\r\n`;\r\n\r\nexport function supportsFloatTarget(gl) {\r\n  // https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_best_practices#Support_for_float_textures_doesnt_mean_you_can_render_into_them!\r\n  return (\r\n    gl.getExtension('EXT_float_blend') &&\r\n    // WebGL 2\r\n    (gl.getExtension('EXT_color_buffer_float') ||\r\n      // WebGL 1\r\n      gl.getExtension('WEBGL_color_buffer_float'))\r\n  );\r\n}\r\n\r\n// A 1x1 framebuffer object that encodes the total count of filtered items\r\nexport function getFramebuffer(gl, useFloatTarget) {\r\n  if (useFloatTarget) {\r\n    return new Framebuffer(gl, {\r\n      width: 1,\r\n      height: 1,\r\n      attachments: {\r\n        [GL.COLOR_ATTACHMENT0]: new Texture2D(gl, {\r\n          format: isWebGL2(gl) ? GL.RGBA32F : GL.RGBA,\r\n          type: GL.FLOAT,\r\n          mipmaps: false\r\n        })\r\n      }\r\n    });\r\n  }\r\n  return new Framebuffer(gl, {\r\n    width: 256,\r\n    height: 64,\r\n    depth: false\r\n  });\r\n}\r\n\r\n// Increments the counter based on dataFilter_value\r\nexport function getModel(gl, shaderOptions, useFloatTarget) {\r\n  shaderOptions.defines.NON_INSTANCED_MODEL = 1;\r\n  if (useFloatTarget) {\r\n    shaderOptions.defines.FLOAT_TARGET = 1;\r\n  }\r\n\r\n  return new Model(gl, {\r\n    id: 'data-filter-aggregation-model',\r\n    vertexCount: 1,\r\n    isInstanced: false,\r\n    drawMode: GL.POINTS,\r\n    vs: AGGREGATE_VS,\r\n    fs: AGGREGATE_FS,\r\n    ...shaderOptions\r\n  });\r\n}\r\n\r\nexport const parameters = {\r\n  blend: true,\r\n  blendFunc: [GL.ONE, GL.ONE, GL.ONE, GL.ONE],\r\n  blendEquation: [GL.FUNC_ADD, GL.FUNC_ADD],\r\n  depthTest: false\r\n};\r\n"]},"metadata":{},"sourceType":"module"}