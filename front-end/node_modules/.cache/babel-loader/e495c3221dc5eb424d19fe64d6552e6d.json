{"ast":null,"code":"import { LayerExtension, _mergeShaders as mergeShaders } from '@deck.gl/core';\nimport { dashShaders, offsetShaders } from './shaders.glsl';\nimport { dist } from 'gl-matrix/vec3';\nconst defaultProps = {\n  getDashArray: {\n    type: 'accessor',\n    value: [0, 0]\n  },\n  getOffset: {\n    type: 'accessor',\n    value: 0\n  },\n  dashJustified: false,\n  dashGapPickable: false\n};\nexport default class PathStyleExtension extends LayerExtension {\n  constructor() {\n    let {\n      dash = false,\n      offset = false,\n      highPrecisionDash = false\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super({\n      dash: dash || highPrecisionDash,\n      offset,\n      highPrecisionDash\n    });\n  }\n\n  isEnabled(layer) {\n    return layer.state.pathTesselator;\n  }\n\n  getShaders(extension) {\n    if (!extension.isEnabled(this)) {\n      return null;\n    }\n\n    let result = {};\n\n    if (extension.opts.dash) {\n      result = mergeShaders(result, dashShaders);\n    }\n\n    if (extension.opts.offset) {\n      result = mergeShaders(result, offsetShaders);\n    }\n\n    return result;\n  }\n\n  initializeState(context, extension) {\n    const attributeManager = this.getAttributeManager();\n\n    if (!attributeManager || !extension.isEnabled(this)) {\n      return;\n    }\n\n    extension.enabled = true;\n\n    if (extension.opts.dash) {\n      attributeManager.addInstanced({\n        instanceDashArrays: {\n          size: 2,\n          accessor: 'getDashArray'\n        }\n      });\n    }\n\n    if (extension.opts.highPrecisionDash) {\n      attributeManager.addInstanced({\n        instanceDashOffsets: {\n          size: 1,\n          accessor: 'getPath',\n          transform: extension.getDashOffsets.bind(this)\n        }\n      });\n    }\n\n    if (extension.opts.offset) {\n      attributeManager.addInstanced({\n        instanceOffsets: {\n          size: 1,\n          accessor: 'getOffset'\n        }\n      });\n    }\n  }\n\n  updateState(params, extension) {\n    if (!extension.isEnabled(this)) {\n      return;\n    }\n\n    const uniforms = {};\n\n    if (extension.opts.dash) {\n      uniforms.dashAlignMode = this.props.dashJustified ? 1 : 0;\n      uniforms.dashGapPickable = Boolean(this.props.dashGapPickable);\n    }\n\n    this.state.model.setUniforms(uniforms);\n  }\n\n  getDashOffsets(path) {\n    const result = [0];\n    const positionSize = this.props.positionFormat === 'XY' ? 2 : 3;\n    const isNested = Array.isArray(path[0]);\n    const geometrySize = isNested ? path.length : path.length / positionSize;\n    let p;\n    let prevP;\n\n    for (let i = 0; i < geometrySize - 1; i++) {\n      p = isNested ? path[i] : path.slice(i * positionSize, i * positionSize + positionSize);\n      p = this.projectPosition(p);\n\n      if (i > 0) {\n        result[i] = result[i - 1] + dist(prevP, p);\n      }\n\n      prevP = p;\n    }\n\n    return result;\n  }\n\n}\nPathStyleExtension.extensionName = 'PathStyleExtension';\nPathStyleExtension.defaultProps = defaultProps;","map":{"version":3,"sources":["../../../src/path-style/path-style.js"],"names":["_mergeShaders","defaultProps","getDashArray","type","value","getOffset","dashJustified","dashGapPickable","constructor","dash","offset","highPrecisionDash","isEnabled","layer","getShaders","extension","result","mergeShaders","initializeState","attributeManager","instanceDashArrays","size","accessor","instanceDashOffsets","transform","instanceOffsets","updateState","uniforms","Boolean","getDashOffsets","positionSize","isNested","Array","path","geometrySize","i","p","dist","prevP","PathStyleExtension"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {LayerExtension, _mergeShaders as mergeShaders} from '@deck.gl/core';\nimport {dashShaders, offsetShaders} from './shaders.glsl';\nimport {dist} from 'gl-matrix/vec3';\n\nconst defaultProps = {\n  getDashArray: {type: 'accessor', value: [0, 0]},\n  getOffset: {type: 'accessor', value: 0},\n  dashJustified: false,\n  dashGapPickable: false\n};\n\nexport default class PathStyleExtension extends LayerExtension {\n  constructor({dash = false, offset = false, highPrecisionDash = false} = {}) {\n    super({dash: dash || highPrecisionDash, offset, highPrecisionDash});\n  }\n\n  isEnabled(layer) {\n    return layer.state.pathTesselator;\n  }\n\n  getShaders(extension) {\n    if (!extension.isEnabled(this)) {\n      return null;\n    }\n\n    // Merge shader injection\n    let result = {};\n    if (extension.opts.dash) {\n      result = mergeShaders(result, dashShaders);\n    }\n    if (extension.opts.offset) {\n      result = mergeShaders(result, offsetShaders);\n    }\n\n    return result;\n  }\n\n  initializeState(context, extension) {\n    const attributeManager = this.getAttributeManager();\n    if (!attributeManager || !extension.isEnabled(this)) {\n      // This extension only works with the PathLayer\n      return;\n    }\n\n    extension.enabled = true;\n\n    if (extension.opts.dash) {\n      attributeManager.addInstanced({\n        instanceDashArrays: {size: 2, accessor: 'getDashArray'}\n      });\n    }\n    if (extension.opts.highPrecisionDash) {\n      attributeManager.addInstanced({\n        instanceDashOffsets: {\n          size: 1,\n          accessor: 'getPath',\n          transform: extension.getDashOffsets.bind(this)\n        }\n      });\n    }\n    if (extension.opts.offset) {\n      attributeManager.addInstanced({\n        instanceOffsets: {size: 1, accessor: 'getOffset'}\n      });\n    }\n  }\n\n  updateState(params, extension) {\n    if (!extension.isEnabled(this)) {\n      return;\n    }\n\n    const uniforms = {};\n\n    if (extension.opts.dash) {\n      uniforms.dashAlignMode = this.props.dashJustified ? 1 : 0;\n      uniforms.dashGapPickable = Boolean(this.props.dashGapPickable);\n    }\n\n    this.state.model.setUniforms(uniforms);\n  }\n\n  getDashOffsets(path) {\n    const result = [0];\n    const positionSize = this.props.positionFormat === 'XY' ? 2 : 3;\n    const isNested = Array.isArray(path[0]);\n    const geometrySize = isNested ? path.length : path.length / positionSize;\n\n    let p;\n    let prevP;\n    for (let i = 0; i < geometrySize - 1; i++) {\n      p = isNested ? path[i] : path.slice(i * positionSize, i * positionSize + positionSize);\n      p = this.projectPosition(p);\n\n      if (i > 0) {\n        result[i] = result[i - 1] + dist(prevP, p);\n      }\n\n      prevP = p;\n    }\n    return result;\n  }\n}\n\nPathStyleExtension.extensionName = 'PathStyleExtension';\nPathStyleExtension.defaultProps = defaultProps;\n"]},"metadata":{},"sourceType":"module"}