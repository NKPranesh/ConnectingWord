{"ast":null,"code":"import { GLTFMaterialParser } from '@luma.gl/experimental';\nimport { Model, pbr } from '@luma.gl/core';\nimport { SimpleMeshLayer } from '@deck.gl/mesh-layers';\nimport vs from './mesh-layer-vertex.glsl';\nimport fs from './mesh-layer-fragment.glsl';\n\nfunction validateGeometryAttributes(attributes) {\n  const hasColorAttribute = attributes.COLOR_0 || attributes.colors;\n\n  if (!hasColorAttribute) {\n    attributes.colors = {\n      constant: true,\n      value: new Float32Array([1, 1, 1])\n    };\n  }\n\n  if (!attributes.uvRegions) {\n    attributes.uvRegions = {\n      constant: true,\n      value: new Float32Array([0, 0, 1, 1])\n    };\n  }\n}\n\nconst defaultProps = {\n  pbrMaterial: {\n    type: 'object',\n    value: null\n  },\n  featureIds: {\n    type: 'array',\n    value: null,\n    optional: true\n  }\n};\nexport default class _MeshLayer extends SimpleMeshLayer {\n  getShaders() {\n    const shaders = super.getShaders();\n    const modules = shaders.modules;\n    modules.push(pbr);\n    return { ...shaders,\n      vs,\n      fs\n    };\n  }\n\n  initializeState() {\n    const {\n      featureIds\n    } = this.props;\n    super.initializeState();\n\n    if (featureIds) {\n      this.state.attributeManager.add({\n        featureIdsPickingColors: {\n          type: 5121,\n          size: 3,\n          noAlloc: true,\n          update: this.calculateFeatureIdsPickingColors\n        }\n      });\n    }\n  }\n\n  updateState(_ref) {\n    let {\n      props,\n      oldProps,\n      changeFlags\n    } = _ref;\n    super.updateState({\n      props,\n      oldProps,\n      changeFlags\n    });\n\n    if (props.pbrMaterial !== oldProps.pbrMaterial) {\n      this.updatePbrMaterialUniforms(props.pbrMaterial);\n    }\n  }\n\n  draw(opts) {\n    const {\n      featureIds\n    } = this.props;\n\n    if (!this.state.model) {\n      return;\n    }\n\n    this.state.model.setUniforms({\n      u_Camera: this.state.model.getUniforms().project_uCameraPosition,\n      u_pickFeatureIds: Boolean(featureIds)\n    });\n    super.draw(opts);\n  }\n\n  getModel(mesh) {\n    const {\n      id,\n      pbrMaterial\n    } = this.props;\n    const materialParser = this.parseMaterial(pbrMaterial, mesh);\n    const shaders = this.getShaders();\n    validateGeometryAttributes(mesh.attributes);\n    const model = new Model(this.context.gl, { ...this.getShaders(),\n      id,\n      geometry: mesh,\n      defines: { ...shaders.defines,\n        ...(materialParser === null || materialParser === void 0 ? void 0 : materialParser.defines)\n      },\n      parameters: materialParser === null || materialParser === void 0 ? void 0 : materialParser.parameters,\n      isInstanced: true\n    });\n    return model;\n  }\n\n  updatePbrMaterialUniforms(pbrMaterial) {\n    const {\n      model\n    } = this.state;\n\n    if (model) {\n      const {\n        mesh\n      } = this.props;\n      const materialParser = this.parseMaterial(pbrMaterial, mesh);\n      model.setUniforms(materialParser.uniforms);\n    }\n  }\n\n  parseMaterial(pbrMaterial, mesh) {\n    const unlit = Boolean(pbrMaterial.pbrMetallicRoughness && pbrMaterial.pbrMetallicRoughness.baseColorTexture);\n    const materialParser = new GLTFMaterialParser(this.context.gl, {\n      attributes: {\n        NORMAL: mesh.attributes.normals,\n        TEXCOORD_0: mesh.attributes.texCoords\n      },\n      material: {\n        unlit,\n        ...pbrMaterial\n      },\n      pbrDebug: false,\n      imageBasedLightingEnvironment: null,\n      lights: true,\n      useTangents: false\n    });\n    return materialParser;\n  }\n\n  calculateFeatureIdsPickingColors(attribute) {\n    const {\n      featureIds\n    } = this.props;\n    const value = new Uint8ClampedArray(featureIds.length * attribute.size);\n    const pickingColor = [];\n\n    for (let index = 0; index < featureIds.length; index++) {\n      this.encodePickingColor(featureIds[index], pickingColor);\n      value[index * 3] = pickingColor[0];\n      value[index * 3 + 1] = pickingColor[1];\n      value[index * 3 + 2] = pickingColor[2];\n    }\n\n    attribute.value = value;\n  }\n\n}\n_MeshLayer.layerName = '_MeshLayer';\n_MeshLayer.defaultProps = defaultProps;","map":{"version":3,"sources":["../../../src/mesh-layer/mesh-layer.js"],"names":["hasColorAttribute","attributes","constant","value","defaultProps","pbrMaterial","type","featureIds","optional","getShaders","shaders","modules","fs","initializeState","featureIdsPickingColors","size","noAlloc","update","calculateFeatureIdsPickingColors","updateState","changeFlags","props","oldProps","draw","u_Camera","u_pickFeatureIds","Boolean","getModel","materialParser","validateGeometryAttributes","mesh","model","geometry","defines","parameters","isInstanced","updatePbrMaterialUniforms","parseMaterial","unlit","NORMAL","TEXCOORD_0","texCoords","material","pbrDebug","imageBasedLightingEnvironment","lights","useTangents","attribute","pickingColor","index","_MeshLayer"],"mappings":"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","sourcesContent":["import {GLTFMaterialParser} from '@luma.gl/experimental';\nimport {Model, pbr} from '@luma.gl/core';\nimport GL from '@luma.gl/constants';\nimport {SimpleMeshLayer} from '@deck.gl/mesh-layers';\n\nimport vs from './mesh-layer-vertex.glsl';\nimport fs from './mesh-layer-fragment.glsl';\n\nfunction validateGeometryAttributes(attributes) {\n  const hasColorAttribute = attributes.COLOR_0 || attributes.colors;\n  if (!hasColorAttribute) {\n    attributes.colors = {constant: true, value: new Float32Array([1, 1, 1])};\n  }\n  if (!attributes.uvRegions) {\n    attributes.uvRegions = {constant: true, value: new Float32Array([0, 0, 1, 1])};\n  }\n}\n\nconst defaultProps = {\n  // PBR material object. _lighting must be pbr for this to work\n  pbrMaterial: {type: 'object', value: null},\n  featureIds: {type: 'array', value: null, optional: true}\n};\n\nexport default class _MeshLayer extends SimpleMeshLayer {\n  getShaders() {\n    const shaders = super.getShaders();\n    const modules = shaders.modules;\n    modules.push(pbr);\n    return {...shaders, vs, fs};\n  }\n\n  initializeState() {\n    const {featureIds} = this.props;\n    super.initializeState();\n\n    if (featureIds) {\n      this.state.attributeManager.add({\n        featureIdsPickingColors: {\n          type: GL.UNSIGNED_BYTE,\n          size: 3,\n          noAlloc: true,\n          update: this.calculateFeatureIdsPickingColors\n        }\n      });\n    }\n  }\n\n  updateState({props, oldProps, changeFlags}) {\n    super.updateState({props, oldProps, changeFlags});\n    if (props.pbrMaterial !== oldProps.pbrMaterial) {\n      this.updatePbrMaterialUniforms(props.pbrMaterial);\n    }\n  }\n\n  draw(opts) {\n    const {featureIds} = this.props;\n    if (!this.state.model) {\n      return;\n    }\n    this.state.model.setUniforms({\n      // Needed for PBR (TODO: find better way to get it)\n      u_Camera: this.state.model.getUniforms().project_uCameraPosition,\n      u_pickFeatureIds: Boolean(featureIds)\n    });\n\n    super.draw(opts);\n  }\n\n  getModel(mesh) {\n    const {id, pbrMaterial} = this.props;\n    const materialParser = this.parseMaterial(pbrMaterial, mesh);\n    const shaders = this.getShaders();\n    validateGeometryAttributes(mesh.attributes);\n    const model = new Model(this.context.gl, {\n      ...this.getShaders(),\n      id,\n      geometry: mesh,\n      defines: {...shaders.defines, ...materialParser?.defines},\n      parameters: materialParser?.parameters,\n      isInstanced: true\n    });\n\n    return model;\n  }\n\n  updatePbrMaterialUniforms(pbrMaterial) {\n    const {model} = this.state;\n    if (model) {\n      const {mesh} = this.props;\n      const materialParser = this.parseMaterial(pbrMaterial, mesh);\n      model.setUniforms(materialParser.uniforms);\n    }\n  }\n\n  parseMaterial(pbrMaterial, mesh) {\n    const unlit = Boolean(\n      pbrMaterial.pbrMetallicRoughness && pbrMaterial.pbrMetallicRoughness.baseColorTexture\n    );\n    const materialParser = new GLTFMaterialParser(this.context.gl, {\n      attributes: {NORMAL: mesh.attributes.normals, TEXCOORD_0: mesh.attributes.texCoords},\n      material: {unlit, ...pbrMaterial},\n      pbrDebug: false,\n      imageBasedLightingEnvironment: null,\n      lights: true,\n      useTangents: false\n    });\n    return materialParser;\n  }\n\n  calculateFeatureIdsPickingColors(attribute) {\n    const {featureIds} = this.props;\n    const value = new Uint8ClampedArray(featureIds.length * attribute.size);\n\n    const pickingColor = [];\n    for (let index = 0; index < featureIds.length; index++) {\n      this.encodePickingColor(featureIds[index], pickingColor);\n\n      value[index * 3] = pickingColor[0];\n      value[index * 3 + 1] = pickingColor[1];\n      value[index * 3 + 2] = pickingColor[2];\n    }\n\n    attribute.value = value;\n  }\n}\n\n_MeshLayer.layerName = '_MeshLayer';\n_MeshLayer.defaultProps = defaultProps;\n"]},"metadata":{},"sourceType":"module"}