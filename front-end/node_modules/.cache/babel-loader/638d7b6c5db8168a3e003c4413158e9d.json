{"ast":null,"code":"import { assert } from '@loaders.gl/loader-utils';\nexport function isLoaderObject(loader) {\n  var _loader;\n\n  if (!loader) {\n    return false;\n  }\n\n  if (Array.isArray(loader)) {\n    loader = loader[0];\n  }\n\n  const hasExtensions = Array.isArray((_loader = loader) === null || _loader === void 0 ? void 0 : _loader.extensions);\n  return hasExtensions;\n}\nexport function normalizeLoader(loader) {\n  var _loader2, _loader3;\n\n  assert(loader, 'null loader');\n  assert(isLoaderObject(loader), 'invalid loader');\n  let options;\n\n  if (Array.isArray(loader)) {\n    options = loader[1];\n    loader = loader[0];\n    loader = { ...loader,\n      options: { ...loader.options,\n        ...options\n      }\n    };\n  }\n\n  if ((_loader2 = loader) !== null && _loader2 !== void 0 && _loader2.parseTextSync || (_loader3 = loader) !== null && _loader3 !== void 0 && _loader3.parseText) {\n    loader.text = true;\n  }\n\n  if (!loader.text) {\n    loader.binary = true;\n  }\n\n  return loader;\n}","map":{"version":3,"sources":["../../../../src/lib/loader-utils/normalize-loader.ts"],"names":["Array","loader","hasExtensions","assert","isLoaderObject","options"],"mappings":"AACA,SAAA,MAAA,QAAA,0BAAA;AAEA,OAAO,SAAA,cAAA,CAAA,MAAA,EAA+C;AAAA,MAAA,OAAA;;AACpD,MAAI,CAAJ,MAAA,EAAa;AACX,WAAA,KAAA;AACD;;AAED,MAAIA,KAAK,CAALA,OAAAA,CAAJ,MAAIA,CAAJ,EAA2B;AACzBC,IAAAA,MAAM,GAAGA,MAAM,CAAfA,CAAe,CAAfA;AACD;;AAED,QAAMC,aAAa,GAAGF,KAAK,CAALA,OAAAA,CAAAA,CAAAA,OAAAA,GAAAA,MAAAA,MAAAA,IAAAA,IAAAA,OAAAA,KAAAA,KAAAA,CAAAA,GAAAA,KAAAA,CAAAA,GAAcC,OAAAA,CAApC,UAAsBD,CAAtB;AAWA,SAAA,aAAA;AACD;AAED,OAAO,SAAA,eAAA,CAAA,MAAA,EAAiD;AAAA,MAAA,QAAA,EAAA,QAAA;;AAItDG,EAAAA,MAAM,CAAA,MAAA,EAANA,aAAM,CAANA;AACAA,EAAAA,MAAM,CAACC,cAAc,CAAf,MAAe,CAAf,EAAND,gBAAM,CAANA;AAKA,MAAA,OAAA;;AACA,MAAIH,KAAK,CAALA,OAAAA,CAAJ,MAAIA,CAAJ,EAA2B;AACzBK,IAAAA,OAAO,GAAGJ,MAAM,CAAhBI,CAAgB,CAAhBA;AACAJ,IAAAA,MAAM,GAAGA,MAAM,CAAfA,CAAe,CAAfA;AACAA,IAAAA,MAAM,GAAG,EACP,GADO,MAAA;AAEPI,MAAAA,OAAO,EAAE,EAAC,GAAGJ,MAAM,CAAV,OAAA;AAAoB,WAAGI;AAAvB;AAFF,KAATJ;AAID;;AAMD,MAAI,CAAA,QAAA,GAAA,MAAA,MAAA,IAAA,IAAA,QAAA,KAAA,KAAA,CAAA,IAAA,QAAA,CAAA,aAAA,IAAA,CAAA,QAAA,GAAA,MAAA,MAAA,IAAA,IAAA,QAAA,KAAA,KAAA,CAAA,IAAyBA,QAAAA,CAA7B,SAAA,EAAgD;AAC9CA,IAAAA,MAAM,CAANA,IAAAA,GAAAA,IAAAA;AACD;;AAED,MAAI,CAACA,MAAM,CAAX,IAAA,EAAkB;AAChBA,IAAAA,MAAM,CAANA,MAAAA,GAAAA,IAAAA;AACD;;AAED,SAAA,MAAA;AACD","sourcesContent":["import type {Loader} from '@loaders.gl/loader-utils';\nimport {assert} from '@loaders.gl/loader-utils';\n\nexport function isLoaderObject(loader?: any): boolean {\n  if (!loader) {\n    return false;\n  }\n\n  if (Array.isArray(loader)) {\n    loader = loader[0];\n  }\n\n  const hasExtensions = Array.isArray(loader?.extensions);\n\n  /* Now handled by types and worker loaders do not have these\n  let hasParser =\n    loader.parseTextSync ||\n    loader.parseSync ||\n    loader.parse ||\n    loader.parseStream || // TODO Remove, Replace with parseInBatches\n    loader.parseInBatches;\n  */\n\n  return hasExtensions;\n}\n\nexport function normalizeLoader(loader: Loader): Loader {\n  // This error is fairly easy to trigger by mixing up import statements etc\n  // So we make an exception and add a developer error message for this case\n  // To help new users from getting stuck here\n  assert(loader, 'null loader');\n  assert(isLoaderObject(loader), 'invalid loader');\n\n  // NORMALIZE [LOADER, OPTIONS] => LOADER\n\n  // If [loader, options], create a new loaders object with options merged in\n  let options;\n  if (Array.isArray(loader)) {\n    options = loader[1];\n    loader = loader[0];\n    loader = {\n      ...loader,\n      options: {...loader.options, ...options}\n    };\n  }\n\n  // NORMALIZE text and binary flags\n  // Ensure at least one of text/binary flags are properly set\n\n  // @ts-expect-error\n  if (loader?.parseTextSync || loader?.parseText) {\n    loader.text = true;\n  }\n\n  if (!loader.text) {\n    loader.binary = true;\n  }\n\n  return loader;\n}\n"]},"metadata":{},"sourceType":"module"}