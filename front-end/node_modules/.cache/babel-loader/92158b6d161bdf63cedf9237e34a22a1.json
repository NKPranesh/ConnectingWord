{"ast":null,"code":"import { Vector3, Matrix3, Quaternion } from '@math.gl/core';\nimport BoundingSphere from './bounding-sphere';\nimport { INTERSECTION } from '../../constants';\nconst scratchVector3 = new Vector3();\nconst scratchOffset = new Vector3();\nconst scratchVectorU = new Vector3();\nconst scratchVectorV = new Vector3();\nconst scratchVectorW = new Vector3();\nconst scratchCorner = new Vector3();\nconst scratchToCenter = new Vector3();\nconst MATRIX3 = {\n  COLUMN0ROW0: 0,\n  COLUMN0ROW1: 1,\n  COLUMN0ROW2: 2,\n  COLUMN1ROW0: 3,\n  COLUMN1ROW1: 4,\n  COLUMN1ROW2: 5,\n  COLUMN2ROW0: 6,\n  COLUMN2ROW1: 7,\n  COLUMN2ROW2: 8\n};\nexport default class OrientedBoundingBox {\n  constructor() {\n    let center = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [0, 0, 0];\n    let halfAxes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0, 0, 0, 0, 0, 0, 0, 0];\n    this.center = new Vector3().from(center);\n    this.halfAxes = new Matrix3(halfAxes);\n  }\n\n  get halfSize() {\n    const xAxis = this.halfAxes.getColumn(0);\n    const yAxis = this.halfAxes.getColumn(1);\n    const zAxis = this.halfAxes.getColumn(2);\n    return [new Vector3(xAxis).len(), new Vector3(yAxis).len(), new Vector3(zAxis).len()];\n  }\n\n  get quaternion() {\n    const xAxis = this.halfAxes.getColumn(0);\n    const yAxis = this.halfAxes.getColumn(1);\n    const zAxis = this.halfAxes.getColumn(2);\n    const normXAxis = new Vector3(xAxis).normalize();\n    const normYAxis = new Vector3(yAxis).normalize();\n    const normZAxis = new Vector3(zAxis).normalize();\n    return new Quaternion().fromMatrix3(new Matrix3([...normXAxis, ...normYAxis, ...normZAxis]));\n  }\n\n  fromCenterHalfSizeQuaternion(center, halfSize, quaternion) {\n    const quaternionObject = new Quaternion(quaternion);\n    const directionsMatrix = new Matrix3().fromQuaternion(quaternionObject);\n    directionsMatrix[0] = directionsMatrix[0] * halfSize[0];\n    directionsMatrix[1] = directionsMatrix[1] * halfSize[0];\n    directionsMatrix[2] = directionsMatrix[2] * halfSize[0];\n    directionsMatrix[3] = directionsMatrix[3] * halfSize[1];\n    directionsMatrix[4] = directionsMatrix[4] * halfSize[1];\n    directionsMatrix[5] = directionsMatrix[5] * halfSize[1];\n    directionsMatrix[6] = directionsMatrix[6] * halfSize[2];\n    directionsMatrix[7] = directionsMatrix[7] * halfSize[2];\n    directionsMatrix[8] = directionsMatrix[8] * halfSize[2];\n    this.center = new Vector3().from(center);\n    this.halfAxes = directionsMatrix;\n    return this;\n  }\n\n  clone() {\n    return new OrientedBoundingBox(this.center, this.halfAxes);\n  }\n\n  equals(right) {\n    return this === right || Boolean(right) && this.center.equals(right.center) && this.halfAxes.equals(right.halfAxes);\n  }\n\n  getBoundingSphere() {\n    let result = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new BoundingSphere();\n    const halfAxes = this.halfAxes;\n    const u = halfAxes.getColumn(0, scratchVectorU);\n    const v = halfAxes.getColumn(1, scratchVectorV);\n    const w = halfAxes.getColumn(2, scratchVectorW);\n    const cornerVector = scratchVector3.copy(u).add(v).add(w);\n    result.center.copy(this.center);\n    result.radius = cornerVector.magnitude();\n    return result;\n  }\n\n  intersectPlane(plane) {\n    const center = this.center;\n    const normal = plane.normal;\n    const halfAxes = this.halfAxes;\n    const normalX = normal.x;\n    const normalY = normal.y;\n    const normalZ = normal.z;\n    const radEffective = Math.abs(normalX * halfAxes[MATRIX3.COLUMN0ROW0] + normalY * halfAxes[MATRIX3.COLUMN0ROW1] + normalZ * halfAxes[MATRIX3.COLUMN0ROW2]) + Math.abs(normalX * halfAxes[MATRIX3.COLUMN1ROW0] + normalY * halfAxes[MATRIX3.COLUMN1ROW1] + normalZ * halfAxes[MATRIX3.COLUMN1ROW2]) + Math.abs(normalX * halfAxes[MATRIX3.COLUMN2ROW0] + normalY * halfAxes[MATRIX3.COLUMN2ROW1] + normalZ * halfAxes[MATRIX3.COLUMN2ROW2]);\n    const distanceToPlane = normal.dot(center) + plane.distance;\n\n    if (distanceToPlane <= -radEffective) {\n      return INTERSECTION.OUTSIDE;\n    } else if (distanceToPlane >= radEffective) {\n      return INTERSECTION.INSIDE;\n    }\n\n    return INTERSECTION.INTERSECTING;\n  }\n\n  distanceTo(point) {\n    return Math.sqrt(this.distanceSquaredTo(point));\n  }\n\n  distanceSquaredTo(point) {\n    const offset = scratchOffset.from(point).subtract(this.center);\n    const halfAxes = this.halfAxes;\n    const u = halfAxes.getColumn(0, scratchVectorU);\n    const v = halfAxes.getColumn(1, scratchVectorV);\n    const w = halfAxes.getColumn(2, scratchVectorW);\n    const uHalf = u.magnitude();\n    const vHalf = v.magnitude();\n    const wHalf = w.magnitude();\n    u.normalize();\n    v.normalize();\n    w.normalize();\n    let distanceSquared = 0.0;\n    let d;\n    d = Math.abs(offset.dot(u)) - uHalf;\n\n    if (d > 0) {\n      distanceSquared += d * d;\n    }\n\n    d = Math.abs(offset.dot(v)) - vHalf;\n\n    if (d > 0) {\n      distanceSquared += d * d;\n    }\n\n    d = Math.abs(offset.dot(w)) - wHalf;\n\n    if (d > 0) {\n      distanceSquared += d * d;\n    }\n\n    return distanceSquared;\n  }\n\n  computePlaneDistances(position, direction) {\n    let result = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [-0, -0];\n    let minDist = Number.POSITIVE_INFINITY;\n    let maxDist = Number.NEGATIVE_INFINITY;\n    const center = this.center;\n    const halfAxes = this.halfAxes;\n    const u = halfAxes.getColumn(0, scratchVectorU);\n    const v = halfAxes.getColumn(1, scratchVectorV);\n    const w = halfAxes.getColumn(2, scratchVectorW);\n    const corner = scratchCorner.copy(u).add(v).add(w).add(center);\n    const toCenter = scratchToCenter.copy(corner).subtract(position);\n    let mag = direction.dot(toCenter);\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n    corner.copy(center).add(u).add(v).subtract(w);\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n    corner.copy(center).add(u).subtract(v).add(w);\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n    corner.copy(center).add(u).subtract(v).subtract(w);\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n    center.copy(corner).subtract(u).add(v).add(w);\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n    center.copy(corner).subtract(u).add(v).subtract(w);\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n    center.copy(corner).subtract(u).subtract(v).add(w);\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n    center.copy(corner).subtract(u).subtract(v).subtract(w);\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n    result[0] = minDist;\n    result[1] = maxDist;\n    return result;\n  }\n\n  transform(transformation) {\n    this.center.transformAsPoint(transformation);\n    const xAxis = this.halfAxes.getColumn(0, scratchVectorU);\n    xAxis.transformAsPoint(transformation);\n    const yAxis = this.halfAxes.getColumn(1, scratchVectorV);\n    yAxis.transformAsPoint(transformation);\n    const zAxis = this.halfAxes.getColumn(2, scratchVectorW);\n    zAxis.transformAsPoint(transformation);\n    this.halfAxes = new Matrix3([...xAxis, ...yAxis, ...zAxis]);\n    return this;\n  }\n\n  getTransform() {\n    throw new Error('not implemented');\n  }\n\n}","map":{"version":3,"sources":["../../../../src/lib/bounding-volumes/oriented-bounding-box.js"],"names":["scratchVector3","scratchOffset","scratchVectorU","scratchVectorV","scratchVectorW","scratchCorner","scratchToCenter","MATRIX3","COLUMN0ROW0","COLUMN0ROW1","COLUMN0ROW2","COLUMN1ROW0","COLUMN1ROW1","COLUMN1ROW2","COLUMN2ROW0","COLUMN2ROW1","COLUMN2ROW2","constructor","center","halfAxes","halfSize","xAxis","yAxis","zAxis","quaternion","normXAxis","normYAxis","normZAxis","fromCenterHalfSizeQuaternion","quaternionObject","directionsMatrix","clone","equals","Boolean","right","getBoundingSphere","result","u","v","w","cornerVector","intersectPlane","normal","plane","normalX","normalY","normalZ","radEffective","Math","distanceToPlane","INTERSECTION","distanceTo","distanceSquaredTo","offset","uHalf","vHalf","wHalf","distanceSquared","d","computePlaneDistances","minDist","Number","maxDist","corner","toCenter","mag","direction","transform","getTransform"],"mappings":"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","sourcesContent":["// This file is derived from the Cesium math library under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\nimport {Vector3, Matrix3, Quaternion} from '@math.gl/core';\nimport BoundingSphere from './bounding-sphere';\nimport {INTERSECTION} from '../../constants';\n\nconst scratchVector3 = new Vector3();\nconst scratchOffset = new Vector3();\nconst scratchVectorU = new Vector3();\nconst scratchVectorV = new Vector3();\nconst scratchVectorW = new Vector3();\nconst scratchCorner = new Vector3();\nconst scratchToCenter = new Vector3();\n\nconst MATRIX3 = {\n  COLUMN0ROW0: 0,\n  COLUMN0ROW1: 1,\n  COLUMN0ROW2: 2,\n  COLUMN1ROW0: 3,\n  COLUMN1ROW1: 4,\n  COLUMN1ROW2: 5,\n  COLUMN2ROW0: 6,\n  COLUMN2ROW1: 7,\n  COLUMN2ROW2: 8\n};\n\nexport default class OrientedBoundingBox {\n  constructor(center = [0, 0, 0], halfAxes = [0, 0, 0, 0, 0, 0, 0, 0, 0]) {\n    this.center = new Vector3().from(center);\n    this.halfAxes = new Matrix3(halfAxes);\n  }\n\n  get halfSize() {\n    const xAxis = this.halfAxes.getColumn(0);\n    const yAxis = this.halfAxes.getColumn(1);\n    const zAxis = this.halfAxes.getColumn(2);\n    return [new Vector3(xAxis).len(), new Vector3(yAxis).len(), new Vector3(zAxis).len()];\n  }\n\n  get quaternion() {\n    const xAxis = this.halfAxes.getColumn(0);\n    const yAxis = this.halfAxes.getColumn(1);\n    const zAxis = this.halfAxes.getColumn(2);\n    const normXAxis = new Vector3(xAxis).normalize();\n    const normYAxis = new Vector3(yAxis).normalize();\n    const normZAxis = new Vector3(zAxis).normalize();\n    return new Quaternion().fromMatrix3(new Matrix3([...normXAxis, ...normYAxis, ...normZAxis]));\n  }\n\n  fromCenterHalfSizeQuaternion(center, halfSize, quaternion) {\n    const quaternionObject = new Quaternion(quaternion);\n    const directionsMatrix = new Matrix3().fromQuaternion(quaternionObject);\n    directionsMatrix[0] = directionsMatrix[0] * halfSize[0];\n    directionsMatrix[1] = directionsMatrix[1] * halfSize[0];\n    directionsMatrix[2] = directionsMatrix[2] * halfSize[0];\n    directionsMatrix[3] = directionsMatrix[3] * halfSize[1];\n    directionsMatrix[4] = directionsMatrix[4] * halfSize[1];\n    directionsMatrix[5] = directionsMatrix[5] * halfSize[1];\n    directionsMatrix[6] = directionsMatrix[6] * halfSize[2];\n    directionsMatrix[7] = directionsMatrix[7] * halfSize[2];\n    directionsMatrix[8] = directionsMatrix[8] * halfSize[2];\n    this.center = new Vector3().from(center);\n    this.halfAxes = directionsMatrix;\n    return this;\n  }\n\n  clone() {\n    return new OrientedBoundingBox(this.center, this.halfAxes);\n  }\n\n  equals(right) {\n    return (\n      this === right ||\n      (Boolean(right) && this.center.equals(right.center) && this.halfAxes.equals(right.halfAxes))\n    );\n  }\n\n  getBoundingSphere(result = new BoundingSphere()) {\n    const halfAxes = this.halfAxes;\n    const u = halfAxes.getColumn(0, scratchVectorU);\n    const v = halfAxes.getColumn(1, scratchVectorV);\n    const w = halfAxes.getColumn(2, scratchVectorW);\n\n    // Calculate \"corner\" vector\n    const cornerVector = scratchVector3.copy(u).add(v).add(w);\n\n    result.center.copy(this.center);\n    result.radius = cornerVector.magnitude();\n\n    return result;\n  }\n\n  intersectPlane(plane) {\n    const center = this.center;\n    const normal = plane.normal;\n    const halfAxes = this.halfAxes;\n\n    const normalX = normal.x;\n    const normalY = normal.y;\n    const normalZ = normal.z;\n\n    // Plane is used as if it is its normal; the first three components are assumed to be normalized\n    const radEffective =\n      Math.abs(\n        normalX * halfAxes[MATRIX3.COLUMN0ROW0] +\n          normalY * halfAxes[MATRIX3.COLUMN0ROW1] +\n          normalZ * halfAxes[MATRIX3.COLUMN0ROW2]\n      ) +\n      Math.abs(\n        normalX * halfAxes[MATRIX3.COLUMN1ROW0] +\n          normalY * halfAxes[MATRIX3.COLUMN1ROW1] +\n          normalZ * halfAxes[MATRIX3.COLUMN1ROW2]\n      ) +\n      Math.abs(\n        normalX * halfAxes[MATRIX3.COLUMN2ROW0] +\n          normalY * halfAxes[MATRIX3.COLUMN2ROW1] +\n          normalZ * halfAxes[MATRIX3.COLUMN2ROW2]\n      );\n    const distanceToPlane = normal.dot(center) + plane.distance;\n\n    if (distanceToPlane <= -radEffective) {\n      // The entire box is on the negative side of the plane normal\n      return INTERSECTION.OUTSIDE;\n    } else if (distanceToPlane >= radEffective) {\n      // The entire box is on the positive side of the plane normal\n      return INTERSECTION.INSIDE;\n    }\n    return INTERSECTION.INTERSECTING;\n  }\n\n  distanceTo(point) {\n    return Math.sqrt(this.distanceSquaredTo(point));\n  }\n\n  distanceSquaredTo(point) {\n    // Computes the estimated distance squared from the\n    // closest point on a bounding box to a point.\n    // See Geometric Tools for Computer Graphics 10.4.2\n    const offset = scratchOffset.from(point).subtract(this.center);\n\n    const halfAxes = this.halfAxes;\n    const u = halfAxes.getColumn(0, scratchVectorU);\n    const v = halfAxes.getColumn(1, scratchVectorV);\n    const w = halfAxes.getColumn(2, scratchVectorW);\n\n    const uHalf = u.magnitude();\n    const vHalf = v.magnitude();\n    const wHalf = w.magnitude();\n\n    u.normalize();\n    v.normalize();\n    w.normalize();\n\n    let distanceSquared = 0.0;\n    let d;\n\n    d = Math.abs(offset.dot(u)) - uHalf;\n    if (d > 0) {\n      distanceSquared += d * d;\n    }\n\n    d = Math.abs(offset.dot(v)) - vHalf;\n    if (d > 0) {\n      distanceSquared += d * d;\n    }\n\n    d = Math.abs(offset.dot(w)) - wHalf;\n    if (d > 0) {\n      distanceSquared += d * d;\n    }\n\n    return distanceSquared;\n  }\n\n  // eslint-disable-next-line max-statements\n  computePlaneDistances(position, direction, result = [-0, -0]) {\n    let minDist = Number.POSITIVE_INFINITY;\n    let maxDist = Number.NEGATIVE_INFINITY;\n\n    const center = this.center;\n    const halfAxes = this.halfAxes;\n\n    const u = halfAxes.getColumn(0, scratchVectorU);\n    const v = halfAxes.getColumn(1, scratchVectorV);\n    const w = halfAxes.getColumn(2, scratchVectorW);\n\n    // project first corner\n    const corner = scratchCorner.copy(u).add(v).add(w).add(center);\n\n    const toCenter = scratchToCenter.copy(corner).subtract(position);\n    let mag = direction.dot(toCenter);\n\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n\n    // project second corner\n    corner.copy(center).add(u).add(v).subtract(w);\n\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n\n    // project third corner\n    corner.copy(center).add(u).subtract(v).add(w);\n\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n\n    // project fourth corner\n    corner.copy(center).add(u).subtract(v).subtract(w);\n\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n\n    // project fifth corner\n    center.copy(corner).subtract(u).add(v).add(w);\n\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n\n    // project sixth corner\n    center.copy(corner).subtract(u).add(v).subtract(w);\n\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n\n    // project seventh corner\n    center.copy(corner).subtract(u).subtract(v).add(w);\n\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n\n    // project eighth corner\n    center.copy(corner).subtract(u).subtract(v).subtract(w);\n\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n\n    result[0] = minDist;\n    result[1] = maxDist;\n    return result;\n  }\n\n  transform(transformation) {\n    this.center.transformAsPoint(transformation);\n\n    const xAxis = this.halfAxes.getColumn(0, scratchVectorU);\n    xAxis.transformAsPoint(transformation);\n\n    const yAxis = this.halfAxes.getColumn(1, scratchVectorV);\n    yAxis.transformAsPoint(transformation);\n\n    const zAxis = this.halfAxes.getColumn(2, scratchVectorW);\n    zAxis.transformAsPoint(transformation);\n\n    this.halfAxes = new Matrix3([...xAxis, ...yAxis, ...zAxis]);\n    return this;\n  }\n\n  getTransform() {\n    // const modelMatrix = Matrix4.fromRotationTranslation(this.boundingVolume.halfAxes, this.boundingVolume.center);\n    // return modelMatrix;\n    throw new Error('not implemented');\n  }\n}\n"]},"metadata":{},"sourceType":"module"}