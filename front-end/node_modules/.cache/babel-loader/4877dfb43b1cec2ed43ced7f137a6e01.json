{"ast":null,"code":"import { clamp } from 'math.gl';\nimport Controller from './controller';\nimport ViewState from './view-state';\nimport { mod } from '../utils/math-utils';\nconst DEFAULT_STATE = {\n  rotationX: 0,\n  rotationOrbit: 0,\n  zoom: 0,\n  target: [0, 0, 0],\n  minRotationX: -90,\n  maxRotationX: 90,\n  minZoom: -Infinity,\n  maxZoom: Infinity\n};\nexport class OrbitState extends ViewState {\n  constructor(_ref) {\n    let {\n      makeViewport,\n      width,\n      height,\n      rotationX = DEFAULT_STATE.rotationX,\n      rotationOrbit = DEFAULT_STATE.rotationOrbit,\n      target = DEFAULT_STATE.target,\n      zoom = DEFAULT_STATE.zoom,\n      minRotationX = DEFAULT_STATE.minRotationX,\n      maxRotationX = DEFAULT_STATE.maxRotationX,\n      minZoom = DEFAULT_STATE.minZoom,\n      maxZoom = DEFAULT_STATE.maxZoom,\n      startPanPosition,\n      startRotatePos,\n      startRotationX,\n      startRotationOrbit,\n      startZoomPosition,\n      startZoom\n    } = _ref;\n    super({\n      width,\n      height,\n      rotationX,\n      rotationOrbit,\n      target,\n      zoom,\n      minRotationX,\n      maxRotationX,\n      minZoom,\n      maxZoom\n    });\n    this._state = {\n      startPanPosition,\n      startRotatePos,\n      startRotationX,\n      startRotationOrbit,\n      startZoomPosition,\n      startZoom\n    };\n    this.makeViewport = makeViewport;\n  }\n\n  panStart(_ref2) {\n    let {\n      pos\n    } = _ref2;\n    return this._getUpdatedState({\n      startPanPosition: this._unproject(pos)\n    });\n  }\n\n  pan(_ref3) {\n    let {\n      pos,\n      startPosition\n    } = _ref3;\n    const startPanPosition = this._state.startPanPosition || startPosition;\n\n    if (!startPanPosition) {\n      return this;\n    }\n\n    const viewport = this.makeViewport(this._viewportProps);\n    const newProps = viewport.panByPosition(startPanPosition, pos);\n    return this._getUpdatedState(newProps);\n  }\n\n  panEnd() {\n    return this._getUpdatedState({\n      startPanPosition: null\n    });\n  }\n\n  rotateStart(_ref4) {\n    let {\n      pos\n    } = _ref4;\n    return this._getUpdatedState({\n      startRotatePos: pos,\n      startRotationX: this._viewportProps.rotationX,\n      startRotationOrbit: this._viewportProps.rotationOrbit\n    });\n  }\n\n  rotate(_ref5) {\n    let {\n      pos,\n      deltaAngleX = 0,\n      deltaAngleY = 0\n    } = _ref5;\n    const {\n      startRotatePos,\n      startRotationX,\n      startRotationOrbit\n    } = this._state;\n    const {\n      width,\n      height\n    } = this._viewportProps;\n\n    if (!startRotatePos || !Number.isFinite(startRotationX) || !Number.isFinite(startRotationOrbit)) {\n      return this;\n    }\n\n    let newRotation;\n\n    if (pos) {\n      let deltaScaleX = (pos[0] - startRotatePos[0]) / width;\n      const deltaScaleY = (pos[1] - startRotatePos[1]) / height;\n\n      if (startRotationX < -90 || startRotationX > 90) {\n        deltaScaleX *= -1;\n      }\n\n      newRotation = {\n        rotationX: startRotationX + deltaScaleY * 180,\n        rotationOrbit: startRotationOrbit + deltaScaleX * 180\n      };\n    } else {\n      newRotation = {\n        rotationX: startRotationX + deltaAngleY,\n        rotationOrbit: startRotationOrbit + deltaAngleX\n      };\n    }\n\n    return this._getUpdatedState(newRotation);\n  }\n\n  rotateEnd() {\n    return this._getUpdatedState({\n      startRotationX: null,\n      startRotationOrbit: null\n    });\n  }\n\n  shortestPathFrom(viewState) {\n    const fromProps = viewState.getViewportProps();\n    const props = { ...this._viewportProps\n    };\n    const {\n      rotationOrbit\n    } = props;\n\n    if (Math.abs(rotationOrbit - fromProps.rotationOrbit) > 180) {\n      props.rotationOrbit = rotationOrbit < 0 ? rotationOrbit + 360 : rotationOrbit - 360;\n    }\n\n    return props;\n  }\n\n  zoomStart(_ref6) {\n    let {\n      pos\n    } = _ref6;\n    return this._getUpdatedState({\n      startZoomPosition: this._unproject(pos),\n      startZoom: this._viewportProps.zoom\n    });\n  }\n\n  zoom(_ref7) {\n    let {\n      pos,\n      startPos,\n      scale\n    } = _ref7;\n    const {\n      zoom\n    } = this._viewportProps;\n    let {\n      startZoom,\n      startZoomPosition\n    } = this._state;\n\n    if (!Number.isFinite(startZoom)) {\n      startZoom = zoom;\n      startZoomPosition = this._unproject(startPos) || this._unproject(pos);\n    }\n\n    const newZoom = this._calculateNewZoom({\n      scale,\n      startZoom\n    });\n\n    const zoomedViewport = this.makeViewport({ ...this._viewportProps,\n      zoom: newZoom\n    });\n    return this._getUpdatedState({\n      zoom: newZoom,\n      ...zoomedViewport.panByPosition(startZoomPosition, pos)\n    });\n  }\n\n  zoomEnd() {\n    return this._getUpdatedState({\n      startZoomPosition: null,\n      startZoom: null\n    });\n  }\n\n  zoomIn() {\n    let speed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 2;\n    return this._getUpdatedState({\n      zoom: this._calculateNewZoom({\n        scale: speed\n      })\n    });\n  }\n\n  zoomOut() {\n    let speed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 2;\n    return this._getUpdatedState({\n      zoom: this._calculateNewZoom({\n        scale: 1 / speed\n      })\n    });\n  }\n\n  moveLeft() {\n    let speed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 50;\n    return this._panFromCenter([-speed, 0]);\n  }\n\n  moveRight() {\n    let speed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 50;\n    return this._panFromCenter([speed, 0]);\n  }\n\n  moveUp() {\n    let speed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 50;\n    return this._panFromCenter([0, -speed]);\n  }\n\n  moveDown() {\n    let speed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 50;\n    return this._panFromCenter([0, speed]);\n  }\n\n  rotateLeft() {\n    let speed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 15;\n    return this._getUpdatedState({\n      rotationOrbit: this._viewportProps.rotationOrbit - speed\n    });\n  }\n\n  rotateRight() {\n    let speed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 15;\n    return this._getUpdatedState({\n      rotationOrbit: this._viewportProps.rotationOrbit + speed\n    });\n  }\n\n  rotateUp() {\n    let speed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;\n    return this._getUpdatedState({\n      rotationX: this._viewportProps.rotationX - speed\n    });\n  }\n\n  rotateDown() {\n    let speed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;\n    return this._getUpdatedState({\n      rotationX: this._viewportProps.rotationX + speed\n    });\n  }\n\n  _unproject(pos) {\n    const viewport = this.makeViewport(this._viewportProps);\n    return pos && viewport.unproject(pos);\n  }\n\n  _calculateNewZoom(_ref8) {\n    let {\n      scale,\n      startZoom\n    } = _ref8;\n    const {\n      maxZoom,\n      minZoom\n    } = this._viewportProps;\n\n    if (!Number.isFinite(startZoom)) {\n      startZoom = this._viewportProps.zoom;\n    }\n\n    const zoom = startZoom + Math.log2(scale);\n    return clamp(zoom, minZoom, maxZoom);\n  }\n\n  _panFromCenter(offset) {\n    const {\n      width,\n      height,\n      target\n    } = this._viewportProps;\n    return this.pan({\n      startPosition: target,\n      pos: [width / 2 + offset[0], height / 2 + offset[1]]\n    });\n  }\n\n  _getUpdatedState(newProps) {\n    return new this.constructor({ ...this._viewportProps,\n      ...this._state,\n      ...newProps\n    });\n  }\n\n  _applyConstraints(props) {\n    const {\n      maxZoom,\n      minZoom,\n      zoom,\n      maxRotationX,\n      minRotationX,\n      rotationOrbit\n    } = props;\n    props.zoom = clamp(zoom, minZoom, maxZoom);\n    props.rotationX = clamp(props.rotationX, minRotationX, maxRotationX);\n\n    if (rotationOrbit < -180 || rotationOrbit > 180) {\n      props.rotationOrbit = mod(rotationOrbit + 180, 360) - 180;\n    }\n\n    return props;\n  }\n\n}\nexport default class OrbitController extends Controller {\n  constructor(props) {\n    super(OrbitState, props);\n  }\n\n  get linearTransitionProps() {\n    return ['target', 'zoom', 'rotationX', 'rotationOrbit'];\n  }\n\n}","map":{"version":3,"sources":["../../../src/controllers/orbit-controller.js"],"names":["DEFAULT_STATE","rotationX","rotationOrbit","zoom","target","minRotationX","maxRotationX","minZoom","maxZoom","Infinity","constructor","startZoom","panStart","pos","startPanPosition","pan","startPosition","viewport","newProps","panEnd","rotateStart","startRotatePos","startRotationX","startRotationOrbit","rotate","deltaAngleX","deltaAngleY","height","Number","deltaScaleX","deltaScaleY","newRotation","rotateEnd","shortestPathFrom","fromProps","viewState","props","_viewportProps","Math","zoomStart","startZoomPosition","scale","newZoom","zoomedViewport","zoomEnd","zoomIn","speed","zoomOut","moveLeft","moveRight","moveUp","moveDown","rotateLeft","rotateRight","rotateUp","rotateDown","_unproject","_calculateNewZoom","clamp","_panFromCenter","width","offset","_getUpdatedState","_applyConstraints","mod","linearTransitionProps"],"mappings":"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","sourcesContent":["import {clamp} from 'math.gl';\nimport Controller from './controller';\nimport ViewState from './view-state';\nimport {mod} from '../utils/math-utils';\n\nconst DEFAULT_STATE = {\n  rotationX: 0,\n  rotationOrbit: 0,\n  zoom: 0,\n  target: [0, 0, 0],\n  minRotationX: -90,\n  maxRotationX: 90,\n  minZoom: -Infinity,\n  maxZoom: Infinity\n};\n\n/* Helpers */\n\nexport class OrbitState extends ViewState {\n  constructor({\n    makeViewport,\n\n    /* Viewport arguments */\n    width, // Width of viewport\n    height, // Height of viewport\n    rotationX = DEFAULT_STATE.rotationX, // Rotation around x axis\n    rotationOrbit = DEFAULT_STATE.rotationOrbit, // Rotation around orbit axis\n    target = DEFAULT_STATE.target,\n    zoom = DEFAULT_STATE.zoom,\n\n    /* Viewport constraints */\n    minRotationX = DEFAULT_STATE.minRotationX,\n    maxRotationX = DEFAULT_STATE.maxRotationX,\n    minZoom = DEFAULT_STATE.minZoom,\n    maxZoom = DEFAULT_STATE.maxZoom,\n\n    /** Interaction states, required to calculate change during transform */\n    // Model state when the pan operation first started\n    startPanPosition,\n    // Model state when the rotate operation first started\n    startRotatePos,\n    startRotationX,\n    startRotationOrbit,\n    // Model state when the zoom operation first started\n    startZoomPosition,\n    startZoom\n  }) {\n    super({\n      width,\n      height,\n      rotationX,\n      rotationOrbit,\n      target,\n      zoom,\n      minRotationX,\n      maxRotationX,\n      minZoom,\n      maxZoom\n    });\n\n    this._state = {\n      startPanPosition,\n      startRotatePos,\n      startRotationX,\n      startRotationOrbit,\n      startZoomPosition,\n      startZoom\n    };\n\n    this.makeViewport = makeViewport;\n  }\n\n  /**\n   * Start panning\n   * @param {[Number, Number]} pos - position on screen where the pointer grabs\n   */\n  panStart({pos}) {\n    return this._getUpdatedState({\n      startPanPosition: this._unproject(pos)\n    });\n  }\n\n  /**\n   * Pan\n   * @param {[Number, Number]} pos - position on screen where the pointer is\n   */\n  pan({pos, startPosition}) {\n    const startPanPosition = this._state.startPanPosition || startPosition;\n\n    if (!startPanPosition) {\n      return this;\n    }\n\n    const viewport = this.makeViewport(this._viewportProps);\n    const newProps = viewport.panByPosition(startPanPosition, pos);\n\n    return this._getUpdatedState(newProps);\n  }\n\n  /**\n   * End panning\n   * Must call if `panStart()` was called\n   */\n  panEnd() {\n    return this._getUpdatedState({\n      startPanPosition: null\n    });\n  }\n\n  /**\n   * Start rotating\n   * @param {[Number, Number]} pos - position on screen where the pointer grabs\n   */\n  rotateStart({pos}) {\n    return this._getUpdatedState({\n      startRotatePos: pos,\n      startRotationX: this._viewportProps.rotationX,\n      startRotationOrbit: this._viewportProps.rotationOrbit\n    });\n  }\n\n  /**\n   * Rotate\n   * @param {[Number, Number]} pos - position on screen where the pointer is\n   */\n  rotate({pos, deltaAngleX = 0, deltaAngleY = 0}) {\n    const {startRotatePos, startRotationX, startRotationOrbit} = this._state;\n    const {width, height} = this._viewportProps;\n\n    if (\n      !startRotatePos ||\n      !Number.isFinite(startRotationX) ||\n      !Number.isFinite(startRotationOrbit)\n    ) {\n      return this;\n    }\n\n    let newRotation;\n    if (pos) {\n      let deltaScaleX = (pos[0] - startRotatePos[0]) / width;\n      const deltaScaleY = (pos[1] - startRotatePos[1]) / height;\n\n      if (startRotationX < -90 || startRotationX > 90) {\n        // When looking at the \"back\" side of the scene, invert horizontal drag\n        // so that the camera movement follows user input\n        deltaScaleX *= -1;\n      }\n      newRotation = {\n        rotationX: startRotationX + deltaScaleY * 180,\n        rotationOrbit: startRotationOrbit + deltaScaleX * 180\n      };\n    } else {\n      newRotation = {\n        rotationX: startRotationX + deltaAngleY,\n        rotationOrbit: startRotationOrbit + deltaAngleX\n      };\n    }\n\n    return this._getUpdatedState(newRotation);\n  }\n\n  /**\n   * End rotating\n   * Must call if `rotateStart()` was called\n   */\n  rotateEnd() {\n    return this._getUpdatedState({\n      startRotationX: null,\n      startRotationOrbit: null\n    });\n  }\n\n  // shortest path between two view states\n  shortestPathFrom(viewState) {\n    const fromProps = viewState.getViewportProps();\n    const props = {...this._viewportProps};\n    const {rotationOrbit} = props;\n\n    if (Math.abs(rotationOrbit - fromProps.rotationOrbit) > 180) {\n      props.rotationOrbit = rotationOrbit < 0 ? rotationOrbit + 360 : rotationOrbit - 360;\n    }\n\n    return props;\n  }\n\n  /**\n   * Start zooming\n   * @param {[Number, Number]} pos - position on screen where the pointer grabs\n   */\n  zoomStart({pos}) {\n    return this._getUpdatedState({\n      startZoomPosition: this._unproject(pos),\n      startZoom: this._viewportProps.zoom\n    });\n  }\n\n  /**\n   * Zoom\n   * @param {[Number, Number]} pos - position on screen where the current target is\n   * @param {[Number, Number]} startPos - the target position at\n   *   the start of the operation. Must be supplied of `zoomStart()` was not called\n   * @param {Number} scale - a number between [0, 1] specifying the accumulated\n   *   relative scale.\n   */\n  zoom({pos, startPos, scale}) {\n    const {zoom} = this._viewportProps;\n    let {startZoom, startZoomPosition} = this._state;\n    if (!Number.isFinite(startZoom)) {\n      // We have two modes of zoom:\n      // scroll zoom that are discrete events (transform from the current zoom level),\n      // and pinch zoom that are continuous events (transform from the zoom level when\n      // pinch started).\n      // If startZoom state is defined, then use the startZoom state;\n      // otherwise assume discrete zooming\n      startZoom = zoom;\n      startZoomPosition = this._unproject(startPos) || this._unproject(pos);\n    }\n\n    const newZoom = this._calculateNewZoom({scale, startZoom});\n    const zoomedViewport = this.makeViewport({...this._viewportProps, zoom: newZoom});\n\n    return this._getUpdatedState({\n      zoom: newZoom,\n      ...zoomedViewport.panByPosition(startZoomPosition, pos)\n    });\n  }\n\n  /**\n   * End zooming\n   * Must call if `zoomStart()` was called\n   */\n  zoomEnd() {\n    return this._getUpdatedState({\n      startZoomPosition: null,\n      startZoom: null\n    });\n  }\n\n  zoomIn(speed = 2) {\n    return this._getUpdatedState({\n      zoom: this._calculateNewZoom({scale: speed})\n    });\n  }\n\n  zoomOut(speed = 2) {\n    return this._getUpdatedState({\n      zoom: this._calculateNewZoom({scale: 1 / speed})\n    });\n  }\n\n  moveLeft(speed = 50) {\n    return this._panFromCenter([-speed, 0]);\n  }\n\n  moveRight(speed = 50) {\n    return this._panFromCenter([speed, 0]);\n  }\n\n  moveUp(speed = 50) {\n    return this._panFromCenter([0, -speed]);\n  }\n\n  moveDown(speed = 50) {\n    return this._panFromCenter([0, speed]);\n  }\n\n  rotateLeft(speed = 15) {\n    return this._getUpdatedState({\n      rotationOrbit: this._viewportProps.rotationOrbit - speed\n    });\n  }\n\n  rotateRight(speed = 15) {\n    return this._getUpdatedState({\n      rotationOrbit: this._viewportProps.rotationOrbit + speed\n    });\n  }\n\n  rotateUp(speed = 10) {\n    return this._getUpdatedState({\n      rotationX: this._viewportProps.rotationX - speed\n    });\n  }\n\n  rotateDown(speed = 10) {\n    return this._getUpdatedState({\n      rotationX: this._viewportProps.rotationX + speed\n    });\n  }\n\n  /* Private methods */\n\n  _unproject(pos) {\n    const viewport = this.makeViewport(this._viewportProps);\n    return pos && viewport.unproject(pos);\n  }\n\n  // Calculates new zoom\n  _calculateNewZoom({scale, startZoom}) {\n    const {maxZoom, minZoom} = this._viewportProps;\n    if (!Number.isFinite(startZoom)) {\n      startZoom = this._viewportProps.zoom;\n    }\n    const zoom = startZoom + Math.log2(scale);\n    return clamp(zoom, minZoom, maxZoom);\n  }\n\n  _panFromCenter(offset) {\n    const {width, height, target} = this._viewportProps;\n    return this.pan({\n      startPosition: target,\n      pos: [width / 2 + offset[0], height / 2 + offset[1]]\n    });\n  }\n\n  _getUpdatedState(newProps) {\n    // Update _viewportProps\n    return new this.constructor({...this._viewportProps, ...this._state, ...newProps});\n  }\n\n  // Apply any constraints (mathematical or defined by _viewportProps) to map state\n  _applyConstraints(props) {\n    // Ensure zoom is within specified range\n    const {maxZoom, minZoom, zoom, maxRotationX, minRotationX, rotationOrbit} = props;\n\n    props.zoom = clamp(zoom, minZoom, maxZoom);\n    props.rotationX = clamp(props.rotationX, minRotationX, maxRotationX);\n    if (rotationOrbit < -180 || rotationOrbit > 180) {\n      props.rotationOrbit = mod(rotationOrbit + 180, 360) - 180;\n    }\n\n    return props;\n  }\n}\n\nexport default class OrbitController extends Controller {\n  constructor(props) {\n    super(OrbitState, props);\n  }\n\n  get linearTransitionProps() {\n    return ['target', 'zoom', 'rotationX', 'rotationOrbit'];\n  }\n}\n"]},"metadata":{},"sourceType":"module"}