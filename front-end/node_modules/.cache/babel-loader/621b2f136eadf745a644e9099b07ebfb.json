{"ast":null,"code":"import { DracoLoader } from '@loaders.gl/draco';\nimport { sliceArrayBuffer } from '@loaders.gl/loader-utils';\nimport { default as Scenegraph } from '../api/gltf-scenegraph';\nimport { KHR_DRACO_MESH_COMPRESSION } from '../gltf-utils/gltf-constants';\nimport { getGLTFAccessors, getGLTFAccessor } from '../gltf-utils/gltf-attribute-utils';\nexport async function decode(gltfData, options, context) {\n  var _options$gltf;\n\n  if (!(options !== null && options !== void 0 && (_options$gltf = options.gltf) !== null && _options$gltf !== void 0 && _options$gltf.decompressMeshes)) {\n    return;\n  }\n\n  const scenegraph = new Scenegraph(gltfData);\n  const promises = [];\n\n  for (const primitive of makeMeshPrimitiveIterator(scenegraph)) {\n    if (scenegraph.getObjectExtension(primitive, KHR_DRACO_MESH_COMPRESSION)) {\n      promises.push(decompressPrimitive(scenegraph, primitive, options, context));\n    }\n  }\n\n  await Promise.all(promises);\n  scenegraph.removeExtension(KHR_DRACO_MESH_COMPRESSION);\n}\nexport function encode(gltfData) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const scenegraph = new Scenegraph(gltfData);\n\n  for (const mesh of scenegraph.json.meshes || []) {\n    compressMesh(mesh, options);\n    scenegraph.addRequiredExtension(KHR_DRACO_MESH_COMPRESSION);\n  }\n}\n\nasync function decompressPrimitive(scenegraph, primitive, options, context) {\n  const dracoExtension = scenegraph.getObjectExtension(primitive, KHR_DRACO_MESH_COMPRESSION);\n\n  if (!dracoExtension) {\n    return;\n  }\n\n  const buffer = scenegraph.getTypedArrayForBufferView(dracoExtension.bufferView);\n  const bufferCopy = sliceArrayBuffer(buffer.buffer, buffer.byteOffset);\n  const {\n    parse\n  } = context;\n  const dracoOptions = { ...options\n  };\n  delete dracoOptions['3d-tiles'];\n  const decodedData = await parse(bufferCopy, DracoLoader, dracoOptions, context);\n  const decodedAttributes = getGLTFAccessors(decodedData.attributes);\n\n  for (const [attributeName, decodedAttribute] of Object.entries(decodedAttributes)) {\n    if (attributeName in primitive.attributes) {\n      const accessorIndex = primitive.attributes[attributeName];\n      const accessor = scenegraph.getAccessor(accessorIndex);\n\n      if (accessor !== null && accessor !== void 0 && accessor.min && accessor !== null && accessor !== void 0 && accessor.max) {\n        decodedAttribute.min = accessor.min;\n        decodedAttribute.max = accessor.max;\n      }\n    }\n  }\n\n  primitive.attributes = decodedAttributes;\n\n  if (decodedData.indices) {\n    primitive.indices = getGLTFAccessor(decodedData.indices);\n  }\n\n  checkPrimitive(primitive);\n}\n\nfunction compressMesh(attributes, indices) {\n  let mode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 4;\n  let options = arguments.length > 3 ? arguments[3] : undefined;\n  let context = arguments.length > 4 ? arguments[4] : undefined;\n\n  var _context$parseSync;\n\n  if (!options.DracoWriter) {\n    throw new Error('options.gltf.DracoWriter not provided');\n  }\n\n  const compressedData = options.DracoWriter.encodeSync({\n    attributes\n  });\n  const decodedData = context === null || context === void 0 ? void 0 : (_context$parseSync = context.parseSync) === null || _context$parseSync === void 0 ? void 0 : _context$parseSync.call(context, {\n    attributes\n  });\n\n  const fauxAccessors = options._addFauxAttributes(decodedData.attributes);\n\n  const bufferViewIndex = options.addBufferView(compressedData);\n  const glTFMesh = {\n    primitives: [{\n      attributes: fauxAccessors,\n      mode,\n      extensions: {\n        [KHR_DRACO_MESH_COMPRESSION]: {\n          bufferView: bufferViewIndex,\n          attributes: fauxAccessors\n        }\n      }\n    }]\n  };\n  return glTFMesh;\n}\n\nfunction checkPrimitive(primitive) {\n  if (!primitive.attributes && Object.keys(primitive.attributes).length > 0) {\n    throw new Error('glTF: Empty primitive detected: Draco decompression failure?');\n  }\n}\n\nfunction* makeMeshPrimitiveIterator(scenegraph) {\n  for (const mesh of scenegraph.json.meshes || []) {\n    for (const primitive of mesh.primitives) {\n      yield primitive;\n    }\n  }\n}","map":{"version":3,"sources":["../../../../src/lib/extensions/KHR_draco_mesh_compression.ts"],"names":["default","options","scenegraph","promises","makeMeshPrimitiveIterator","decompressPrimitive","Promise","compressMesh","dracoExtension","buffer","bufferCopy","sliceArrayBuffer","parse","dracoOptions","decodedData","decodedAttributes","getGLTFAccessors","Object","attributeName","primitive","accessorIndex","accessor","decodedAttribute","getGLTFAccessor","checkPrimitive","mode","compressedData","attributes","context","fauxAccessors","bufferViewIndex","glTFMesh","primitives","extensions","bufferView","mesh"],"mappings":"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","sourcesContent":["// https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression\n// Only TRIANGLES: 0x0004 and TRIANGLE_STRIP: 0x0005 are supported\n\n/* eslint-disable camelcase */\nimport type {GLTF, GLTFAccessor, GLTFMeshPrimitive} from '../types/gltf-types';\nimport type {GLTFLoaderOptions} from '../../gltf-loader';\n\nimport type {LoaderContext} from '@loaders.gl/loader-utils';\nimport {DracoLoader} from '@loaders.gl/draco';\nimport {DracoLoaderOptions, DracoMeshData} from '@loaders.gl/draco';\nimport {sliceArrayBuffer} from '@loaders.gl/loader-utils';\nimport {default as Scenegraph} from '../api/gltf-scenegraph';\nimport {KHR_DRACO_MESH_COMPRESSION} from '../gltf-utils/gltf-constants';\nimport {getGLTFAccessors, getGLTFAccessor} from '../gltf-utils/gltf-attribute-utils';\n\n// Note: We have a \"soft dependency\" on DracoWriter to avoid bundling it when not needed\nexport async function decode(\n  gltfData: {json: GLTF},\n  options: GLTFLoaderOptions,\n  context: LoaderContext\n): Promise<void> {\n  if (!options?.gltf?.decompressMeshes) {\n    return;\n  }\n\n  const scenegraph = new Scenegraph(gltfData);\n  const promises: Promise<void>[] = [];\n  for (const primitive of makeMeshPrimitiveIterator(scenegraph)) {\n    if (scenegraph.getObjectExtension(primitive, KHR_DRACO_MESH_COMPRESSION)) {\n      promises.push(decompressPrimitive(scenegraph, primitive, options, context));\n    }\n  }\n\n  // Decompress meshes in parallel\n  await Promise.all(promises);\n\n  // We have now decompressed all primitives, so remove the top-level extensions\n  scenegraph.removeExtension(KHR_DRACO_MESH_COMPRESSION);\n}\n\nexport function encode(gltfData, options: GLTFLoaderOptions = {}): void {\n  const scenegraph = new Scenegraph(gltfData);\n\n  for (const mesh of scenegraph.json.meshes || []) {\n    // eslint-disable-next-line camelcase\n    // @ts-ignore\n    compressMesh(mesh, options);\n    // NOTE: Only add the extension if something was actually compressed\n    scenegraph.addRequiredExtension(KHR_DRACO_MESH_COMPRESSION);\n  }\n}\n\n// DECODE\n\n// Unpacks one mesh primitive and removes the extension from the primitive\n// DracoDecoder needs to be imported and registered by app\n// Returns: Promise that resolves when all pending draco decoder jobs for this mesh complete\n\n// TODO - Implement fallback behavior per KHR_DRACO_MESH_COMPRESSION spec\n\nasync function decompressPrimitive(\n  scenegraph: Scenegraph,\n  primitive: GLTFMeshPrimitive,\n  options: GLTFLoaderOptions,\n  context: LoaderContext\n): Promise<void> {\n  const dracoExtension = scenegraph.getObjectExtension(primitive, KHR_DRACO_MESH_COMPRESSION);\n  if (!dracoExtension) {\n    return;\n  }\n\n  const buffer = scenegraph.getTypedArrayForBufferView(dracoExtension.bufferView);\n  // TODO - parse does not yet deal well with byte offsets embedded in typed arrays. Copy buffer\n  // TODO - remove when `parse` is fixed to handle `byteOffset`s\n  const bufferCopy = sliceArrayBuffer(buffer.buffer, buffer.byteOffset); // , buffer.byteLength);\n\n  const {parse} = context;\n  const dracoOptions: DracoLoaderOptions = {...options};\n\n  // TODO - remove hack: The entire tileset might be included, too expensive to serialize\n  delete dracoOptions['3d-tiles'];\n  const decodedData = (await parse(\n    bufferCopy,\n    DracoLoader,\n    dracoOptions,\n    context\n  )) as DracoMeshData;\n\n  const decodedAttributes: {[key: string]: GLTFAccessor} = getGLTFAccessors(decodedData.attributes);\n\n  // Restore min/max values\n  for (const [attributeName, decodedAttribute] of Object.entries(decodedAttributes)) {\n    if (attributeName in primitive.attributes) {\n      const accessorIndex: number = primitive.attributes[attributeName];\n      const accessor = scenegraph.getAccessor(accessorIndex);\n      if (accessor?.min && accessor?.max) {\n        decodedAttribute.min = accessor.min;\n        decodedAttribute.max = accessor.max;\n      }\n    }\n  }\n\n  // @ts-ignore\n  primitive.attributes = decodedAttributes;\n  if (decodedData.indices) {\n    // @ts-ignore\n    primitive.indices = getGLTFAccessor(decodedData.indices);\n  }\n\n  // Extension has been processed, delete it\n  // delete primitive.extensions[KHR_DRACO_MESH_COMPRESSION];\n\n  checkPrimitive(primitive);\n}\n\n// ENCODE\n\n// eslint-disable-next-line max-len\n// Only TRIANGLES: 0x0004 and TRIANGLE_STRIP: 0x0005 are supported\nfunction compressMesh(attributes, indices, mode: number = 4, options, context: LoaderContext) {\n  if (!options.DracoWriter) {\n    throw new Error('options.gltf.DracoWriter not provided');\n  }\n\n  // TODO - use DracoWriter using encode w/ registered DracoWriter...\n  const compressedData = options.DracoWriter.encodeSync({attributes});\n\n  // Draco compression may change the order and number of vertices in a mesh.\n  // To satisfy the requirement that accessors properties be correct for both\n  // compressed and uncompressed data, generators should create uncompressed\n  // attributes and indices using data that has been decompressed from the Draco buffer,\n  // rather than the original source data.\n  // @ts-ignore TODO this needs to be fixed\n  const decodedData = context?.parseSync?.({attributes});\n  const fauxAccessors = options._addFauxAttributes(decodedData.attributes);\n\n  const bufferViewIndex = options.addBufferView(compressedData);\n\n  const glTFMesh = {\n    primitives: [\n      {\n        attributes: fauxAccessors, // TODO - verify with spec\n        mode, // GL.POINTS\n        extensions: {\n          [KHR_DRACO_MESH_COMPRESSION]: {\n            bufferView: bufferViewIndex,\n            attributes: fauxAccessors // TODO - verify with spec\n          }\n        }\n      }\n    ]\n  };\n\n  return glTFMesh;\n}\n\n// UTILS\n\nfunction checkPrimitive(primitive: GLTFMeshPrimitive) {\n  if (!primitive.attributes && Object.keys(primitive.attributes).length > 0) {\n    throw new Error('glTF: Empty primitive detected: Draco decompression failure?');\n  }\n}\n\nfunction* makeMeshPrimitiveIterator(scenegraph) {\n  for (const mesh of scenegraph.json.meshes || []) {\n    for (const primitive of mesh.primitives) {\n      yield primitive;\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}