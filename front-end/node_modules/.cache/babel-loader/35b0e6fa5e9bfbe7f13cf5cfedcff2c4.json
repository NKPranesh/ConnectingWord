{"ast":null,"code":"export function getFirstCharacters(data) {\n  let length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5;\n\n  if (typeof data === 'string') {\n    return data.slice(0, length);\n  } else if (ArrayBuffer.isView(data)) {\n    return getMagicString(data.buffer, data.byteOffset, length);\n  } else if (data instanceof ArrayBuffer) {\n    const byteOffset = 0;\n    return getMagicString(data, byteOffset, length);\n  }\n\n  return '';\n}\nexport function getMagicString(arrayBuffer, byteOffset, length) {\n  if (arrayBuffer.byteLength <= byteOffset + length) {\n    return '';\n  }\n\n  const dataView = new DataView(arrayBuffer);\n  let magic = '';\n\n  for (let i = 0; i < length; i++) {\n    magic += String.fromCharCode(dataView.getUint8(byteOffset + i));\n  }\n\n  return magic;\n}","map":{"version":3,"sources":["../../../../src/lib/binary-utils/get-first-characters.ts"],"names":["length","data","ArrayBuffer","getMagicString","byteOffset","arrayBuffer","dataView","magic","i","String"],"mappings":"AAAA,OAAO,SAAA,kBAAA,CAAA,IAAA,EAAsD;AAAA,MAApBA,MAAoB,uEAAtD,CAAsD;;AAC3D,MAAI,OAAA,IAAA,KAAJ,QAAA,EAA8B;AAC5B,WAAOC,IAAI,CAAJA,KAAAA,CAAAA,CAAAA,EAAP,MAAOA,CAAP;AADF,GAAA,MAEO,IAAIC,WAAW,CAAXA,MAAAA,CAAJ,IAAIA,CAAJ,EAA8B;AAEnC,WAAOC,cAAc,CAACF,IAAI,CAAL,MAAA,EAAcA,IAAI,CAAlB,UAAA,EAArB,MAAqB,CAArB;AAFK,GAAA,MAGA,IAAIA,IAAI,YAAR,WAAA,EAAiC;AACtC,UAAMG,UAAU,GAAhB,CAAA;AACA,WAAOD,cAAc,CAAA,IAAA,EAAA,UAAA,EAArB,MAAqB,CAArB;AACD;;AACD,SAAA,EAAA;AACD;AAED,OAAO,SAAA,cAAA,CAAA,WAAA,EAAA,UAAA,EAAA,MAAA,EAIG;AACR,MAAIE,WAAW,CAAXA,UAAAA,IAA0BD,UAAU,GAAxC,MAAA,EAAmD;AACjD,WAAA,EAAA;AACD;;AACD,QAAME,QAAQ,GAAG,IAAA,QAAA,CAAjB,WAAiB,CAAjB;AACA,MAAIC,KAAK,GAAT,EAAA;;AACA,OAAK,IAAIC,CAAC,GAAV,CAAA,EAAgBA,CAAC,GAAjB,MAAA,EAA4BA,CAA5B,EAAA,EAAiC;AAC/BD,IAAAA,KAAK,IAAIE,MAAM,CAANA,YAAAA,CAAoBH,QAAQ,CAARA,QAAAA,CAAkBF,UAAU,GAAzDG,CAA6BD,CAApBG,CAATF;AACD;;AACD,SAAA,KAAA;AACD","sourcesContent":["export function getFirstCharacters(data, length = 5): string {\n  if (typeof data === 'string') {\n    return data.slice(0, length);\n  } else if (ArrayBuffer.isView(data)) {\n    // Typed Arrays can have offsets into underlying buffer\n    return getMagicString(data.buffer, data.byteOffset, length);\n  } else if (data instanceof ArrayBuffer) {\n    const byteOffset = 0;\n    return getMagicString(data, byteOffset, length);\n  }\n  return '';\n}\n\nexport function getMagicString(\n  arrayBuffer: ArrayBuffer,\n  byteOffset: number,\n  length: number\n): string {\n  if (arrayBuffer.byteLength <= byteOffset + length) {\n    return '';\n  }\n  const dataView = new DataView(arrayBuffer);\n  let magic = '';\n  for (let i = 0; i < length; i++) {\n    magic += String.fromCharCode(dataView.getUint8(byteOffset + i));\n  }\n  return magic;\n}\n"]},"metadata":{},"sourceType":"module"}