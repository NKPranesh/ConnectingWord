{"ast":null,"code":"import typedArrayManager from './typed-array-manager';\nimport { Vector3 } from 'math.gl';\nexport function createMat4() {\n  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n}\nexport function mod(value, divisor) {\n  const modulus = value % divisor;\n  return modulus < 0 ? divisor + modulus : modulus;\n}\nexport function getCameraPosition(viewMatrixInverse) {\n  return [viewMatrixInverse[12], viewMatrixInverse[13], viewMatrixInverse[14]];\n}\nexport function getFrustumPlanes(viewProjectionMatrix) {\n  const planes = {};\n  planes.left = getFrustumPlane(viewProjectionMatrix[3] + viewProjectionMatrix[0], viewProjectionMatrix[7] + viewProjectionMatrix[4], viewProjectionMatrix[11] + viewProjectionMatrix[8], viewProjectionMatrix[15] + viewProjectionMatrix[12]);\n  planes.right = getFrustumPlane(viewProjectionMatrix[3] - viewProjectionMatrix[0], viewProjectionMatrix[7] - viewProjectionMatrix[4], viewProjectionMatrix[11] - viewProjectionMatrix[8], viewProjectionMatrix[15] - viewProjectionMatrix[12]);\n  planes.bottom = getFrustumPlane(viewProjectionMatrix[3] + viewProjectionMatrix[1], viewProjectionMatrix[7] + viewProjectionMatrix[5], viewProjectionMatrix[11] + viewProjectionMatrix[9], viewProjectionMatrix[15] + viewProjectionMatrix[13]);\n  planes.top = getFrustumPlane(viewProjectionMatrix[3] - viewProjectionMatrix[1], viewProjectionMatrix[7] - viewProjectionMatrix[5], viewProjectionMatrix[11] - viewProjectionMatrix[9], viewProjectionMatrix[15] - viewProjectionMatrix[13]);\n  planes.near = getFrustumPlane(viewProjectionMatrix[3] + viewProjectionMatrix[2], viewProjectionMatrix[7] + viewProjectionMatrix[6], viewProjectionMatrix[11] + viewProjectionMatrix[10], viewProjectionMatrix[15] + viewProjectionMatrix[14]);\n  planes.far = getFrustumPlane(viewProjectionMatrix[3] - viewProjectionMatrix[2], viewProjectionMatrix[7] - viewProjectionMatrix[6], viewProjectionMatrix[11] - viewProjectionMatrix[10], viewProjectionMatrix[15] - viewProjectionMatrix[14]);\n  return planes;\n}\nconst scratchVector = new Vector3();\n\nfunction getFrustumPlane(a, b, c, d) {\n  scratchVector.set(a, b, c);\n  const L = scratchVector.len();\n  return {\n    distance: d / L,\n    normal: new Vector3(-a / L, -b / L, -c / L)\n  };\n}\n\nexport function fp64LowPart(x) {\n  return x - Math.fround(x);\n}\nlet scratchArray;\nexport function toDoublePrecisionArray(typedArray, _ref) {\n  let {\n    size = 1,\n    startIndex = 0,\n    endIndex\n  } = _ref;\n\n  if (!Number.isFinite(endIndex)) {\n    endIndex = typedArray.length;\n  }\n\n  const count = (endIndex - startIndex) / size;\n  scratchArray = typedArrayManager.allocate(scratchArray, count, {\n    type: Float32Array,\n    size: size * 2\n  });\n  let sourceIndex = startIndex;\n  let targetIndex = 0;\n\n  while (sourceIndex < endIndex) {\n    for (let j = 0; j < size; j++) {\n      const value = typedArray[sourceIndex++];\n      scratchArray[targetIndex + j] = value;\n      scratchArray[targetIndex + j + size] = fp64LowPart(value);\n    }\n\n    targetIndex += size * 2;\n  }\n\n  return scratchArray.subarray(0, count * size * 2);\n}","map":{"version":3,"sources":["../../../src/utils/math-utils.js"],"names":["modulus","value","divisor","viewMatrixInverse","planes","getFrustumPlane","viewProjectionMatrix","scratchVector","L","distance","d","normal","x","Math","size","startIndex","endIndex","Number","typedArray","count","scratchArray","type","sourceIndex","targetIndex","j","fp64LowPart"],"mappings":"AACA,OAAA,iBAAA,MAAA,uBAAA;AACA,SAAA,OAAA,QAAA,SAAA;AAGA,OAAO,SAAA,UAAA,GAAsB;AAC3B,SAAO,CAAA,CAAA,EAAA,CAAA,EAAA,CAAA,EAAA,CAAA,EAAA,CAAA,EAAA,CAAA,EAAA,CAAA,EAAA,CAAA,EAAA,CAAA,EAAA,CAAA,EAAA,CAAA,EAAA,CAAA,EAAA,CAAA,EAAA,CAAA,EAAA,CAAA,EAAP,CAAO,CAAP;AACD;AAED,OAAO,SAAA,GAAA,CAAA,KAAA,EAAA,OAAA,EAA6B;AAClC,QAAMA,OAAO,GAAGC,KAAK,GAArB,OAAA;AACA,SAAOD,OAAO,GAAPA,CAAAA,GAAcE,OAAO,GAArBF,OAAAA,GAAP,OAAA;AACD;AAGD,OAAO,SAAA,iBAAA,CAAA,iBAAA,EAA8C;AAEnD,SAAO,CAACG,iBAAiB,CAAlB,EAAkB,CAAlB,EAAwBA,iBAAiB,CAAzC,EAAyC,CAAzC,EAA+CA,iBAAiB,CAAvE,EAAuE,CAAhE,CAAP;AACD;AAGD,OAAO,SAAA,gBAAA,CAAA,oBAAA,EAAgD;AACrD,QAAMC,MAAM,GAAZ,EAAA;AAEAA,EAAAA,MAAM,CAANA,IAAAA,GAAcC,eAAe,CAC3BC,oBAAoB,CAApBA,CAAoB,CAApBA,GAA0BA,oBAAoB,CADnB,CACmB,CADnB,EAE3BA,oBAAoB,CAApBA,CAAoB,CAApBA,GAA0BA,oBAAoB,CAFnB,CAEmB,CAFnB,EAG3BA,oBAAoB,CAApBA,EAAoB,CAApBA,GAA2BA,oBAAoB,CAHpB,CAGoB,CAHpB,EAI3BA,oBAAoB,CAApBA,EAAoB,CAApBA,GAA2BA,oBAAoB,CAJjDF,EAIiD,CAJpB,CAA7BA;AAMAA,EAAAA,MAAM,CAANA,KAAAA,GAAeC,eAAe,CAC5BC,oBAAoB,CAApBA,CAAoB,CAApBA,GAA0BA,oBAAoB,CADlB,CACkB,CADlB,EAE5BA,oBAAoB,CAApBA,CAAoB,CAApBA,GAA0BA,oBAAoB,CAFlB,CAEkB,CAFlB,EAG5BA,oBAAoB,CAApBA,EAAoB,CAApBA,GAA2BA,oBAAoB,CAHnB,CAGmB,CAHnB,EAI5BA,oBAAoB,CAApBA,EAAoB,CAApBA,GAA2BA,oBAAoB,CAJjDF,EAIiD,CAJnB,CAA9BA;AAMAA,EAAAA,MAAM,CAANA,MAAAA,GAAgBC,eAAe,CAC7BC,oBAAoB,CAApBA,CAAoB,CAApBA,GAA0BA,oBAAoB,CADjB,CACiB,CADjB,EAE7BA,oBAAoB,CAApBA,CAAoB,CAApBA,GAA0BA,oBAAoB,CAFjB,CAEiB,CAFjB,EAG7BA,oBAAoB,CAApBA,EAAoB,CAApBA,GAA2BA,oBAAoB,CAHlB,CAGkB,CAHlB,EAI7BA,oBAAoB,CAApBA,EAAoB,CAApBA,GAA2BA,oBAAoB,CAJjDF,EAIiD,CAJlB,CAA/BA;AAMAA,EAAAA,MAAM,CAANA,GAAAA,GAAaC,eAAe,CAC1BC,oBAAoB,CAApBA,CAAoB,CAApBA,GAA0BA,oBAAoB,CADpB,CACoB,CADpB,EAE1BA,oBAAoB,CAApBA,CAAoB,CAApBA,GAA0BA,oBAAoB,CAFpB,CAEoB,CAFpB,EAG1BA,oBAAoB,CAApBA,EAAoB,CAApBA,GAA2BA,oBAAoB,CAHrB,CAGqB,CAHrB,EAI1BA,oBAAoB,CAApBA,EAAoB,CAApBA,GAA2BA,oBAAoB,CAJjDF,EAIiD,CAJrB,CAA5BA;AAMAA,EAAAA,MAAM,CAANA,IAAAA,GAAcC,eAAe,CAC3BC,oBAAoB,CAApBA,CAAoB,CAApBA,GAA0BA,oBAAoB,CADnB,CACmB,CADnB,EAE3BA,oBAAoB,CAApBA,CAAoB,CAApBA,GAA0BA,oBAAoB,CAFnB,CAEmB,CAFnB,EAG3BA,oBAAoB,CAApBA,EAAoB,CAApBA,GAA2BA,oBAAoB,CAHpB,EAGoB,CAHpB,EAI3BA,oBAAoB,CAApBA,EAAoB,CAApBA,GAA2BA,oBAAoB,CAJjDF,EAIiD,CAJpB,CAA7BA;AAMAA,EAAAA,MAAM,CAANA,GAAAA,GAAaC,eAAe,CAC1BC,oBAAoB,CAApBA,CAAoB,CAApBA,GAA0BA,oBAAoB,CADpB,CACoB,CADpB,EAE1BA,oBAAoB,CAApBA,CAAoB,CAApBA,GAA0BA,oBAAoB,CAFpB,CAEoB,CAFpB,EAG1BA,oBAAoB,CAApBA,EAAoB,CAApBA,GAA2BA,oBAAoB,CAHrB,EAGqB,CAHrB,EAI1BA,oBAAoB,CAApBA,EAAoB,CAApBA,GAA2BA,oBAAoB,CAJjDF,EAIiD,CAJrB,CAA5BA;AAOA,SAAA,MAAA;AACD;AAED,MAAMG,aAAa,GAAG,IAAtB,OAAsB,EAAtB;;AAEA,SAAA,eAAA,CAAA,CAAA,EAAA,CAAA,EAAA,CAAA,EAAA,CAAA,EAAqC;AACnCA,EAAAA,aAAa,CAAbA,GAAAA,CAAAA,CAAAA,EAAAA,CAAAA,EAAAA,CAAAA;AACA,QAAMC,CAAC,GAAGD,aAAa,CAAvB,GAAUA,EAAV;AACA,SAAO;AAACE,IAAAA,QAAQ,EAAEC,CAAC,GAAZ,CAAA;AAAkBC,IAAAA,MAAM,EAAE,IAAA,OAAA,CAAY,CAAA,CAAA,GAAZ,CAAA,EAAoB,CAAA,CAAA,GAApB,CAAA,EAA4B,CAAA,CAAA,GAA5B,CAAA;AAA1B,GAAP;AACD;;AAOD,OAAO,SAAA,WAAA,CAAA,CAAA,EAAwB;AAC7B,SAAOC,CAAC,GAAGC,IAAI,CAAJA,MAAAA,CAAX,CAAWA,CAAX;AACD;AAED,IAAA,YAAA;AAWA,OAAO,SAAA,sBAAA,CAAA,UAAA,QAAkF;AAAA,MAAtC;AAACC,IAAAA,IAAI,GAAL,CAAA;AAAWC,IAAAA,UAAU,GAArB,CAAA;AAA2BC,IAAAA;AAA3B,GAAsC;;AACvF,MAAI,CAACC,MAAM,CAANA,QAAAA,CAAL,QAAKA,CAAL,EAAgC;AAC9BD,IAAAA,QAAQ,GAAGE,UAAU,CAArBF,MAAAA;AACD;;AACD,QAAMG,KAAK,GAAG,CAACH,QAAQ,GAAT,UAAA,IAAd,IAAA;AACAI,EAAAA,YAAY,GAAG,iBAAiB,CAAjB,QAAA,CAAA,YAAA,EAAA,KAAA,EAAgD;AAC7DC,IAAAA,IAAI,EADyD,YAAA;AAE7DP,IAAAA,IAAI,EAAEA,IAAI,GAAG;AAFgD,GAAhD,CAAfM;AAKA,MAAIE,WAAW,GAAf,UAAA;AACA,MAAIC,WAAW,GAAf,CAAA;;AACA,SAAOD,WAAW,GAAlB,QAAA,EAA+B;AAC7B,SAAK,IAAIE,CAAC,GAAV,CAAA,EAAgBA,CAAC,GAAjB,IAAA,EAA0BA,CAA1B,EAAA,EAA+B;AAC7B,YAAMvB,KAAK,GAAGiB,UAAU,CAACI,WAAzB,EAAwB,CAAxB;AACAF,MAAAA,YAAY,CAACG,WAAW,GAAxBH,CAAY,CAAZA,GAAAA,KAAAA;AACAA,MAAAA,YAAY,CAACG,WAAW,GAAXA,CAAAA,GAAbH,IAAY,CAAZA,GAAuCK,WAAW,CAAlDL,KAAkD,CAAlDA;AACD;;AACDG,IAAAA,WAAW,IAAIT,IAAI,GAAnBS,CAAAA;AACD;;AAED,SAAOH,YAAY,CAAZA,QAAAA,CAAAA,CAAAA,EAAyBD,KAAK,GAALA,IAAAA,GAAhC,CAAOC,CAAP;AACD","sourcesContent":["// Extensions to math.gl library. Intended to be folded back.\nimport typedArrayManager from './typed-array-manager';\nimport {Vector3} from 'math.gl';\n\n// Helper, avoids low-precision 32 bit matrices from gl-matrix mat4.create()\nexport function createMat4() {\n  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n}\n\nexport function mod(value, divisor) {\n  const modulus = value % divisor;\n  return modulus < 0 ? divisor + modulus : modulus;\n}\n\n// Extract camera vectors (move to math library?)\nexport function getCameraPosition(viewMatrixInverse) {\n  // Read the translation from the inverse view matrix\n  return [viewMatrixInverse[12], viewMatrixInverse[13], viewMatrixInverse[14]];\n}\n\n// https://www.gamedevs.org/uploads/fast-extraction-viewing-frustum-planes-from-world-view-projection-matrix.pdf\nexport function getFrustumPlanes(viewProjectionMatrix) {\n  const planes = {};\n\n  planes.left = getFrustumPlane(\n    viewProjectionMatrix[3] + viewProjectionMatrix[0],\n    viewProjectionMatrix[7] + viewProjectionMatrix[4],\n    viewProjectionMatrix[11] + viewProjectionMatrix[8],\n    viewProjectionMatrix[15] + viewProjectionMatrix[12]\n  );\n  planes.right = getFrustumPlane(\n    viewProjectionMatrix[3] - viewProjectionMatrix[0],\n    viewProjectionMatrix[7] - viewProjectionMatrix[4],\n    viewProjectionMatrix[11] - viewProjectionMatrix[8],\n    viewProjectionMatrix[15] - viewProjectionMatrix[12]\n  );\n  planes.bottom = getFrustumPlane(\n    viewProjectionMatrix[3] + viewProjectionMatrix[1],\n    viewProjectionMatrix[7] + viewProjectionMatrix[5],\n    viewProjectionMatrix[11] + viewProjectionMatrix[9],\n    viewProjectionMatrix[15] + viewProjectionMatrix[13]\n  );\n  planes.top = getFrustumPlane(\n    viewProjectionMatrix[3] - viewProjectionMatrix[1],\n    viewProjectionMatrix[7] - viewProjectionMatrix[5],\n    viewProjectionMatrix[11] - viewProjectionMatrix[9],\n    viewProjectionMatrix[15] - viewProjectionMatrix[13]\n  );\n  planes.near = getFrustumPlane(\n    viewProjectionMatrix[3] + viewProjectionMatrix[2],\n    viewProjectionMatrix[7] + viewProjectionMatrix[6],\n    viewProjectionMatrix[11] + viewProjectionMatrix[10],\n    viewProjectionMatrix[15] + viewProjectionMatrix[14]\n  );\n  planes.far = getFrustumPlane(\n    viewProjectionMatrix[3] - viewProjectionMatrix[2],\n    viewProjectionMatrix[7] - viewProjectionMatrix[6],\n    viewProjectionMatrix[11] - viewProjectionMatrix[10],\n    viewProjectionMatrix[15] - viewProjectionMatrix[14]\n  );\n\n  return planes;\n}\n\nconst scratchVector = new Vector3();\n\nfunction getFrustumPlane(a, b, c, d) {\n  scratchVector.set(a, b, c);\n  const L = scratchVector.len();\n  return {distance: d / L, normal: new Vector3(-a / L, -b / L, -c / L)};\n}\n\n/**\n * Calculate the low part of a WebGL 64 bit float\n * @param x {number} - the input float number\n * @returns {number} - the lower 32 bit of the number\n */\nexport function fp64LowPart(x) {\n  return x - Math.fround(x);\n}\n\nlet scratchArray;\n\n/**\n * Split a Float64Array into a double-length Float32Array\n * @param typedArray {Float64Array}\n * @param size {Number} - per attribute size\n * @param [startIndex] {Number} - start index in the source array\n * @param [endIndex] {Number} - end index in the source array\n * @returns {Float32Array} - high part, low part for each attribute:\n    [1xHi, 1yHi, 1zHi, 1xLow, 1yLow, 1zLow, 2xHi, ...]\n */\nexport function toDoublePrecisionArray(typedArray, {size = 1, startIndex = 0, endIndex}) {\n  if (!Number.isFinite(endIndex)) {\n    endIndex = typedArray.length;\n  }\n  const count = (endIndex - startIndex) / size;\n  scratchArray = typedArrayManager.allocate(scratchArray, count, {\n    type: Float32Array,\n    size: size * 2\n  });\n\n  let sourceIndex = startIndex;\n  let targetIndex = 0;\n  while (sourceIndex < endIndex) {\n    for (let j = 0; j < size; j++) {\n      const value = typedArray[sourceIndex++];\n      scratchArray[targetIndex + j] = value;\n      scratchArray[targetIndex + j + size] = fp64LowPart(value);\n    }\n    targetIndex += size * 2;\n  }\n\n  return scratchArray.subarray(0, count * size * 2);\n}\n"]},"metadata":{},"sourceType":"module"}