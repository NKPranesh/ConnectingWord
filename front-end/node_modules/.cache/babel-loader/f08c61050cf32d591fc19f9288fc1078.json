{"ast":null,"code":"import { Vector3, assert, equals as equalsEpsilon } from '@math.gl/core';\nconst EPSILON14 = 1e-14;\nconst scratchOrigin = new Vector3();\nconst VECTOR_PRODUCT_LOCAL_FRAME = {\n  up: {\n    south: 'east',\n    north: 'west',\n    west: 'south',\n    east: 'north'\n  },\n  down: {\n    south: 'west',\n    north: 'east',\n    west: 'north',\n    east: 'south'\n  },\n  south: {\n    up: 'west',\n    down: 'east',\n    west: 'down',\n    east: 'up'\n  },\n  north: {\n    up: 'east',\n    down: 'west',\n    west: 'up',\n    east: 'down'\n  },\n  west: {\n    up: 'north',\n    down: 'south',\n    north: 'down',\n    south: 'up'\n  },\n  east: {\n    up: 'south',\n    down: 'north',\n    north: 'up',\n    south: 'down'\n  }\n};\nconst degeneratePositionLocalFrame = {\n  north: [-1, 0, 0],\n  east: [0, 1, 0],\n  up: [0, 0, 1],\n  south: [1, 0, 0],\n  west: [0, -1, 0],\n  down: [0, 0, -1]\n};\nconst scratchAxisVectors = {\n  east: new Vector3(),\n  north: new Vector3(),\n  up: new Vector3(),\n  west: new Vector3(),\n  south: new Vector3(),\n  down: new Vector3()\n};\nconst scratchVector1 = new Vector3();\nconst scratchVector2 = new Vector3();\nconst scratchVector3 = new Vector3();\nexport default function localFrameToFixedFrame(ellipsoid, firstAxis, secondAxis, thirdAxis, cartesianOrigin, result) {\n  const thirdAxisInferred = VECTOR_PRODUCT_LOCAL_FRAME[firstAxis] && VECTOR_PRODUCT_LOCAL_FRAME[firstAxis][secondAxis];\n  assert(thirdAxisInferred && (!thirdAxis || thirdAxis === thirdAxisInferred));\n  let firstAxisVector;\n  let secondAxisVector;\n  let thirdAxisVector;\n  const origin = scratchOrigin.copy(cartesianOrigin);\n  const atPole = equalsEpsilon(origin.x, 0.0, EPSILON14) && equalsEpsilon(origin.y, 0.0, EPSILON14);\n\n  if (atPole) {\n    const sign = Math.sign(origin.z);\n    firstAxisVector = scratchVector1.fromArray(degeneratePositionLocalFrame[firstAxis]);\n\n    if (firstAxis !== 'east' && firstAxis !== 'west') {\n      firstAxisVector.scale(sign);\n    }\n\n    secondAxisVector = scratchVector2.fromArray(degeneratePositionLocalFrame[secondAxis]);\n\n    if (secondAxis !== 'east' && secondAxis !== 'west') {\n      secondAxisVector.scale(sign);\n    }\n\n    thirdAxisVector = scratchVector3.fromArray(degeneratePositionLocalFrame[thirdAxis]);\n\n    if (thirdAxis !== 'east' && thirdAxis !== 'west') {\n      thirdAxisVector.scale(sign);\n    }\n  } else {\n    const {\n      up,\n      east,\n      north\n    } = scratchAxisVectors;\n    east.set(-origin.y, origin.x, 0.0).normalize();\n    ellipsoid.geodeticSurfaceNormal(origin, up);\n    north.copy(up).cross(east);\n    const {\n      down,\n      west,\n      south\n    } = scratchAxisVectors;\n    down.copy(up).scale(-1);\n    west.copy(east).scale(-1);\n    south.copy(north).scale(-1);\n    firstAxisVector = scratchAxisVectors[firstAxis];\n    secondAxisVector = scratchAxisVectors[secondAxis];\n    thirdAxisVector = scratchAxisVectors[thirdAxis];\n  }\n\n  result[0] = firstAxisVector.x;\n  result[1] = firstAxisVector.y;\n  result[2] = firstAxisVector.z;\n  result[3] = 0.0;\n  result[4] = secondAxisVector.x;\n  result[5] = secondAxisVector.y;\n  result[6] = secondAxisVector.z;\n  result[7] = 0.0;\n  result[8] = thirdAxisVector.x;\n  result[9] = thirdAxisVector.y;\n  result[10] = thirdAxisVector.z;\n  result[11] = 0.0;\n  result[12] = origin.x;\n  result[13] = origin.y;\n  result[14] = origin.z;\n  result[15] = 1.0;\n  return result;\n}","map":{"version":3,"sources":["../../../../src/ellipsoid/helpers/ellipsoid-transform.js"],"names":["equals","EPSILON14","scratchOrigin","VECTOR_PRODUCT_LOCAL_FRAME","up","south","north","west","east","down","degeneratePositionLocalFrame","scratchAxisVectors","scratchVector1","scratchVector2","scratchVector3","thirdAxisInferred","assert","thirdAxis","origin","atPole","equalsEpsilon","sign","Math","firstAxisVector","firstAxis","secondAxisVector","secondAxis","thirdAxisVector","ellipsoid","result"],"mappings":"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","sourcesContent":["import {Vector3, assert, equals as equalsEpsilon} from '@math.gl/core';\n\nconst EPSILON14 = 1e-14;\n\nconst scratchOrigin = new Vector3();\n\n// Caclulate third axis from given two axii\nconst VECTOR_PRODUCT_LOCAL_FRAME = {\n  up: {\n    south: 'east',\n    north: 'west',\n    west: 'south',\n    east: 'north'\n  },\n  down: {\n    south: 'west',\n    north: 'east',\n    west: 'north',\n    east: 'south'\n  },\n  south: {\n    up: 'west',\n    down: 'east',\n    west: 'down',\n    east: 'up'\n  },\n  north: {\n    up: 'east',\n    down: 'west',\n    west: 'up',\n    east: 'down'\n  },\n  west: {\n    up: 'north',\n    down: 'south',\n    north: 'down',\n    south: 'up'\n  },\n  east: {\n    up: 'south',\n    down: 'north',\n    north: 'up',\n    south: 'down'\n  }\n};\n\nconst degeneratePositionLocalFrame = {\n  north: [-1, 0, 0],\n  east: [0, 1, 0],\n  up: [0, 0, 1],\n  south: [1, 0, 0],\n  west: [0, -1, 0],\n  down: [0, 0, -1]\n};\n\nconst scratchAxisVectors = {\n  east: new Vector3(),\n  north: new Vector3(),\n  up: new Vector3(),\n  west: new Vector3(),\n  south: new Vector3(),\n  down: new Vector3()\n};\n\nconst scratchVector1 = new Vector3();\nconst scratchVector2 = new Vector3();\nconst scratchVector3 = new Vector3();\n\n// Computes a 4x4 transformation matrix from a reference frame\n// centered at the provided origin to the provided ellipsoid's fixed reference frame.\n// eslint-disable-next-line max-statements, max-params, complexity\nexport default function localFrameToFixedFrame(\n  ellipsoid,\n  firstAxis,\n  secondAxis,\n  thirdAxis,\n  cartesianOrigin,\n  result\n) {\n  const thirdAxisInferred =\n    VECTOR_PRODUCT_LOCAL_FRAME[firstAxis] && VECTOR_PRODUCT_LOCAL_FRAME[firstAxis][secondAxis];\n  // firstAxis and secondAxis must be east, north, up, west, south or down.');\n  assert(thirdAxisInferred && (!thirdAxis || thirdAxis === thirdAxisInferred));\n\n  let firstAxisVector;\n  let secondAxisVector;\n  let thirdAxisVector;\n\n  const origin = scratchOrigin.copy(cartesianOrigin);\n\n  // If x and y are zero, assume origin is at a pole, which is a special case.\n  const atPole = equalsEpsilon(origin.x, 0.0, EPSILON14) && equalsEpsilon(origin.y, 0.0, EPSILON14);\n\n  if (atPole) {\n    // Look up axis value and adjust\n    const sign = Math.sign(origin.z);\n\n    firstAxisVector = scratchVector1.fromArray(degeneratePositionLocalFrame[firstAxis]);\n    if (firstAxis !== 'east' && firstAxis !== 'west') {\n      firstAxisVector.scale(sign);\n    }\n\n    secondAxisVector = scratchVector2.fromArray(degeneratePositionLocalFrame[secondAxis]);\n    if (secondAxis !== 'east' && secondAxis !== 'west') {\n      secondAxisVector.scale(sign);\n    }\n\n    thirdAxisVector = scratchVector3.fromArray(degeneratePositionLocalFrame[thirdAxis]);\n    if (thirdAxis !== 'east' && thirdAxis !== 'west') {\n      thirdAxisVector.scale(sign);\n    }\n  } else {\n    // Calculate all axis\n    const {up, east, north} = scratchAxisVectors;\n\n    east.set(-origin.y, origin.x, 0.0).normalize();\n    ellipsoid.geodeticSurfaceNormal(origin, up);\n    north.copy(up).cross(east);\n\n    const {down, west, south} = scratchAxisVectors;\n\n    down.copy(up).scale(-1);\n    west.copy(east).scale(-1);\n    south.copy(north).scale(-1);\n\n    // Pick three axis based on desired orientation\n    firstAxisVector = scratchAxisVectors[firstAxis];\n    secondAxisVector = scratchAxisVectors[secondAxis];\n    thirdAxisVector = scratchAxisVectors[thirdAxis];\n  }\n\n  // TODO - assuming the result is column-major\n  result[0] = firstAxisVector.x;\n  result[1] = firstAxisVector.y;\n  result[2] = firstAxisVector.z;\n  result[3] = 0.0;\n  result[4] = secondAxisVector.x;\n  result[5] = secondAxisVector.y;\n  result[6] = secondAxisVector.z;\n  result[7] = 0.0;\n  result[8] = thirdAxisVector.x;\n  result[9] = thirdAxisVector.y;\n  result[10] = thirdAxisVector.z;\n  result[11] = 0.0;\n  result[12] = origin.x;\n  result[13] = origin.y;\n  result[14] = origin.z;\n  result[15] = 1.0;\n  return result;\n}\n"]},"metadata":{},"sourceType":"module"}