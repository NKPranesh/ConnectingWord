{"ast":null,"code":"import Resource from './resource';\nimport Accessor from './accessor';\nimport { getGLTypeFromTypedArray, getTypedArrayFromGLType } from '../webgl-utils/typed-array-utils';\nimport { assertWebGL2Context, log } from '@luma.gl/gltools';\nimport { assert } from '../utils/assert';\nimport { checkProps } from '../utils/check-props';\nconst DEBUG_DATA_LENGTH = 10;\nconst DEPRECATED_PROPS = {\n  offset: 'accessor.offset',\n  stride: 'accessor.stride',\n  type: 'accessor.type',\n  size: 'accessor.size',\n  divisor: 'accessor.divisor',\n  normalized: 'accessor.normalized',\n  integer: 'accessor.integer',\n  instanced: 'accessor.divisor',\n  isInstanced: 'accessor.divisor'\n};\nconst PROP_CHECKS_INITIALIZE = {\n  removedProps: {},\n  replacedProps: {\n    bytes: 'byteLength'\n  },\n  deprecatedProps: DEPRECATED_PROPS\n};\nconst PROP_CHECKS_SET_PROPS = {\n  removedProps: DEPRECATED_PROPS\n};\nexport default class Buffer extends Resource {\n  constructor(gl) {\n    let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super(gl, props);\n    this.stubRemovedMethods('Buffer', 'v6.0', ['layout', 'setLayout', 'getIndexedParameter']);\n    this.target = props.target || (this.gl.webgl2 ? 36662 : 34962);\n    this.initialize(props);\n    Object.seal(this);\n  }\n\n  getElementCount() {\n    let accessor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.accessor;\n    return Math.round(this.byteLength / Accessor.getBytesPerElement(accessor));\n  }\n\n  getVertexCount() {\n    let accessor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.accessor;\n    return Math.round(this.byteLength / Accessor.getBytesPerVertex(accessor));\n  }\n\n  initialize() {\n    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (ArrayBuffer.isView(props)) {\n      props = {\n        data: props\n      };\n    }\n\n    if (Number.isFinite(props)) {\n      props = {\n        byteLength: props\n      };\n    }\n\n    props = checkProps('Buffer', props, PROP_CHECKS_INITIALIZE);\n    this.usage = props.usage || 35044;\n    this.debugData = null;\n    this.setAccessor(Object.assign({}, props, props.accessor));\n\n    if (props.data) {\n      this._setData(props.data, props.offset, props.byteLength);\n    } else {\n      this._setByteLength(props.byteLength || 0);\n    }\n\n    return this;\n  }\n\n  setProps(props) {\n    props = checkProps('Buffer', props, PROP_CHECKS_SET_PROPS);\n\n    if ('accessor' in props) {\n      this.setAccessor(props.accessor);\n    }\n\n    return this;\n  }\n\n  setAccessor(accessor) {\n    accessor = Object.assign({}, accessor);\n    delete accessor.buffer;\n    this.accessor = new Accessor(accessor);\n    return this;\n  }\n\n  reallocate(byteLength) {\n    if (byteLength > this.byteLength) {\n      this._setByteLength(byteLength);\n\n      return true;\n    }\n\n    this.bytesUsed = byteLength;\n    return false;\n  }\n\n  setData(props) {\n    return this.initialize(props);\n  }\n\n  subData(props) {\n    if (ArrayBuffer.isView(props)) {\n      props = {\n        data: props\n      };\n    }\n\n    const {\n      data,\n      offset = 0,\n      srcOffset = 0\n    } = props;\n    const byteLength = props.byteLength || props.length;\n    assert(data);\n    const target = this.gl.webgl2 ? 36663 : this.target;\n    this.gl.bindBuffer(target, this.handle);\n\n    if (srcOffset !== 0 || byteLength !== undefined) {\n      assertWebGL2Context(this.gl);\n      this.gl.bufferSubData(this.target, offset, data, srcOffset, byteLength);\n    } else {\n      this.gl.bufferSubData(target, offset, data);\n    }\n\n    this.gl.bindBuffer(target, null);\n    this.debugData = null;\n\n    this._inferType(data);\n\n    return this;\n  }\n\n  copyData(_ref) {\n    let {\n      sourceBuffer,\n      readOffset = 0,\n      writeOffset = 0,\n      size\n    } = _ref;\n    const {\n      gl\n    } = this;\n    assertWebGL2Context(gl);\n    gl.bindBuffer(36662, sourceBuffer.handle);\n    gl.bindBuffer(36663, this.handle);\n    gl.copyBufferSubData(36662, 36663, readOffset, writeOffset, size);\n    gl.bindBuffer(36662, null);\n    gl.bindBuffer(36663, null);\n    this.debugData = null;\n    return this;\n  }\n\n  getData() {\n    let {\n      dstData = null,\n      srcByteOffset = 0,\n      dstOffset = 0,\n      length = 0\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    assertWebGL2Context(this.gl);\n    const ArrayType = getTypedArrayFromGLType(this.accessor.type || 5126, {\n      clamped: false\n    });\n\n    const sourceAvailableElementCount = this._getAvailableElementCount(srcByteOffset);\n\n    const dstElementOffset = dstOffset;\n    let dstAvailableElementCount;\n    let dstElementCount;\n\n    if (dstData) {\n      dstElementCount = dstData.length;\n      dstAvailableElementCount = dstElementCount - dstElementOffset;\n    } else {\n      dstAvailableElementCount = Math.min(sourceAvailableElementCount, length || sourceAvailableElementCount);\n      dstElementCount = dstElementOffset + dstAvailableElementCount;\n    }\n\n    const copyElementCount = Math.min(sourceAvailableElementCount, dstAvailableElementCount);\n    length = length || copyElementCount;\n    assert(length <= copyElementCount);\n    dstData = dstData || new ArrayType(dstElementCount);\n    this.gl.bindBuffer(36662, this.handle);\n    this.gl.getBufferSubData(36662, srcByteOffset, dstData, dstOffset, length);\n    this.gl.bindBuffer(36662, null);\n    return dstData;\n  }\n\n  bind() {\n    let {\n      target = this.target,\n      index = this.accessor && this.accessor.index,\n      offset = 0,\n      size\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (target === 35345 || target === 35982) {\n      if (size !== undefined) {\n        this.gl.bindBufferRange(target, index, this.handle, offset, size);\n      } else {\n        assert(offset === 0);\n        this.gl.bindBufferBase(target, index, this.handle);\n      }\n    } else {\n      this.gl.bindBuffer(target, this.handle);\n    }\n\n    return this;\n  }\n\n  unbind() {\n    let {\n      target = this.target,\n      index = this.accessor && this.accessor.index\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const isIndexedBuffer = target === 35345 || target === 35982;\n\n    if (isIndexedBuffer) {\n      this.gl.bindBufferBase(target, index, null);\n    } else {\n      this.gl.bindBuffer(target, null);\n    }\n\n    return this;\n  }\n\n  getDebugData() {\n    if (!this.debugData) {\n      this.debugData = this.getData({\n        length: Math.min(DEBUG_DATA_LENGTH, this.byteLength)\n      });\n      return {\n        data: this.debugData,\n        changed: true\n      };\n    }\n\n    return {\n      data: this.debugData,\n      changed: false\n    };\n  }\n\n  invalidateDebugData() {\n    this.debugData = null;\n  }\n\n  _setData(data) {\n    let offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    let byteLength = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : data.byteLength + offset;\n    assert(ArrayBuffer.isView(data));\n\n    this._trackDeallocatedMemory();\n\n    const target = this._getTarget();\n\n    this.gl.bindBuffer(target, this.handle);\n    this.gl.bufferData(target, byteLength, this.usage);\n    this.gl.bufferSubData(target, offset, data);\n    this.gl.bindBuffer(target, null);\n    this.debugData = data.slice(0, DEBUG_DATA_LENGTH);\n    this.bytesUsed = byteLength;\n\n    this._trackAllocatedMemory(byteLength);\n\n    const type = getGLTypeFromTypedArray(data);\n    assert(type);\n    this.setAccessor(new Accessor(this.accessor, {\n      type\n    }));\n    return this;\n  }\n\n  _setByteLength(byteLength) {\n    let usage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.usage;\n    assert(byteLength >= 0);\n\n    this._trackDeallocatedMemory();\n\n    let data = byteLength;\n\n    if (byteLength === 0) {\n      data = new Float32Array(0);\n    }\n\n    const target = this._getTarget();\n\n    this.gl.bindBuffer(target, this.handle);\n    this.gl.bufferData(target, data, usage);\n    this.gl.bindBuffer(target, null);\n    this.usage = usage;\n    this.debugData = null;\n    this.bytesUsed = byteLength;\n\n    this._trackAllocatedMemory(byteLength);\n\n    return this;\n  }\n\n  _getTarget() {\n    return this.gl.webgl2 ? 36663 : this.target;\n  }\n\n  _getAvailableElementCount(srcByteOffset) {\n    const ArrayType = getTypedArrayFromGLType(this.accessor.type || 5126, {\n      clamped: false\n    });\n    const sourceElementOffset = srcByteOffset / ArrayType.BYTES_PER_ELEMENT;\n    return this.getElementCount() - sourceElementOffset;\n  }\n\n  _inferType(data) {\n    if (!this.accessor.type) {\n      this.setAccessor(new Accessor(this.accessor, {\n        type: getGLTypeFromTypedArray(data)\n      }));\n    }\n  }\n\n  _createHandle() {\n    return this.gl.createBuffer();\n  }\n\n  _deleteHandle() {\n    this.gl.deleteBuffer(this.handle);\n\n    this._trackDeallocatedMemory();\n  }\n\n  _getParameter(pname) {\n    this.gl.bindBuffer(this.target, this.handle);\n    const value = this.gl.getBufferParameter(this.target, pname);\n    this.gl.bindBuffer(this.target, null);\n    return value;\n  }\n\n  get type() {\n    log.deprecated('Buffer.type', 'Buffer.accessor.type')();\n    return this.accessor.type;\n  }\n\n  get bytes() {\n    log.deprecated('Buffer.bytes', 'Buffer.byteLength')();\n    return this.byteLength;\n  }\n\n  setByteLength(byteLength) {\n    log.deprecated('setByteLength', 'reallocate')();\n    return this.reallocate(byteLength);\n  }\n\n  updateAccessor(opts) {\n    log.deprecated('updateAccessor(...)', 'setAccessor(new Accessor(buffer.accessor, ...)')();\n    this.accessor = new Accessor(this.accessor, opts);\n    return this;\n  }\n\n}","map":{"version":3,"sources":["../../../src/classes/buffer.js"],"names":["DEBUG_DATA_LENGTH","DEPRECATED_PROPS","offset","stride","type","size","divisor","normalized","integer","instanced","isInstanced","PROP_CHECKS_INITIALIZE","removedProps","replacedProps","bytes","deprecatedProps","PROP_CHECKS_SET_PROPS","constructor","props","Object","getElementCount","accessor","Math","Accessor","getVertexCount","initialize","ArrayBuffer","data","Number","byteLength","checkProps","setProps","setAccessor","reallocate","setData","subData","srcOffset","assert","target","assertWebGL2Context","copyData","readOffset","writeOffset","gl","sourceBuffer","getData","dstData","srcByteOffset","dstOffset","length","ArrayType","getTypedArrayFromGLType","clamped","sourceAvailableElementCount","dstElementOffset","dstElementCount","dstAvailableElementCount","copyElementCount","bind","index","unbind","isIndexedBuffer","getDebugData","changed","invalidateDebugData","_setData","getGLTypeFromTypedArray","_setByteLength","usage","_getTarget","_getAvailableElementCount","sourceElementOffset","_inferType","_createHandle","_deleteHandle","_getParameter","value","log","setByteLength","updateAccessor"],"mappings":"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","sourcesContent":["import GL from '@luma.gl/constants';\nimport Resource from './resource';\nimport Accessor from './accessor';\nimport {getGLTypeFromTypedArray, getTypedArrayFromGLType} from '../webgl-utils/typed-array-utils';\nimport {assertWebGL2Context, log} from '@luma.gl/gltools';\nimport {assert} from '../utils/assert';\nimport {checkProps} from '../utils/check-props';\n\nconst DEBUG_DATA_LENGTH = 10;\n\n// Shared prop checks for constructor and setProps\nconst DEPRECATED_PROPS = {\n  offset: 'accessor.offset',\n  stride: 'accessor.stride',\n  type: 'accessor.type',\n  size: 'accessor.size',\n  divisor: 'accessor.divisor',\n  normalized: 'accessor.normalized',\n  integer: 'accessor.integer',\n  instanced: 'accessor.divisor',\n  isInstanced: 'accessor.divisor'\n};\n\n// Prop checks for constructor\nconst PROP_CHECKS_INITIALIZE = {\n  removedProps: {},\n  replacedProps: {\n    bytes: 'byteLength'\n  },\n  // new Buffer() with individual accessor props is still used in apps, emit warnings\n  deprecatedProps: DEPRECATED_PROPS\n};\n\n// Prop checks for setProps\nconst PROP_CHECKS_SET_PROPS = {\n  // Buffer.setProps() with individual accessor props is rare => emit errors\n  removedProps: DEPRECATED_PROPS\n};\n\nexport default class Buffer extends Resource {\n  constructor(gl, props = {}) {\n    super(gl, props);\n\n    this.stubRemovedMethods('Buffer', 'v6.0', ['layout', 'setLayout', 'getIndexedParameter']);\n    // this.stubRemovedMethods('Buffer', 'v7.0', ['updateAccessor']);\n\n    // In WebGL1, need to make sure we use GL.ELEMENT_ARRAY_BUFFER when initializing element buffers\n    // otherwise buffer type will lock to generic (non-element) buffer\n    // In WebGL2, we can use GL.COPY_READ_BUFFER which avoids locking the type here\n    this.target = props.target || (this.gl.webgl2 ? GL.COPY_READ_BUFFER : GL.ARRAY_BUFFER);\n\n    this.initialize(props);\n\n    Object.seal(this);\n  }\n\n  // returns number of elements in the buffer (assuming that the full buffer is used)\n  getElementCount(accessor = this.accessor) {\n    return Math.round(this.byteLength / Accessor.getBytesPerElement(accessor));\n  }\n\n  // returns number of vertices in the buffer (assuming that the full buffer is used)\n  getVertexCount(accessor = this.accessor) {\n    return Math.round(this.byteLength / Accessor.getBytesPerVertex(accessor));\n  }\n\n  // Creates and initializes the buffer object's data store.\n  // Signature: `new Buffer(gl, {data: new Float32Array(...)})`\n  // Signature: `new Buffer(gl, new Float32Array(...))`\n  // Signature: `new Buffer(gl, 100)`\n  initialize(props = {}) {\n    // Signature `new Buffer(gl, new Float32Array(...)`\n    if (ArrayBuffer.isView(props)) {\n      props = {data: props};\n    }\n\n    // Signature: `new Buffer(gl, 100)`\n    if (Number.isFinite(props)) {\n      props = {byteLength: props};\n    }\n\n    props = checkProps('Buffer', props, PROP_CHECKS_INITIALIZE);\n\n    // Initialize member fields\n    this.usage = props.usage || GL.STATIC_DRAW;\n    this.debugData = null;\n\n    // Deprecated: Merge main props and accessor\n    this.setAccessor(Object.assign({}, props, props.accessor));\n\n    // Set data: (re)initializes the buffer\n    if (props.data) {\n      this._setData(props.data, props.offset, props.byteLength);\n    } else {\n      this._setByteLength(props.byteLength || 0);\n    }\n\n    return this;\n  }\n\n  setProps(props) {\n    props = checkProps('Buffer', props, PROP_CHECKS_SET_PROPS);\n\n    if ('accessor' in props) {\n      this.setAccessor(props.accessor);\n    }\n\n    return this;\n  }\n\n  // Optionally stores an accessor with the buffer, makes it easier to use it as an attribute later\n  // {type, size = 1, offset = 0, stride = 0, normalized = false, integer = false, divisor = 0}\n  setAccessor(accessor) {\n    // NOTE: From luma.gl v7.0, Accessors have an optional `buffer `field\n    // (mainly to support \"interleaving\")\n    // To avoid confusion, ensure `buffer.accessor` does not have a `buffer.accessor.buffer` field:\n    accessor = Object.assign({}, accessor);\n    delete accessor.buffer;\n\n    // This new statement ensures that an \"accessor object\" is re-packaged as an Accessor instance\n    this.accessor = new Accessor(accessor);\n    return this;\n  }\n\n  // Allocate a bigger GPU buffer (if the current buffer is not big enough).\n  // If a reallocation is triggered it clears the buffer\n  // Returns:\n  //  `true`: buffer was reallocated, data was cleared\n  //  `false`: buffer was big enough, data is intact\n  reallocate(byteLength) {\n    if (byteLength > this.byteLength) {\n      this._setByteLength(byteLength);\n      return true;\n    }\n    this.bytesUsed = byteLength;\n    return false;\n  }\n\n  // Update with new data. Reinitializes the buffer\n  setData(props) {\n    return this.initialize(props);\n  }\n\n  // Updates a subset of a buffer object's data store.\n  // Data (Typed Array or ArrayBuffer), length is inferred unless provided\n  // Offset into buffer\n  // WebGL2 only: Offset into srcData\n  // WebGL2 only: Number of bytes to be copied\n  subData(props) {\n    // Signature: buffer.subData(new Float32Array([...]))\n    if (ArrayBuffer.isView(props)) {\n      props = {data: props};\n    }\n\n    const {data, offset = 0, srcOffset = 0} = props;\n    const byteLength = props.byteLength || props.length;\n\n    assert(data);\n\n    // Create the buffer - binding it here for the first time locks the type\n    // In WebGL2, use GL.COPY_WRITE_BUFFER to avoid locking the type\n    const target = this.gl.webgl2 ? GL.COPY_WRITE_BUFFER : this.target;\n    this.gl.bindBuffer(target, this.handle);\n    // WebGL2: subData supports additional srcOffset and length parameters\n    if (srcOffset !== 0 || byteLength !== undefined) {\n      assertWebGL2Context(this.gl);\n      this.gl.bufferSubData(this.target, offset, data, srcOffset, byteLength);\n    } else {\n      this.gl.bufferSubData(target, offset, data);\n    }\n    this.gl.bindBuffer(target, null);\n\n    // TODO - update local `data` if offsets are right\n    this.debugData = null;\n\n    this._inferType(data);\n\n    return this;\n  }\n\n  // WEBGL2 ONLY: Copies part of the data of another buffer into this buffer\n  copyData({sourceBuffer, readOffset = 0, writeOffset = 0, size}) {\n    const {gl} = this;\n    assertWebGL2Context(gl);\n\n    // Use GL.COPY_READ_BUFFER+GL.COPY_WRITE_BUFFER avoid disturbing other targets and locking type\n    gl.bindBuffer(GL.COPY_READ_BUFFER, sourceBuffer.handle);\n    gl.bindBuffer(GL.COPY_WRITE_BUFFER, this.handle);\n    gl.copyBufferSubData(GL.COPY_READ_BUFFER, GL.COPY_WRITE_BUFFER, readOffset, writeOffset, size);\n    gl.bindBuffer(GL.COPY_READ_BUFFER, null);\n    gl.bindBuffer(GL.COPY_WRITE_BUFFER, null);\n\n    // TODO - update local `data` if offsets are 0\n    this.debugData = null;\n\n    return this;\n  }\n\n  // WEBGL2 ONLY: Reads data from buffer into an ArrayBufferView or SharedArrayBuffer.\n  getData({dstData = null, srcByteOffset = 0, dstOffset = 0, length = 0} = {}) {\n    assertWebGL2Context(this.gl);\n\n    const ArrayType = getTypedArrayFromGLType(this.accessor.type || GL.FLOAT, {clamped: false});\n    const sourceAvailableElementCount = this._getAvailableElementCount(srcByteOffset);\n\n    const dstElementOffset = dstOffset;\n\n    let dstAvailableElementCount;\n    let dstElementCount;\n    if (dstData) {\n      dstElementCount = dstData.length;\n      dstAvailableElementCount = dstElementCount - dstElementOffset;\n    } else {\n      // Allocate ArrayBufferView with enough size to copy all eligible data.\n      dstAvailableElementCount = Math.min(\n        sourceAvailableElementCount,\n        length || sourceAvailableElementCount\n      );\n      dstElementCount = dstElementOffset + dstAvailableElementCount;\n    }\n\n    const copyElementCount = Math.min(sourceAvailableElementCount, dstAvailableElementCount);\n    length = length || copyElementCount;\n    assert(length <= copyElementCount);\n    dstData = dstData || new ArrayType(dstElementCount);\n\n    // Use GL.COPY_READ_BUFFER to avoid disturbing other targets and locking type\n    this.gl.bindBuffer(GL.COPY_READ_BUFFER, this.handle);\n    this.gl.getBufferSubData(GL.COPY_READ_BUFFER, srcByteOffset, dstData, dstOffset, length);\n    this.gl.bindBuffer(GL.COPY_READ_BUFFER, null);\n\n    // TODO - update local `data` if offsets are 0\n    return dstData;\n  }\n\n  /**\n   * Binds a buffer to a given binding point (target).\n   *   GL.TRANSFORM_FEEDBACK_BUFFER and GL.UNIFORM_BUFFER take an index, and optionally a range.\n   *   - GL.TRANSFORM_FEEDBACK_BUFFER and GL.UNIFORM_BUFFER need an index to affect state\n   *   - GL.UNIFORM_BUFFER: `offset` must be aligned to GL.UNIFORM_BUFFER_OFFSET_ALIGNMENT.\n   *   - GL.UNIFORM_BUFFER: `size` must be a minimum of GL.UNIFORM_BLOCK_SIZE_DATA.\n   */\n  bind({\n    target = this.target, // target for the bind operation\n    index = this.accessor && this.accessor.index, // index = index of target (indexed bind point)\n    offset = 0,\n    size\n  } = {}) {\n    // NOTE: While GL.TRANSFORM_FEEDBACK_BUFFER and GL.UNIFORM_BUFFER could\n    // be used as direct binding points, they will not affect transform feedback or\n    // uniform buffer state. Instead indexed bindings need to be made.\n    if (target === GL.UNIFORM_BUFFER || target === GL.TRANSFORM_FEEDBACK_BUFFER) {\n      if (size !== undefined) {\n        this.gl.bindBufferRange(target, index, this.handle, offset, size);\n      } else {\n        assert(offset === 0); // Make sure offset wasn't supplied\n        this.gl.bindBufferBase(target, index, this.handle);\n      }\n    } else {\n      this.gl.bindBuffer(target, this.handle);\n    }\n\n    return this;\n  }\n\n  unbind({target = this.target, index = this.accessor && this.accessor.index} = {}) {\n    const isIndexedBuffer = target === GL.UNIFORM_BUFFER || target === GL.TRANSFORM_FEEDBACK_BUFFER;\n    if (isIndexedBuffer) {\n      this.gl.bindBufferBase(target, index, null);\n    } else {\n      this.gl.bindBuffer(target, null);\n    }\n    return this;\n  }\n\n  // PROTECTED METHODS (INTENDED FOR USE BY OTHER FRAMEWORK CODE ONLY)\n\n  // Returns a short initial data array\n  getDebugData() {\n    if (!this.debugData) {\n      this.debugData = this.getData({length: Math.min(DEBUG_DATA_LENGTH, this.byteLength)});\n      return {data: this.debugData, changed: true};\n    }\n    return {data: this.debugData, changed: false};\n  }\n\n  invalidateDebugData() {\n    this.debugData = null;\n  }\n\n  // PRIVATE METHODS\n\n  // Allocate a new buffer and initialize to contents of typed array\n  _setData(data, offset = 0, byteLength = data.byteLength + offset) {\n    assert(ArrayBuffer.isView(data));\n\n    this._trackDeallocatedMemory();\n\n    const target = this._getTarget();\n    this.gl.bindBuffer(target, this.handle);\n    this.gl.bufferData(target, byteLength, this.usage);\n    this.gl.bufferSubData(target, offset, data);\n    this.gl.bindBuffer(target, null);\n\n    this.debugData = data.slice(0, DEBUG_DATA_LENGTH);\n    this.bytesUsed = byteLength;\n\n    this._trackAllocatedMemory(byteLength);\n\n    // infer GL type from supplied typed array\n    const type = getGLTypeFromTypedArray(data);\n    assert(type);\n    this.setAccessor(new Accessor(this.accessor, {type}));\n    return this;\n  }\n\n  // Allocate a GPU buffer of specified size.\n  _setByteLength(byteLength, usage = this.usage) {\n    assert(byteLength >= 0);\n\n    this._trackDeallocatedMemory();\n\n    // Workaround needed for Safari (#291):\n    // gl.bufferData with size equal to 0 crashes. Instead create zero sized array.\n    let data = byteLength;\n    if (byteLength === 0) {\n      data = new Float32Array(0);\n    }\n\n    const target = this._getTarget();\n    this.gl.bindBuffer(target, this.handle);\n    this.gl.bufferData(target, data, usage);\n    this.gl.bindBuffer(target, null);\n\n    this.usage = usage;\n    this.debugData = null;\n    this.bytesUsed = byteLength;\n\n    this._trackAllocatedMemory(byteLength);\n\n    return this;\n  }\n\n  // Binding a buffer for the first time locks the type\n  // In WebGL2, use GL.COPY_WRITE_BUFFER to avoid locking the type\n  _getTarget() {\n    return this.gl.webgl2 ? GL.COPY_WRITE_BUFFER : this.target;\n  }\n\n  _getAvailableElementCount(srcByteOffset) {\n    const ArrayType = getTypedArrayFromGLType(this.accessor.type || GL.FLOAT, {clamped: false});\n    const sourceElementOffset = srcByteOffset / ArrayType.BYTES_PER_ELEMENT;\n    return this.getElementCount() - sourceElementOffset;\n  }\n\n  // Automatically infers type from typed array passed to setData\n  // Note: No longer that useful, since type is now autodeduced from the compiled shaders\n  _inferType(data) {\n    if (!this.accessor.type) {\n      this.setAccessor(new Accessor(this.accessor, {type: getGLTypeFromTypedArray(data)}));\n    }\n  }\n\n  // RESOURCE METHODS\n\n  _createHandle() {\n    return this.gl.createBuffer();\n  }\n\n  _deleteHandle() {\n    this.gl.deleteBuffer(this.handle);\n    this._trackDeallocatedMemory();\n  }\n\n  _getParameter(pname) {\n    this.gl.bindBuffer(this.target, this.handle);\n    const value = this.gl.getBufferParameter(this.target, pname);\n    this.gl.bindBuffer(this.target, null);\n    return value;\n  }\n\n  // DEPRECATIONS - v7.0\n  get type() {\n    log.deprecated('Buffer.type', 'Buffer.accessor.type')();\n    return this.accessor.type;\n  }\n\n  get bytes() {\n    log.deprecated('Buffer.bytes', 'Buffer.byteLength')();\n    return this.byteLength;\n  }\n\n  // DEPRECATIONS - v6.0\n  // Deprecated in v6.x, but not warnings not properly implemented\n  setByteLength(byteLength) {\n    log.deprecated('setByteLength', 'reallocate')();\n    return this.reallocate(byteLength);\n  }\n\n  // Deprecated in v6.x, but not warnings not properly implemented\n  updateAccessor(opts) {\n    log.deprecated('updateAccessor(...)', 'setAccessor(new Accessor(buffer.accessor, ...)')();\n    this.accessor = new Accessor(this.accessor, opts);\n    return this;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}