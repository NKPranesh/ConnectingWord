{"ast":null,"code":"import { Ellipsoid } from '@math.gl/geospatial';\nimport { Matrix4, Vector3 } from '@math.gl/core';\nimport { assert } from '@loaders.gl/loader-utils';\nexport function calculateTransformProps(tileHeader, tile) {\n  assert(tileHeader);\n  assert(tile);\n  const {\n    rtcCenter,\n    gltfUpAxis\n  } = tile;\n  const {\n    computedTransform,\n    boundingVolume: {\n      center\n    }\n  } = tileHeader;\n  let modelMatrix = new Matrix4(computedTransform);\n\n  if (rtcCenter) {\n    modelMatrix.translate(rtcCenter);\n  }\n\n  switch (gltfUpAxis) {\n    case 'Z':\n      break;\n\n    case 'Y':\n      const rotationY = new Matrix4().rotateX(Math.PI / 2);\n      modelMatrix = modelMatrix.multiplyRight(rotationY);\n      break;\n\n    case 'X':\n      const rotationX = new Matrix4().rotateY(-Math.PI / 2);\n      modelMatrix = modelMatrix.multiplyRight(rotationX);\n      break;\n\n    default:\n      break;\n  }\n\n  if (tile.isQuantized) {\n    modelMatrix.translate(tile.quantizedVolumeOffset).scale(tile.quantizedVolumeScale);\n  }\n\n  const cartesianOrigin = new Vector3(center);\n  tile.cartesianModelMatrix = modelMatrix;\n  tile.cartesianOrigin = cartesianOrigin;\n  const cartographicOrigin = Ellipsoid.WGS84.cartesianToCartographic(cartesianOrigin, new Vector3());\n  const fromFixedFrameMatrix = Ellipsoid.WGS84.eastNorthUpToFixedFrame(cartesianOrigin);\n  const toFixedFrameMatrix = fromFixedFrameMatrix.invert();\n  tile.cartographicModelMatrix = toFixedFrameMatrix.multiplyRight(modelMatrix);\n  tile.cartographicOrigin = cartographicOrigin;\n  tile.modelMatrix = tile.cartographicModelMatrix;\n}","map":{"version":3,"sources":["../../../../src/tileset/helpers/transform-utils.ts"],"names":["assert","gltfUpAxis","boundingVolume","center","modelMatrix","rotationY","Math","rotationX","tile","cartesianOrigin","cartographicOrigin","Ellipsoid","fromFixedFrameMatrix","toFixedFrameMatrix"],"mappings":"AAAA,SAAA,SAAA,QAAA,qBAAA;AACA,SAAA,OAAA,EAAA,OAAA,QAAA,eAAA;AACA,SAAA,MAAA,QAAA,0BAAA;AAEA,OAAO,SAAA,uBAAA,CAAA,UAAA,EAAA,IAAA,EAAmD;AACxDA,EAAAA,MAAM,CAANA,UAAM,CAANA;AACAA,EAAAA,MAAM,CAANA,IAAM,CAANA;AAEA,QAAM;AAAA,IAAA,SAAA;AAAYC,IAAAA;AAAZ,MAAN,IAAA;AACA,QAAM;AAAA,IAAA,iBAAA;AAEJC,IAAAA,cAAc,EAAE;AAACC,MAAAA;AAAD;AAFZ,MAAN,UAAA;AAKA,MAAIC,WAAW,GAAG,IAAA,OAAA,CAAlB,iBAAkB,CAAlB;;AAGA,MAAA,SAAA,EAAe;AACbA,IAAAA,WAAW,CAAXA,SAAAA,CAAAA,SAAAA;AACD;;AAID,UAAA,UAAA;AACE,SAAA,GAAA;AACE;;AACF,SAAA,GAAA;AACE,YAAMC,SAAS,GAAG,IAAA,OAAA,GAAA,OAAA,CAAsBC,IAAI,CAAJA,EAAAA,GAAxC,CAAkB,CAAlB;AACAF,MAAAA,WAAW,GAAGA,WAAW,CAAXA,aAAAA,CAAdA,SAAcA,CAAdA;AACA;;AACF,SAAA,GAAA;AACE,YAAMG,SAAS,GAAG,IAAA,OAAA,GAAA,OAAA,CAAsB,CAACD,IAAI,CAAL,EAAA,GAAxC,CAAkB,CAAlB;AACAF,MAAAA,WAAW,GAAGA,WAAW,CAAXA,aAAAA,CAAdA,SAAcA,CAAdA;AACA;;AACF;AACE;AAZJ;;AAgBA,MAAII,IAAI,CAAR,WAAA,EAAsB;AACpBJ,IAAAA,WAAW,CAAXA,SAAAA,CAAsBI,IAAI,CAA1BJ,qBAAAA,EAAAA,KAAAA,CAAwDI,IAAI,CAA5DJ,oBAAAA;AACD;;AAGD,QAAMK,eAAe,GAAG,IAAA,OAAA,CAAxB,MAAwB,CAAxB;AAEAD,EAAAA,IAAI,CAAJA,oBAAAA,GAAAA,WAAAA;AACAA,EAAAA,IAAI,CAAJA,eAAAA,GAAAA,eAAAA;AAGA,QAAME,kBAAkB,GAAGC,SAAS,CAATA,KAAAA,CAAAA,uBAAAA,CAAAA,eAAAA,EAEzB,IAFF,OAEE,EAFyBA,CAA3B;AAIA,QAAMC,oBAAoB,GAAGD,SAAS,CAATA,KAAAA,CAAAA,uBAAAA,CAA7B,eAA6BA,CAA7B;AACA,QAAME,kBAAkB,GAAGD,oBAAoB,CAA/C,MAA2BA,EAA3B;AAEAJ,EAAAA,IAAI,CAAJA,uBAAAA,GAA+BK,kBAAkB,CAAlBA,aAAAA,CAA/BL,WAA+BK,CAA/BL;AACAA,EAAAA,IAAI,CAAJA,kBAAAA,GAAAA,kBAAAA;AAGAA,EAAAA,IAAI,CAAJA,WAAAA,GAAmBA,IAAI,CAAvBA,uBAAAA;AACD","sourcesContent":["import {Ellipsoid} from '@math.gl/geospatial';\nimport {Matrix4, Vector3} from '@math.gl/core';\nimport {assert} from '@loaders.gl/loader-utils';\n\nexport function calculateTransformProps(tileHeader, tile) {\n  assert(tileHeader);\n  assert(tile);\n\n  const {rtcCenter, gltfUpAxis} = tile;\n  const {\n    computedTransform,\n    boundingVolume: {center}\n  } = tileHeader;\n\n  let modelMatrix = new Matrix4(computedTransform);\n\n  // Translate if appropriate\n  if (rtcCenter) {\n    modelMatrix.translate(rtcCenter);\n  }\n\n  // glTF models need to be rotated from Y to Z up\n  // https://github.com/AnalyticalGraphicsInc/3d-tiles/tree/master/specification#y-up-to-z-up\n  switch (gltfUpAxis) {\n    case 'Z':\n      break;\n    case 'Y':\n      const rotationY = new Matrix4().rotateX(Math.PI / 2);\n      modelMatrix = modelMatrix.multiplyRight(rotationY);\n      break;\n    case 'X':\n      const rotationX = new Matrix4().rotateY(-Math.PI / 2);\n      modelMatrix = modelMatrix.multiplyRight(rotationX);\n      break;\n    default:\n      break;\n  }\n\n  // Scale/offset positions if normalized integers\n  if (tile.isQuantized) {\n    modelMatrix.translate(tile.quantizedVolumeOffset).scale(tile.quantizedVolumeScale);\n  }\n\n  // Option 1: Cartesian matrix and origin\n  const cartesianOrigin = new Vector3(center);\n\n  tile.cartesianModelMatrix = modelMatrix;\n  tile.cartesianOrigin = cartesianOrigin;\n\n  // Option 2: Cartographic matrix and origin\n  const cartographicOrigin = Ellipsoid.WGS84.cartesianToCartographic(\n    cartesianOrigin,\n    new Vector3()\n  );\n  const fromFixedFrameMatrix = Ellipsoid.WGS84.eastNorthUpToFixedFrame(cartesianOrigin);\n  const toFixedFrameMatrix = fromFixedFrameMatrix.invert();\n\n  tile.cartographicModelMatrix = toFixedFrameMatrix.multiplyRight(modelMatrix);\n  tile.cartographicOrigin = cartographicOrigin;\n\n  // Deprecated, drop\n  tile.modelMatrix = tile.cartographicModelMatrix;\n}\n"]},"metadata":{},"sourceType":"module"}