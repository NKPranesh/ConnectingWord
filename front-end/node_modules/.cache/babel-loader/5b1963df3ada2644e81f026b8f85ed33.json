{"ast":null,"code":"export function binaryToGeojson(data, options) {\n  const globalFeatureId = options === null || options === void 0 ? void 0 : options.globalFeatureId;\n\n  if (globalFeatureId !== undefined) {\n    return getSingleFeature(data, globalFeatureId);\n  }\n\n  return parseFeatures(data, options === null || options === void 0 ? void 0 : options.type);\n}\nexport function binaryToGeoJson(data, type) {\n  let format = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'feature';\n\n  switch (format) {\n    case 'feature':\n      return parseFeatures(data, type);\n\n    case 'geometry':\n      return binaryToGeometry(data);\n\n    default:\n      throw new Error(format);\n  }\n}\n\nfunction getSingleFeature(data, globalFeatureId) {\n  const dataArray = normalizeInput(data);\n\n  for (const data of dataArray) {\n    let lastIndex = 0;\n    let lastValue = data.featureIds.value[0];\n\n    for (let i = 0; i < data.featureIds.value.length; i++) {\n      const currValue = data.featureIds.value[i];\n\n      if (currValue === lastValue) {\n        continue;\n      }\n\n      if (globalFeatureId === data.globalFeatureIds.value[lastIndex]) {\n        return parseFeature(data, lastIndex, i);\n      }\n\n      lastIndex = i;\n      lastValue = currValue;\n    }\n\n    if (globalFeatureId === data.globalFeatureIds.value[lastIndex]) {\n      return parseFeature(data, lastIndex, data.featureIds.value.length);\n    }\n  }\n\n  throw new Error(\"featureId:\".concat(globalFeatureId, \" not found\"));\n}\n\nfunction parseFeatures(data, type) {\n  const dataArray = normalizeInput(data, type);\n  return parseFeatureCollection(dataArray);\n}\n\nexport function binaryToGeometry(data, startIndex, endIndex) {\n  switch (data.type) {\n    case 'Point':\n      return pointToGeoJson(data, startIndex, endIndex);\n\n    case 'LineString':\n      return lineStringToGeoJson(data, startIndex, endIndex);\n\n    case 'Polygon':\n      return polygonToGeoJson(data, startIndex, endIndex);\n\n    default:\n      const unexpectedInput = data;\n      throw new Error(\"Unsupported geometry type: \".concat(unexpectedInput === null || unexpectedInput === void 0 ? void 0 : unexpectedInput.type));\n  }\n}\n\nfunction normalizeInput(data, type) {\n  const isHeterogeneousType = Boolean(data.points || data.lines || data.polygons);\n\n  if (!isHeterogeneousType) {\n    data.type = type || parseType(data);\n    return [data];\n  }\n\n  const features = [];\n\n  if (data.points) {\n    data.points.type = 'Point';\n    features.push(data.points);\n  }\n\n  if (data.lines) {\n    data.lines.type = 'LineString';\n    features.push(data.lines);\n  }\n\n  if (data.polygons) {\n    data.polygons.type = 'Polygon';\n    features.push(data.polygons);\n  }\n\n  return features;\n}\n\nfunction parseFeatureCollection(dataArray) {\n  const features = [];\n\n  for (const data of dataArray) {\n    if (data.featureIds.value.length === 0) {\n      continue;\n    }\n\n    let lastIndex = 0;\n    let lastValue = data.featureIds.value[0];\n\n    for (let i = 0; i < data.featureIds.value.length; i++) {\n      const currValue = data.featureIds.value[i];\n\n      if (currValue === lastValue) {\n        continue;\n      }\n\n      features.push(parseFeature(data, lastIndex, i));\n      lastIndex = i;\n      lastValue = currValue;\n    }\n\n    features.push(parseFeature(data, lastIndex, data.featureIds.value.length));\n  }\n\n  return features;\n}\n\nfunction parseFeature(data, startIndex, endIndex) {\n  const geometry = binaryToGeometry(data, startIndex, endIndex);\n  const properties = parseProperties(data, startIndex, endIndex);\n  const fields = parseFields(data, startIndex, endIndex);\n  return {\n    type: 'Feature',\n    geometry,\n    properties,\n    ...fields\n  };\n}\n\nfunction parseFields(data) {\n  let startIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  let endIndex = arguments.length > 2 ? arguments[2] : undefined;\n  return data.fields && data.fields[data.featureIds.value[startIndex]];\n}\n\nfunction parseProperties(data) {\n  let startIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  let endIndex = arguments.length > 2 ? arguments[2] : undefined;\n  const properties = Object.assign({}, data.properties[data.featureIds.value[startIndex]]);\n\n  for (const key in data.numericProps) {\n    properties[key] = data.numericProps[key].value[startIndex];\n  }\n\n  return properties;\n}\n\nfunction polygonToGeoJson(data) {\n  let startIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -Infinity;\n  let endIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Infinity;\n  const {\n    positions\n  } = data;\n  const polygonIndices = data.polygonIndices.value.filter(x => x >= startIndex && x <= endIndex);\n  const primitivePolygonIndices = data.primitivePolygonIndices.value.filter(x => x >= startIndex && x <= endIndex);\n  const multi = polygonIndices.length > 2;\n\n  if (!multi) {\n    const coordinates = [];\n\n    for (let i = 0; i < primitivePolygonIndices.length - 1; i++) {\n      const startRingIndex = primitivePolygonIndices[i];\n      const endRingIndex = primitivePolygonIndices[i + 1];\n      const ringCoordinates = ringToGeoJson(positions, startRingIndex, endRingIndex);\n      coordinates.push(ringCoordinates);\n    }\n\n    return {\n      type: 'Polygon',\n      coordinates\n    };\n  }\n\n  const coordinates = [];\n\n  for (let i = 0; i < polygonIndices.length - 1; i++) {\n    const startPolygonIndex = polygonIndices[i];\n    const endPolygonIndex = polygonIndices[i + 1];\n    const polygonCoordinates = polygonToGeoJson(data, startPolygonIndex, endPolygonIndex).coordinates;\n    coordinates.push(polygonCoordinates);\n  }\n\n  return {\n    type: 'MultiPolygon',\n    coordinates\n  };\n}\n\nfunction lineStringToGeoJson(data) {\n  let startIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -Infinity;\n  let endIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Infinity;\n  const {\n    positions\n  } = data;\n  const pathIndices = data.pathIndices.value.filter(x => x >= startIndex && x <= endIndex);\n  const multi = pathIndices.length > 2;\n\n  if (!multi) {\n    const coordinates = ringToGeoJson(positions, pathIndices[0], pathIndices[1]);\n    return {\n      type: 'LineString',\n      coordinates\n    };\n  }\n\n  const coordinates = [];\n\n  for (let i = 0; i < pathIndices.length - 1; i++) {\n    const ringCoordinates = ringToGeoJson(positions, pathIndices[i], pathIndices[i + 1]);\n    coordinates.push(ringCoordinates);\n  }\n\n  return {\n    type: 'MultiLineString',\n    coordinates\n  };\n}\n\nfunction pointToGeoJson(data, startIndex, endIndex) {\n  const {\n    positions\n  } = data;\n  const coordinates = ringToGeoJson(positions, startIndex, endIndex);\n  const multi = coordinates.length > 1;\n\n  if (multi) {\n    return {\n      type: 'MultiPoint',\n      coordinates\n    };\n  }\n\n  return {\n    type: 'Point',\n    coordinates: coordinates[0]\n  };\n}\n\nfunction ringToGeoJson(positions, startIndex, endIndex) {\n  startIndex = startIndex || 0;\n  endIndex = endIndex || positions.value.length / positions.size;\n  const ringCoordinates = [];\n\n  for (let j = startIndex; j < endIndex; j++) {\n    const coord = Array();\n\n    for (let k = j * positions.size; k < (j + 1) * positions.size; k++) {\n      coord.push(Number(positions.value[k]));\n    }\n\n    ringCoordinates.push(coord);\n  }\n\n  return ringCoordinates;\n}\n\nfunction parseType(data) {\n  if (data.pathIndices) {\n    return 'LineString';\n  }\n\n  if (data.polygonIndices) {\n    return 'Polygon';\n  }\n\n  return 'Point';\n}","map":{"version":3,"sources":["../../../src/lib/binary-to-geojson.ts"],"names":["globalFeatureId","options","getSingleFeature","parseFeatures","format","binaryToGeometry","dataArray","normalizeInput","lastIndex","lastValue","data","i","currValue","parseFeature","parseFeatureCollection","pointToGeoJson","lineStringToGeoJson","polygonToGeoJson","unexpectedInput","isHeterogeneousType","Boolean","type","parseType","features","geometry","properties","parseProperties","fields","parseFields","startIndex","Object","endIndex","positions","polygonIndices","x","primitivePolygonIndices","multi","coordinates","startRingIndex","endRingIndex","ringCoordinates","ringToGeoJson","startPolygonIndex","endPolygonIndex","polygonCoordinates","pathIndices","j","coord","Array","k","Number"],"mappings":"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","sourcesContent":["import type {\n  BinaryGeometry,\n  BinaryFeatures,\n  BinaryGeometryType,\n  BinaryPointFeatures,\n  BinaryLineFeatures,\n  BinaryPolygonFeatures,\n  BinaryAttribute\n} from '@loaders.gl/schema';\nimport type {Feature, Geometry, Position, GeoJsonProperties} from '@loaders.gl/schema';\nimport type {\n  Point,\n  MultiPoint,\n  LineString,\n  MultiLineString,\n  Polygon,\n  MultiPolygon\n} from '@loaders.gl/schema';\n\n// Note:L We do not handle GeometryCollection, define a limited Geometry type that always has coordinates.\n// type FeatureGeometry = Point | MultiPoint | LineString | MultiLineString | Polygon | MultiPolygon;\n\ntype BinaryToGeoJsonOptions = {\n  type?: BinaryGeometryType;\n  globalFeatureId?: number;\n};\n\n/**\n * Convert binary geometry representation to GeoJSON\n * @param data   geometry data in binary representation\n * @param options\n * @param options.type  Input data type: Point, LineString, or Polygon\n * @param options.featureId  Global feature id. If specified, only a single feature is extracted\n * @return GeoJSON objects\n */\nexport function binaryToGeojson(\n  data: BinaryFeatures,\n  options?: BinaryToGeoJsonOptions\n): Feature[] | Feature {\n  const globalFeatureId = options?.globalFeatureId;\n  if (globalFeatureId !== undefined) {\n    return getSingleFeature(data, globalFeatureId);\n  }\n  return parseFeatures(data, options?.type);\n}\n\n/** @deprecated use `binaryToGeojson` or `binaryToGeometry` instead */\nexport function binaryToGeoJson(\n  data: BinaryGeometry | BinaryFeatures,\n  type?: BinaryGeometryType,\n  format: 'feature' | 'geometry' = 'feature'\n): Geometry | Feature[] {\n  switch (format) {\n    case 'feature':\n      return parseFeatures(data as BinaryFeatures, type);\n    case 'geometry':\n      return binaryToGeometry(data as BinaryGeometry);\n    default:\n      throw new Error(format);\n  }\n}\n\n/**\n * Return a single feature from a binary geometry representation as GeoJSON\n * @param data   geometry data in binary representation\n * @return GeoJSON feature\n */\nfunction getSingleFeature(data: BinaryFeatures, globalFeatureId: number): Feature {\n  const dataArray = normalizeInput(data);\n  for (const data of dataArray) {\n    let lastIndex = 0;\n    let lastValue = data.featureIds.value[0];\n\n    // Scan through data until we find matching feature\n    for (let i = 0; i < data.featureIds.value.length; i++) {\n      const currValue = data.featureIds.value[i];\n      if (currValue === lastValue) {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n      if (globalFeatureId === data.globalFeatureIds.value[lastIndex]) {\n        return parseFeature(data, lastIndex, i);\n      }\n      lastIndex = i;\n      lastValue = currValue;\n    }\n\n    if (globalFeatureId === data.globalFeatureIds.value[lastIndex]) {\n      return parseFeature(data, lastIndex, data.featureIds.value.length);\n    }\n  }\n\n  throw new Error(`featureId:${globalFeatureId} not found`);\n}\n\nfunction parseFeatures(data: BinaryFeatures, type?: BinaryGeometryType): Feature[] {\n  const dataArray = normalizeInput(data, type);\n  return parseFeatureCollection(dataArray);\n}\n\n/** Parse input binary data and return a valid GeoJSON geometry object */\nexport function binaryToGeometry(\n  data: BinaryGeometry,\n  startIndex?: number,\n  endIndex?: number\n): Geometry {\n  switch (data.type) {\n    case 'Point':\n      return pointToGeoJson(data, startIndex, endIndex);\n    case 'LineString':\n      return lineStringToGeoJson(data, startIndex, endIndex);\n    case 'Polygon':\n      return polygonToGeoJson(data, startIndex, endIndex);\n    default:\n      const unexpectedInput: never = data;\n      throw new Error(`Unsupported geometry type: ${(unexpectedInput as any)?.type}`);\n  }\n}\n\ntype BinaryFeature = BinaryPointFeatures | BinaryLineFeatures | BinaryPolygonFeatures;\ntype BinaryFeaturesArray = BinaryFeature[];\n\n// Normalize features\n// Return an array of data objects, each of which have a type key\nfunction normalizeInput(data: BinaryFeatures, type?: BinaryGeometryType): BinaryFeaturesArray {\n  const isHeterogeneousType = Boolean(data.points || data.lines || data.polygons);\n\n  if (!isHeterogeneousType) {\n    // @ts-expect-error This is a legacy check which allowed `data` to be an instance of the values\n    // here. Aka the new data.points, data.lines, or data.polygons.\n    data.type = type || parseType(data);\n    return [data] as BinaryFeaturesArray;\n  }\n\n  const features: BinaryFeaturesArray = [];\n  if (data.points) {\n    data.points.type = 'Point';\n    features.push(data.points);\n  }\n  if (data.lines) {\n    data.lines.type = 'LineString';\n    features.push(data.lines);\n  }\n  if (data.polygons) {\n    data.polygons.type = 'Polygon';\n    features.push(data.polygons);\n  }\n\n  return features;\n}\n\n/** Parse input binary data and return an array of GeoJSON Features */\nfunction parseFeatureCollection(dataArray): Feature[] {\n  const features: Feature[] = [];\n  for (const data of dataArray) {\n    if (data.featureIds.value.length === 0) {\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n    let lastIndex = 0;\n    let lastValue = data.featureIds.value[0];\n\n    // Need to deduce start, end indices of each feature\n    for (let i = 0; i < data.featureIds.value.length; i++) {\n      const currValue = data.featureIds.value[i];\n      if (currValue === lastValue) {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n\n      features.push(parseFeature(data, lastIndex, i));\n      lastIndex = i;\n      lastValue = currValue;\n    }\n\n    // Last feature\n    features.push(parseFeature(data, lastIndex, data.featureIds.value.length));\n  }\n  return features;\n}\n\n/** Parse input binary data and return a single GeoJSON Feature */\nfunction parseFeature(data, startIndex?: number, endIndex?: number): Feature {\n  const geometry = binaryToGeometry(data, startIndex, endIndex);\n  const properties = parseProperties(data, startIndex, endIndex);\n  const fields = parseFields(data, startIndex, endIndex);\n  return {type: 'Feature', geometry, properties, ...fields};\n}\n\n/** Parse input binary data and return an object of fields */\nfunction parseFields(data, startIndex: number = 0, endIndex?: number): GeoJsonProperties {\n  return data.fields && data.fields[data.featureIds.value[startIndex]];\n}\n\n/** Parse input binary data and return an object of properties */\nfunction parseProperties(data, startIndex: number = 0, endIndex?: number): GeoJsonProperties {\n  const properties = Object.assign({}, data.properties[data.featureIds.value[startIndex]]);\n  for (const key in data.numericProps) {\n    properties[key] = data.numericProps[key].value[startIndex];\n  }\n  return properties;\n}\n\n/** Parse binary data of type Polygon */\nfunction polygonToGeoJson(\n  data,\n  startIndex: number = -Infinity,\n  endIndex: number = Infinity\n): Polygon | MultiPolygon {\n  const {positions} = data;\n  const polygonIndices = data.polygonIndices.value.filter((x) => x >= startIndex && x <= endIndex);\n  const primitivePolygonIndices = data.primitivePolygonIndices.value.filter(\n    (x) => x >= startIndex && x <= endIndex\n  );\n  const multi = polygonIndices.length > 2;\n\n  // Polygon\n  if (!multi) {\n    const coordinates: Position[][] = [];\n    for (let i = 0; i < primitivePolygonIndices.length - 1; i++) {\n      const startRingIndex = primitivePolygonIndices[i];\n      const endRingIndex = primitivePolygonIndices[i + 1];\n      const ringCoordinates = ringToGeoJson(positions, startRingIndex, endRingIndex);\n      coordinates.push(ringCoordinates);\n    }\n\n    return {type: 'Polygon', coordinates};\n  }\n\n  // MultiPolygon\n  const coordinates: Position[][][] = [];\n  for (let i = 0; i < polygonIndices.length - 1; i++) {\n    const startPolygonIndex = polygonIndices[i];\n    const endPolygonIndex = polygonIndices[i + 1];\n    const polygonCoordinates = polygonToGeoJson(\n      data,\n      startPolygonIndex,\n      endPolygonIndex\n    ).coordinates;\n    coordinates.push(polygonCoordinates as Position[][]);\n  }\n\n  return {type: 'MultiPolygon', coordinates};\n}\n\n/** Parse binary data of type LineString */\nfunction lineStringToGeoJson(\n  data,\n  startIndex: number = -Infinity,\n  endIndex: number = Infinity\n): LineString | MultiLineString {\n  const {positions} = data;\n  const pathIndices = data.pathIndices.value.filter((x) => x >= startIndex && x <= endIndex);\n  const multi = pathIndices.length > 2;\n\n  if (!multi) {\n    const coordinates = ringToGeoJson(positions, pathIndices[0], pathIndices[1]);\n    return {type: 'LineString', coordinates};\n  }\n\n  const coordinates: Position[][] = [];\n  for (let i = 0; i < pathIndices.length - 1; i++) {\n    const ringCoordinates = ringToGeoJson(positions, pathIndices[i], pathIndices[i + 1]);\n    coordinates.push(ringCoordinates);\n  }\n\n  return {type: 'MultiLineString', coordinates};\n}\n\n/** Parse binary data of type Point */\nfunction pointToGeoJson(data, startIndex, endIndex): Point | MultiPoint {\n  const {positions} = data;\n  const coordinates = ringToGeoJson(positions, startIndex, endIndex);\n  const multi = coordinates.length > 1;\n\n  if (multi) {\n    return {type: 'MultiPoint', coordinates};\n  }\n\n  return {type: 'Point', coordinates: coordinates[0]};\n}\n\n/**\n * Parse a linear ring of positions to a GeoJSON linear ring\n *\n * @param positions Positions TypedArray\n * @param startIndex Start index to include in ring\n * @param endIndex End index to include in ring\n * @returns GeoJSON ring\n */\nfunction ringToGeoJson(\n  positions: BinaryAttribute,\n  startIndex?: number,\n  endIndex?: number\n): Position[] {\n  startIndex = startIndex || 0;\n  endIndex = endIndex || positions.value.length / positions.size;\n\n  const ringCoordinates: Position[] = [];\n  for (let j = startIndex; j < endIndex; j++) {\n    const coord = Array<number>();\n    for (let k = j * positions.size; k < (j + 1) * positions.size; k++) {\n      coord.push(Number(positions.value[k]));\n    }\n    ringCoordinates.push(coord);\n  }\n  return ringCoordinates;\n}\n\n// Deduce geometry type of data object\nfunction parseType(data) {\n  if (data.pathIndices) {\n    return 'LineString';\n  }\n\n  if (data.polygonIndices) {\n    return 'Polygon';\n  }\n\n  return 'Point';\n}\n"]},"metadata":{},"sourceType":"module"}