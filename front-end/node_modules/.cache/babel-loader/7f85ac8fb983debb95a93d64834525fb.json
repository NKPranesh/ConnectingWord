{"ast":null,"code":"import { project } from '@deck.gl/core';\nconst vs = \"\\n  uniform bool brushing_enabled;\\n  uniform int brushing_target;\\n  uniform vec2 brushing_mousePos;\\n  uniform float brushing_radius;\\n\\n  #ifdef NON_INSTANCED_MODEL\\n  attribute vec2 brushingTargets;\\n  #else\\n  attribute vec2 instanceBrushingTargets;\\n  #endif\\n\\n  varying float brushing_isVisible;\\n\\n  bool brushing_isPointInRange(vec2 position) {\\n    if (!brushing_enabled) {\\n      return true;\\n    }\\n    vec2 source_commonspace = project_position(position);\\n    vec2 target_commonspace = project_position(brushing_mousePos);\\n    float distance = length((target_commonspace - source_commonspace) / project_uCommonUnitsPerMeter.xy);\\n\\n    return distance <= brushing_radius;\\n  }\\n\\n  bool brushing_arePointsInRange(vec2 sourcePos, vec2 targetPos) {\\n    return brushing_isPointInRange(sourcePos) || brushing_isPointInRange(targetPos);\\n  }\\n\\n  void brushing_setVisible(bool visible) {\\n    brushing_isVisible = float(visible);\\n  }\\n\";\nconst fs = \"\\n  uniform bool brushing_enabled;\\n  varying float brushing_isVisible;\\n\";\nconst TARGET = {\n  source: 0,\n  target: 1,\n  custom: 2,\n  source_target: 3\n};\nconst inject = {\n  'vs:DECKGL_FILTER_GL_POSITION': \"\\n    vec2 brushingTarget;\\n    vec2 brushingSource;\\n    if (brushing_target == 3) {\\n      brushingTarget = geometry.worldPositionAlt.xy;\\n      brushingSource = geometry.worldPosition.xy;\\n    } else if (brushing_target == 0) {\\n      brushingTarget = geometry.worldPosition.xy;\\n    } else if (brushing_target == 1) {\\n      brushingTarget = geometry.worldPositionAlt.xy;\\n    } else {\\n      #ifdef NON_INSTANCED_MODEL\\n      brushingTarget = brushingTargets;\\n      #else\\n      brushingTarget = instanceBrushingTargets;\\n      #endif\\n    }\\n    bool visible;\\n    if (brushing_target == 3) {\\n      visible = brushing_arePointsInRange(brushingSource, brushingTarget);\\n    } else {\\n      visible = brushing_isPointInRange(brushingTarget);\\n    }\\n    brushing_setVisible(visible);\\n  \",\n  'fs:DECKGL_FILTER_COLOR': \"\\n    if (brushing_enabled && brushing_isVisible < 0.5) {\\n      discard;\\n    }\\n  \"\n};\nexport default {\n  name: 'brushing',\n  dependencies: [project],\n  vs,\n  fs,\n  inject,\n  getUniforms: opts => {\n    if (!opts || !opts.viewport) {\n      return {};\n    }\n\n    const {\n      brushingEnabled = true,\n      brushingRadius = 10000,\n      brushingTarget = 'source',\n      mousePosition,\n      viewport\n    } = opts;\n    return {\n      brushing_enabled: Boolean(brushingEnabled && mousePosition && viewport.containsPixel(mousePosition)),\n      brushing_radius: brushingRadius,\n      brushing_target: TARGET[brushingTarget] || 0,\n      brushing_mousePos: mousePosition ? viewport.unproject([mousePosition.x - viewport.x, mousePosition.y - viewport.y]) : [0, 0]\n    };\n  }\n};","map":{"version":3,"sources":["../../../src/brushing/shader-module.js"],"names":["vs","fs","TARGET","source","target","custom","source_target","inject","name","dependencies","getUniforms","opts","brushingEnabled","brushingRadius","brushingTarget","viewport","brushing_enabled","Boolean","brushing_radius","brushing_target","brushing_mousePos","mousePosition"],"mappings":"AAmBA,SAAA,OAAA,QAAA,eAAA;AAEA,MAAMA,EAAE,GAAR,u7BAAA;AAkCA,MAAMC,EAAE,GAAR,2EAAA;AAKA,MAAMC,MAAM,GAAG;AACbC,EAAAA,MAAM,EADO,CAAA;AAEbC,EAAAA,MAAM,EAFO,CAAA;AAGbC,EAAAA,MAAM,EAHO,CAAA;AAIbC,EAAAA,aAAa,EAAE;AAJF,CAAf;AAOA,MAAMC,MAAM,GAAG;AACb,kCADa,2xBAAA;AA2Bb,4BAAA;AA3Ba,CAAf;AAkCA,eAAe;AACbC,EAAAA,IAAI,EADS,UAAA;AAEbC,EAAAA,YAAY,EAAE,CAFD,OAEC,CAFD;AAAA,EAAA,EAAA;AAAA,EAAA,EAAA;AAAA,EAAA,MAAA;AAMbC,EAAAA,WAAW,EAAEC,IAAI,IAAI;AACnB,QAAI,CAAA,IAAA,IAAS,CAACA,IAAI,CAAlB,QAAA,EAA6B;AAC3B,aAAA,EAAA;AACD;;AACD,UAAM;AACJC,MAAAA,eAAe,GADX,IAAA;AAEJC,MAAAA,cAAc,GAFV,KAAA;AAGJC,MAAAA,cAAc,GAHV,QAAA;AAAA,MAAA,aAAA;AAKJC,MAAAA;AALI,QAAN,IAAA;AAOA,WAAO;AACLC,MAAAA,gBAAgB,EAAEC,OAAO,CACvBL,eAAe,IAAfA,aAAAA,IAAoCG,QAAQ,CAARA,aAAAA,CAFjC,aAEiCA,CADb,CADpB;AAILG,MAAAA,eAAe,EAJV,cAAA;AAKLC,MAAAA,eAAe,EAAEjB,MAAM,CAANA,cAAM,CAANA,IALZ,CAAA;AAMLkB,MAAAA,iBAAiB,EAAEC,aAAa,GAC5BN,QAAQ,CAARA,SAAAA,CAAmB,CAACM,aAAa,CAAbA,CAAAA,GAAkBN,QAAQ,CAA3B,CAAA,EAA+BM,aAAa,CAAbA,CAAAA,GAAkBN,QAAQ,CADhD,CACT,CAAnBA,CAD4B,GAE5B,CAAA,CAAA,EAAA,CAAA;AARC,KAAP;AAUD;AA3BY,CAAf","sourcesContent":["// Copyright (c) 2015-2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nimport {project} from '@deck.gl/core';\n\nconst vs = `\n  uniform bool brushing_enabled;\n  uniform int brushing_target;\n  uniform vec2 brushing_mousePos;\n  uniform float brushing_radius;\n\n  #ifdef NON_INSTANCED_MODEL\n  attribute vec2 brushingTargets;\n  #else\n  attribute vec2 instanceBrushingTargets;\n  #endif\n\n  varying float brushing_isVisible;\n\n  bool brushing_isPointInRange(vec2 position) {\n    if (!brushing_enabled) {\n      return true;\n    }\n    vec2 source_commonspace = project_position(position);\n    vec2 target_commonspace = project_position(brushing_mousePos);\n    float distance = length((target_commonspace - source_commonspace) / project_uCommonUnitsPerMeter.xy);\n\n    return distance <= brushing_radius;\n  }\n\n  bool brushing_arePointsInRange(vec2 sourcePos, vec2 targetPos) {\n    return brushing_isPointInRange(sourcePos) || brushing_isPointInRange(targetPos);\n  }\n\n  void brushing_setVisible(bool visible) {\n    brushing_isVisible = float(visible);\n  }\n`;\n\nconst fs = `\n  uniform bool brushing_enabled;\n  varying float brushing_isVisible;\n`;\n\nconst TARGET = {\n  source: 0,\n  target: 1,\n  custom: 2,\n  source_target: 3\n};\n\nconst inject = {\n  'vs:DECKGL_FILTER_GL_POSITION': `\n    vec2 brushingTarget;\n    vec2 brushingSource;\n    if (brushing_target == 3) {\n      brushingTarget = geometry.worldPositionAlt.xy;\n      brushingSource = geometry.worldPosition.xy;\n    } else if (brushing_target == 0) {\n      brushingTarget = geometry.worldPosition.xy;\n    } else if (brushing_target == 1) {\n      brushingTarget = geometry.worldPositionAlt.xy;\n    } else {\n      #ifdef NON_INSTANCED_MODEL\n      brushingTarget = brushingTargets;\n      #else\n      brushingTarget = instanceBrushingTargets;\n      #endif\n    }\n    bool visible;\n    if (brushing_target == 3) {\n      visible = brushing_arePointsInRange(brushingSource, brushingTarget);\n    } else {\n      visible = brushing_isPointInRange(brushingTarget);\n    }\n    brushing_setVisible(visible);\n  `,\n\n  'fs:DECKGL_FILTER_COLOR': `\n    if (brushing_enabled && brushing_isVisible < 0.5) {\n      discard;\n    }\n  `\n};\n\nexport default {\n  name: 'brushing',\n  dependencies: [project],\n  vs,\n  fs,\n  inject,\n  getUniforms: opts => {\n    if (!opts || !opts.viewport) {\n      return {};\n    }\n    const {\n      brushingEnabled = true,\n      brushingRadius = 10000,\n      brushingTarget = 'source',\n      mousePosition,\n      viewport\n    } = opts;\n    return {\n      brushing_enabled: Boolean(\n        brushingEnabled && mousePosition && viewport.containsPixel(mousePosition)\n      ),\n      brushing_radius: brushingRadius,\n      brushing_target: TARGET[brushingTarget] || 0,\n      brushing_mousePos: mousePosition\n        ? viewport.unproject([mousePosition.x - viewport.x, mousePosition.y - viewport.y])\n        : [0, 0]\n    };\n  }\n};\n"]},"metadata":{},"sourceType":"module"}