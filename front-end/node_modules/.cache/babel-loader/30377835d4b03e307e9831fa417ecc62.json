{"ast":null,"code":"import { concatenateArrayBuffers } from '../binary-utils/array-buffer-utils';\nexport async function forEach(iterator, visitor) {\n  while (true) {\n    const {\n      done,\n      value\n    } = await iterator.next();\n\n    if (done) {\n      iterator.return();\n      return;\n    }\n\n    const cancel = visitor(value);\n\n    if (cancel) {\n      return;\n    }\n  }\n}\nexport async function concatenateArrayBuffersAsync(asyncIterator) {\n  const arrayBuffers = [];\n\n  for await (const chunk of asyncIterator) {\n    arrayBuffers.push(chunk);\n  }\n\n  return concatenateArrayBuffers(...arrayBuffers);\n}\nexport async function concatenateStringsAsync(asyncIterator) {\n  const strings = [];\n\n  for await (const chunk of asyncIterator) {\n    strings.push(chunk);\n  }\n\n  return strings.join('');\n}","map":{"version":3,"sources":["../../../../src/lib/iterators/async-iteration.ts"],"names":["value","iterator","cancel","visitor","arrayBuffers","concatenateArrayBuffers","strings"],"mappings":"AAAA,SAAA,uBAAA,QAAA,oCAAA;AAgBA,OAAO,eAAA,OAAA,CAAA,QAAA,EAAA,OAAA,EAA0C;AAE/C,SAAA,IAAA,EAAa;AACX,UAAM;AAAA,MAAA,IAAA;AAAOA,MAAAA;AAAP,QAAgB,MAAMC,QAAQ,CAApC,IAA4BA,EAA5B;;AACA,QAAA,IAAA,EAAU;AACRA,MAAAA,QAAQ,CAARA,MAAAA;AACA;AACD;;AACD,UAAMC,MAAM,GAAGC,OAAO,CAAtB,KAAsB,CAAtB;;AACA,QAAA,MAAA,EAAY;AACV;AACD;AACF;AACF;AASD,OAAO,eAAA,4BAAA,CAAA,aAAA,EAEiB;AACtB,QAAMC,YAA2B,GAAjC,EAAA;;AACA,aAAW,MAAX,KAAA,IAAA,aAAA,EAAyC;AACvCA,IAAAA,YAAY,CAAZA,IAAAA,CAAAA,KAAAA;AACD;;AACD,SAAOC,uBAAuB,CAAC,GAA/B,YAA8B,CAA9B;AACD;AAED,OAAO,eAAA,uBAAA,CAAA,aAAA,EAEY;AACjB,QAAMC,OAAiB,GAAvB,EAAA;;AACA,aAAW,MAAX,KAAA,IAAA,aAAA,EAAyC;AACvCA,IAAAA,OAAO,CAAPA,IAAAA,CAAAA,KAAAA;AACD;;AACD,SAAOA,OAAO,CAAPA,IAAAA,CAAP,EAAOA,CAAP;AACD","sourcesContent":["import {concatenateArrayBuffers} from '../binary-utils/array-buffer-utils';\n\n// GENERAL UTILITIES\n\n/**\n * Iterate over async iterator, without resetting iterator if end is not reached\n * - forEach intentionally does not reset iterator if exiting loop prematurely\n *   so that iteration can continue in a second loop\n * - It is recommended to use a standard for-await as last loop to ensure\n *   iterator gets properly reset\n *\n * TODO - optimize using sync iteration if argument is an Iterable?\n *\n * @param iterator\n * @param visitor\n */\nexport async function forEach(iterator, visitor) {\n  // eslint-disable-next-line\n  while (true) {\n    const {done, value} = await iterator.next();\n    if (done) {\n      iterator.return();\n      return;\n    }\n    const cancel = visitor(value);\n    if (cancel) {\n      return;\n    }\n  }\n}\n\n// Breaking big data into iterable chunks, concatenating iterable chunks into big data objects\n\n/**\n * Concatenates all data chunks yielded by an (async) iterator\n * This function can e.g. be used to enable atomic parsers to work on (async) iterator inputs\n */\n\nexport async function concatenateArrayBuffersAsync(\n  asyncIterator: AsyncIterable<ArrayBuffer> | Iterable<ArrayBuffer>\n): Promise<ArrayBuffer> {\n  const arrayBuffers: ArrayBuffer[] = [];\n  for await (const chunk of asyncIterator) {\n    arrayBuffers.push(chunk);\n  }\n  return concatenateArrayBuffers(...arrayBuffers);\n}\n\nexport async function concatenateStringsAsync(\n  asyncIterator: AsyncIterable<string> | Iterable<string>\n): Promise<string> {\n  const strings: string[] = [];\n  for await (const chunk of asyncIterator) {\n    strings.push(chunk);\n  }\n  return strings.join('');\n}\n"]},"metadata":{},"sourceType":"module"}