{"ast":null,"code":"import { log } from '@deck.gl/core';\nexport function getGeojsonFeatures(geojson) {\n  if (Array.isArray(geojson)) {\n    return geojson;\n  }\n\n  log.assert(geojson.type, 'GeoJSON does not have type');\n\n  switch (geojson.type) {\n    case 'Feature':\n      return [geojson];\n\n    case 'FeatureCollection':\n      log.assert(Array.isArray(geojson.features), 'GeoJSON does not have features array');\n      return geojson.features;\n\n    default:\n      return [{\n        geometry: geojson\n      }];\n  }\n}\nexport function separateGeojsonFeatures(features, wrapFeature) {\n  let dataRange = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const separated = {\n    pointFeatures: [],\n    lineFeatures: [],\n    polygonFeatures: [],\n    polygonOutlineFeatures: []\n  };\n  const {\n    startRow = 0,\n    endRow = features.length\n  } = dataRange;\n\n  for (let featureIndex = startRow; featureIndex < endRow; featureIndex++) {\n    const feature = features[featureIndex];\n    log.assert(feature && feature.geometry, 'GeoJSON does not have geometry');\n    const {\n      geometry\n    } = feature;\n\n    if (geometry.type === 'GeometryCollection') {\n      log.assert(Array.isArray(geometry.geometries), 'GeoJSON does not have geometries array');\n      const {\n        geometries\n      } = geometry;\n\n      for (let i = 0; i < geometries.length; i++) {\n        const subGeometry = geometries[i];\n        separateGeometry(subGeometry, separated, wrapFeature, feature, featureIndex);\n      }\n    } else {\n      separateGeometry(geometry, separated, wrapFeature, feature, featureIndex);\n    }\n  }\n\n  return separated;\n}\n\nfunction separateGeometry(geometry, separated, wrapFeature, sourceFeature, sourceFeatureIndex) {\n  const {\n    type,\n    coordinates\n  } = geometry;\n  const {\n    pointFeatures,\n    lineFeatures,\n    polygonFeatures,\n    polygonOutlineFeatures\n  } = separated;\n\n  if (!validateGeometry(type, coordinates)) {\n    log.warn(\"\".concat(type, \" coordinates are malformed\"))();\n    return;\n  }\n\n  switch (type) {\n    case 'Point':\n      pointFeatures.push(wrapFeature({\n        geometry\n      }, sourceFeature, sourceFeatureIndex));\n      break;\n\n    case 'MultiPoint':\n      coordinates.forEach(point => {\n        pointFeatures.push(wrapFeature({\n          geometry: {\n            type: 'Point',\n            coordinates: point\n          }\n        }, sourceFeature, sourceFeatureIndex));\n      });\n      break;\n\n    case 'LineString':\n      lineFeatures.push(wrapFeature({\n        geometry\n      }, sourceFeature, sourceFeatureIndex));\n      break;\n\n    case 'MultiLineString':\n      coordinates.forEach(path => {\n        lineFeatures.push(wrapFeature({\n          geometry: {\n            type: 'LineString',\n            coordinates: path\n          }\n        }, sourceFeature, sourceFeatureIndex));\n      });\n      break;\n\n    case 'Polygon':\n      polygonFeatures.push(wrapFeature({\n        geometry\n      }, sourceFeature, sourceFeatureIndex));\n      coordinates.forEach(path => {\n        polygonOutlineFeatures.push(wrapFeature({\n          geometry: {\n            type: 'LineString',\n            coordinates: path\n          }\n        }, sourceFeature, sourceFeatureIndex));\n      });\n      break;\n\n    case 'MultiPolygon':\n      coordinates.forEach(polygon => {\n        polygonFeatures.push(wrapFeature({\n          geometry: {\n            type: 'Polygon',\n            coordinates: polygon\n          }\n        }, sourceFeature, sourceFeatureIndex));\n        polygon.forEach(path => {\n          polygonOutlineFeatures.push(wrapFeature({\n            geometry: {\n              type: 'LineString',\n              coordinates: path\n            }\n          }, sourceFeature, sourceFeatureIndex));\n        });\n      });\n      break;\n\n    default:\n  }\n}\n\nconst COORDINATE_NEST_LEVEL = {\n  Point: 1,\n  MultiPoint: 2,\n  LineString: 2,\n  MultiLineString: 3,\n  Polygon: 3,\n  MultiPolygon: 4\n};\nexport function validateGeometry(type, coordinates) {\n  let nestLevel = COORDINATE_NEST_LEVEL[type];\n  log.assert(nestLevel, \"Unknown GeoJSON type \".concat(type));\n\n  while (coordinates && --nestLevel > 0) {\n    coordinates = coordinates[0];\n  }\n\n  return coordinates && Number.isFinite(coordinates[0]);\n}","map":{"version":3,"sources":["../../../src/geojson-layer/geojson.js"],"names":["Array","log","geojson","geometry","dataRange","separated","pointFeatures","lineFeatures","polygonFeatures","polygonOutlineFeatures","startRow","endRow","features","length","featureIndex","feature","geometries","i","subGeometry","separateGeometry","coordinates","validateGeometry","wrapFeature","point","type","path","polygon","COORDINATE_NEST_LEVEL","Point","MultiPoint","LineString","MultiLineString","Polygon","MultiPolygon","nestLevel","Number"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nimport {log} from '@deck.gl/core';\n\n/**\n * \"Normalizes\" complete or partial GeoJSON data into iterable list of features\n * Can accept GeoJSON geometry or \"Feature\", \"FeatureCollection\" in addition\n * to plain arrays and iterables.\n * Works by extracting the feature array or wrapping single objects in an array,\n * so that subsequent code can simply iterate over features.\n *\n * @param {object} geojson - geojson data\n * @param {Object|Array} data - geojson object (FeatureCollection, Feature or\n *  Geometry) or array of features\n * @return {Array|\"iteratable\"} - iterable list of features\n */\nexport function getGeojsonFeatures(geojson) {\n  // If array, assume this is a list of features\n  if (Array.isArray(geojson)) {\n    return geojson;\n  }\n\n  log.assert(geojson.type, 'GeoJSON does not have type');\n\n  switch (geojson.type) {\n    case 'Feature':\n      // Wrap the feature in a 'Features' array\n      return [geojson];\n    case 'FeatureCollection':\n      // Just return the 'Features' array from the collection\n      log.assert(Array.isArray(geojson.features), 'GeoJSON does not have features array');\n      return geojson.features;\n    default:\n      // Assume it's a geometry, we'll check type in separateGeojsonFeatures\n      // Wrap the geometry object in a 'Feature' object and wrap in an array\n      return [{geometry: geojson}];\n  }\n}\n\n// Linearize\nexport function separateGeojsonFeatures(features, wrapFeature, dataRange = {}) {\n  const separated = {\n    pointFeatures: [],\n    lineFeatures: [],\n    polygonFeatures: [],\n    polygonOutlineFeatures: []\n  };\n  const {startRow = 0, endRow = features.length} = dataRange;\n\n  for (let featureIndex = startRow; featureIndex < endRow; featureIndex++) {\n    const feature = features[featureIndex];\n\n    log.assert(feature && feature.geometry, 'GeoJSON does not have geometry');\n\n    const {geometry} = feature;\n\n    if (geometry.type === 'GeometryCollection') {\n      log.assert(Array.isArray(geometry.geometries), 'GeoJSON does not have geometries array');\n      const {geometries} = geometry;\n      for (let i = 0; i < geometries.length; i++) {\n        const subGeometry = geometries[i];\n        separateGeometry(subGeometry, separated, wrapFeature, feature, featureIndex);\n      }\n    } else {\n      separateGeometry(geometry, separated, wrapFeature, feature, featureIndex);\n    }\n  }\n\n  return separated;\n}\n\nfunction separateGeometry(geometry, separated, wrapFeature, sourceFeature, sourceFeatureIndex) {\n  const {type, coordinates} = geometry;\n  const {pointFeatures, lineFeatures, polygonFeatures, polygonOutlineFeatures} = separated;\n\n  if (!validateGeometry(type, coordinates)) {\n    // Avoid hard failure if some features are malformed\n    log.warn(`${type} coordinates are malformed`)();\n    return;\n  }\n\n  // Split each feature, but keep track of the source feature and index (for Multi* geometries)\n  switch (type) {\n    case 'Point':\n      pointFeatures.push(\n        wrapFeature(\n          {\n            geometry\n          },\n          sourceFeature,\n          sourceFeatureIndex\n        )\n      );\n      break;\n    case 'MultiPoint':\n      coordinates.forEach(point => {\n        pointFeatures.push(\n          wrapFeature(\n            {\n              geometry: {type: 'Point', coordinates: point}\n            },\n            sourceFeature,\n            sourceFeatureIndex\n          )\n        );\n      });\n      break;\n    case 'LineString':\n      lineFeatures.push(\n        wrapFeature(\n          {\n            geometry\n          },\n          sourceFeature,\n          sourceFeatureIndex\n        )\n      );\n      break;\n    case 'MultiLineString':\n      // Break multilinestrings into multiple lines\n      coordinates.forEach(path => {\n        lineFeatures.push(\n          wrapFeature(\n            {\n              geometry: {type: 'LineString', coordinates: path}\n            },\n            sourceFeature,\n            sourceFeatureIndex\n          )\n        );\n      });\n      break;\n    case 'Polygon':\n      polygonFeatures.push(\n        wrapFeature(\n          {\n            geometry\n          },\n          sourceFeature,\n          sourceFeatureIndex\n        )\n      );\n      // Break polygon into multiple lines\n      coordinates.forEach(path => {\n        polygonOutlineFeatures.push(\n          wrapFeature(\n            {\n              geometry: {type: 'LineString', coordinates: path}\n            },\n            sourceFeature,\n            sourceFeatureIndex\n          )\n        );\n      });\n      break;\n    case 'MultiPolygon':\n      // Break multipolygons into multiple polygons\n      coordinates.forEach(polygon => {\n        polygonFeatures.push(\n          wrapFeature(\n            {\n              geometry: {type: 'Polygon', coordinates: polygon}\n            },\n            sourceFeature,\n            sourceFeatureIndex\n          )\n        );\n        // Break polygon into multiple lines\n        polygon.forEach(path => {\n          polygonOutlineFeatures.push(\n            wrapFeature(\n              {\n                geometry: {type: 'LineString', coordinates: path}\n              },\n              sourceFeature,\n              sourceFeatureIndex\n            )\n          );\n        });\n      });\n      break;\n    default:\n  }\n}\n\n/**\n * Simple GeoJSON validation util. For perf reasons we do not validate against the full spec,\n * only the following:\n   - geometry.type is supported\n   - geometry.coordinate has correct nesting level\n */\nconst COORDINATE_NEST_LEVEL = {\n  Point: 1,\n  MultiPoint: 2,\n  LineString: 2,\n  MultiLineString: 3,\n  Polygon: 3,\n  MultiPolygon: 4\n};\n\nexport function validateGeometry(type, coordinates) {\n  let nestLevel = COORDINATE_NEST_LEVEL[type];\n\n  log.assert(nestLevel, `Unknown GeoJSON type ${type}`);\n\n  while (coordinates && --nestLevel > 0) {\n    coordinates = coordinates[0];\n  }\n\n  return coordinates && Number.isFinite(coordinates[0]);\n}\n"]},"metadata":{},"sourceType":"module"}