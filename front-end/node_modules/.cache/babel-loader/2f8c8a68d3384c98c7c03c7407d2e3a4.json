{"ast":null,"code":"const DEFAULT_CHUNK_SIZE = 256 * 1024;\nexport function* makeStringIterator(string, options) {\n  const chunkSize = (options === null || options === void 0 ? void 0 : options.chunkSize) || DEFAULT_CHUNK_SIZE;\n  let offset = 0;\n  const textEncoder = new TextEncoder();\n\n  while (offset < string.length) {\n    const chunkLength = Math.min(string.length - offset, chunkSize);\n    const chunk = string.slice(offset, offset + chunkLength);\n    offset += chunkLength;\n    yield textEncoder.encode(chunk);\n  }\n}","map":{"version":3,"sources":["../../../../src/iterators/make-iterator/make-string-iterator.ts"],"names":["DEFAULT_CHUNK_SIZE","chunkSize","offset","textEncoder","string","chunkLength","Math","chunk"],"mappings":"AAEA,MAAMA,kBAAkB,GAAG,MAA3B,IAAA;AAQA,OAAO,UAAA,kBAAA,CAAA,MAAA,EAAA,OAAA,EAGkB;AACvB,QAAMC,SAAS,GAAG,CAAA,OAAO,KAAP,IAAA,IAAA,OAAO,KAAA,KAAP,CAAA,GAAA,KAAA,CAAA,GAAA,OAAO,CAAP,SAAA,KAAlB,kBAAA;AAEA,MAAIC,MAAM,GAAV,CAAA;AACA,QAAMC,WAAW,GAAG,IAApB,WAAoB,EAApB;;AACA,SAAOD,MAAM,GAAGE,MAAM,CAAtB,MAAA,EAA+B;AAE7B,UAAMC,WAAW,GAAGC,IAAI,CAAJA,GAAAA,CAASF,MAAM,CAANA,MAAAA,GAATE,MAAAA,EAApB,SAAoBA,CAApB;AACA,UAAMC,KAAK,GAAGH,MAAM,CAANA,KAAAA,CAAAA,MAAAA,EAAqBF,MAAM,GAAzC,WAAcE,CAAd;AACAF,IAAAA,MAAM,IAANA,WAAAA;AAGA,UAAMC,WAAW,CAAXA,MAAAA,CAAN,KAAMA,CAAN;AACD;AACF","sourcesContent":["import type {IteratorOptions} from './make-iterator';\n\nconst DEFAULT_CHUNK_SIZE = 256 * 1024;\n\n/**\n * Returns an iterator that breaks a big string into chunks and yields them one-by-one as ArrayBuffers\n * @param blob string to iterate over\n * @param options\n * @param options.chunkSize\n */\nexport function* makeStringIterator(\n  string: string,\n  options?: IteratorOptions\n): Iterable<ArrayBuffer> {\n  const chunkSize = options?.chunkSize || DEFAULT_CHUNK_SIZE;\n\n  let offset = 0;\n  const textEncoder = new TextEncoder();\n  while (offset < string.length) {\n    // Create a chunk of the right size\n    const chunkLength = Math.min(string.length - offset, chunkSize);\n    const chunk = string.slice(offset, offset + chunkLength);\n    offset += chunkLength;\n\n    // yield an ArrayBuffer chunk\n    yield textEncoder.encode(chunk);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}