{"ast":null,"code":"import { getOSMTileIndices } from './tile-2d-traversal';\nconst TILE_SIZE = 512;\nconst DEFAULT_EXTENT = [-Infinity, -Infinity, Infinity, Infinity];\nexport const urlType = {\n  type: 'url',\n  value: null,\n  validate: (value, propType) => propType.optional && value === null || typeof value === 'string' || Array.isArray(value) && value.every(url => typeof url === 'string'),\n  equals: (value1, value2) => {\n    if (value1 === value2) {\n      return true;\n    }\n\n    if (!Array.isArray(value1) || !Array.isArray(value2)) {\n      return false;\n    }\n\n    const len = value1.length;\n\n    if (len !== value2.length) {\n      return false;\n    }\n\n    for (let i = 0; i < len; i++) {\n      if (value1[i] !== value2[i]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n};\n\nfunction transformBox(bbox, modelMatrix) {\n  const transformedCoords = [modelMatrix.transformPoint([bbox[0], bbox[1]]), modelMatrix.transformPoint([bbox[2], bbox[1]]), modelMatrix.transformPoint([bbox[0], bbox[3]]), modelMatrix.transformPoint([bbox[2], bbox[3]])];\n  const transformedBox = [Math.min(...transformedCoords.map(i => i[0])), Math.min(...transformedCoords.map(i => i[1])), Math.max(...transformedCoords.map(i => i[0])), Math.max(...transformedCoords.map(i => i[1]))];\n  return transformedBox;\n}\n\nexport function getURLFromTemplate(template, properties) {\n  if (!template || !template.length) {\n    return null;\n  }\n\n  if (Array.isArray(template)) {\n    const index = Math.abs(properties.x + properties.y) % template.length;\n    template = template[index];\n  }\n\n  const {\n    x,\n    y,\n    z\n  } = properties;\n  return template.replace('{x}', x).replace('{y}', y).replace('{z}', z).replace('{-y}', Math.pow(2, z) - y - 1);\n}\n\nfunction getBoundingBox(viewport, zRange, extent) {\n  let bounds;\n\n  if (zRange && zRange.length === 2) {\n    const [minZ, maxZ] = zRange;\n    const bounds0 = viewport.getBounds({\n      z: minZ\n    });\n    const bounds1 = viewport.getBounds({\n      z: maxZ\n    });\n    bounds = [Math.min(bounds0[0], bounds1[0]), Math.min(bounds0[1], bounds1[1]), Math.max(bounds0[2], bounds1[2]), Math.max(bounds0[3], bounds1[3])];\n  } else {\n    bounds = viewport.getBounds();\n  }\n\n  if (!viewport.isGeospatial) {\n    return [Math.max(Math.min(bounds[0], extent[2]), extent[0]), Math.max(Math.min(bounds[1], extent[3]), extent[1]), Math.min(Math.max(bounds[2], extent[0]), extent[2]), Math.min(Math.max(bounds[3], extent[1]), extent[3])];\n  }\n\n  return [Math.max(bounds[0], extent[0]), Math.max(bounds[1], extent[1]), Math.min(bounds[2], extent[2]), Math.min(bounds[3], extent[3])];\n}\n\nfunction getIndexingCoords(bbox, scale, modelMatrixInverse) {\n  if (modelMatrixInverse) {\n    const transformedTileIndex = transformBox(bbox, modelMatrixInverse).map(i => i * scale / TILE_SIZE);\n    return transformedTileIndex;\n  }\n\n  return bbox.map(i => i * scale / TILE_SIZE);\n}\n\nfunction getScale(z, tileSize) {\n  return Math.pow(2, z) * TILE_SIZE / tileSize;\n}\n\nexport function osmTile2lngLat(x, y, z) {\n  const scale = getScale(z, TILE_SIZE);\n  const lng = x / scale * 360 - 180;\n  const n = Math.PI - 2 * Math.PI * y / scale;\n  const lat = 180 / Math.PI * Math.atan(0.5 * (Math.exp(n) - Math.exp(-n)));\n  return [lng, lat];\n}\n\nfunction tile2XY(x, y, z, tileSize) {\n  const scale = getScale(z, tileSize);\n  return [x / scale * TILE_SIZE, y / scale * TILE_SIZE];\n}\n\nexport function tileToBoundingBox(viewport, x, y, z) {\n  let tileSize = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : TILE_SIZE;\n\n  if (viewport.isGeospatial) {\n    const [west, north] = osmTile2lngLat(x, y, z);\n    const [east, south] = osmTile2lngLat(x + 1, y + 1, z);\n    return {\n      west,\n      north,\n      east,\n      south\n    };\n  }\n\n  const [left, top] = tile2XY(x, y, z, tileSize);\n  const [right, bottom] = tile2XY(x + 1, y + 1, z, tileSize);\n  return {\n    left,\n    top,\n    right,\n    bottom\n  };\n}\n\nfunction getIdentityTileIndices(viewport, z, tileSize, extent, modelMatrixInverse) {\n  const bbox = getBoundingBox(viewport, null, extent);\n  const scale = getScale(z, tileSize);\n  const [minX, minY, maxX, maxY] = getIndexingCoords(bbox, scale, modelMatrixInverse);\n  const indices = [];\n\n  for (let x = Math.floor(minX); x < maxX; x++) {\n    for (let y = Math.floor(minY); y < maxY; y++) {\n      indices.push({\n        x,\n        y,\n        z\n      });\n    }\n  }\n\n  return indices;\n}\n\nexport function getTileIndices(_ref) {\n  let {\n    viewport,\n    maxZoom,\n    minZoom,\n    zRange,\n    extent,\n    tileSize = TILE_SIZE,\n    modelMatrix,\n    modelMatrixInverse,\n    zoomOffset = 0\n  } = _ref;\n  let z = viewport.isGeospatial ? Math.round(viewport.zoom + Math.log2(TILE_SIZE / tileSize)) + zoomOffset : Math.ceil(viewport.zoom) + zoomOffset;\n\n  if (Number.isFinite(minZoom) && z < minZoom) {\n    if (!extent) {\n      return [];\n    }\n\n    z = minZoom;\n  }\n\n  if (Number.isFinite(maxZoom) && z > maxZoom) {\n    z = maxZoom;\n  }\n\n  let transformedExtent = extent;\n\n  if (modelMatrix && modelMatrixInverse && extent && !viewport.isGeospatial) {\n    transformedExtent = transformBox(extent, modelMatrix);\n  }\n\n  return viewport.isGeospatial ? getOSMTileIndices(viewport, z, zRange, extent) : getIdentityTileIndices(viewport, z, tileSize, transformedExtent || DEFAULT_EXTENT, modelMatrixInverse);\n}\nexport function isURLTemplate(s) {\n  return /(?=.*{z})(?=.*{x})(?=.*({y}|{-y}))/.test(s);\n}","map":{"version":3,"sources":["../../../src/tile-layer/utils.js"],"names":["TILE_SIZE","DEFAULT_EXTENT","urlType","type","value","validate","propType","Array","url","equals","value1","len","value2","i","transformedCoords","modelMatrix","bbox","transformedBox","Math","template","index","properties","z","zRange","bounds0","minZ","bounds1","maxZ","bounds","viewport","extent","transformedTileIndex","transformBox","scale","getScale","lng","x","n","lat","y","tileSize","osmTile2lngLat","south","tile2XY","bottom","getBoundingBox","getIndexingCoords","indices","zoomOffset","Number","transformedExtent","getOSMTileIndices","getIdentityTileIndices"],"mappings":"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","sourcesContent":["import {getOSMTileIndices} from './tile-2d-traversal';\n\nconst TILE_SIZE = 512;\nconst DEFAULT_EXTENT = [-Infinity, -Infinity, Infinity, Infinity];\n\nexport const urlType = {\n  type: 'url',\n  value: null,\n  validate: (value, propType) =>\n    (propType.optional && value === null) ||\n    typeof value === 'string' ||\n    (Array.isArray(value) && value.every(url => typeof url === 'string')),\n  equals: (value1, value2) => {\n    if (value1 === value2) {\n      return true;\n    }\n    if (!Array.isArray(value1) || !Array.isArray(value2)) {\n      return false;\n    }\n    const len = value1.length;\n    if (len !== value2.length) {\n      return false;\n    }\n    for (let i = 0; i < len; i++) {\n      if (value1[i] !== value2[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n};\n\nfunction transformBox(bbox, modelMatrix) {\n  const transformedCoords = [\n    // top-left\n    modelMatrix.transformPoint([bbox[0], bbox[1]]),\n    // top-right\n    modelMatrix.transformPoint([bbox[2], bbox[1]]),\n    // bottom-left\n    modelMatrix.transformPoint([bbox[0], bbox[3]]),\n    // bottom-right\n    modelMatrix.transformPoint([bbox[2], bbox[3]])\n  ];\n  const transformedBox = [\n    // Minimum x coord\n    Math.min(...transformedCoords.map(i => i[0])),\n    // Minimum y coord\n    Math.min(...transformedCoords.map(i => i[1])),\n    // Max x coord\n    Math.max(...transformedCoords.map(i => i[0])),\n    // Max y coord\n    Math.max(...transformedCoords.map(i => i[1]))\n  ];\n  return transformedBox;\n}\n\nexport function getURLFromTemplate(template, properties) {\n  if (!template || !template.length) {\n    return null;\n  }\n  if (Array.isArray(template)) {\n    const index = Math.abs(properties.x + properties.y) % template.length;\n    template = template[index];\n  }\n\n  const {x, y, z} = properties;\n  return template\n    .replace('{x}', x)\n    .replace('{y}', y)\n    .replace('{z}', z)\n    .replace('{-y}', Math.pow(2, z) - y - 1);\n}\n\n/**\n * gets the bounding box of a viewport\n */\nfunction getBoundingBox(viewport, zRange, extent) {\n  let bounds;\n  if (zRange && zRange.length === 2) {\n    const [minZ, maxZ] = zRange;\n    const bounds0 = viewport.getBounds({z: minZ});\n    const bounds1 = viewport.getBounds({z: maxZ});\n    bounds = [\n      Math.min(bounds0[0], bounds1[0]),\n      Math.min(bounds0[1], bounds1[1]),\n      Math.max(bounds0[2], bounds1[2]),\n      Math.max(bounds0[3], bounds1[3])\n    ];\n  } else {\n    bounds = viewport.getBounds();\n  }\n  if (!viewport.isGeospatial) {\n    return [\n      // Top corner should not be more then bottom corner in either direction\n      Math.max(Math.min(bounds[0], extent[2]), extent[0]),\n      Math.max(Math.min(bounds[1], extent[3]), extent[1]),\n      // Bottom corner should not be less then top corner in either direction\n      Math.min(Math.max(bounds[2], extent[0]), extent[2]),\n      Math.min(Math.max(bounds[3], extent[1]), extent[3])\n    ];\n  }\n  return [\n    Math.max(bounds[0], extent[0]),\n    Math.max(bounds[1], extent[1]),\n    Math.min(bounds[2], extent[2]),\n    Math.min(bounds[3], extent[3])\n  ];\n}\n\nfunction getIndexingCoords(bbox, scale, modelMatrixInverse) {\n  if (modelMatrixInverse) {\n    const transformedTileIndex = transformBox(bbox, modelMatrixInverse).map(\n      i => (i * scale) / TILE_SIZE\n    );\n    return transformedTileIndex;\n  }\n  return bbox.map(i => (i * scale) / TILE_SIZE);\n}\n\nfunction getScale(z, tileSize) {\n  return (Math.pow(2, z) * TILE_SIZE) / tileSize;\n}\n\n// https://wiki.openstreetmap.org/wiki/Slippy_map_tilenames#Lon..2Flat._to_tile_numbers_2\nexport function osmTile2lngLat(x, y, z) {\n  const scale = getScale(z, TILE_SIZE);\n  const lng = (x / scale) * 360 - 180;\n  const n = Math.PI - (2 * Math.PI * y) / scale;\n  const lat = (180 / Math.PI) * Math.atan(0.5 * (Math.exp(n) - Math.exp(-n)));\n  return [lng, lat];\n}\n\nfunction tile2XY(x, y, z, tileSize) {\n  const scale = getScale(z, tileSize);\n  return [(x / scale) * TILE_SIZE, (y / scale) * TILE_SIZE];\n}\nexport function tileToBoundingBox(viewport, x, y, z, tileSize = TILE_SIZE) {\n  if (viewport.isGeospatial) {\n    const [west, north] = osmTile2lngLat(x, y, z);\n    const [east, south] = osmTile2lngLat(x + 1, y + 1, z);\n    return {west, north, east, south};\n  }\n  const [left, top] = tile2XY(x, y, z, tileSize);\n  const [right, bottom] = tile2XY(x + 1, y + 1, z, tileSize);\n  return {left, top, right, bottom};\n}\n\nfunction getIdentityTileIndices(viewport, z, tileSize, extent, modelMatrixInverse) {\n  const bbox = getBoundingBox(viewport, null, extent);\n  const scale = getScale(z, tileSize);\n  const [minX, minY, maxX, maxY] = getIndexingCoords(bbox, scale, modelMatrixInverse);\n  const indices = [];\n\n  /*\n      |  TILE  |  TILE  |  TILE  |\n        |(minX)            |(maxX)\n   */\n  for (let x = Math.floor(minX); x < maxX; x++) {\n    for (let y = Math.floor(minY); y < maxY; y++) {\n      indices.push({x, y, z});\n    }\n  }\n  return indices;\n}\n\n/**\n * Returns all tile indices in the current viewport. If the current zoom level is smaller\n * than minZoom, return an empty array. If the current zoom level is greater than maxZoom,\n * return tiles that are on maxZoom.\n */\n// eslint-disable-next-line complexity\nexport function getTileIndices({\n  viewport,\n  maxZoom,\n  minZoom,\n  zRange,\n  extent,\n  tileSize = TILE_SIZE,\n  modelMatrix,\n  modelMatrixInverse,\n  zoomOffset = 0\n}) {\n  let z = viewport.isGeospatial\n    ? Math.round(viewport.zoom + Math.log2(TILE_SIZE / tileSize)) + zoomOffset\n    : Math.ceil(viewport.zoom) + zoomOffset;\n  if (Number.isFinite(minZoom) && z < minZoom) {\n    if (!extent) {\n      return [];\n    }\n    z = minZoom;\n  }\n  if (Number.isFinite(maxZoom) && z > maxZoom) {\n    z = maxZoom;\n  }\n  let transformedExtent = extent;\n  if (modelMatrix && modelMatrixInverse && extent && !viewport.isGeospatial) {\n    transformedExtent = transformBox(extent, modelMatrix);\n  }\n  return viewport.isGeospatial\n    ? getOSMTileIndices(viewport, z, zRange, extent)\n    : getIdentityTileIndices(\n        viewport,\n        z,\n        tileSize,\n        transformedExtent || DEFAULT_EXTENT,\n        modelMatrixInverse\n      );\n}\n\n/**\n * Returns true if s is a valid URL template\n */\nexport function isURLTemplate(s) {\n  return /(?=.*{z})(?=.*{x})(?=.*({y}|{-y}))/.test(s);\n}\n"]},"metadata":{},"sourceType":"module"}