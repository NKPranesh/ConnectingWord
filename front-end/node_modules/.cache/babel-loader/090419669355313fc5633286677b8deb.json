{"ast":null,"code":"import { Vector3 } from '@math.gl/core';\nimport { GL, octDecode } from '@loaders.gl/math';\nconst scratchNormal = new Vector3();\nexport function normalize3DTileNormalAttribute(tile, normals) {\n  if (!normals) {\n    return null;\n  }\n\n  if (tile.isOctEncoded16P) {\n    const decodedArray = new Float32Array(tile.pointsLength * 3);\n\n    for (let i = 0; i < tile.pointsLength; i++) {\n      octDecode(normals[i * 2], normals[i * 2 + 1], scratchNormal);\n      scratchNormal.toArray(decodedArray, i * 3);\n    }\n\n    return {\n      type: GL.FLOAT,\n      size: 2,\n      value: decodedArray\n    };\n  }\n\n  return {\n    type: GL.FLOAT,\n    size: 2,\n    value: normals\n  };\n}","map":{"version":3,"sources":["../../../../../src/lib/parsers/helpers/normalize-3d-tile-normals.js"],"names":["scratchNormal","tile","decodedArray","i","octDecode","normals","type","GL","size","value"],"mappings":"AAAA,SAAA,OAAA,QAAA,eAAA;AACA,SAAA,EAAA,EAAA,SAAA,QAAA,kBAAA;AAEA,MAAMA,aAAa,GAAG,IAAtB,OAAsB,EAAtB;AAEA,OAAO,SAAA,8BAAA,CAAA,IAAA,EAAA,OAAA,EAAuD;AAC5D,MAAI,CAAJ,OAAA,EAAc;AACZ,WAAA,IAAA;AACD;;AAED,MAAIC,IAAI,CAAR,eAAA,EAA0B;AACxB,UAAMC,YAAY,GAAG,IAAA,YAAA,CAAiBD,IAAI,CAAJA,YAAAA,GAAtC,CAAqB,CAArB;;AACA,SAAK,IAAIE,CAAC,GAAV,CAAA,EAAgBA,CAAC,GAAGF,IAAI,CAAxB,YAAA,EAAuCE,CAAvC,EAAA,EAA4C;AAC1CC,MAAAA,SAAS,CAACC,OAAO,CAACF,CAAC,GAAV,CAAQ,CAAR,EAAiBE,OAAO,CAACF,CAAC,GAADA,CAAAA,GAAzB,CAAwB,CAAxB,EAATC,aAAS,CAATA;AAEAJ,MAAAA,aAAa,CAAbA,OAAAA,CAAAA,YAAAA,EAAoCG,CAAC,GAArCH,CAAAA;AACD;;AAED,WAAO;AACLM,MAAAA,IAAI,EAAEC,EAAE,CADH,KAAA;AAELC,MAAAA,IAAI,EAFC,CAAA;AAGLC,MAAAA,KAAK,EAAEP;AAHF,KAAP;AAKD;;AAED,SAAO;AACLI,IAAAA,IAAI,EAAEC,EAAE,CADH,KAAA;AAELC,IAAAA,IAAI,EAFC,CAAA;AAGLC,IAAAA,KAAK,EAAEJ;AAHF,GAAP;AAKD","sourcesContent":["import {Vector3} from '@math.gl/core';\nimport {GL, octDecode} from '@loaders.gl/math';\n\nconst scratchNormal = new Vector3();\n\nexport function normalize3DTileNormalAttribute(tile, normals) {\n  if (!normals) {\n    return null;\n  }\n\n  if (tile.isOctEncoded16P) {\n    const decodedArray = new Float32Array(tile.pointsLength * 3);\n    for (let i = 0; i < tile.pointsLength; i++) {\n      octDecode(normals[i * 2], normals[i * 2 + 1], scratchNormal);\n      // @ts-ignore\n      scratchNormal.toArray(decodedArray, i * 3);\n    }\n\n    return {\n      type: GL.FLOAT,\n      size: 2,\n      value: decodedArray\n    };\n  }\n\n  return {\n    type: GL.FLOAT,\n    size: 2,\n    value: normals\n  };\n}\n"]},"metadata":{},"sourceType":"module"}