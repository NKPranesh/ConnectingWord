{"ast":null,"code":"export async function* makeTextDecoderIterator(arrayBufferIterator) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const textDecoder = new TextDecoder(undefined, options);\n\n  for await (const arrayBuffer of arrayBufferIterator) {\n    yield typeof arrayBuffer === 'string' ? arrayBuffer : textDecoder.decode(arrayBuffer, {\n      stream: true\n    });\n  }\n}\nexport async function* makeTextEncoderIterator(textIterator) {\n  const textEncoder = new TextEncoder();\n\n  for await (const text of textIterator) {\n    yield typeof text === 'string' ? textEncoder.encode(text) : text;\n  }\n}\nexport async function* makeLineIterator(textIterator) {\n  let previous = '';\n\n  for await (const textChunk of textIterator) {\n    previous += textChunk;\n    let eolIndex;\n\n    while ((eolIndex = previous.indexOf('\\n')) >= 0) {\n      const line = previous.slice(0, eolIndex + 1);\n      previous = previous.slice(eolIndex + 1);\n      yield line;\n    }\n  }\n\n  if (previous.length > 0) {\n    yield previous;\n  }\n}\nexport async function* makeNumberedLineIterator(lineIterator) {\n  let counter = 1;\n\n  for await (const line of lineIterator) {\n    yield {\n      counter,\n      line\n    };\n    counter++;\n  }\n}","map":{"version":3,"sources":["../../../../src/lib/iterators/text-iterators.ts"],"names":["options","textDecoder","stream","textEncoder","previous","eolIndex","line","counter"],"mappings":"AAGA,OAAO,gBAAA,uBAAA,CAAA,mBAAA,EAGkB;AAAA,MADvBA,OACuB,uEAHlB,EAGkB;AACvB,QAAMC,WAAW,GAAG,IAAA,WAAA,CAAA,SAAA,EAApB,OAAoB,CAApB;;AACA,aAAW,MAAX,WAAA,IAAA,mBAAA,EAAqD;AACnD,UAAM,OAAA,WAAA,KAAA,QAAA,GAAA,WAAA,GAEF,WAAW,CAAX,MAAA,CAAA,WAAA,EAAgC;AAACC,MAAAA,MAAM,EAAE;AAAT,KAAhC,CAFJ;AAGD;AACF;AAOD,OAAO,gBAAA,uBAAA,CAAA,YAAA,EAEuB;AAC5B,QAAMC,WAAW,GAAG,IAApB,WAAoB,EAApB;;AACA,aAAW,MAAX,IAAA,IAAA,YAAA,EAAuC;AACrC,UAAM,OAAA,IAAA,KAAA,QAAA,GAA2BA,WAAW,CAAXA,MAAAA,CAA3B,IAA2BA,CAA3B,GAAN,IAAA;AACD;AACF;AAQD,OAAO,gBAAA,gBAAA,CAAA,YAAA,EAEkB;AACvB,MAAIC,QAAQ,GAAZ,EAAA;;AACA,aAAW,MAAX,SAAA,IAAA,YAAA,EAA4C;AAC1CA,IAAAA,QAAQ,IAARA,SAAAA;AACA,QAAA,QAAA;;AACA,WAAO,CAACC,QAAQ,GAAGD,QAAQ,CAARA,OAAAA,CAAZ,IAAYA,CAAZ,KAAP,CAAA,EAAiD;AAE/C,YAAME,IAAI,GAAGF,QAAQ,CAARA,KAAAA,CAAAA,CAAAA,EAAkBC,QAAQ,GAAvC,CAAaD,CAAb;AACAA,MAAAA,QAAQ,GAAGA,QAAQ,CAARA,KAAAA,CAAeC,QAAQ,GAAlCD,CAAWA,CAAXA;AACA,YAAA,IAAA;AACD;AACF;;AAED,MAAIA,QAAQ,CAARA,MAAAA,GAAJ,CAAA,EAAyB;AACvB,UAAA,QAAA;AACD;AACF;AAQD,OAAO,gBAAA,wBAAA,CAAA,YAAA,EAE2C;AAChD,MAAIG,OAAO,GAAX,CAAA;;AACA,aAAW,MAAX,IAAA,IAAA,YAAA,EAAuC;AACrC,UAAM;AAAA,MAAA,OAAA;AAAUD,MAAAA;AAAV,KAAN;AACAC,IAAAA,OAAO;AACR;AACF","sourcesContent":["// TextDecoder iterators\n// TextDecoder will keep any partial undecoded bytes between calls to `decode`\n\nexport async function* makeTextDecoderIterator(\n  arrayBufferIterator: AsyncIterable<ArrayBuffer> | Iterable<ArrayBuffer>,\n  options: TextDecoderOptions = {}\n): AsyncIterable<string> {\n  const textDecoder = new TextDecoder(undefined, options);\n  for await (const arrayBuffer of arrayBufferIterator) {\n    yield typeof arrayBuffer === 'string'\n      ? arrayBuffer\n      : textDecoder.decode(arrayBuffer, {stream: true});\n  }\n}\n\n// TextEncoder iterator\n// TODO - this is not useful unless min chunk size is given\n// TextEncoder will keep any partial undecoded bytes between calls to `encode`\n// If iterator does not yield strings, assume arrayBuffer and return unencoded\n\nexport async function* makeTextEncoderIterator(\n  textIterator: AsyncIterable<string> | Iterable<ArrayBuffer>\n): AsyncIterable<ArrayBuffer> {\n  const textEncoder = new TextEncoder();\n  for await (const text of textIterator) {\n    yield typeof text === 'string' ? textEncoder.encode(text) : text;\n  }\n}\n\n/**\n * @param textIterator async iterable yielding strings\n * @returns an async iterable over lines\n * See http://2ality.com/2018/04/async-iter-nodejs.html\n */\n\nexport async function* makeLineIterator(\n  textIterator: AsyncIterable<string>\n): AsyncIterable<string> {\n  let previous = '';\n  for await (const textChunk of textIterator) {\n    previous += textChunk;\n    let eolIndex;\n    while ((eolIndex = previous.indexOf('\\n')) >= 0) {\n      // line includes the EOL\n      const line = previous.slice(0, eolIndex + 1);\n      previous = previous.slice(eolIndex + 1);\n      yield line;\n    }\n  }\n\n  if (previous.length > 0) {\n    yield previous;\n  }\n}\n\n/**\n * @param lineIterator async iterable yielding lines\n * @returns async iterable yielding numbered lines\n *\n * See http://2ality.com/2018/04/async-iter-nodejs.html\n */\nexport async function* makeNumberedLineIterator(\n  lineIterator: AsyncIterable<string>\n): AsyncIterable<{counter: number; line: string}> {\n  let counter = 1;\n  for await (const line of lineIterator) {\n    yield {counter, line};\n    counter++;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}