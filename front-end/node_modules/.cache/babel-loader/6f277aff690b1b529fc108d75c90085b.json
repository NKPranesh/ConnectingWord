{"ast":null,"code":"export const EMPTY = [];\nexport const FULL = [[0, Infinity]];\nexport function add(rangeList, range) {\n  if (rangeList === FULL) {\n    return rangeList;\n  }\n\n  if (range[0] < 0) {\n    range[0] = 0;\n  }\n\n  if (range[0] >= range[1]) {\n    return rangeList;\n  }\n\n  const newRangeList = [];\n  const len = rangeList.length;\n  let insertPosition = 0;\n\n  for (let i = 0; i < len; i++) {\n    const range0 = rangeList[i];\n\n    if (range0[1] < range[0]) {\n      newRangeList.push(range0);\n      insertPosition = i + 1;\n    } else if (range0[0] > range[1]) {\n      newRangeList.push(range0);\n    } else {\n      range = [Math.min(range0[0], range[0]), Math.max(range0[1], range[1])];\n    }\n  }\n\n  newRangeList.splice(insertPosition, 0, range);\n  return newRangeList;\n}","map":{"version":3,"sources":["../../../src/utils/range.js"],"names":["EMPTY","FULL","rangeList","range","newRangeList","len","insertPosition","i","range0","Math"],"mappings":"AAMA,OAAO,MAAMA,KAAK,GAAX,EAAA;AACP,OAAO,MAAMC,IAAI,GAAG,CAAC,CAAA,CAAA,EAAd,QAAc,CAAD,CAAb;AAGP,OAAO,SAAA,GAAA,CAAA,SAAA,EAAA,KAAA,EAA+B;AAEpC,MAAIC,SAAS,KAAb,IAAA,EAAwB;AACtB,WAAA,SAAA;AACD;;AAGD,MAAIC,KAAK,CAALA,CAAK,CAALA,GAAJ,CAAA,EAAkB;AAChBA,IAAAA,KAAK,CAALA,CAAK,CAALA,GAAAA,CAAAA;AACD;;AACD,MAAIA,KAAK,CAALA,CAAK,CAALA,IAAYA,KAAK,CAArB,CAAqB,CAArB,EAA0B;AACxB,WAAA,SAAA;AACD;;AAGD,QAAMC,YAAY,GAAlB,EAAA;AACA,QAAMC,GAAG,GAAGH,SAAS,CAArB,MAAA;AACA,MAAII,cAAc,GAAlB,CAAA;;AAEA,OAAK,IAAIC,CAAC,GAAV,CAAA,EAAgBA,CAAC,GAAjB,GAAA,EAAyBA,CAAzB,EAAA,EAA8B;AAC5B,UAAMC,MAAM,GAAGN,SAAS,CAAxB,CAAwB,CAAxB;;AAEA,QAAIM,MAAM,CAANA,CAAM,CAANA,GAAYL,KAAK,CAArB,CAAqB,CAArB,EAA0B;AAExBC,MAAAA,YAAY,CAAZA,IAAAA,CAAAA,MAAAA;AACAE,MAAAA,cAAc,GAAGC,CAAC,GAAlBD,CAAAA;AAHF,KAAA,MAIO,IAAIE,MAAM,CAANA,CAAM,CAANA,GAAYL,KAAK,CAArB,CAAqB,CAArB,EAA0B;AAE/BC,MAAAA,YAAY,CAAZA,IAAAA,CAAAA,MAAAA;AAFK,KAAA,MAGA;AACLD,MAAAA,KAAK,GAAG,CAACM,IAAI,CAAJA,GAAAA,CAASD,MAAM,CAAfC,CAAe,CAAfA,EAAoBN,KAAK,CAA1B,CAA0B,CAAzBM,CAAD,EAAgCA,IAAI,CAAJA,GAAAA,CAASD,MAAM,CAAfC,CAAe,CAAfA,EAAoBN,KAAK,CAAjEA,CAAiE,CAAzBM,CAAhC,CAARN;AACD;AACF;;AACDC,EAAAA,YAAY,CAAZA,MAAAA,CAAAA,cAAAA,EAAAA,CAAAA,EAAAA,KAAAA;AACA,SAAA,YAAA;AACD","sourcesContent":["/* \n * range (Array)\n *   + start (Number) - the start index (incl.)\n *   + end (Number) - the end index (excl.)\n * rangeList (Array) - array of sorted, combined ranges\n */\nexport const EMPTY = [];\nexport const FULL = [[0, Infinity]];\n\n// Insert a range into a range collection\nexport function add(rangeList, range) {\n  // Noop if range collection already covers all\n  if (rangeList === FULL) {\n    return rangeList;\n  }\n\n  // Validate the input range\n  if (range[0] < 0) {\n    range[0] = 0;\n  }\n  if (range[0] >= range[1]) {\n    return rangeList;\n  }\n\n  // TODO - split off to tree-shakable Range class\n  const newRangeList = [];\n  const len = rangeList.length;\n  let insertPosition = 0;\n\n  for (let i = 0; i < len; i++) {\n    const range0 = rangeList[i];\n\n    if (range0[1] < range[0]) {\n      // the current range is to the left of the new range\n      newRangeList.push(range0);\n      insertPosition = i + 1;\n    } else if (range0[0] > range[1]) {\n      // the current range is to the right of the new range\n      newRangeList.push(range0);\n    } else {\n      range = [Math.min(range0[0], range[0]), Math.max(range0[1], range[1])];\n    }\n  }\n  newRangeList.splice(insertPosition, 0, range);\n  return newRangeList;\n}\n"]},"metadata":{},"sourceType":"module"}