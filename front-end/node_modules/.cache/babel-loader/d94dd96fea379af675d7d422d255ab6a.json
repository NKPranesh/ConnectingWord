{"ast":null,"code":"import { Buffer, Texture2D, assert } from '@luma.gl/webgl';\nimport { isWebGL2 } from '@luma.gl/gltools';\nimport { Transform } from '@luma.gl/engine';\nimport { default as textureFilterModule } from './texture-filter';\nimport { POLY_TEX_VS, FILTER_VS } from './shaders';\nimport * as Polygon from './polygon';\nconst TEXTURE_SIZE = 512;\nexport default class GPUPointInPolygon {\n  constructor(gl) {\n    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.gl = gl;\n    assert(isWebGL2(gl));\n    this.textureSize = TEXTURE_SIZE;\n\n    this._setupResources();\n\n    this.update(opts);\n  }\n\n  update() {\n    let {\n      polygons,\n      textureSize\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (textureSize) {\n      this.textureSize = textureSize;\n    }\n\n    if (!polygons || polygons.length === 0) {\n      return;\n    }\n\n    const {\n      vertices,\n      indices,\n      vertexCount,\n      ids\n    } = triangulatePolygons(polygons);\n\n    this._updateResources(vertices, indices, ids, vertexCount);\n  }\n\n  filter(_ref) {\n    let {\n      positionBuffer,\n      filterValueIndexBuffer,\n      count\n    } = _ref;\n    this.filterTransform.update({\n      sourceBuffers: {\n        a_position: positionBuffer\n      },\n      feedbackBuffers: {\n        filterValueIndex: filterValueIndexBuffer\n      },\n      elementCount: count\n    });\n    const {\n      polygonTexture,\n      boundingBox\n    } = this;\n    this.filterTransform.run({\n      moduleSettings: {\n        boundingBox,\n        texture: polygonTexture\n      }\n    });\n  }\n\n  _setupResources() {\n    const {\n      gl\n    } = this;\n    this.polygonTexture = new Texture2D(gl, {\n      format: 6407,\n      type: 5121,\n      dataFormat: 6407,\n      border: 0,\n      mipmaps: false,\n      parameters: {\n        [10240]: 9728,\n        [10241]: 9728,\n        [10242]: 33071,\n        [10243]: 33071\n      }\n    });\n    this.positionBuffer = new Buffer(gl, {\n      accessor: {\n        type: 5126,\n        size: 2\n      }\n    });\n    this.idBuffer = new Buffer(gl, {\n      accessor: {\n        type: 5126,\n        size: 1\n      }\n    });\n    this.indexBuffer = new Buffer(gl, {\n      target: 34963,\n      accessor: {\n        type: 5123\n      }\n    });\n    this.polyTextureTransform = new Transform(gl, {\n      id: `polygon-texture-creation-transform`,\n      elementCount: 0,\n      _targetTexture: this.polygonTexture,\n      _targetTextureVarying: 'v_polygonColor',\n      vs: POLY_TEX_VS,\n      drawMode: 4,\n      isIndexed: true,\n      sourceBuffers: {\n        a_position: this.positionBuffer,\n        a_polygonID: this.idBuffer,\n        indices: this.indexBuffer\n      }\n    });\n    this.filterTransform = new Transform(gl, {\n      id: 'filter transform',\n      vs: FILTER_VS,\n      modules: [textureFilterModule],\n      varyings: ['filterValueIndex']\n    });\n  }\n\n  _updateResources(vertices, indices, ids, vertexCount) {\n    const boundingBox = getBoundingBox(vertices, vertexCount);\n    const [xMin, yMin, xMax, yMax] = boundingBox;\n    const width = xMax - xMin;\n    const height = yMax - yMin;\n    const whRatio = width / height;\n    const {\n      textureSize\n    } = this;\n    let texWidth = textureSize;\n    let texHeight = textureSize;\n\n    if (whRatio > 1) {\n      texHeight = texWidth / whRatio;\n    } else {\n      texWidth = texHeight * whRatio;\n    }\n\n    this.boundingBox = boundingBox;\n    this.polygonTexture.resize({\n      width: texWidth,\n      height: texHeight,\n      mipmaps: false\n    });\n    this.positionBuffer.setData(new Float32Array(vertices));\n    this.idBuffer.setData(new Float32Array(ids));\n    this.indexBuffer.setData(new Uint16Array(indices));\n    this.polyTextureTransform.update({\n      elementCount: indices.length,\n      _targetTexture: this.polygonTexture\n    });\n    this.polyTextureTransform.run({\n      uniforms: {\n        boundingBoxOriginSize: [xMin, yMin, width, height]\n      }\n    });\n  }\n\n}\n\nfunction getBoundingBox(positions, vertexCount) {\n  let yMin = Infinity;\n  let yMax = -Infinity;\n  let xMin = Infinity;\n  let xMax = -Infinity;\n  let y;\n  let x;\n\n  for (let i = 0; i < vertexCount; i++) {\n    x = positions[i * 2];\n    y = positions[i * 2 + 1];\n    yMin = y < yMin ? y : yMin;\n    yMax = y > yMax ? y : yMax;\n    xMin = x < xMin ? x : xMin;\n    xMax = x > xMax ? x : xMax;\n  }\n\n  return [xMin, yMin, xMax, yMax];\n}\n\nfunction triangulatePolygons(polygons) {\n  const SIZE = 2;\n  const vertices = [];\n  const indices = [];\n  const ids = [];\n  let count = 0;\n  let polygonId = 0;\n\n  for (let i = 0; i < polygons.length; i++) {\n    const normalized = Polygon.normalize(polygons[i], SIZE);\n    const curVertices = normalized.positions || normalized;\n    const curCount = curVertices.length / SIZE;\n    const curIds = new Array(curCount).fill(polygonId);\n    vertices.push(...curVertices);\n    ids.push(...curIds);\n    const curIndices = Polygon.getSurfaceIndices(normalized, SIZE);\n    const indexCount = curIndices.length;\n\n    for (let j = 0; j < indexCount; j++) {\n      curIndices[j] += count;\n    }\n\n    count += curCount;\n    indices.push(...curIndices);\n    polygonId++;\n  }\n\n  assert(count < 65536);\n  const vertexCount = Polygon.getVertexCount(vertices, SIZE);\n  return {\n    vertices,\n    indices,\n    ids,\n    vertexCount\n  };\n}","map":{"version":3,"sources":["../../../../src/gpgpu/point-in-polygon/gpu-point-in-polygon.js"],"names":["default","TEXTURE_SIZE","constructor","opts","assert","isWebGL2","update","textureSize","polygons","ids","triangulatePolygons","filter","count","sourceBuffers","a_position","positionBuffer","feedbackBuffers","filterValueIndex","filterValueIndexBuffer","elementCount","boundingBox","moduleSettings","texture","polygonTexture","_setupResources","gl","format","type","dataFormat","border","mipmaps","parameters","accessor","size","target","id","_targetTexture","_targetTextureVarying","vs","drawMode","isIndexed","a_polygonID","indices","indexBuffer","modules","varyings","_updateResources","getBoundingBox","width","xMax","height","yMax","whRatio","texWidth","texHeight","uniforms","boundingBoxOriginSize","yMin","xMin","i","x","positions","y","SIZE","vertices","polygonId","normalized","Polygon","curVertices","curCount","curIds","curIndices","indexCount","j","vertexCount"],"mappings":"AAGA,SAAA,MAAA,EAAA,SAAA,EAAA,MAAA,QAAA,gBAAA;AACA,SAAA,QAAA,QAAA,kBAAA;AACA,SAAA,SAAA,QAAA,iBAAA;AACA,SAAQA,OAAO,IAAf,mBAAA,QAAA,kBAAA;AACA,SAAA,WAAA,EAAA,SAAA,QAAA,WAAA;AACA,OAAO,KAAP,OAAA,MAAA,WAAA;AACA,MAAMC,YAAY,GAAlB,GAAA;AAEA,eAAe,MAAA,iBAAA,CAAwB;AACrCC,EAAAA,WAAW,CAAA,EAAA,EAAgB;AAAA,QAAXC,IAAW,uEAAhB,EAAgB;AACzB,SAAA,EAAA,GAAA,EAAA;AACAC,IAAAA,MAAM,CAACC,QAAQ,CAAfD,EAAe,CAAT,CAANA;AACA,SAAA,WAAA,GAAA,YAAA;;AACA,SAAA,eAAA;;AACA,SAAA,MAAA,CAAA,IAAA;AACD;;AAEDE,EAAAA,MAAM,GAA+B;AAAA,QAA9B;AAAA,MAAA,QAAA;AAAWC,MAAAA;AAAX,KAA8B,uEAA/B,EAA+B;;AACnC,QAAA,WAAA,EAAiB;AACf,WAAA,WAAA,GAAA,WAAA;AACD;;AACD,QAAI,CAAA,QAAA,IAAaC,QAAQ,CAARA,MAAAA,KAAjB,CAAA,EAAwC;AACtC;AACD;;AAED,UAAM;AAAA,MAAA,QAAA;AAAA,MAAA,OAAA;AAAA,MAAA,WAAA;AAAiCC,MAAAA;AAAjC,QAAwCC,mBAAmB,CAAjE,QAAiE,CAAjE;;AACA,SAAA,gBAAA,CAAA,QAAA,EAAA,OAAA,EAAA,GAAA,EAAA,WAAA;AACD;;AAEDC,EAAAA,MAAM,OAAkD;AAAA,QAAjD;AAAA,MAAA,cAAA;AAAA,MAAA,sBAAA;AAAyCC,MAAAA;AAAzC,KAAiD;AACtD,SAAA,eAAA,CAAA,MAAA,CAA4B;AAC1BC,MAAAA,aAAa,EAAE;AACbC,QAAAA,UAAU,EAAEC;AADC,OADW;AAI1BC,MAAAA,eAAe,EAAE;AACfC,QAAAA,gBAAgB,EAAEC;AADH,OAJS;AAO1BC,MAAAA,YAAY,EAAEP;AAPY,KAA5B;AASA,UAAM;AAAA,MAAA,cAAA;AAAiBQ,MAAAA;AAAjB,QAAN,IAAA;AAEA,SAAA,eAAA,CAAA,GAAA,CAAyB;AACvBC,MAAAA,cAAc,EAAE;AAAA,QAAA,WAAA;AAAcC,QAAAA,OAAO,EAAEC;AAAvB;AADO,KAAzB;AAGD;;AAIDC,EAAAA,eAAe,GAAG;AAChB,UAAM;AAACC,MAAAA;AAAD,QAAN,IAAA;AAGA,SAAA,cAAA,GAAsB,IAAA,SAAA,CAAA,EAAA,EAAkB;AACtCC,MAAAA,MAAM,EADgC,IAAA;AAEtCC,MAAAA,IAAI,EAFkC,IAAA;AAGtCC,MAAAA,UAAU,EAH4B,IAAA;AAItCC,MAAAA,MAAM,EAJgC,CAAA;AAKtCC,MAAAA,OAAO,EAL+B,KAAA;AAMtCC,MAAAA,UAAU,EAAE;AACV,SAAA,KAAA,GADU,IAAA;AAEV,SAAA,KAAA,GAFU,IAAA;AAGV,SAAA,KAAA,GAHU,KAAA;AAIV,SAAA,KAAA,GAAA;AAJU;AAN0B,KAAlB,CAAtB;AAaA,SAAA,cAAA,GAAsB,IAAA,MAAA,CAAA,EAAA,EAAe;AAACC,MAAAA,QAAQ,EAAE;AAACL,QAAAA,IAAI,EAAL,IAAA;AAAiBM,QAAAA,IAAI,EAAE;AAAvB;AAAX,KAAf,CAAtB;AACA,SAAA,QAAA,GAAgB,IAAA,MAAA,CAAA,EAAA,EAAe;AAACD,MAAAA,QAAQ,EAAE;AAACL,QAAAA,IAAI,EAAL,IAAA;AAAiBM,QAAAA,IAAI,EAAE;AAAvB;AAAX,KAAf,CAAhB;AACA,SAAA,WAAA,GAAmB,IAAA,MAAA,CAAA,EAAA,EAAe;AAChCC,MAAAA,MAAM,EAD0B,KAAA;AAEhCF,MAAAA,QAAQ,EAAE;AAACL,QAAAA,IAAI,EAAA;AAAL;AAFsB,KAAf,CAAnB;AAMA,SAAA,oBAAA,GAA4B,IAAA,SAAA,CAAA,EAAA,EAAkB;AAC5CQ,MAAAA,EAAE,EAD0C,oCAAA;AAE5ChB,MAAAA,YAAY,EAFgC,CAAA;AAG5CiB,MAAAA,cAAc,EAAE,KAH4B,cAAA;AAI5CC,MAAAA,qBAAqB,EAJuB,gBAAA;AAK5CC,MAAAA,EAAE,EAL0C,WAAA;AAM5CC,MAAAA,QAAQ,EANoC,CAAA;AAO5CC,MAAAA,SAAS,EAPmC,IAAA;AAQ5C3B,MAAAA,aAAa,EAAE;AACbC,QAAAA,UAAU,EAAE,KADC,cAAA;AAEb2B,QAAAA,WAAW,EAAE,KAFA,QAAA;AAGbC,QAAAA,OAAO,EAAE,KAAKC;AAHD;AAR6B,KAAlB,CAA5B;AAgBA,SAAA,eAAA,GAAuB,IAAA,SAAA,CAAA,EAAA,EAAkB;AACvCR,MAAAA,EAAE,EADqC,kBAAA;AAEvCG,MAAAA,EAAE,EAFqC,SAAA;AAGvCM,MAAAA,OAAO,EAAE,CAH8B,mBAG9B,CAH8B;AAIvCC,MAAAA,QAAQ,EAAE,CAAA,kBAAA;AAJ6B,KAAlB,CAAvB;AAMD;;AAEDC,EAAAA,gBAAgB,CAAA,QAAA,EAAA,OAAA,EAAA,GAAA,EAAA,WAAA,EAAsC;AACpD,UAAM1B,WAAW,GAAG2B,cAAc,CAAA,QAAA,EAAlC,WAAkC,CAAlC;AACA,UAAM,CAAA,IAAA,EAAA,IAAA,EAAA,IAAA,EAAA,IAAA,IAAN,WAAA;AACA,UAAMC,KAAK,GAAGC,IAAI,GAAlB,IAAA;AACA,UAAMC,MAAM,GAAGC,IAAI,GAAnB,IAAA;AACA,UAAMC,OAAO,GAAGJ,KAAK,GAArB,MAAA;AACA,UAAM;AAACzC,MAAAA;AAAD,QAAN,IAAA;AAGA,QAAI8C,QAAQ,GAAZ,WAAA;AACA,QAAIC,SAAS,GAAb,WAAA;;AACA,QAAIF,OAAO,GAAX,CAAA,EAAiB;AACfE,MAAAA,SAAS,GAAGD,QAAQ,GAApBC,OAAAA;AADF,KAAA,MAEO;AACLD,MAAAA,QAAQ,GAAGC,SAAS,GAApBD,OAAAA;AACD;;AAED,SAAA,WAAA,GAAA,WAAA;AACA,SAAA,cAAA,CAAA,MAAA,CAA2B;AAACL,MAAAA,KAAK,EAAN,QAAA;AAAkBE,MAAAA,MAAM,EAAxB,SAAA;AAAqCpB,MAAAA,OAAO,EAAE;AAA9C,KAA3B;AACA,SAAA,cAAA,CAAA,OAAA,CAA4B,IAAA,YAAA,CAA5B,QAA4B,CAA5B;AACA,SAAA,QAAA,CAAA,OAAA,CAAsB,IAAA,YAAA,CAAtB,GAAsB,CAAtB;AACA,SAAA,WAAA,CAAA,OAAA,CAAyB,IAAA,WAAA,CAAzB,OAAyB,CAAzB;AACA,SAAA,oBAAA,CAAA,MAAA,CAAiC;AAC/BX,MAAAA,YAAY,EAAEuB,OAAO,CADU,MAAA;AAE/BN,MAAAA,cAAc,EAAE,KAAKb;AAFU,KAAjC;AAKA,SAAA,oBAAA,CAAA,GAAA,CAA8B;AAC5BgC,MAAAA,QAAQ,EAAE;AACRC,QAAAA,qBAAqB,EAAE,CAAA,IAAA,EAAA,IAAA,EAAA,KAAA,EAAA,MAAA;AADf;AADkB,KAA9B;AAKD;;AAzHoC;;AA8HvC,SAAA,cAAA,CAAA,SAAA,EAAA,WAAA,EAAgD;AAC9C,MAAIC,IAAI,GAAR,QAAA;AACA,MAAIN,IAAI,GAAG,CAAX,QAAA;AACA,MAAIO,IAAI,GAAR,QAAA;AACA,MAAIT,IAAI,GAAG,CAAX,QAAA;AACA,MAAA,CAAA;AACA,MAAA,CAAA;;AAEA,OAAK,IAAIU,CAAC,GAAV,CAAA,EAAgBA,CAAC,GAAjB,WAAA,EAAiCA,CAAjC,EAAA,EAAsC;AACpCC,IAAAA,CAAC,GAAGC,SAAS,CAACF,CAAC,GAAfC,CAAa,CAAbA;AACAE,IAAAA,CAAC,GAAGD,SAAS,CAACF,CAAC,GAADA,CAAAA,GAAdG,CAAa,CAAbA;AACAL,IAAAA,IAAI,GAAGK,CAAC,GAADA,IAAAA,GAAAA,CAAAA,GAAPL,IAAAA;AACAN,IAAAA,IAAI,GAAGW,CAAC,GAADA,IAAAA,GAAAA,CAAAA,GAAPX,IAAAA;AACAO,IAAAA,IAAI,GAAGE,CAAC,GAADA,IAAAA,GAAAA,CAAAA,GAAPF,IAAAA;AACAT,IAAAA,IAAI,GAAGW,CAAC,GAADA,IAAAA,GAAAA,CAAAA,GAAPX,IAAAA;AACD;;AAED,SAAO,CAAA,IAAA,EAAA,IAAA,EAAA,IAAA,EAAP,IAAO,CAAP;AACD;;AAED,SAAA,mBAAA,CAAA,QAAA,EAAuC;AACrC,QAAMc,IAAI,GAAV,CAAA;AACA,QAAMC,QAAQ,GAAd,EAAA;AACA,QAAMtB,OAAO,GAAb,EAAA;AACA,QAAMjC,GAAG,GAAT,EAAA;AACA,MAAIG,KAAK,GAAT,CAAA;AACA,MAAIqD,SAAS,GAAb,CAAA;;AACA,OAAK,IAAIN,CAAC,GAAV,CAAA,EAAgBA,CAAC,GAAGnD,QAAQ,CAA5B,MAAA,EAAqCmD,CAArC,EAAA,EAA0C;AACxC,UAAMO,UAAU,GAAGC,OAAO,CAAPA,SAAAA,CAAkB3D,QAAQ,CAA1B2D,CAA0B,CAA1BA,EAAnB,IAAmBA,CAAnB;AACA,UAAMC,WAAW,GAAGF,UAAU,CAAVA,SAAAA,IAApB,UAAA;AACA,UAAMG,QAAQ,GAAGD,WAAW,CAAXA,MAAAA,GAAjB,IAAA;AACA,UAAME,MAAM,GAAG,IAAA,KAAA,CAAA,QAAA,EAAA,IAAA,CAAf,SAAe,CAAf;AACAN,IAAAA,QAAQ,CAARA,IAAAA,CAAc,GAAdA,WAAAA;AACAvD,IAAAA,GAAG,CAAHA,IAAAA,CAAS,GAATA,MAAAA;AACA,UAAM8D,UAAU,GAAGJ,OAAO,CAAPA,iBAAAA,CAAAA,UAAAA,EAAnB,IAAmBA,CAAnB;AACA,UAAMK,UAAU,GAAGD,UAAU,CAA7B,MAAA;;AACA,SAAK,IAAIE,CAAC,GAAV,CAAA,EAAgBA,CAAC,GAAjB,UAAA,EAAgCA,CAAhC,EAAA,EAAqC;AACnCF,MAAAA,UAAU,CAAVA,CAAU,CAAVA,IAAAA,KAAAA;AACD;;AACD3D,IAAAA,KAAK,IAALA,QAAAA;AACA8B,IAAAA,OAAO,CAAPA,IAAAA,CAAa,GAAbA,UAAAA;AACAuB,IAAAA,SAAS;AACV;;AAGD7D,EAAAA,MAAM,CAACQ,KAAK,GAAZR,KAAM,CAANA;AAEA,QAAMsE,WAAW,GAAGP,OAAO,CAAPA,cAAAA,CAAAA,QAAAA,EAApB,IAAoBA,CAApB;AAEA,SAAO;AAAA,IAAA,QAAA;AAAA,IAAA,OAAA;AAAA,IAAA,GAAA;AAAyBO,IAAAA;AAAzB,GAAP;AACD","sourcesContent":["// @ts-nocheck TODO remove\n\nimport GL from '@luma.gl/constants';\nimport {Buffer, Texture2D, assert} from '@luma.gl/webgl';\nimport {isWebGL2} from '@luma.gl/gltools';\nimport {Transform} from '@luma.gl/engine';\nimport {default as textureFilterModule} from './texture-filter';\nimport {POLY_TEX_VS, FILTER_VS} from './shaders';\nimport * as Polygon from './polygon';\nconst TEXTURE_SIZE = 512;\n\nexport default class GPUPointInPolygon {\n  constructor(gl, opts = {}) {\n    this.gl = gl;\n    assert(isWebGL2(gl)); // supports WebGL2 only\n    this.textureSize = TEXTURE_SIZE;\n    this._setupResources();\n    this.update(opts);\n  }\n\n  update({polygons, textureSize} = {}) {\n    if (textureSize) {\n      this.textureSize = textureSize;\n    }\n    if (!polygons || polygons.length === 0) {\n      return;\n    }\n\n    const {vertices, indices, vertexCount, ids} = triangulatePolygons(polygons);\n    this._updateResources(vertices, indices, ids, vertexCount);\n  }\n\n  filter({positionBuffer, filterValueIndexBuffer, count}) {\n    this.filterTransform.update({\n      sourceBuffers: {\n        a_position: positionBuffer\n      },\n      feedbackBuffers: {\n        filterValueIndex: filterValueIndexBuffer\n      },\n      elementCount: count\n    });\n    const {polygonTexture, boundingBox} = this;\n\n    this.filterTransform.run({\n      moduleSettings: {boundingBox, texture: polygonTexture}\n    });\n  }\n\n  // PRIVATE\n\n  _setupResources() {\n    const {gl} = this;\n\n    // texture to render polygons to\n    this.polygonTexture = new Texture2D(gl, {\n      format: GL.RGB,\n      type: GL.UNSIGNED_BYTE,\n      dataFormat: GL.RGB,\n      border: 0,\n      mipmaps: false,\n      parameters: {\n        [GL.TEXTURE_MAG_FILTER]: GL.NEAREST,\n        [GL.TEXTURE_MIN_FILTER]: GL.NEAREST,\n        [GL.TEXTURE_WRAP_S]: gl.CLAMP_TO_EDGE,\n        [GL.TEXTURE_WRAP_T]: gl.CLAMP_TO_EDGE\n      }\n    });\n    this.positionBuffer = new Buffer(gl, {accessor: {type: GL.FLOAT, size: 2}});\n    this.idBuffer = new Buffer(gl, {accessor: {type: GL.FLOAT, size: 1}});\n    this.indexBuffer = new Buffer(gl, {\n      target: GL.ELEMENT_ARRAY_BUFFER,\n      accessor: {type: GL.UNSIGNED_SHORT}\n    });\n\n    // transform to generate polygon texture\n    this.polyTextureTransform = new Transform(gl, {\n      id: `polygon-texture-creation-transform`,\n      elementCount: 0,\n      _targetTexture: this.polygonTexture,\n      _targetTextureVarying: 'v_polygonColor',\n      vs: POLY_TEX_VS,\n      drawMode: GL.TRIANGLES,\n      isIndexed: true,\n      sourceBuffers: {\n        a_position: this.positionBuffer,\n        a_polygonID: this.idBuffer,\n        indices: this.indexBuffer\n      }\n    });\n\n    // transform to perform filtering\n    this.filterTransform = new Transform(gl, {\n      id: 'filter transform',\n      vs: FILTER_VS,\n      modules: [textureFilterModule],\n      varyings: ['filterValueIndex']\n    });\n  }\n\n  _updateResources(vertices, indices, ids, vertexCount) {\n    const boundingBox = getBoundingBox(vertices, vertexCount);\n    const [xMin, yMin, xMax, yMax] = boundingBox;\n    const width = xMax - xMin;\n    const height = yMax - yMin;\n    const whRatio = width / height;\n    const {textureSize} = this;\n\n    // calculate max texture size with same aspect ratio\n    let texWidth = textureSize;\n    let texHeight = textureSize;\n    if (whRatio > 1) {\n      texHeight = texWidth / whRatio;\n    } else {\n      texWidth = texHeight * whRatio;\n    }\n\n    this.boundingBox = boundingBox;\n    this.polygonTexture.resize({width: texWidth, height: texHeight, mipmaps: false});\n    this.positionBuffer.setData(new Float32Array(vertices));\n    this.idBuffer.setData(new Float32Array(ids));\n    this.indexBuffer.setData(new Uint16Array(indices));\n    this.polyTextureTransform.update({\n      elementCount: indices.length,\n      _targetTexture: this.polygonTexture\n    });\n\n    this.polyTextureTransform.run({\n      uniforms: {\n        boundingBoxOriginSize: [xMin, yMin, width, height]\n      }\n    });\n  }\n}\n\n// Helper methods\n\nfunction getBoundingBox(positions, vertexCount) {\n  let yMin = Infinity;\n  let yMax = -Infinity;\n  let xMin = Infinity;\n  let xMax = -Infinity;\n  let y;\n  let x;\n\n  for (let i = 0; i < vertexCount; i++) {\n    x = positions[i * 2];\n    y = positions[i * 2 + 1];\n    yMin = y < yMin ? y : yMin;\n    yMax = y > yMax ? y : yMax;\n    xMin = x < xMin ? x : xMin;\n    xMax = x > xMax ? x : xMax;\n  }\n\n  return [xMin, yMin, xMax, yMax];\n}\n\nfunction triangulatePolygons(polygons) {\n  const SIZE = 2;\n  const vertices = [];\n  const indices = [];\n  const ids = [];\n  let count = 0;\n  let polygonId = 0;\n  for (let i = 0; i < polygons.length; i++) {\n    const normalized = Polygon.normalize(polygons[i], SIZE);\n    const curVertices = normalized.positions || normalized;\n    const curCount = curVertices.length / SIZE;\n    const curIds = new Array(curCount).fill(polygonId);\n    vertices.push(...curVertices);\n    ids.push(...curIds);\n    const curIndices = Polygon.getSurfaceIndices(normalized, SIZE);\n    const indexCount = curIndices.length;\n    for (let j = 0; j < indexCount; j++) {\n      curIndices[j] += count;\n    }\n    count += curCount;\n    indices.push(...curIndices);\n    polygonId++;\n  }\n\n  // UInt16 (UNSIGNED_SHORT) buffer is used for indices\n  assert(count < 65536); // 0xFFFF\n\n  const vertexCount = Polygon.getVertexCount(vertices, SIZE);\n\n  return {vertices, indices, ids, vertexCount};\n}\n"]},"metadata":{},"sourceType":"module"}