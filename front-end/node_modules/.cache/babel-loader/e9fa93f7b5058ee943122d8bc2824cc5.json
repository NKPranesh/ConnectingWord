{"ast":null,"code":"import { Matrix3, _MathUtils } from '@math.gl/core';\nconst scratchMatrix = new Matrix3();\nconst scratchUnitary = new Matrix3();\nconst scratchDiagonal = new Matrix3();\nconst jMatrix = new Matrix3();\nconst jMatrixTranspose = new Matrix3();\nexport default function computeEigenDecomposition(matrix) {\n  let result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const EIGEN_TOLERANCE = _MathUtils.EPSILON20;\n  const EIGEN_MAX_SWEEPS = 10;\n  let count = 0;\n  let sweep = 0;\n  const unitaryMatrix = scratchUnitary;\n  const diagonalMatrix = scratchDiagonal;\n  unitaryMatrix.identity();\n  diagonalMatrix.copy(matrix);\n  const epsilon = EIGEN_TOLERANCE * computeFrobeniusNorm(diagonalMatrix);\n\n  while (sweep < EIGEN_MAX_SWEEPS && offDiagonalFrobeniusNorm(diagonalMatrix) > epsilon) {\n    shurDecomposition(diagonalMatrix, jMatrix);\n    jMatrixTranspose.copy(jMatrix).transpose();\n    diagonalMatrix.multiplyRight(jMatrix);\n    diagonalMatrix.multiplyLeft(jMatrixTranspose);\n    unitaryMatrix.multiplyRight(jMatrix);\n\n    if (++count > 2) {\n      ++sweep;\n      count = 0;\n    }\n  }\n\n  result.unitary = unitaryMatrix.toTarget(result.unitary);\n  result.diagonal = diagonalMatrix.toTarget(result.diagonal);\n  return result;\n}\n\nfunction computeFrobeniusNorm(matrix) {\n  let norm = 0.0;\n\n  for (let i = 0; i < 9; ++i) {\n    const temp = matrix[i];\n    norm += temp * temp;\n  }\n\n  return Math.sqrt(norm);\n}\n\nconst rowVal = [1, 0, 0];\nconst colVal = [2, 2, 1];\n\nfunction offDiagonalFrobeniusNorm(matrix) {\n  let norm = 0.0;\n\n  for (let i = 0; i < 3; ++i) {\n    const temp = matrix[scratchMatrix.getElementIndex(colVal[i], rowVal[i])];\n    norm += 2.0 * temp * temp;\n  }\n\n  return Math.sqrt(norm);\n}\n\nfunction shurDecomposition(matrix, result) {\n  const tolerance = _MathUtils.EPSILON15;\n  let maxDiagonal = 0.0;\n  let rotAxis = 1;\n\n  for (let i = 0; i < 3; ++i) {\n    const temp = Math.abs(matrix[scratchMatrix.getElementIndex(colVal[i], rowVal[i])]);\n\n    if (temp > maxDiagonal) {\n      rotAxis = i;\n      maxDiagonal = temp;\n    }\n  }\n\n  const p = rowVal[rotAxis];\n  const q = colVal[rotAxis];\n  let c = 1.0;\n  let s = 0.0;\n\n  if (Math.abs(matrix[scratchMatrix.getElementIndex(q, p)]) > tolerance) {\n    const qq = matrix[scratchMatrix.getElementIndex(q, q)];\n    const pp = matrix[scratchMatrix.getElementIndex(p, p)];\n    const qp = matrix[scratchMatrix.getElementIndex(q, p)];\n    const tau = (qq - pp) / 2.0 / qp;\n    let t;\n\n    if (tau < 0.0) {\n      t = -1.0 / (-tau + Math.sqrt(1.0 + tau * tau));\n    } else {\n      t = 1.0 / (tau + Math.sqrt(1.0 + tau * tau));\n    }\n\n    c = 1.0 / Math.sqrt(1.0 + t * t);\n    s = t * c;\n  }\n\n  Matrix3.IDENTITY.to(result);\n  result[scratchMatrix.getElementIndex(p, p)] = result[scratchMatrix.getElementIndex(q, q)] = c;\n  result[scratchMatrix.getElementIndex(q, p)] = s;\n  result[scratchMatrix.getElementIndex(p, q)] = -s;\n  return result;\n}","map":{"version":3,"sources":["../../../../src/lib/algorithms/compute-eigen-decomposition.js"],"names":["scratchMatrix","scratchUnitary","scratchDiagonal","jMatrix","jMatrixTranspose","result","EIGEN_TOLERANCE","_MathUtils","EIGEN_MAX_SWEEPS","count","sweep","unitaryMatrix","diagonalMatrix","epsilon","computeFrobeniusNorm","offDiagonalFrobeniusNorm","shurDecomposition","norm","i","temp","matrix","Math","rowVal","colVal","tolerance","maxDiagonal","rotAxis","p","q","c","s","qq","pp","qp","tau","t","Matrix3"],"mappings":"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","sourcesContent":["// This file is derived from the Cesium math library under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\nimport {Matrix3, _MathUtils} from '@math.gl/core';\n\nconst scratchMatrix = new Matrix3();\nconst scratchUnitary = new Matrix3();\nconst scratchDiagonal = new Matrix3();\n\nconst jMatrix = new Matrix3();\nconst jMatrixTranspose = new Matrix3();\n\nexport default function computeEigenDecomposition(matrix, result = {}) {\n  const EIGEN_TOLERANCE = _MathUtils.EPSILON20;\n  const EIGEN_MAX_SWEEPS = 10;\n\n  let count = 0;\n  let sweep = 0;\n\n  const unitaryMatrix = scratchUnitary;\n  const diagonalMatrix = scratchDiagonal;\n\n  unitaryMatrix.identity();\n  diagonalMatrix.copy(matrix);\n\n  const epsilon = EIGEN_TOLERANCE * computeFrobeniusNorm(diagonalMatrix);\n\n  while (sweep < EIGEN_MAX_SWEEPS && offDiagonalFrobeniusNorm(diagonalMatrix) > epsilon) {\n    shurDecomposition(diagonalMatrix, jMatrix);\n\n    jMatrixTranspose.copy(jMatrix).transpose();\n\n    diagonalMatrix.multiplyRight(jMatrix);\n    diagonalMatrix.multiplyLeft(jMatrixTranspose);\n    unitaryMatrix.multiplyRight(jMatrix);\n\n    if (++count > 2) {\n      ++sweep;\n      count = 0;\n    }\n  }\n\n  result.unitary = unitaryMatrix.toTarget(result.unitary);\n  result.diagonal = diagonalMatrix.toTarget(result.diagonal);\n\n  return result;\n}\n\nfunction computeFrobeniusNorm(matrix) {\n  let norm = 0.0;\n  for (let i = 0; i < 9; ++i) {\n    const temp = matrix[i];\n    norm += temp * temp;\n  }\n  return Math.sqrt(norm);\n}\n\nconst rowVal = [1, 0, 0];\nconst colVal = [2, 2, 1];\n\n// Computes the \"off-diagonal\" Frobenius norm.\n// Assumes matrix is symmetric.\nfunction offDiagonalFrobeniusNorm(matrix) {\n  let norm = 0.0;\n  for (let i = 0; i < 3; ++i) {\n    const temp = matrix[scratchMatrix.getElementIndex(colVal[i], rowVal[i])];\n    norm += 2.0 * temp * temp;\n  }\n  return Math.sqrt(norm);\n}\n\n// The routine takes a matrix, which is assumed to be symmetric, and\n// finds the largest off-diagonal term, and then creates\n// a matrix (result) which can be used to help reduce it\n//\n// This routine was created based upon Matrix Computations, 3rd ed., by Golub and Van Loan,\n// section 8.4.2 The 2by2 Symmetric Schur Decomposition.\n//\n// eslint-disable-next-line max-statements\nfunction shurDecomposition(matrix, result) {\n  const tolerance = _MathUtils.EPSILON15;\n\n  let maxDiagonal = 0.0;\n  let rotAxis = 1;\n\n  // find pivot (rotAxis) based on max diagonal of matrix\n  for (let i = 0; i < 3; ++i) {\n    const temp = Math.abs(matrix[scratchMatrix.getElementIndex(colVal[i], rowVal[i])]);\n    if (temp > maxDiagonal) {\n      rotAxis = i;\n      maxDiagonal = temp;\n    }\n  }\n\n  const p = rowVal[rotAxis];\n  const q = colVal[rotAxis];\n\n  let c = 1.0;\n  let s = 0.0;\n\n  if (Math.abs(matrix[scratchMatrix.getElementIndex(q, p)]) > tolerance) {\n    const qq = matrix[scratchMatrix.getElementIndex(q, q)];\n    const pp = matrix[scratchMatrix.getElementIndex(p, p)];\n    const qp = matrix[scratchMatrix.getElementIndex(q, p)];\n\n    const tau = (qq - pp) / 2.0 / qp;\n    let t;\n\n    if (tau < 0.0) {\n      t = -1.0 / (-tau + Math.sqrt(1.0 + tau * tau));\n    } else {\n      t = 1.0 / (tau + Math.sqrt(1.0 + tau * tau));\n    }\n\n    c = 1.0 / Math.sqrt(1.0 + t * t);\n    s = t * c;\n  }\n\n  // Copy into result\n  Matrix3.IDENTITY.to(result);\n  result[scratchMatrix.getElementIndex(p, p)] = result[scratchMatrix.getElementIndex(q, q)] = c;\n  result[scratchMatrix.getElementIndex(q, p)] = s;\n  result[scratchMatrix.getElementIndex(p, q)] = -s;\n\n  return result;\n}\n"]},"metadata":{},"sourceType":"module"}