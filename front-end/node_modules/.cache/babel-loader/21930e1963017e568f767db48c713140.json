{"ast":null,"code":"import { toRadians } from '@math.gl/core';\nconst WGS84_RADIUS_X = 6378137.0;\nconst qualityFactor = Math.PI / 2;\nexport function lodJudge(tile, frameState) {\n  const viewport = frameState.viewport;\n  const metersPerPixel = viewport.metersPerPixel;\n  const mbsLat = tile.header.mbs[1];\n  const mbsLon = tile.header.mbs[0];\n  const mbsZ = tile.header.mbs[2];\n  const mbsR = tile.header.mbs[3];\n  const {\n    height,\n    width,\n    latitude,\n    longitude\n  } = viewport;\n  const viewportCenter = [longitude, latitude];\n  const mbsCenter = [mbsLon, mbsLat, mbsZ];\n  const mbsLatProjected = [longitude, mbsLat];\n  const mbsLonProjected = [mbsLon, latitude];\n  const diagonalInMeters = Math.sqrt(height * height + width * width) * metersPerPixel[0];\n  const distanceInMeters = getDistanceFromLatLon(viewportCenter, mbsCenter);\n  const visibleHeight = height * 0.5 + mbsR / WGS84_RADIUS_X;\n  const visibleWidth = width * 0.5 + mbsR / WGS84_RADIUS_X;\n\n  if (distanceInMeters > diagonalInMeters + mbsR / WGS84_RADIUS_X) {\n    return 'OUT';\n  }\n\n  if (getDistanceFromLatLon(viewportCenter, mbsLatProjected) > visibleHeight) {\n    return 'OUT';\n  }\n\n  if (getDistanceFromLatLon(viewportCenter, mbsLonProjected) > visibleWidth) {\n    return 'OUT';\n  }\n\n  if (tile.lodMetricValue === 0) {\n    return 'DIG';\n  }\n\n  let screenSize = getI3ScreenSize(tile, frameState);\n  screenSize *= qualityFactor;\n\n  if (screenSize < 0.5) {\n    return 'OUT';\n  }\n\n  if (!tile.header.children || screenSize <= tile.lodMetricValue) {\n    return 'DRAW';\n  } else if (tile.header.children) {\n    return 'DIG';\n  }\n\n  return 'OUT';\n}\n\nfunction projectVertexToSphere(_ref) {\n  let [x, y, z] = _ref;\n  const azim = toRadians(x);\n  const incl = toRadians(y);\n  const radius = 1.0 + z / WGS84_RADIUS_X;\n  const radCosInc = radius * Math.cos(incl);\n  x = radCosInc * Math.cos(azim);\n  y = radCosInc * Math.sin(azim);\n  z = radius * Math.sin(incl);\n  return [x, y, z];\n}\n\nfunction getDistanceFromLatLon(observer, center) {\n  const [observerLon, observerLat, observerZ = 0.0] = observer;\n  const [centerLon, centerLat, centerZ = 0.0] = center;\n  const projectedCenter = projectVertexToSphere([centerLon, centerLat, centerZ]);\n  const projectedObserver = projectVertexToSphere([observerLon, observerLat, observerZ]);\n  const dx = projectedObserver[0] - projectedCenter[0];\n  const dy = projectedObserver[1] - projectedCenter[1];\n  const dz = projectedObserver[2] - projectedCenter[2];\n  return dx * dx + dy * dy + dz * dz;\n}\n\nexport function getI3ScreenSize(tile, frameState) {\n  const viewport = frameState.viewport;\n  const mbsLat = tile.header.mbs[1];\n  const mbsLon = tile.header.mbs[0];\n  const mbsZ = tile.header.mbs[2];\n  const mbsR = tile.header.mbs[3];\n  const mbsCenter = [mbsLon, mbsLat, mbsZ];\n  const cameraPositionCartographic = viewport.unprojectPosition(viewport.cameraPosition);\n  const dSquared = getDistanceFromLatLon(cameraPositionCartographic, mbsCenter);\n  const mbsRNormalized = mbsR / WGS84_RADIUS_X;\n  const d = dSquared - mbsRNormalized * mbsRNormalized;\n  const fltMax = 3.4028235e38;\n\n  if (d <= 0.0) {\n    return 0.5 * fltMax;\n  }\n\n  const screenSizeFactor = getTanOfHalfVFAngle(frameState) * mbsRNormalized / Math.sqrt(d) * 300;\n  return screenSizeFactor;\n}\n\nfunction getTanOfHalfVFAngle(frameState) {\n  const {\n    projectionMatrix\n  } = frameState.viewport;\n  const t = projectionMatrix[5];\n  return t;\n}","map":{"version":3,"sources":["../../../../src/tileset/helpers/i3s-lod.ts"],"names":["WGS84_RADIUS_X","qualityFactor","Math","viewport","frameState","metersPerPixel","mbsLat","tile","mbsLon","mbsZ","mbsR","longitude","viewportCenter","mbsCenter","mbsLatProjected","mbsLonProjected","diagonalInMeters","height","width","distanceInMeters","getDistanceFromLatLon","visibleHeight","visibleWidth","screenSize","getI3ScreenSize","azim","toRadians","incl","radius","z","radCosInc","x","y","observerZ","centerZ","projectedCenter","projectVertexToSphere","projectedObserver","dx","dy","dz","cameraPositionCartographic","dSquared","mbsRNormalized","d","fltMax","screenSizeFactor","getTanOfHalfVFAngle","projectionMatrix","t"],"mappings":"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","sourcesContent":["import {toRadians} from '@math.gl/core';\n\nconst WGS84_RADIUS_X = 6378137.0;\n// use this to bias the lod switching  (1+ results in increasing the LOD quality)\nconst qualityFactor = Math.PI / 2; // empirical derived bias factor\n/* eslint-disable max-statements */\nexport function lodJudge(tile, frameState) {\n  const viewport = frameState.viewport;\n  const metersPerPixel = viewport.metersPerPixel;\n\n  const mbsLat = tile.header.mbs[1];\n  const mbsLon = tile.header.mbs[0];\n  const mbsZ = tile.header.mbs[2];\n  const mbsR = tile.header.mbs[3];\n\n  const {height, width, latitude, longitude} = viewport;\n\n  const viewportCenter = [longitude, latitude];\n  const mbsCenter = [mbsLon, mbsLat, mbsZ];\n  const mbsLatProjected = [longitude, mbsLat];\n  const mbsLonProjected = [mbsLon, latitude];\n\n  const diagonalInMeters = Math.sqrt(height * height + width * width) * metersPerPixel[0];\n  const distanceInMeters = getDistanceFromLatLon(viewportCenter, mbsCenter);\n\n  const visibleHeight = height * 0.5 + mbsR / WGS84_RADIUS_X;\n  const visibleWidth = width * 0.5 + mbsR / WGS84_RADIUS_X;\n\n  if (distanceInMeters > diagonalInMeters + mbsR / WGS84_RADIUS_X) {\n    return 'OUT';\n  }\n  if (getDistanceFromLatLon(viewportCenter, mbsLatProjected) > visibleHeight) {\n    return 'OUT';\n  }\n  if (getDistanceFromLatLon(viewportCenter, mbsLonProjected) > visibleWidth) {\n    return 'OUT';\n  }\n\n  if (tile.lodMetricValue === 0) {\n    return 'DIG';\n  }\n\n  // For the maxScreenThreshold error metric, maxError means that you should replace the node with it's children\n  // as soon as the nodes bounding sphere has a screen radius larger than maxError pixels.\n  // In this sense a value of 0 means you should always load it's children,\n  // or if it's a leaf node, you should always display it.\n  let screenSize = getI3ScreenSize(tile, frameState); // in pixels\n  screenSize *= qualityFactor;\n  if (screenSize < 0.5) {\n    return 'OUT';\n  }\n  if (!tile.header.children || screenSize <= tile.lodMetricValue) {\n    return 'DRAW';\n  } else if (tile.header.children) {\n    return 'DIG';\n  }\n  return 'OUT';\n}\n\n/* eslint-enable max-statements */\n\nfunction projectVertexToSphere([x, y, z]) {\n  const azim = toRadians(x);\n  const incl = toRadians(y);\n  const radius = 1.0 + z / WGS84_RADIUS_X;\n  const radCosInc = radius * Math.cos(incl);\n  x = radCosInc * Math.cos(azim);\n  y = radCosInc * Math.sin(azim);\n  z = radius * Math.sin(incl);\n  return [x, y, z];\n}\n\nfunction getDistanceFromLatLon(observer: number[], center: number[]) {\n  const [observerLon, observerLat, observerZ = 0.0] = observer;\n  const [centerLon, centerLat, centerZ = 0.0] = center;\n\n  const projectedCenter = projectVertexToSphere([centerLon, centerLat, centerZ]);\n  const projectedObserver = projectVertexToSphere([observerLon, observerLat, observerZ]);\n  const dx = projectedObserver[0] - projectedCenter[0];\n  const dy = projectedObserver[1] - projectedCenter[1];\n  const dz = projectedObserver[2] - projectedCenter[2];\n  return dx * dx + dy * dy + dz * dz;\n}\n\nexport function getI3ScreenSize(tile, frameState) {\n  const viewport = frameState.viewport;\n  const mbsLat = tile.header.mbs[1];\n  const mbsLon = tile.header.mbs[0];\n  const mbsZ = tile.header.mbs[2];\n  const mbsR = tile.header.mbs[3];\n\n  const mbsCenter = [mbsLon, mbsLat, mbsZ];\n  const cameraPositionCartographic = viewport.unprojectPosition(viewport.cameraPosition);\n  const dSquared = getDistanceFromLatLon(cameraPositionCartographic, mbsCenter);\n  const mbsRNormalized = mbsR / WGS84_RADIUS_X;\n  const d = dSquared - mbsRNormalized * mbsRNormalized;\n  const fltMax = 3.4028235e38; // convert from 0x7f7fffff which is the maximum\n  if (d <= 0.0) {\n    return 0.5 * fltMax;\n  }\n  // https://stackoverflow.com/questions/21648630/radius-of-projected-sphere-in-screen-space\n  // There is a formula there to calculate projected radius:\n  // return 1.0 / Math.tan(fov) * r / Math.sqrt(d * d - r * r); // Right\n  // Hack: 300 is a Magic number to get the correct LoD. Possibly, d and r are calculated in a wrong way.\n  const screenSizeFactor =\n    ((getTanOfHalfVFAngle(frameState) * mbsRNormalized) / Math.sqrt(d)) * 300;\n  return screenSizeFactor;\n}\n\nfunction getTanOfHalfVFAngle(frameState) {\n  const {projectionMatrix} = frameState.viewport;\n  const t = projectionMatrix[5];\n  return t;\n}\n"]},"metadata":{},"sourceType":"module"}