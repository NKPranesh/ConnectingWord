{"ast":null,"code":"import * as fs from '../node/fs';\nexport default class NodeFileSystem {\n  constructor(options) {\n    this.fetch = options._fetch;\n  }\n\n  async readdir() {\n    let dirname = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '.';\n    let options = arguments.length > 1 ? arguments[1] : undefined;\n    return await fs.readdir(dirname, options);\n  }\n\n  async stat(path, options) {\n    const info = await fs.stat(path, options);\n    return {\n      size: Number(info.size),\n      isDirectory: () => false,\n      info\n    };\n  }\n\n  async fetch(path, options) {\n    const fallbackFetch = options.fetch || this.fetch;\n    return fallbackFetch(path, options);\n  }\n\n  async open(path, flags, mode) {\n    return await fs.open(path, flags);\n  }\n\n  async close(fd) {\n    return await fs.close(fd);\n  }\n\n  async fstat(fd) {\n    const info = await fs.fstat(fd);\n    return info;\n  }\n\n  async read(fd, _ref) {\n    let {\n      buffer = null,\n      offset = 0,\n      length = buffer.byteLength,\n      position = null\n    } = _ref;\n    let totalBytesRead = 0;\n\n    while (totalBytesRead < length) {\n      const {\n        bytesRead\n      } = await fs.read(fd, buffer, offset + totalBytesRead, length - totalBytesRead, position + totalBytesRead);\n      totalBytesRead += bytesRead;\n    }\n\n    return {\n      bytesRead: totalBytesRead,\n      buffer\n    };\n  }\n\n}","map":{"version":3,"sources":["../../../../src/lib/filesystems/node-filesystem.ts"],"names":["constructor","options","readdir","dirname","fs","stat","info","size","Number","isDirectory","fetch","fallbackFetch","open","close","fstat","read","buffer","offset","length","position","totalBytesRead","bytesRead"],"mappings":"AAAA,OAAO,KAAP,EAAA,MAAA,YAAA;AAuBA,eAAe,MAAA,cAAA,CAAyE;AAEtFA,EAAAA,WAAW,CAAA,OAAA,EAAgC;AACzC,SAAA,KAAA,GAAaC,OAAO,CAApB,MAAA;AACD;;AAEY,QAAPC,OAAO,GAA8C;AAAA,QAA7CC,OAA6C,uEAA9C,GAA8C;AAAA,QAA9C,OAA8C;AACzD,WAAO,MAAMC,EAAE,CAAFA,OAAAA,CAAAA,OAAAA,EAAb,OAAaA,CAAb;AACD;;AAES,QAAJC,IAAI,CAAA,IAAA,EAAA,OAAA,EAA4C;AACpD,UAAMC,IAAI,GAAG,MAAMF,EAAE,CAAFA,IAAAA,CAAAA,IAAAA,EAAnB,OAAmBA,CAAnB;AACA,WAAO;AAACG,MAAAA,IAAI,EAAEC,MAAM,CAACF,IAAI,CAAlB,IAAa,CAAb;AAA0BG,MAAAA,WAAW,EAAE,MAAvC,KAAA;AAAoDH,MAAAA;AAApD,KAAP;AACD;;AAEU,QAALI,KAAK,CAAA,IAAA,EAAA,OAAA,EAA8C;AAGvD,UAAMC,aAAa,GAAGV,OAAO,CAAPA,KAAAA,IAAiB,KAAvC,KAAA;AACA,WAAOU,aAAa,CAAA,IAAA,EAApB,OAAoB,CAApB;AACD;;AAGS,QAAJC,IAAI,CAAA,IAAA,EAAA,KAAA,EAAA,IAAA,EAAoE;AAC5E,WAAO,MAAMR,EAAE,CAAFA,IAAAA,CAAAA,IAAAA,EAAb,KAAaA,CAAb;AACD;;AAEU,QAALS,KAAK,CAAA,EAAA,EAA4B;AACrC,WAAO,MAAMT,EAAE,CAAFA,KAAAA,CAAb,EAAaA,CAAb;AACD;;AAEU,QAALU,KAAK,CAAA,EAAA,EAA4B;AACrC,UAAMR,IAAI,GAAG,MAAMF,EAAE,CAAFA,KAAAA,CAAnB,EAAmBA,CAAnB;AACA,WAAA,IAAA;AACD;;AAES,QAAJW,IAAI,CAAA,EAAA,QAIsC;AAAA,QAD9C;AAACC,MAAAA,MAAM,GAAP,IAAA;AAAgBC,MAAAA,MAAM,GAAtB,CAAA;AAA4BC,MAAAA,MAAM,GAAGF,MAAM,CAA3C,UAAA;AAAwDG,MAAAA,QAAQ,GAAG;AAAnE,KAC8C;AAC9C,QAAIC,cAAc,GAAlB,CAAA;;AAEA,WAAOA,cAAc,GAArB,MAAA,EAAgC;AAC9B,YAAM;AAACC,QAAAA;AAAD,UAAc,MAAMjB,EAAE,CAAFA,IAAAA,CAAAA,EAAAA,EAAAA,MAAAA,EAGxBa,MAAM,GAHkBb,cAAAA,EAIxBc,MAAM,GAJkBd,cAAAA,EAKxBe,QAAQ,GALV,cAA0Bf,CAA1B;AAOAgB,MAAAA,cAAc,IAAdA,SAAAA;AACD;;AACD,WAAO;AAACC,MAAAA,SAAS,EAAV,cAAA;AAA4BL,MAAAA;AAA5B,KAAP;AACD;;AAtDqF","sourcesContent":["import * as fs from '../node/fs';\nimport {IFileSystem, IRandomAccessReadFileSystem} from '@loaders.gl/loader-utils';\n// import {fetchFile} from \"../fetch/fetch-file\"\n// import {selectLoader} from \"../api/select-loader\";\n\ntype Stat = {\n  size: number;\n  isDirectory: () => boolean;\n  info?: fs.Stats;\n};\n\ntype ReadOptions = {\n  buffer?: Buffer;\n  offset?: number;\n  length?: number;\n  position?: number;\n};\n\n/**\n * FileSystem pass-through for Node.js\n * Compatible with BrowserFileSystem.\n * @param options\n */\nexport default class NodeFileSystem implements IFileSystem, IRandomAccessReadFileSystem {\n  // implements IFileSystem\n  constructor(options: {[key: string]: any}) {\n    this.fetch = options._fetch;\n  }\n\n  async readdir(dirname = '.', options?: {}): Promise<any[]> {\n    return await fs.readdir(dirname, options);\n  }\n\n  async stat(path: string, options?: {}): Promise<Stat> {\n    const info = await fs.stat(path, options);\n    return {size: Number(info.size), isDirectory: () => false, info};\n  }\n\n  async fetch(path: string, options: {[key: string]: any}) {\n    // Falls back to handle https:/http:/data: etc fetches\n    // eslint-disable-next-line\n    const fallbackFetch = options.fetch || this.fetch;\n    return fallbackFetch(path, options);\n  }\n\n  // implements IRandomAccessFileSystem\n  async open(path: string, flags: string | number, mode?: any): Promise<number> {\n    return await fs.open(path, flags);\n  }\n\n  async close(fd: number): Promise<void> {\n    return await fs.close(fd);\n  }\n\n  async fstat(fd: number): Promise<Stat> {\n    const info = await fs.fstat(fd);\n    return info;\n  }\n\n  async read(\n    fd: number,\n    // @ts-ignore Possibly null\n    {buffer = null, offset = 0, length = buffer.byteLength, position = null}: ReadOptions\n  ): Promise<{bytesRead: number; buffer: Buffer}> {\n    let totalBytesRead = 0;\n    // Read in loop until we get required number of bytes\n    while (totalBytesRead < length) {\n      const {bytesRead} = await fs.read(\n        fd,\n        buffer,\n        offset + totalBytesRead,\n        length - totalBytesRead,\n        position + totalBytesRead\n      );\n      totalBytesRead += bytesRead;\n    }\n    return {bytesRead: totalBytesRead, buffer};\n  }\n}\n"]},"metadata":{},"sourceType":"module"}