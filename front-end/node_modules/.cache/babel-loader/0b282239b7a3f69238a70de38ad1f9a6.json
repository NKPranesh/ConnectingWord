{"ast":null,"code":"import { getDefaultCredentials, buildMapsUrlFromBase } from '../config';\nimport { API_VERSIONS, encodeParameter, FORMATS, MAP_TYPES } from './maps-api-common';\nimport { log } from '@deck.gl/core';\nconst MAX_GET_LENGTH = 2048;\n\nasync function request(_ref) {\n  let {\n    method,\n    url,\n    format,\n    accessToken,\n    body\n  } = _ref;\n  let response;\n  const headers = {\n    Accept: 'application/json'\n  };\n\n  if (accessToken) {\n    headers.Authorization = \"Bearer \".concat(accessToken);\n  }\n\n  if (method === 'POST') {\n    headers['Content-Type'] = 'application/json';\n  }\n\n  try {\n    response = await fetch(url, {\n      method,\n      headers,\n      body\n    });\n  } catch (error) {\n    throw new Error(\"Failed to connect to Maps API: \".concat(error));\n  }\n\n  if (format === FORMATS.NDJSON) {\n    return response;\n  }\n\n  const json = await response.json();\n\n  if (!response.ok) {\n    dealWithError({\n      response,\n      error: json.error\n    });\n  }\n\n  return json.rows ? json.rows : json;\n}\n\nfunction dealWithError(_ref2) {\n  let {\n    response,\n    error\n  } = _ref2;\n\n  switch (response.status) {\n    case 400:\n      throw new Error(\"Bad request. \".concat(error));\n\n    case 401:\n    case 403:\n      throw new Error(\"Unauthorized access. \".concat(error));\n\n    default:\n      throw new Error(error);\n  }\n}\n\nfunction getParameters(_ref3) {\n  let {\n    type,\n    source,\n    geoColumn,\n    columns,\n    schema\n  } = _ref3;\n  const parameters = [encodeParameter('client', 'deck-gl-carto')];\n\n  if (schema) {\n    parameters.push(encodeParameter('schema', true));\n  }\n\n  const sourceName = type === MAP_TYPES.QUERY ? 'q' : 'name';\n  parameters.push(encodeParameter(sourceName, source));\n\n  if (type === MAP_TYPES.TABLE) {\n    if (geoColumn) {\n      parameters.push(encodeParameter('geo_column', geoColumn));\n    }\n\n    if (columns) {\n      parameters.push(encodeParameter('columns', columns.join(',')));\n    }\n  }\n\n  return parameters.join('&');\n}\n\nexport async function mapInstantiation(_ref4) {\n  let {\n    type,\n    source,\n    connection,\n    credentials,\n    geoColumn,\n    columns,\n    schema\n  } = _ref4;\n  const baseUrl = \"\".concat(credentials.mapsUrl, \"/\").concat(connection, \"/\").concat(type);\n  const url = \"\".concat(baseUrl, \"?\").concat(getParameters({\n    type,\n    source,\n    geoColumn,\n    columns,\n    schema\n  }));\n  const {\n    accessToken\n  } = credentials;\n  const format = 'json';\n\n  if (url.length > MAX_GET_LENGTH && type === MAP_TYPES.QUERY) {\n    const body = JSON.stringify({\n      q: source,\n      client: 'deck-gl-carto'\n    });\n    return await request({\n      method: 'POST',\n      url: baseUrl,\n      format,\n      accessToken,\n      body\n    });\n  }\n\n  return await request({\n    url,\n    format,\n    accessToken\n  });\n}\n\nfunction getUrlFromMetadata(metadata, format) {\n  const m = metadata[format];\n\n  if (m && !m.error && m.url) {\n    return m.url[0];\n  }\n\n  return null;\n}\n\nfunction checkGetLayerDataParameters(_ref5) {\n  let {\n    type,\n    source,\n    connection,\n    localCreds\n  } = _ref5;\n  log.assert(connection, 'Must define connection');\n  log.assert(type, 'Must define a type');\n  log.assert(source, 'Must define a source');\n  log.assert(localCreds.apiVersion === API_VERSIONS.V3, 'Method only available for v3');\n  log.assert(localCreds.apiBaseUrl, 'Must define apiBaseUrl');\n  log.assert(localCreds.accessToken, 'Must define an accessToken');\n}\n\nexport async function fetchLayerData(_ref6) {\n  let {\n    type,\n    source,\n    connection,\n    credentials,\n    geoColumn,\n    columns,\n    format,\n    schema\n  } = _ref6;\n  const defaultCredentials = getDefaultCredentials();\n  const localCreds = { ...(defaultCredentials.apiVersion === API_VERSIONS.V3 && defaultCredentials),\n    ...credentials\n  };\n  checkGetLayerDataParameters({\n    type,\n    source,\n    connection,\n    localCreds\n  });\n\n  if (!localCreds.mapsUrl) {\n    localCreds.mapsUrl = buildMapsUrlFromBase(localCreds.apiBaseUrl);\n  }\n\n  const metadata = await mapInstantiation({\n    type,\n    source,\n    connection,\n    credentials: localCreds,\n    geoColumn,\n    columns,\n    schema\n  });\n  let url;\n  let mapFormat;\n\n  if (format) {\n    mapFormat = format;\n    url = getUrlFromMetadata(metadata, format);\n    log.assert(url, \"Format \".concat(format, \" not available\"));\n  } else {\n    const prioritizedFormats = [FORMATS.GEOJSON, FORMATS.NDJSON, FORMATS.TILEJSON];\n\n    for (const f of prioritizedFormats) {\n      url = getUrlFromMetadata(metadata, f);\n\n      if (url) {\n        mapFormat = f;\n        break;\n      }\n    }\n  }\n\n  const {\n    accessToken\n  } = localCreds;\n  const data = await request({\n    url,\n    format: mapFormat,\n    accessToken\n  });\n  const result = {\n    data,\n    format: mapFormat\n  };\n\n  if (schema) {\n    result.schema = metadata.schema;\n  }\n\n  return result;\n}\nexport async function getData(_ref7) {\n  let {\n    type,\n    source,\n    connection,\n    credentials,\n    geoColumn,\n    columns,\n    format\n  } = _ref7;\n  const layerData = await fetchLayerData({\n    type,\n    source,\n    connection,\n    credentials,\n    geoColumn,\n    columns,\n    format,\n    schema: false\n  });\n  return layerData.data;\n}","map":{"version":3,"sources":["../../../src/api/maps-v3-client.js"],"names":["MAX_GET_LENGTH","body","headers","Accept","method","response","fetch","format","FORMATS","json","dealWithError","error","schema","parameters","encodeParameter","sourceName","type","MAP_TYPES","columns","baseUrl","credentials","url","getParameters","accessToken","q","client","request","m","metadata","localCreds","log","API_VERSIONS","defaultCredentials","getDefaultCredentials","checkGetLayerDataParameters","buildMapsUrlFromBase","mapInstantiation","mapFormat","getUrlFromMetadata","prioritizedFormats","data","result","layerData","fetchLayerData"],"mappings":"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","sourcesContent":["/**\n * Maps API Client for Carto 3\n */\nimport {getDefaultCredentials, buildMapsUrlFromBase} from '../config';\nimport {API_VERSIONS, encodeParameter, FORMATS, MAP_TYPES} from './maps-api-common';\nimport {log} from '@deck.gl/core';\n\nconst MAX_GET_LENGTH = 2048;\n\n/**\n * Request against Maps API\n */\nasync function request({method, url, format, accessToken, body}) {\n  let response;\n\n  const headers = {\n    Accept: 'application/json'\n  };\n\n  if (accessToken) {\n    headers.Authorization = `Bearer ${accessToken}`;\n  }\n\n  if (method === 'POST') {\n    headers['Content-Type'] = 'application/json';\n  }\n\n  try {\n    /* global fetch */\n    /* eslint no-undef: \"error\" */\n    response = await fetch(url, {\n      method,\n      headers,\n      body\n    });\n  } catch (error) {\n    throw new Error(`Failed to connect to Maps API: ${error}`);\n  }\n\n  if (format === FORMATS.NDJSON) {\n    return response;\n  }\n\n  const json = await response.json();\n\n  if (!response.ok) {\n    dealWithError({response, error: json.error});\n  }\n\n  return json.rows ? json.rows : json;\n}\n\n/**\n * Display proper message from Maps API error\n */\nfunction dealWithError({response, error}) {\n  switch (response.status) {\n    case 400:\n      throw new Error(`Bad request. ${error}`);\n    case 401:\n    case 403:\n      throw new Error(`Unauthorized access. ${error}`);\n    default:\n      throw new Error(error);\n  }\n}\n\n/**\n * Build a URL with all required parameters\n */\nfunction getParameters({type, source, geoColumn, columns, schema}) {\n  const parameters = [encodeParameter('client', 'deck-gl-carto')];\n  if (schema) {\n    parameters.push(encodeParameter('schema', true));\n  }\n\n  const sourceName = type === MAP_TYPES.QUERY ? 'q' : 'name';\n  parameters.push(encodeParameter(sourceName, source));\n\n  if (type === MAP_TYPES.TABLE) {\n    if (geoColumn) {\n      parameters.push(encodeParameter('geo_column', geoColumn));\n    }\n    if (columns) {\n      parameters.push(encodeParameter('columns', columns.join(',')));\n    }\n  }\n\n  return parameters.join('&');\n}\n\nexport async function mapInstantiation({\n  type,\n  source,\n  connection,\n  credentials,\n  geoColumn,\n  columns,\n  schema\n}) {\n  const baseUrl = `${credentials.mapsUrl}/${connection}/${type}`;\n  const url = `${baseUrl}?${getParameters({type, source, geoColumn, columns, schema})}`;\n  const {accessToken} = credentials;\n\n  const format = 'json';\n\n  if (url.length > MAX_GET_LENGTH && type === MAP_TYPES.QUERY) {\n    // need to be a POST request\n    const body = JSON.stringify({\n      q: source,\n      client: 'deck-gl-carto'\n    });\n    return await request({method: 'POST', url: baseUrl, format, accessToken, body});\n  }\n\n  return await request({url, format, accessToken});\n}\n\nfunction getUrlFromMetadata(metadata, format) {\n  const m = metadata[format];\n\n  if (m && !m.error && m.url) {\n    return m.url[0];\n  }\n\n  return null;\n}\n\nfunction checkGetLayerDataParameters({type, source, connection, localCreds}) {\n  log.assert(connection, 'Must define connection');\n  log.assert(type, 'Must define a type');\n  log.assert(source, 'Must define a source');\n\n  log.assert(localCreds.apiVersion === API_VERSIONS.V3, 'Method only available for v3');\n  log.assert(localCreds.apiBaseUrl, 'Must define apiBaseUrl');\n  log.assert(localCreds.accessToken, 'Must define an accessToken');\n}\n\nexport async function fetchLayerData({\n  type,\n  source,\n  connection,\n  credentials,\n  geoColumn,\n  columns,\n  format,\n  schema\n}) {\n  const defaultCredentials = getDefaultCredentials();\n  // Only pick up default credentials if they have been defined for\n  // correct API version\n  const localCreds = {\n    ...(defaultCredentials.apiVersion === API_VERSIONS.V3 && defaultCredentials),\n    ...credentials\n  };\n  checkGetLayerDataParameters({type, source, connection, localCreds});\n\n  if (!localCreds.mapsUrl) {\n    localCreds.mapsUrl = buildMapsUrlFromBase(localCreds.apiBaseUrl);\n  }\n\n  const metadata = await mapInstantiation({\n    type,\n    source,\n    connection,\n    credentials: localCreds,\n    geoColumn,\n    columns,\n    schema\n  });\n  let url;\n  let mapFormat;\n\n  if (format) {\n    mapFormat = format;\n    url = getUrlFromMetadata(metadata, format);\n    log.assert(url, `Format ${format} not available`);\n  } else {\n    // guess map format\n    const prioritizedFormats = [FORMATS.GEOJSON, FORMATS.NDJSON, FORMATS.TILEJSON];\n    for (const f of prioritizedFormats) {\n      url = getUrlFromMetadata(metadata, f);\n      if (url) {\n        mapFormat = f;\n        break;\n      }\n    }\n  }\n\n  const {accessToken} = localCreds;\n\n  const data = await request({url, format: mapFormat, accessToken});\n  const result = {data, format: mapFormat};\n  if (schema) {\n    result.schema = metadata.schema;\n  }\n\n  return result;\n}\n\nexport async function getData({type, source, connection, credentials, geoColumn, columns, format}) {\n  const layerData = await fetchLayerData({\n    type,\n    source,\n    connection,\n    credentials,\n    geoColumn,\n    columns,\n    format,\n    schema: false\n  });\n  return layerData.data;\n}\n"]},"metadata":{},"sourceType":"module"}