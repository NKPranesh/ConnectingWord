{"ast":null,"code":"import { createTexture, destroyTexture } from '../utils/texture';\nconst TYPE_DEFINITIONS = {\n  boolean: {\n    validate(value, propType) {\n      return true;\n    },\n\n    equal(value1, value2, propType) {\n      return Boolean(value1) === Boolean(value2);\n    }\n\n  },\n  number: {\n    validate(value, propType) {\n      return Number.isFinite(value) && (!('max' in propType) || value <= propType.max) && (!('min' in propType) || value >= propType.min);\n    }\n\n  },\n  color: {\n    validate(value, propType) {\n      return propType.optional && !value || isArray(value) && (value.length === 3 || value.length === 4);\n    },\n\n    equal(value1, value2, propType) {\n      return arrayEqual(value1, value2);\n    }\n\n  },\n  accessor: {\n    validate(value, propType) {\n      const valueType = getTypeOf(value);\n      return valueType === 'function' || valueType === getTypeOf(propType.value);\n    },\n\n    equal(value1, value2, propType) {\n      if (typeof value2 === 'function') {\n        return true;\n      }\n\n      return arrayEqual(value1, value2);\n    }\n\n  },\n  array: {\n    validate(value, propType) {\n      return propType.optional && !value || isArray(value);\n    },\n\n    equal(value1, value2, propType) {\n      return propType.compare ? arrayEqual(value1, value2) : value1 === value2;\n    }\n\n  },\n  function: {\n    validate(value, propType) {\n      return propType.optional && !value || typeof value === 'function';\n    },\n\n    equal(value1, value2, propType) {\n      return !propType.compare || value1 === value2;\n    }\n\n  },\n  data: {\n    transform: (value, propType, component) => {\n      const {\n        dataTransform\n      } = component ? component.props : {};\n      return dataTransform && value ? dataTransform(value) : value;\n    }\n  },\n  image: {\n    transform: (value, propType, component) => {\n      return createTexture(component, value);\n    },\n    release: value => {\n      destroyTexture(value);\n    }\n  }\n};\n\nfunction arrayEqual(array1, array2) {\n  if (array1 === array2) {\n    return true;\n  }\n\n  if (!isArray(array1) || !isArray(array2)) {\n    return false;\n  }\n\n  const len = array1.length;\n\n  if (len !== array2.length) {\n    return false;\n  }\n\n  for (let i = 0; i < len; i++) {\n    if (array1[i] !== array2[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexport function parsePropTypes(propDefs) {\n  const propTypes = {};\n  const defaultProps = {};\n  const deprecatedProps = {};\n\n  for (const [propName, propDef] of Object.entries(propDefs)) {\n    if (propDef && propDef.deprecatedFor) {\n      deprecatedProps[propName] = Array.isArray(propDef.deprecatedFor) ? propDef.deprecatedFor : [propDef.deprecatedFor];\n    } else {\n      const propType = parsePropType(propName, propDef);\n      propTypes[propName] = propType;\n      defaultProps[propName] = propType.value;\n    }\n  }\n\n  return {\n    propTypes,\n    defaultProps,\n    deprecatedProps\n  };\n}\n\nfunction parsePropType(name, propDef) {\n  switch (getTypeOf(propDef)) {\n    case 'object':\n      return normalizePropDefinition(name, propDef);\n\n    case 'array':\n      return normalizePropDefinition(name, {\n        type: 'array',\n        value: propDef,\n        compare: false\n      });\n\n    case 'boolean':\n      return normalizePropDefinition(name, {\n        type: 'boolean',\n        value: propDef\n      });\n\n    case 'number':\n      return normalizePropDefinition(name, {\n        type: 'number',\n        value: propDef\n      });\n\n    case 'function':\n      return normalizePropDefinition(name, {\n        type: 'function',\n        value: propDef,\n        compare: true\n      });\n\n    default:\n      return {\n        name,\n        type: 'unknown',\n        value: propDef\n      };\n  }\n}\n\nfunction normalizePropDefinition(name, propDef) {\n  if (!('type' in propDef)) {\n    if (!('value' in propDef)) {\n      return {\n        name,\n        type: 'object',\n        value: propDef\n      };\n    }\n\n    return {\n      name,\n      type: getTypeOf(propDef.value),\n      ...propDef\n    };\n  }\n\n  return {\n    name,\n    ...TYPE_DEFINITIONS[propDef.type],\n    ...propDef\n  };\n}\n\nfunction isArray(value) {\n  return Array.isArray(value) || ArrayBuffer.isView(value);\n}\n\nfunction getTypeOf(value) {\n  if (isArray(value)) {\n    return 'array';\n  }\n\n  if (value === null) {\n    return 'null';\n  }\n\n  return typeof value;\n}","map":{"version":3,"sources":["../../../src/lifecycle/prop-types.js"],"names":["TYPE_DEFINITIONS","boolean","validate","equal","Boolean","number","Number","value","propType","color","isArray","arrayEqual","accessor","valueType","getTypeOf","array","value1","function","data","transform","dataTransform","component","image","createTexture","release","destroyTexture","array1","len","array2","i","propTypes","defaultProps","deprecatedProps","Object","propDef","Array","parsePropType","normalizePropDefinition","type","compare","ArrayBuffer"],"mappings":"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","sourcesContent":["import {createTexture, destroyTexture} from '../utils/texture';\n\nconst TYPE_DEFINITIONS = {\n  boolean: {\n    validate(value, propType) {\n      return true;\n    },\n    equal(value1, value2, propType) {\n      return Boolean(value1) === Boolean(value2);\n    }\n  },\n  number: {\n    validate(value, propType) {\n      return (\n        Number.isFinite(value) &&\n        (!('max' in propType) || value <= propType.max) &&\n        (!('min' in propType) || value >= propType.min)\n      );\n    }\n  },\n  color: {\n    validate(value, propType) {\n      return (\n        (propType.optional && !value) ||\n        (isArray(value) && (value.length === 3 || value.length === 4))\n      );\n    },\n    equal(value1, value2, propType) {\n      return arrayEqual(value1, value2);\n    }\n  },\n  accessor: {\n    validate(value, propType) {\n      const valueType = getTypeOf(value);\n      return valueType === 'function' || valueType === getTypeOf(propType.value);\n    },\n    equal(value1, value2, propType) {\n      if (typeof value2 === 'function') {\n        return true;\n      }\n      return arrayEqual(value1, value2);\n    }\n  },\n  array: {\n    validate(value, propType) {\n      return (propType.optional && !value) || isArray(value);\n    },\n    equal(value1, value2, propType) {\n      return propType.compare ? arrayEqual(value1, value2) : value1 === value2;\n    }\n  },\n  function: {\n    validate(value, propType) {\n      return (propType.optional && !value) || typeof value === 'function';\n    },\n    equal(value1, value2, propType) {\n      return !propType.compare || value1 === value2;\n    }\n  },\n  data: {\n    transform: (value, propType, component) => {\n      const {dataTransform} = component ? component.props : {};\n      return dataTransform && value ? dataTransform(value) : value;\n    }\n  },\n  image: {\n    transform: (value, propType, component) => {\n      return createTexture(component, value);\n    },\n    release: value => {\n      destroyTexture(value);\n    }\n  }\n};\n\nfunction arrayEqual(array1, array2) {\n  if (array1 === array2) {\n    return true;\n  }\n  if (!isArray(array1) || !isArray(array2)) {\n    return false;\n  }\n  const len = array1.length;\n  if (len !== array2.length) {\n    return false;\n  }\n  for (let i = 0; i < len; i++) {\n    if (array1[i] !== array2[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport function parsePropTypes(propDefs) {\n  const propTypes = {};\n  const defaultProps = {};\n  const deprecatedProps = {};\n\n  for (const [propName, propDef] of Object.entries(propDefs)) {\n    if (propDef && propDef.deprecatedFor) {\n      deprecatedProps[propName] = Array.isArray(propDef.deprecatedFor)\n        ? propDef.deprecatedFor\n        : [propDef.deprecatedFor];\n    } else {\n      const propType = parsePropType(propName, propDef);\n      propTypes[propName] = propType;\n      defaultProps[propName] = propType.value;\n    }\n  }\n  return {propTypes, defaultProps, deprecatedProps};\n}\n\n// Parses one property definition entry. Either contains:\n// * a valid prop type object ({type, ...})\n// * or just a default value, in which case type and name inference is used\nfunction parsePropType(name, propDef) {\n  switch (getTypeOf(propDef)) {\n    case 'object':\n      return normalizePropDefinition(name, propDef);\n\n    case 'array':\n      return normalizePropDefinition(name, {type: 'array', value: propDef, compare: false});\n\n    case 'boolean':\n      return normalizePropDefinition(name, {type: 'boolean', value: propDef});\n\n    case 'number':\n      return normalizePropDefinition(name, {type: 'number', value: propDef});\n\n    case 'function':\n      return normalizePropDefinition(name, {type: 'function', value: propDef, compare: true});\n    // return guessFunctionType(name, propDef);\n\n    default:\n      return {name, type: 'unknown', value: propDef};\n  }\n}\n\nfunction normalizePropDefinition(name, propDef) {\n  if (!('type' in propDef)) {\n    if (!('value' in propDef)) {\n      // If no type and value this object is likely the value\n      return {name, type: 'object', value: propDef};\n    }\n    return {name, type: getTypeOf(propDef.value), ...propDef};\n  }\n  return {name, ...TYPE_DEFINITIONS[propDef.type], ...propDef};\n}\n\nfunction isArray(value) {\n  return Array.isArray(value) || ArrayBuffer.isView(value);\n}\n\n// improved version of javascript typeof that can distinguish arrays and null values\nfunction getTypeOf(value) {\n  if (isArray(value)) {\n    return 'array';\n  }\n  if (value === null) {\n    return 'null';\n  }\n  return typeof value;\n}\n"]},"metadata":{},"sourceType":"module"}