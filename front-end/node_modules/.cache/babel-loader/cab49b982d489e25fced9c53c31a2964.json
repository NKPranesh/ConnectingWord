{"ast":null,"code":"function isEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n\n  if (Array.isArray(a)) {\n    const len = a.length;\n\n    if (!b || b.length !== len) {\n      return false;\n    }\n\n    for (let i = 0; i < len; i++) {\n      if (a[i] !== b[i]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  return false;\n}\n\nexport default function memoize(compute) {\n  let cachedArgs = {};\n  let cachedResult;\n  return args => {\n    for (const key in args) {\n      if (!isEqual(args[key], cachedArgs[key])) {\n        cachedResult = compute(args);\n        cachedArgs = args;\n        break;\n      }\n    }\n\n    return cachedResult;\n  };\n}","map":{"version":3,"sources":["../../../src/utils/memoize.js"],"names":["a","Array","len","b","i","cachedArgs","args","isEqual","cachedResult","compute"],"mappings":"AAAA,SAAA,OAAA,CAAA,CAAA,EAAA,CAAA,EAAuB;AACrB,MAAIA,CAAC,KAAL,CAAA,EAAa;AACX,WAAA,IAAA;AACD;;AACD,MAAIC,KAAK,CAALA,OAAAA,CAAJ,CAAIA,CAAJ,EAAsB;AAGpB,UAAMC,GAAG,GAAGF,CAAC,CAAb,MAAA;;AACA,QAAI,CAAA,CAAA,IAAMG,CAAC,CAADA,MAAAA,KAAV,GAAA,EAA4B;AAC1B,aAAA,KAAA;AACD;;AAED,SAAK,IAAIC,CAAC,GAAV,CAAA,EAAgBA,CAAC,GAAjB,GAAA,EAAyBA,CAAzB,EAAA,EAA8B;AAC5B,UAAIJ,CAAC,CAADA,CAAC,CAADA,KAASG,CAAC,CAAd,CAAc,CAAd,EAAmB;AACjB,eAAA,KAAA;AACD;AACF;;AACD,WAAA,IAAA;AACD;;AACD,SAAA,KAAA;AACD;;AAOD,eAAe,SAAA,OAAA,CAAA,OAAA,EAA0B;AACvC,MAAIE,UAAU,GAAd,EAAA;AACA,MAAA,YAAA;AAEA,SAAOC,IAAI,IAAI;AACb,SAAK,MAAL,GAAA,IAAA,IAAA,EAAwB;AACtB,UAAI,CAACC,OAAO,CAACD,IAAI,CAAL,GAAK,CAAL,EAAYD,UAAU,CAAlC,GAAkC,CAAtB,CAAZ,EAA0C;AACxCG,QAAAA,YAAY,GAAGC,OAAO,CAAtBD,IAAsB,CAAtBA;AACAH,QAAAA,UAAU,GAAVA,IAAAA;AACA;AACD;AACF;;AACD,WAAA,YAAA;AARF,GAAA;AAUD","sourcesContent":["function isEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n  if (Array.isArray(a)) {\n    // Special treatment for arrays: compare 1-level deep\n    // This is to support equality of matrix/coordinate props\n    const len = a.length;\n    if (!b || b.length !== len) {\n      return false;\n    }\n\n    for (let i = 0; i < len; i++) {\n      if (a[i] !== b[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n  return false;\n}\n\n/**\n * Speed up consecutive function calls by caching the result of calls with identical input\n * https://en.wikipedia.org/wiki/Memoization\n * @param {function} compute - the function to be memoized\n */\nexport default function memoize(compute) {\n  let cachedArgs = {};\n  let cachedResult;\n\n  return args => {\n    for (const key in args) {\n      if (!isEqual(args[key], cachedArgs[key])) {\n        cachedResult = compute(args);\n        cachedArgs = args;\n        break;\n      }\n    }\n    return cachedResult;\n  };\n}\n"]},"metadata":{},"sourceType":"module"}