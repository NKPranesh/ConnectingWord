{"ast":null,"code":"import { Vector3 } from '@math.gl/core';\nconst WGS84_RADIUS_X = 6378137.0;\nconst WGS84_RADIUS_Y = 6378137.0;\nconst WGS84_RADIUS_Z = 6356752.3142451793;\nconst scratchVector = new Vector3();\nexport function getZoomFromBoundingVolume(boundingVolume) {\n  const {\n    halfAxes,\n    radius,\n    width,\n    height\n  } = boundingVolume;\n\n  if (halfAxes) {\n    const obbSize = getObbSize(halfAxes);\n    return Math.log2(WGS84_RADIUS_Z / obbSize);\n  } else if (radius) {\n    return Math.log2(WGS84_RADIUS_Z / radius);\n  } else if (height && width) {\n    const zoomX = Math.log2(WGS84_RADIUS_X / width);\n    const zoomY = Math.log2(WGS84_RADIUS_Y / height);\n    return (zoomX + zoomY) / 2;\n  }\n\n  return 1;\n}\n\nfunction getObbSize(halfAxes) {\n  halfAxes.getColumn(0, scratchVector);\n  const axeY = halfAxes.getColumn(1);\n  const axeZ = halfAxes.getColumn(2);\n  const farthestVertex = scratchVector.add(axeY).add(axeZ);\n  const size = farthestVertex.len();\n  return size;\n}","map":{"version":3,"sources":["../../../../src/tileset/helpers/zoom.ts"],"names":["WGS84_RADIUS_X","WGS84_RADIUS_Y","WGS84_RADIUS_Z","scratchVector","height","obbSize","getObbSize","Math","zoomX","zoomY","halfAxes","axeY","axeZ","farthestVertex","size"],"mappings":"AAAA,SAAA,OAAA,QAAA,eAAA;AAEA,MAAMA,cAAc,GAApB,SAAA;AACA,MAAMC,cAAc,GAApB,SAAA;AACA,MAAMC,cAAc,GAApB,kBAAA;AAEA,MAAMC,aAAa,GAAG,IAAtB,OAAsB,EAAtB;AAOA,OAAO,SAAA,yBAAA,CAAA,cAAA,EAAmD;AACxD,QAAM;AAAA,IAAA,QAAA;AAAA,IAAA,MAAA;AAAA,IAAA,KAAA;AAA0BC,IAAAA;AAA1B,MAAN,cAAA;;AAEA,MAAA,QAAA,EAAc;AAEZ,UAAMC,OAAO,GAAGC,UAAU,CAA1B,QAA0B,CAA1B;AAEA,WAAOC,IAAI,CAAJA,IAAAA,CAAUL,cAAc,GAA/B,OAAOK,CAAP;AAJF,GAAA,MAKO,IAAA,MAAA,EAAY;AAEjB,WAAOA,IAAI,CAAJA,IAAAA,CAAUL,cAAc,GAA/B,MAAOK,CAAP;AAFK,GAAA,MAGA,IAAIH,MAAM,IAAV,KAAA,EAAqB;AAE1B,UAAMI,KAAK,GAAGD,IAAI,CAAJA,IAAAA,CAAUP,cAAc,GAAtC,KAAcO,CAAd;AACA,UAAME,KAAK,GAAGF,IAAI,CAAJA,IAAAA,CAAUN,cAAc,GAAtC,MAAcM,CAAd;AAEA,WAAO,CAACC,KAAK,GAAN,KAAA,IAAP,CAAA;AACD;;AAED,SAAA,CAAA;AACD;;AAED,SAAA,UAAA,CAAA,QAAA,EAA8B;AAC5BE,EAAAA,QAAQ,CAARA,SAAAA,CAAAA,CAAAA,EAAAA,aAAAA;AACA,QAAMC,IAAI,GAAGD,QAAQ,CAARA,SAAAA,CAAb,CAAaA,CAAb;AACA,QAAME,IAAI,GAAGF,QAAQ,CAARA,SAAAA,CAAb,CAAaA,CAAb;AACA,QAAMG,cAAc,GAAGV,aAAa,CAAbA,GAAAA,CAAAA,IAAAA,EAAAA,GAAAA,CAAvB,IAAuBA,CAAvB;AACA,QAAMW,IAAI,GAAGD,cAAc,CAA3B,GAAaA,EAAb;AACA,SAAA,IAAA;AACD","sourcesContent":["import {Vector3} from '@math.gl/core';\n\nconst WGS84_RADIUS_X = 6378137.0;\nconst WGS84_RADIUS_Y = 6378137.0;\nconst WGS84_RADIUS_Z = 6356752.3142451793;\n\nconst scratchVector = new Vector3();\n\n/**\n * Calculate appropriate zoom value for a particular boundingVolume\n * @param {BoundingSphere, OrientedBoundingBox} boundingVolume - the instance of bounding volume\n * @returns {number} - zoom value\n */\nexport function getZoomFromBoundingVolume(boundingVolume) {\n  const {halfAxes, radius, width, height} = boundingVolume;\n\n  if (halfAxes) {\n    // OrientedBoundingBox\n    const obbSize = getObbSize(halfAxes);\n    // Use WGS84_RADIUS_Z to allign with BoundingSphere algorithm\n    return Math.log2(WGS84_RADIUS_Z / obbSize);\n  } else if (radius) {\n    // BoundingSphere\n    return Math.log2(WGS84_RADIUS_Z / radius);\n  } else if (height && width) {\n    // BoundingRectangle\n    const zoomX = Math.log2(WGS84_RADIUS_X / width);\n    const zoomY = Math.log2(WGS84_RADIUS_Y / height);\n\n    return (zoomX + zoomY) / 2;\n  }\n\n  return 1;\n}\n\nfunction getObbSize(halfAxes) {\n  halfAxes.getColumn(0, scratchVector);\n  const axeY = halfAxes.getColumn(1);\n  const axeZ = halfAxes.getColumn(2);\n  const farthestVertex = scratchVector.add(axeY).add(axeZ);\n  const size = farthestVertex.len();\n  return size;\n}\n"]},"metadata":{},"sourceType":"module"}