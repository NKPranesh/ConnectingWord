{"ast":null,"code":"import GLTFScenegraph from '../api/gltf-scenegraph';\nimport { KHR_BINARY_GLTF } from '../gltf-utils/gltf-constants';\nexport function decode(gltfData) {\n  const gltfScenegraph = new GLTFScenegraph(gltfData);\n  const {\n    json\n  } = gltfScenegraph;\n\n  for (const node of json.images || []) {\n    const extension = gltfScenegraph.removeObjectExtension(node, KHR_BINARY_GLTF);\n\n    if (extension) {\n      Object.assign(node, extension);\n    }\n  }\n\n  if (json.buffers && json.buffers[0]) {\n    delete json.buffers[0].uri;\n  }\n\n  gltfScenegraph.removeExtension(KHR_BINARY_GLTF);\n}\nexport function encode() {\n  throw new Error(KHR_BINARY_GLTF);\n}","map":{"version":3,"sources":["../../../../src/lib/extensions/KHR_binary_gltf.ts"],"names":["gltfScenegraph","json","extension","Object"],"mappings":"AAKA,OAAA,cAAA,MAAA,wBAAA;AACA,SAAA,eAAA,QAAA,8BAAA;AAEA,OAAO,SAAA,MAAA,CAAA,QAAA,EAA8C;AACnD,QAAMA,cAAc,GAAG,IAAA,cAAA,CAAvB,QAAuB,CAAvB;AACA,QAAM;AAACC,IAAAA;AAAD,MAAN,cAAA;;AAOA,OAAK,MAAL,IAAA,IAAmBA,IAAI,CAAJA,MAAAA,IAAnB,EAAA,EAAsC;AACpC,UAAMC,SAAS,GAAGF,cAAc,CAAdA,qBAAAA,CAAAA,IAAAA,EAAlB,eAAkBA,CAAlB;;AAEA,QAAA,SAAA,EAAe;AACbG,MAAAA,MAAM,CAANA,MAAAA,CAAAA,IAAAA,EAAAA,SAAAA;AACD;AACF;;AAMD,MAAIF,IAAI,CAAJA,OAAAA,IAAgBA,IAAI,CAAJA,OAAAA,CAApB,CAAoBA,CAApB,EAAqC;AACnC,WAAOA,IAAI,CAAJA,OAAAA,CAAAA,CAAAA,EAAP,GAAA;AACD;;AAGDD,EAAAA,cAAc,CAAdA,eAAAA,CAAAA,eAAAA;AACD;AAGD,OAAO,SAAA,MAAA,GAAkB;AACvB,QAAM,IAAA,KAAA,CAAN,eAAM,CAAN;AACD","sourcesContent":["// GLTF 1.0 EXTENSION: KHR_binary_glTF\n// https://github.com/KhronosGroup/glTF/tree/master/extensions/1.0/Khronos/KHR_binary_glTF\n\nimport type {GLTF} from '../types/gltf-types';\n\nimport GLTFScenegraph from '../api/gltf-scenegraph';\nimport {KHR_BINARY_GLTF} from '../gltf-utils/gltf-constants';\n\nexport function decode(gltfData: {json: GLTF}): void {\n  const gltfScenegraph = new GLTFScenegraph(gltfData);\n  const {json} = gltfScenegraph;\n\n  // Note: json.buffers.binary_glTF also needs to be replaced\n  // This is currently done during gltf normalization\n\n  // Image and shader nodes can have the extension\n  // https://github.com/KhronosGroup/glTF/blob/master/extensions/1.0/Khronos/KHR_binary_glTF/schema/image.KHR_binary_glTF.schema.json\n  for (const node of json.images || []) {\n    const extension = gltfScenegraph.removeObjectExtension(node, KHR_BINARY_GLTF);\n    // The data in the extension is valid as glTF 2.0 data inside the object, so just copy it in\n    if (extension) {\n      Object.assign(node, extension);\n    }\n  }\n\n  // TODO shaders\n  // https://github.com/KhronosGroup/glTF/blob/master/extensions/1.0/Khronos/KHR_binary_glTF/schema/shader.KHR_binary_glTF.schema.json\n\n  // glTF v1 one files have a partially formed URI field that is not expected in (and causes problems in) 2.0\n  if (json.buffers && json.buffers[0]) {\n    delete json.buffers[0].uri;\n  }\n\n  // Remove the top-level extension as it has now been removed from all nodes\n  gltfScenegraph.removeExtension(KHR_BINARY_GLTF);\n}\n\n// KHR_binary_gltf is a 1.0 extension that is supported natively by 2.0\nexport function encode() {\n  throw new Error(KHR_BINARY_GLTF);\n}\n"]},"metadata":{},"sourceType":"module"}