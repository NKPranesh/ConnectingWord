{"ast":null,"code":"import { COORDINATE_SYSTEM } from './constants';\nimport AttributeManager from './attribute/attribute-manager';\nimport UniformTransitionManager from './uniform-transition-manager';\nimport { diffProps, validateProps } from '../lifecycle/props';\nimport { count } from '../utils/count';\nimport log from '../utils/log';\nimport debug from '../debug';\nimport { withParameters, setParameters } from '@luma.gl/core';\nimport assert from '../utils/assert';\nimport memoize from '../utils/memoize';\nimport { mergeShaders } from '../utils/shader';\nimport { projectPosition, getWorldPosition } from '../shaderlib/project/project-functions';\nimport typedArrayManager from '../utils/typed-array-manager';\nimport Component from '../lifecycle/component';\nimport LayerState from './layer-state';\nimport { worldToPixels } from '@math.gl/web-mercator';\nimport { load } from '@loaders.gl/core';\nconst TRACE_CHANGE_FLAG = 'layer.changeFlag';\nconst TRACE_INITIALIZE = 'layer.initialize';\nconst TRACE_UPDATE = 'layer.update';\nconst TRACE_FINALIZE = 'layer.finalize';\nconst TRACE_MATCHED = 'layer.matched';\nconst MAX_PICKING_COLOR_CACHE_SIZE = 2 ** 24 - 1;\nconst EMPTY_ARRAY = Object.freeze([]);\nconst areViewportsEqual = memoize(_ref => {\n  let {\n    oldViewport,\n    viewport\n  } = _ref;\n  return oldViewport.equals(viewport);\n});\nlet pickingColorCache = new Uint8ClampedArray(0);\nconst defaultProps = {\n  data: {\n    type: 'data',\n    value: EMPTY_ARRAY,\n    async: true\n  },\n  dataComparator: null,\n  _dataDiff: {\n    type: 'function',\n    value: data => data && data.__diff,\n    compare: false,\n    optional: true\n  },\n  dataTransform: {\n    type: 'function',\n    value: null,\n    compare: false,\n    optional: true\n  },\n  onDataLoad: {\n    type: 'function',\n    value: null,\n    compare: false,\n    optional: true\n  },\n  onError: {\n    type: 'function',\n    value: null,\n    compare: false,\n    optional: true\n  },\n  fetch: {\n    type: 'function',\n    value: (url, _ref2) => {\n      let {\n        propName,\n        layer,\n        loaders,\n        loadOptions,\n        signal\n      } = _ref2;\n      const {\n        resourceManager\n      } = layer.context;\n      loadOptions = loadOptions || layer.getLoadOptions();\n      loaders = loaders || layer.props.loaders;\n\n      if (signal) {\n        var _loadOptions;\n\n        loadOptions = { ...loadOptions,\n          fetch: { ...((_loadOptions = loadOptions) === null || _loadOptions === void 0 ? void 0 : _loadOptions.fetch),\n            signal\n          }\n        };\n      }\n\n      let inResourceManager = resourceManager.contains(url);\n\n      if (!inResourceManager && !loadOptions) {\n        resourceManager.add({\n          resourceId: url,\n          data: load(url, loaders),\n          persistent: false\n        });\n        inResourceManager = true;\n      }\n\n      if (inResourceManager) {\n        return resourceManager.subscribe({\n          resourceId: url,\n          onChange: data => layer.internalState.reloadAsyncProp(propName, data),\n          consumerId: layer.id,\n          requestId: propName\n        });\n      }\n\n      return load(url, loaders, loadOptions);\n    },\n    compare: false\n  },\n  updateTriggers: {},\n  visible: true,\n  pickable: false,\n  opacity: {\n    type: 'number',\n    min: 0,\n    max: 1,\n    value: 1\n  },\n  onHover: {\n    type: 'function',\n    value: null,\n    compare: false,\n    optional: true\n  },\n  onClick: {\n    type: 'function',\n    value: null,\n    compare: false,\n    optional: true\n  },\n  onDragStart: {\n    type: 'function',\n    value: null,\n    compare: false,\n    optional: true\n  },\n  onDrag: {\n    type: 'function',\n    value: null,\n    compare: false,\n    optional: true\n  },\n  onDragEnd: {\n    type: 'function',\n    value: null,\n    compare: false,\n    optional: true\n  },\n  coordinateSystem: COORDINATE_SYSTEM.DEFAULT,\n  coordinateOrigin: {\n    type: 'array',\n    value: [0, 0, 0],\n    compare: true\n  },\n  modelMatrix: {\n    type: 'array',\n    value: null,\n    compare: true,\n    optional: true\n  },\n  wrapLongitude: false,\n  positionFormat: 'XYZ',\n  colorFormat: 'RGBA',\n  parameters: {},\n  transitions: null,\n  extensions: [],\n  loaders: {\n    type: 'array',\n    value: [],\n    optional: true,\n    compare: true\n  },\n  getPolygonOffset: {\n    type: 'function',\n    value: _ref3 => {\n      let {\n        layerIndex\n      } = _ref3;\n      return [0, -layerIndex * 100];\n    },\n    compare: false\n  },\n  highlightedObjectIndex: -1,\n  autoHighlight: false,\n  highlightColor: {\n    type: 'accessor',\n    value: [0, 0, 128, 128]\n  }\n};\nexport default class Layer extends Component {\n  toString() {\n    const className = this.constructor.layerName || this.constructor.name;\n    return \"\".concat(className, \"({id: '\").concat(this.props.id, \"'})\");\n  }\n\n  raiseError(error, message) {\n    var _this$props$onError, _this$props;\n\n    if (message) {\n      error.message = \"\".concat(message, \": \").concat(error.message);\n    }\n\n    if (!((_this$props$onError = (_this$props = this.props).onError) === null || _this$props$onError === void 0 ? void 0 : _this$props$onError.call(_this$props, error))) {\n      var _this$context, _this$context$onError;\n\n      (_this$context = this.context) === null || _this$context === void 0 ? void 0 : (_this$context$onError = _this$context.onError) === null || _this$context$onError === void 0 ? void 0 : _this$context$onError.call(_this$context, error, this);\n    }\n  }\n\n  setState(updateObject) {\n    this.setChangeFlags({\n      stateChanged: true\n    });\n    Object.assign(this.state, updateObject);\n    this.setNeedsRedraw();\n  }\n\n  setNeedsRedraw() {\n    let redraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n    if (this.internalState) {\n      this.internalState.needsRedraw = redraw;\n    }\n  }\n\n  setNeedsUpdate() {\n    this.context.layerManager.setNeedsUpdate(String(this));\n    this.internalState.needsUpdate = true;\n  }\n\n  getNeedsRedraw() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      clearRedrawFlags: false\n    };\n    return this._getNeedsRedraw(opts);\n  }\n\n  needsUpdate() {\n    return this.internalState.needsUpdate || this.hasUniformTransition() || this.shouldUpdateState(this._getUpdateParams());\n  }\n\n  hasUniformTransition() {\n    return this.internalState.uniformTransitions.active;\n  }\n\n  get isLoaded() {\n    return this.internalState && !this.internalState.isAsyncPropLoading();\n  }\n\n  get wrapLongitude() {\n    return this.props.wrapLongitude;\n  }\n\n  isPickable() {\n    return this.props.pickable && this.props.visible;\n  }\n\n  getModels() {\n    return this.state && (this.state.models || (this.state.model ? [this.state.model] : []));\n  }\n\n  getAttributeManager() {\n    return this.internalState && this.internalState.attributeManager;\n  }\n\n  getCurrentLayer() {\n    return this.internalState && this.internalState.layer;\n  }\n\n  getLoadOptions() {\n    return this.props.loadOptions;\n  }\n\n  project(xyz) {\n    const {\n      viewport\n    } = this.context;\n    const worldPosition = getWorldPosition(xyz, {\n      viewport,\n      modelMatrix: this.props.modelMatrix,\n      coordinateOrigin: this.props.coordinateOrigin,\n      coordinateSystem: this.props.coordinateSystem\n    });\n    const [x, y, z] = worldToPixels(worldPosition, viewport.pixelProjectionMatrix);\n    return xyz.length === 2 ? [x, y] : [x, y, z];\n  }\n\n  unproject(xy) {\n    const {\n      viewport\n    } = this.context;\n    return viewport.unproject(xy);\n  }\n\n  projectPosition(xyz) {\n    return projectPosition(xyz, {\n      viewport: this.context.viewport,\n      modelMatrix: this.props.modelMatrix,\n      coordinateOrigin: this.props.coordinateOrigin,\n      coordinateSystem: this.props.coordinateSystem\n    });\n  }\n\n  use64bitPositions() {\n    const {\n      coordinateSystem\n    } = this.props;\n    return coordinateSystem === COORDINATE_SYSTEM.DEFAULT || coordinateSystem === COORDINATE_SYSTEM.LNGLAT || coordinateSystem === COORDINATE_SYSTEM.CARTESIAN;\n  }\n\n  onHover(info, pickingEvent) {\n    if (this.props.onHover) {\n      return this.props.onHover(info, pickingEvent);\n    }\n\n    return false;\n  }\n\n  onClick(info, pickingEvent) {\n    if (this.props.onClick) {\n      return this.props.onClick(info, pickingEvent);\n    }\n\n    return false;\n  }\n\n  nullPickingColor() {\n    return [0, 0, 0];\n  }\n\n  encodePickingColor(i) {\n    let target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    target[0] = i + 1 & 255;\n    target[1] = i + 1 >> 8 & 255;\n    target[2] = i + 1 >> 8 >> 8 & 255;\n    return target;\n  }\n\n  decodePickingColor(color) {\n    assert(color instanceof Uint8Array);\n    const [i1, i2, i3] = color;\n    const index = i1 + i2 * 256 + i3 * 65536 - 1;\n    return index;\n  }\n\n  initializeState() {\n    throw new Error(\"Layer \".concat(this, \" has not defined initializeState\"));\n  }\n\n  getShaders(shaders) {\n    for (const extension of this.props.extensions) {\n      shaders = mergeShaders(shaders, extension.getShaders.call(this, extension));\n    }\n\n    return shaders;\n  }\n\n  shouldUpdateState(_ref4) {\n    let {\n      oldProps,\n      props,\n      context,\n      changeFlags\n    } = _ref4;\n    return changeFlags.propsOrDataChanged;\n  }\n\n  updateState(_ref5) {\n    let {\n      oldProps,\n      props,\n      context,\n      changeFlags\n    } = _ref5;\n    const attributeManager = this.getAttributeManager();\n\n    if (changeFlags.dataChanged && attributeManager) {\n      const {\n        dataChanged\n      } = changeFlags;\n\n      if (Array.isArray(dataChanged)) {\n        for (const dataRange of dataChanged) {\n          attributeManager.invalidateAll(dataRange);\n        }\n      } else {\n        attributeManager.invalidateAll();\n      }\n    }\n\n    const neededPickingBuffer = oldProps.highlightedObjectIndex >= 0 || oldProps.pickable;\n    const needPickingBuffer = props.highlightedObjectIndex >= 0 || props.pickable;\n\n    if (neededPickingBuffer !== needPickingBuffer && attributeManager) {\n      const {\n        pickingColors,\n        instancePickingColors\n      } = attributeManager.attributes;\n      const pickingColorsAttribute = pickingColors || instancePickingColors;\n\n      if (pickingColorsAttribute) {\n        if (needPickingBuffer && pickingColorsAttribute.constant) {\n          pickingColorsAttribute.constant = false;\n          attributeManager.invalidate(pickingColorsAttribute.id);\n        }\n\n        if (!pickingColorsAttribute.value && !needPickingBuffer) {\n          pickingColorsAttribute.constant = true;\n          pickingColorsAttribute.value = [0, 0, 0];\n        }\n      }\n    }\n  }\n\n  finalizeState() {\n    for (const model of this.getModels()) {\n      model.delete();\n    }\n\n    const attributeManager = this.getAttributeManager();\n\n    if (attributeManager) {\n      attributeManager.finalize();\n    }\n\n    this.context.resourceManager.unsubscribe({\n      consumerId: this.id\n    });\n    this.internalState.uniformTransitions.clear();\n    this.internalState.finalize();\n  }\n\n  draw(opts) {\n    for (const model of this.getModels()) {\n      model.draw(opts);\n    }\n  }\n\n  getPickingInfo(_ref6) {\n    let {\n      info,\n      mode\n    } = _ref6;\n    const {\n      index\n    } = info;\n\n    if (index >= 0) {\n      if (Array.isArray(this.props.data)) {\n        info.object = this.props.data[index];\n      }\n    }\n\n    return info;\n  }\n\n  activateViewport(viewport) {\n    const oldViewport = this.internalState.viewport;\n    this.internalState.viewport = viewport;\n\n    if (!oldViewport || !areViewportsEqual({\n      oldViewport,\n      viewport\n    })) {\n      this.setChangeFlags({\n        viewportChanged: true\n      });\n\n      if (this.isComposite) {\n        if (this.needsUpdate()) {\n          this.setNeedsUpdate();\n        }\n      } else {\n        this._update();\n      }\n    }\n  }\n\n  invalidateAttribute() {\n    let name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'all';\n    let diffReason = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n    const attributeManager = this.getAttributeManager();\n\n    if (!attributeManager) {\n      return;\n    }\n\n    if (name === 'all') {\n      attributeManager.invalidateAll();\n    } else {\n      attributeManager.invalidate(name);\n    }\n  }\n\n  updateAttributes(changedAttributes) {\n    for (const model of this.getModels()) {\n      this._setModelAttributes(model, changedAttributes);\n    }\n  }\n\n  _updateAttributes(props) {\n    const attributeManager = this.getAttributeManager();\n\n    if (!attributeManager) {\n      return;\n    }\n\n    const numInstances = this.getNumInstances(props);\n    const startIndices = this.getStartIndices(props);\n    attributeManager.update({\n      data: props.data,\n      numInstances,\n      startIndices,\n      props,\n      transitions: props.transitions,\n      buffers: props.data.attributes,\n      context: this,\n      ignoreUnknownAttributes: true\n    });\n    const changedAttributes = attributeManager.getChangedAttributes({\n      clearChangedFlags: true\n    });\n    this.updateAttributes(changedAttributes);\n  }\n\n  _updateAttributeTransition() {\n    const attributeManager = this.getAttributeManager();\n\n    if (attributeManager) {\n      attributeManager.updateTransition();\n    }\n  }\n\n  _updateUniformTransition() {\n    const {\n      uniformTransitions\n    } = this.internalState;\n\n    if (uniformTransitions.active) {\n      const propsInTransition = uniformTransitions.update();\n      const props = Object.create(this.props);\n\n      for (const key in propsInTransition) {\n        Object.defineProperty(props, key, {\n          value: propsInTransition[key]\n        });\n      }\n\n      return props;\n    }\n\n    return this.props;\n  }\n\n  calculateInstancePickingColors(attribute, _ref7) {\n    let {\n      numInstances\n    } = _ref7;\n\n    if (attribute.constant) {\n      return;\n    }\n\n    const cacheSize = Math.floor(pickingColorCache.length / 3);\n    this.internalState.usesPickingColorCache = true;\n\n    if (cacheSize < numInstances) {\n      if (numInstances > MAX_PICKING_COLOR_CACHE_SIZE) {\n        log.warn('Layer has too many data objects. Picking might not be able to distinguish all objects.')();\n      }\n\n      pickingColorCache = typedArrayManager.allocate(pickingColorCache, numInstances, {\n        size: 3,\n        copy: true,\n        maxCount: Math.max(numInstances, MAX_PICKING_COLOR_CACHE_SIZE)\n      });\n      const newCacheSize = Math.floor(pickingColorCache.length / 3);\n      const pickingColor = [];\n\n      for (let i = cacheSize; i < newCacheSize; i++) {\n        this.encodePickingColor(i, pickingColor);\n        pickingColorCache[i * 3 + 0] = pickingColor[0];\n        pickingColorCache[i * 3 + 1] = pickingColor[1];\n        pickingColorCache[i * 3 + 2] = pickingColor[2];\n      }\n    }\n\n    attribute.value = pickingColorCache.subarray(0, numInstances * 3);\n  }\n\n  _setModelAttributes(model, changedAttributes) {\n    const attributeManager = this.getAttributeManager();\n    const excludeAttributes = model.userData.excludeAttributes || {};\n    const shaderAttributes = attributeManager.getShaderAttributes(changedAttributes, excludeAttributes);\n    model.setAttributes(shaderAttributes);\n  }\n\n  disablePickingIndex(objectIndex) {\n    this._disablePickingIndex(objectIndex);\n  }\n\n  _disablePickingIndex(objectIndex) {\n    const {\n      pickingColors,\n      instancePickingColors\n    } = this.getAttributeManager().attributes;\n    const colors = pickingColors || instancePickingColors;\n    const start = colors.getVertexOffset(objectIndex);\n    const end = colors.getVertexOffset(objectIndex + 1);\n    colors.buffer.subData({\n      data: new Uint8Array(end - start),\n      offset: start\n    });\n  }\n\n  restorePickingColors() {\n    const {\n      pickingColors,\n      instancePickingColors\n    } = this.getAttributeManager().attributes;\n    const colors = pickingColors || instancePickingColors;\n\n    if (this.internalState.usesPickingColorCache && colors.value.buffer !== pickingColorCache.buffer) {\n      colors.value = pickingColorCache.subarray(0, colors.value.length);\n    }\n\n    colors.updateSubBuffer({\n      startOffset: 0\n    });\n  }\n\n  getNumInstances(props) {\n    props = props || this.props;\n\n    if (props.numInstances !== undefined) {\n      return props.numInstances;\n    }\n\n    if (this.state && this.state.numInstances !== undefined) {\n      return this.state.numInstances;\n    }\n\n    return count(props.data);\n  }\n\n  getStartIndices(props) {\n    props = props || this.props;\n\n    if (props.startIndices !== undefined) {\n      return props.startIndices;\n    }\n\n    if (this.state && this.state.startIndices) {\n      return this.state.startIndices;\n    }\n\n    return null;\n  }\n\n  _initialize() {\n    debug(TRACE_INITIALIZE, this);\n\n    this._initState();\n\n    this.initializeState(this.context);\n\n    for (const extension of this.props.extensions) {\n      extension.initializeState.call(this, this.context, extension);\n    }\n\n    this.setChangeFlags({\n      dataChanged: true,\n      propsChanged: true,\n      viewportChanged: true,\n      extensionsChanged: true\n    });\n\n    this._updateState();\n  }\n\n  _update() {\n    const stateNeedsUpdate = this.needsUpdate();\n    debug(TRACE_UPDATE, this, stateNeedsUpdate);\n\n    if (stateNeedsUpdate) {\n      this._updateState();\n    }\n  }\n\n  _updateState() {\n    const currentProps = this.props;\n    const currentViewport = this.context.viewport;\n\n    const propsInTransition = this._updateUniformTransition();\n\n    this.internalState.propsInTransition = propsInTransition;\n    this.context.viewport = this.internalState.viewport || currentViewport;\n    this.props = propsInTransition;\n\n    try {\n      const updateParams = this._getUpdateParams();\n\n      const oldModels = this.getModels();\n\n      if (this.context.gl) {\n        this.updateState(updateParams);\n      } else {\n        try {\n          this.updateState(updateParams);\n        } catch (error) {}\n      }\n\n      for (const extension of this.props.extensions) {\n        extension.updateState.call(this, updateParams, extension);\n      }\n\n      const modelChanged = this.getModels()[0] !== oldModels[0];\n\n      this._updateModules(updateParams, modelChanged);\n\n      if (this.isComposite) {\n        this._renderLayers(updateParams);\n      } else {\n        this.setNeedsRedraw();\n\n        this._updateAttributes(this.props);\n\n        if (this.state.model) {\n          this.state.model.setInstanceCount(this.getNumInstances());\n        }\n      }\n    } finally {\n      this.context.viewport = currentViewport;\n      this.props = currentProps;\n      this.clearChangeFlags();\n      this.internalState.needsUpdate = false;\n      this.internalState.resetOldProps();\n    }\n  }\n\n  _finalize() {\n    debug(TRACE_FINALIZE, this);\n    this.finalizeState(this.context);\n\n    for (const extension of this.props.extensions) {\n      extension.finalizeState.call(this, extension);\n    }\n  }\n\n  drawLayer(_ref8) {\n    let {\n      moduleParameters = null,\n      uniforms = {},\n      parameters = {}\n    } = _ref8;\n\n    this._updateAttributeTransition();\n\n    const currentProps = this.props;\n    this.props = this.internalState.propsInTransition || currentProps;\n    const {\n      opacity\n    } = this.props;\n    uniforms.opacity = Math.pow(opacity, 1 / 2.2);\n\n    try {\n      if (moduleParameters) {\n        this.setModuleParameters(moduleParameters);\n      }\n\n      const {\n        getPolygonOffset\n      } = this.props;\n      const offsets = getPolygonOffset && getPolygonOffset(uniforms) || [0, 0];\n      setParameters(this.context.gl, {\n        polygonOffset: offsets\n      });\n      withParameters(this.context.gl, parameters, () => {\n        const opts = {\n          moduleParameters,\n          uniforms,\n          parameters,\n          context: this.context\n        };\n\n        for (const extension of this.props.extensions) {\n          extension.draw.call(this, opts, extension);\n        }\n\n        this.draw(opts);\n      });\n    } finally {\n      this.props = currentProps;\n    }\n  }\n\n  getChangeFlags() {\n    return this.internalState.changeFlags;\n  }\n\n  setChangeFlags(flags) {\n    const {\n      changeFlags\n    } = this.internalState;\n\n    for (const key in flags) {\n      if (flags[key]) {\n        let flagChanged = false;\n\n        switch (key) {\n          case 'dataChanged':\n            if (Array.isArray(changeFlags[key])) {\n              changeFlags[key] = Array.isArray(flags[key]) ? changeFlags[key].concat(flags[key]) : flags[key];\n              flagChanged = true;\n            }\n\n          default:\n            if (!changeFlags[key]) {\n              changeFlags[key] = flags[key];\n              flagChanged = true;\n            }\n\n        }\n\n        if (flagChanged) {\n          debug(TRACE_CHANGE_FLAG, this, key, flags);\n        }\n      }\n    }\n\n    const propsOrDataChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged || changeFlags.propsChanged || changeFlags.extensionsChanged;\n    changeFlags.propsOrDataChanged = propsOrDataChanged;\n    changeFlags.somethingChanged = propsOrDataChanged || flags.viewportChanged || flags.stateChanged;\n  }\n\n  clearChangeFlags() {\n    this.internalState.changeFlags = {\n      dataChanged: false,\n      propsChanged: false,\n      updateTriggersChanged: false,\n      viewportChanged: false,\n      stateChanged: false,\n      extensionsChanged: false,\n      propsOrDataChanged: false,\n      somethingChanged: false\n    };\n  }\n\n  diffProps(newProps, oldProps) {\n    const changeFlags = diffProps(newProps, oldProps);\n\n    if (changeFlags.updateTriggersChanged) {\n      for (const key in changeFlags.updateTriggersChanged) {\n        if (changeFlags.updateTriggersChanged[key]) {\n          this.invalidateAttribute(key);\n        }\n      }\n    }\n\n    if (changeFlags.transitionsChanged) {\n      for (const key in changeFlags.transitionsChanged) {\n        this.internalState.uniformTransitions.add(key, oldProps[key], newProps[key], newProps.transitions[key]);\n      }\n    }\n\n    return this.setChangeFlags(changeFlags);\n  }\n\n  validateProps() {\n    validateProps(this.props);\n  }\n\n  setModuleParameters(moduleParameters) {\n    for (const model of this.getModels()) {\n      model.updateModuleSettings(moduleParameters);\n    }\n  }\n\n  updateAutoHighlight(info) {\n    if (this.props.autoHighlight) {\n      this._updateAutoHighlight(info);\n    }\n  }\n\n  _updateAutoHighlight(info) {\n    const pickingModuleParameters = {\n      pickingSelectedColor: info.picked ? info.color : null\n    };\n    const {\n      highlightColor\n    } = this.props;\n\n    if (info.picked && typeof highlightColor === 'function') {\n      pickingModuleParameters.pickingHighlightColor = highlightColor(info);\n    }\n\n    this.setModuleParameters(pickingModuleParameters);\n    this.setNeedsRedraw();\n  }\n\n  _updateModules(_ref9, forceUpdate) {\n    let {\n      props,\n      oldProps\n    } = _ref9;\n    const {\n      autoHighlight,\n      highlightedObjectIndex,\n      highlightColor\n    } = props;\n\n    if (forceUpdate || oldProps.autoHighlight !== autoHighlight || oldProps.highlightedObjectIndex !== highlightedObjectIndex || oldProps.highlightColor !== highlightColor) {\n      const parameters = {};\n\n      if (!autoHighlight) {\n        parameters.pickingSelectedColor = null;\n      }\n\n      if (Array.isArray(highlightColor)) {\n        parameters.pickingHighlightColor = highlightColor;\n      }\n\n      if (Number.isInteger(highlightedObjectIndex)) {\n        parameters.pickingSelectedColor = highlightedObjectIndex >= 0 ? this.encodePickingColor(highlightedObjectIndex) : null;\n      }\n\n      this.setModuleParameters(parameters);\n    }\n  }\n\n  _getUpdateParams() {\n    return {\n      props: this.props,\n      oldProps: this.internalState.getOldProps(),\n      context: this.context,\n      changeFlags: this.internalState.changeFlags\n    };\n  }\n\n  _getNeedsRedraw(opts) {\n    if (!this.internalState) {\n      return false;\n    }\n\n    let redraw = false;\n    redraw = redraw || this.internalState.needsRedraw && this.id;\n    this.internalState.needsRedraw = this.internalState.needsRedraw && !opts.clearRedrawFlags;\n    const attributeManager = this.getAttributeManager();\n    const attributeManagerNeedsRedraw = attributeManager && attributeManager.getNeedsRedraw(opts);\n    redraw = redraw || attributeManagerNeedsRedraw;\n    return redraw;\n  }\n\n  _getAttributeManager() {\n    return new AttributeManager(this.context.gl, {\n      id: this.props.id,\n      stats: this.context.stats,\n      timeline: this.context.timeline\n    });\n  }\n\n  _initState() {\n    assert(!this.internalState && !this.state);\n    assert(isFinite(this.props.coordinateSystem));\n\n    const attributeManager = this._getAttributeManager();\n\n    if (attributeManager) {\n      attributeManager.addInstanced({\n        instancePickingColors: {\n          type: 5121,\n          size: 3,\n          noAlloc: true,\n          update: this.calculateInstancePickingColors\n        }\n      });\n    }\n\n    this.internalState = new LayerState({\n      attributeManager,\n      layer: this\n    });\n    this.clearChangeFlags();\n    this.state = {};\n    Object.defineProperty(this.state, 'attributeManager', {\n      get: () => {\n        log.deprecated('layer.state.attributeManager', 'layer.getAttributeManager()');\n        return attributeManager;\n      }\n    });\n    this.internalState.layer = this;\n    this.internalState.uniformTransitions = new UniformTransitionManager(this.context.timeline);\n    this.internalState.onAsyncPropUpdated = this._onAsyncPropUpdated.bind(this);\n    this.internalState.setAsyncProps(this.props);\n  }\n\n  _transferState(oldLayer) {\n    debug(TRACE_MATCHED, this, this === oldLayer);\n    const {\n      state,\n      internalState\n    } = oldLayer;\n\n    if (this === oldLayer) {\n      return;\n    }\n\n    this.internalState = internalState;\n    this.internalState.layer = this;\n    this.state = state;\n    this.internalState.setAsyncProps(this.props);\n    this.diffProps(this.props, this.internalState.getOldProps());\n  }\n\n  _onAsyncPropUpdated() {\n    this.diffProps(this.props, this.internalState.getOldProps());\n    this.setNeedsUpdate();\n  }\n\n}\nLayer.layerName = 'Layer';\nLayer.defaultProps = defaultProps;","map":{"version":3,"sources":["../../../src/lib/layer.js"],"names":["TRACE_CHANGE_FLAG","TRACE_INITIALIZE","TRACE_UPDATE","TRACE_FINALIZE","TRACE_MATCHED","MAX_PICKING_COLOR_CACHE_SIZE","EMPTY_ARRAY","Object","areViewportsEqual","memoize","viewport","oldViewport","pickingColorCache","defaultProps","data","type","value","async","dataComparator","_dataDiff","compare","optional","dataTransform","onDataLoad","onError","fetch","signal","resourceManager","layer","loadOptions","loaders","inResourceManager","resourceId","load","persistent","onChange","consumerId","requestId","propName","updateTriggers","visible","pickable","opacity","min","max","onHover","onClick","onDragStart","onDrag","onDragEnd","coordinateSystem","COORDINATE_SYSTEM","coordinateOrigin","modelMatrix","wrapLongitude","positionFormat","colorFormat","parameters","transitions","extensions","getPolygonOffset","layerIndex","highlightedObjectIndex","autoHighlight","highlightColor","toString","className","raiseError","error","setState","stateChanged","setNeedsRedraw","redraw","setNeedsUpdate","String","getNeedsRedraw","opts","clearRedrawFlags","needsUpdate","hasUniformTransition","isLoaded","isPickable","getModels","getAttributeManager","getCurrentLayer","getLoadOptions","project","worldPosition","getWorldPosition","worldToPixels","xyz","unproject","projectPosition","use64bitPositions","nullPickingColor","encodePickingColor","target","i","decodePickingColor","assert","color","index","i1","i2","i3","initializeState","getShaders","shaders","mergeShaders","extension","shouldUpdateState","changeFlags","updateState","attributeManager","dataChanged","Array","neededPickingBuffer","oldProps","needPickingBuffer","props","instancePickingColors","pickingColorsAttribute","pickingColors","finalizeState","model","id","draw","getPickingInfo","mode","info","activateViewport","viewportChanged","invalidateAttribute","name","diffReason","updateAttributes","_updateAttributes","numInstances","startIndices","buffers","context","ignoreUnknownAttributes","changedAttributes","clearChangedFlags","_updateAttributeTransition","_updateUniformTransition","uniformTransitions","propsInTransition","calculateInstancePickingColors","attribute","cacheSize","Math","log","size","copy","maxCount","newCacheSize","pickingColor","_setModelAttributes","excludeAttributes","shaderAttributes","disablePickingIndex","_disablePickingIndex","colors","start","end","objectIndex","offset","restorePickingColors","startOffset","getNumInstances","count","getStartIndices","_initialize","debug","propsChanged","extensionsChanged","_update","stateNeedsUpdate","_updateState","currentProps","currentViewport","updateParams","oldModels","modelChanged","_finalize","drawLayer","moduleParameters","uniforms","offsets","setParameters","polygonOffset","withParameters","getChangeFlags","setChangeFlags","flags","flagChanged","propsOrDataChanged","clearChangeFlags","updateTriggersChanged","somethingChanged","diffProps","newProps","validateProps","setModuleParameters","updateAutoHighlight","_updateAutoHighlight","pickingModuleParameters","pickingSelectedColor","_updateModules","forceUpdate","Number","_getUpdateParams","_getNeedsRedraw","attributeManagerNeedsRedraw","_getAttributeManager","stats","timeline","_initState","isFinite","noAlloc","update","get","_transferState","internalState","_onAsyncPropUpdated","Layer"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/* eslint-disable react/no-direct-mutation-state */\nimport {COORDINATE_SYSTEM} from './constants';\nimport AttributeManager from './attribute/attribute-manager';\nimport UniformTransitionManager from './uniform-transition-manager';\nimport {diffProps, validateProps} from '../lifecycle/props';\nimport {count} from '../utils/count';\nimport log from '../utils/log';\nimport debug from '../debug';\nimport GL from '@luma.gl/constants';\nimport {withParameters, setParameters} from '@luma.gl/core';\nimport assert from '../utils/assert';\nimport memoize from '../utils/memoize';\nimport {mergeShaders} from '../utils/shader';\nimport {projectPosition, getWorldPosition} from '../shaderlib/project/project-functions';\nimport typedArrayManager from '../utils/typed-array-manager';\n\nimport Component from '../lifecycle/component';\nimport LayerState from './layer-state';\n\nimport {worldToPixels} from '@math.gl/web-mercator';\n\nimport {load} from '@loaders.gl/core';\n\nconst TRACE_CHANGE_FLAG = 'layer.changeFlag';\nconst TRACE_INITIALIZE = 'layer.initialize';\nconst TRACE_UPDATE = 'layer.update';\nconst TRACE_FINALIZE = 'layer.finalize';\nconst TRACE_MATCHED = 'layer.matched';\n\nconst MAX_PICKING_COLOR_CACHE_SIZE = 2 ** 24 - 1;\n\nconst EMPTY_ARRAY = Object.freeze([]);\n\n// Only compare the same two viewports once\nconst areViewportsEqual = memoize(({oldViewport, viewport}) => {\n  return oldViewport.equals(viewport);\n});\n\nlet pickingColorCache = new Uint8ClampedArray(0);\n\nconst defaultProps = {\n  // data: Special handling for null, see below\n  data: {type: 'data', value: EMPTY_ARRAY, async: true},\n  dataComparator: null,\n  _dataDiff: {type: 'function', value: data => data && data.__diff, compare: false, optional: true},\n  dataTransform: {type: 'function', value: null, compare: false, optional: true},\n  onDataLoad: {type: 'function', value: null, compare: false, optional: true},\n  onError: {type: 'function', value: null, compare: false, optional: true},\n  fetch: {\n    type: 'function',\n    value: (url, {propName, layer, loaders, loadOptions, signal}) => {\n      const {resourceManager} = layer.context;\n      loadOptions = loadOptions || layer.getLoadOptions();\n      loaders = loaders || layer.props.loaders;\n      if (signal) {\n        loadOptions = {\n          ...loadOptions,\n          fetch: {\n            ...loadOptions?.fetch,\n            signal\n          }\n        };\n      }\n\n      let inResourceManager = resourceManager.contains(url);\n\n      if (!inResourceManager && !loadOptions) {\n        // If there is no layer-specific load options, then attempt to cache this resource in the data manager\n        resourceManager.add({resourceId: url, data: load(url, loaders), persistent: false});\n        inResourceManager = true;\n      }\n      if (inResourceManager) {\n        return resourceManager.subscribe({\n          resourceId: url,\n          onChange: data => layer.internalState.reloadAsyncProp(propName, data),\n          consumerId: layer.id,\n          requestId: propName\n        });\n      }\n\n      return load(url, loaders, loadOptions);\n    },\n    compare: false\n  },\n  updateTriggers: {}, // Update triggers: a core change detection mechanism in deck.gl\n\n  visible: true,\n  pickable: false,\n  opacity: {type: 'number', min: 0, max: 1, value: 1},\n\n  onHover: {type: 'function', value: null, compare: false, optional: true},\n  onClick: {type: 'function', value: null, compare: false, optional: true},\n  onDragStart: {type: 'function', value: null, compare: false, optional: true},\n  onDrag: {type: 'function', value: null, compare: false, optional: true},\n  onDragEnd: {type: 'function', value: null, compare: false, optional: true},\n\n  coordinateSystem: COORDINATE_SYSTEM.DEFAULT,\n  coordinateOrigin: {type: 'array', value: [0, 0, 0], compare: true},\n  modelMatrix: {type: 'array', value: null, compare: true, optional: true},\n  wrapLongitude: false,\n  positionFormat: 'XYZ',\n  colorFormat: 'RGBA',\n\n  parameters: {},\n  transitions: null,\n  extensions: [],\n  loaders: {type: 'array', value: [], optional: true, compare: true},\n\n  // Offset depth based on layer index to avoid z-fighting.\n  // Negative values pull layer towards the camera\n  // https://www.opengl.org/archives/resources/faq/technical/polygonoffset.htm\n  getPolygonOffset: {\n    type: 'function',\n    value: ({layerIndex}) => [0, -layerIndex * 100],\n    compare: false\n  },\n\n  // Selection/Highlighting\n  highlightedObjectIndex: -1,\n  autoHighlight: false,\n  highlightColor: {type: 'accessor', value: [0, 0, 128, 128]}\n};\n\nexport default class Layer extends Component {\n  toString() {\n    const className = this.constructor.layerName || this.constructor.name;\n    return `${className}({id: '${this.props.id}'})`;\n  }\n\n  raiseError(error, message) {\n    if (message) {\n      error.message = `${message}: ${error.message}`;\n    }\n    if (!this.props.onError?.(error)) {\n      this.context?.onError?.(error, this);\n    }\n  }\n\n  // Public API\n\n  // Updates selected state members and marks the object for redraw\n  setState(updateObject) {\n    this.setChangeFlags({stateChanged: true});\n    Object.assign(this.state, updateObject);\n    this.setNeedsRedraw();\n  }\n\n  // Sets the redraw flag for this layer, will trigger a redraw next animation frame\n  setNeedsRedraw(redraw = true) {\n    if (this.internalState) {\n      this.internalState.needsRedraw = redraw;\n    }\n  }\n\n  // This layer needs a deep update\n  setNeedsUpdate() {\n    this.context.layerManager.setNeedsUpdate(String(this));\n    this.internalState.needsUpdate = true;\n  }\n\n  // Checks state of attributes and model\n  getNeedsRedraw(opts = {clearRedrawFlags: false}) {\n    return this._getNeedsRedraw(opts);\n  }\n\n  // Checks if layer attributes needs updating\n  needsUpdate() {\n    // Call subclass lifecycle method\n    return (\n      this.internalState.needsUpdate ||\n      this.hasUniformTransition() ||\n      this.shouldUpdateState(this._getUpdateParams())\n    );\n    // End lifecycle method\n  }\n\n  hasUniformTransition() {\n    return this.internalState.uniformTransitions.active;\n  }\n\n  get isLoaded() {\n    return this.internalState && !this.internalState.isAsyncPropLoading();\n  }\n\n  get wrapLongitude() {\n    return this.props.wrapLongitude;\n  }\n\n  // Returns true if the layer is pickable and visible.\n  isPickable() {\n    return this.props.pickable && this.props.visible;\n  }\n\n  // Return an array of models used by this layer, can be overriden by layer subclass\n  getModels() {\n    return this.state && (this.state.models || (this.state.model ? [this.state.model] : []));\n  }\n\n  getAttributeManager() {\n    return this.internalState && this.internalState.attributeManager;\n  }\n\n  // Returns the most recent layer that matched to this state\n  // (When reacting to an async event, this layer may no longer be the latest)\n  getCurrentLayer() {\n    return this.internalState && this.internalState.layer;\n  }\n\n  // Returns the default parse options for async props\n  getLoadOptions() {\n    return this.props.loadOptions;\n  }\n\n  // PROJECTION METHODS\n\n  // Projects a point with current map state (lat, lon, zoom, pitch, bearing)\n  // From the current layer's coordinate system to screen\n  project(xyz) {\n    const {viewport} = this.context;\n    const worldPosition = getWorldPosition(xyz, {\n      viewport,\n      modelMatrix: this.props.modelMatrix,\n      coordinateOrigin: this.props.coordinateOrigin,\n      coordinateSystem: this.props.coordinateSystem\n    });\n    const [x, y, z] = worldToPixels(worldPosition, viewport.pixelProjectionMatrix);\n    return xyz.length === 2 ? [x, y] : [x, y, z];\n  }\n\n  // Note: this does not reverse `project`.\n  // Always unprojects to the viewport's coordinate system\n  unproject(xy) {\n    const {viewport} = this.context;\n    return viewport.unproject(xy);\n  }\n\n  projectPosition(xyz) {\n    return projectPosition(xyz, {\n      viewport: this.context.viewport,\n      modelMatrix: this.props.modelMatrix,\n      coordinateOrigin: this.props.coordinateOrigin,\n      coordinateSystem: this.props.coordinateSystem\n    });\n  }\n\n  use64bitPositions() {\n    const {coordinateSystem} = this.props;\n    return (\n      coordinateSystem === COORDINATE_SYSTEM.DEFAULT ||\n      coordinateSystem === COORDINATE_SYSTEM.LNGLAT ||\n      coordinateSystem === COORDINATE_SYSTEM.CARTESIAN\n    );\n  }\n\n  // Event handling\n  onHover(info, pickingEvent) {\n    if (this.props.onHover) {\n      return this.props.onHover(info, pickingEvent);\n    }\n    return false;\n  }\n\n  onClick(info, pickingEvent) {\n    if (this.props.onClick) {\n      return this.props.onClick(info, pickingEvent);\n    }\n    return false;\n  }\n\n  // Returns the picking color that doesn't match any subfeature\n  // Use if some graphics do not belong to any pickable subfeature\n  // @return {Array} - a black color\n  nullPickingColor() {\n    return [0, 0, 0];\n  }\n\n  // Returns the picking color that doesn't match any subfeature\n  // Use if some graphics do not belong to any pickable subfeature\n  encodePickingColor(i, target = []) {\n    target[0] = (i + 1) & 255;\n    target[1] = ((i + 1) >> 8) & 255;\n    target[2] = (((i + 1) >> 8) >> 8) & 255;\n    return target;\n  }\n\n  // Returns the index corresponding to a picking color that doesn't match any subfeature\n  // @param {Uint8Array} color - color array to be decoded\n  // @return {Array} - the decoded picking color\n  decodePickingColor(color) {\n    assert(color instanceof Uint8Array);\n    const [i1, i2, i3] = color;\n    // 1 was added to seperate from no selection\n    const index = i1 + i2 * 256 + i3 * 65536 - 1;\n    return index;\n  }\n\n  // //////////////////////////////////////////////////\n  // LIFECYCLE METHODS, overridden by the layer subclasses\n\n  // Called once to set up the initial state\n  // App can create WebGL resources\n  initializeState() {\n    throw new Error(`Layer ${this} has not defined initializeState`);\n  }\n\n  getShaders(shaders) {\n    for (const extension of this.props.extensions) {\n      shaders = mergeShaders(shaders, extension.getShaders.call(this, extension));\n    }\n    return shaders;\n  }\n\n  // Let's layer control if updateState should be called\n  shouldUpdateState({oldProps, props, context, changeFlags}) {\n    return changeFlags.propsOrDataChanged;\n  }\n\n  // Default implementation, all attributes will be invalidated and updated\n  // when data changes\n  /* eslint-disable-next-line complexity */\n  updateState({oldProps, props, context, changeFlags}) {\n    const attributeManager = this.getAttributeManager();\n    if (changeFlags.dataChanged && attributeManager) {\n      const {dataChanged} = changeFlags;\n      if (Array.isArray(dataChanged)) {\n        // is partial update\n        for (const dataRange of dataChanged) {\n          attributeManager.invalidateAll(dataRange);\n        }\n      } else {\n        attributeManager.invalidateAll();\n      }\n    }\n\n    const neededPickingBuffer = oldProps.highlightedObjectIndex >= 0 || oldProps.pickable;\n    const needPickingBuffer = props.highlightedObjectIndex >= 0 || props.pickable;\n    if (neededPickingBuffer !== needPickingBuffer && attributeManager) {\n      const {pickingColors, instancePickingColors} = attributeManager.attributes;\n      const pickingColorsAttribute = pickingColors || instancePickingColors;\n      if (pickingColorsAttribute) {\n        if (needPickingBuffer && pickingColorsAttribute.constant) {\n          pickingColorsAttribute.constant = false;\n          attributeManager.invalidate(pickingColorsAttribute.id);\n        }\n        if (!pickingColorsAttribute.value && !needPickingBuffer) {\n          pickingColorsAttribute.constant = true;\n          pickingColorsAttribute.value = [0, 0, 0];\n        }\n      }\n    }\n  }\n\n  // Called once when layer is no longer matched and state will be discarded\n  // App can destroy WebGL resources here\n  finalizeState() {\n    for (const model of this.getModels()) {\n      model.delete();\n    }\n    const attributeManager = this.getAttributeManager();\n    if (attributeManager) {\n      attributeManager.finalize();\n    }\n    this.context.resourceManager.unsubscribe({consumerId: this.id});\n    this.internalState.uniformTransitions.clear();\n    this.internalState.finalize();\n  }\n\n  // If state has a model, draw it with supplied uniforms\n  draw(opts) {\n    for (const model of this.getModels()) {\n      model.draw(opts);\n    }\n  }\n\n  // called to populate the info object that is passed to the event handler\n  // @return null to cancel event\n  getPickingInfo({info, mode}) {\n    const {index} = info;\n\n    if (index >= 0) {\n      // If props.data is an indexable array, get the object\n      if (Array.isArray(this.props.data)) {\n        info.object = this.props.data[index];\n      }\n    }\n\n    return info;\n  }\n\n  // END LIFECYCLE METHODS\n  // //////////////////////////////////////////////////\n\n  // INTERNAL METHODS\n  activateViewport(viewport) {\n    const oldViewport = this.internalState.viewport;\n    this.internalState.viewport = viewport;\n\n    if (!oldViewport || !areViewportsEqual({oldViewport, viewport})) {\n      this.setChangeFlags({viewportChanged: true});\n\n      if (this.isComposite) {\n        if (this.needsUpdate()) {\n          // Composite layers may add/remove sublayers on viewport change\n          // Because we cannot change the layers list during a draw cycle, we don't want to update sublayers right away\n          // This will not call update immediately, but mark the layerManager as needs update on the next frame\n          this.setNeedsUpdate();\n        }\n      } else {\n        this._update();\n      }\n    }\n  }\n\n  // Default implementation of attribute invalidation, can be redefined\n  invalidateAttribute(name = 'all', diffReason = '') {\n    const attributeManager = this.getAttributeManager();\n    if (!attributeManager) {\n      return;\n    }\n\n    if (name === 'all') {\n      attributeManager.invalidateAll();\n    } else {\n      attributeManager.invalidate(name);\n    }\n  }\n\n  updateAttributes(changedAttributes) {\n    for (const model of this.getModels()) {\n      this._setModelAttributes(model, changedAttributes);\n    }\n  }\n\n  // Calls attribute manager to update any WebGL attributes\n  _updateAttributes(props) {\n    const attributeManager = this.getAttributeManager();\n    if (!attributeManager) {\n      return;\n    }\n\n    // Figure out data length\n    const numInstances = this.getNumInstances(props);\n    const startIndices = this.getStartIndices(props);\n\n    attributeManager.update({\n      data: props.data,\n      numInstances,\n      startIndices,\n      props,\n      transitions: props.transitions,\n      buffers: props.data.attributes,\n      context: this,\n      // Don't worry about non-attribute props\n      ignoreUnknownAttributes: true\n    });\n\n    const changedAttributes = attributeManager.getChangedAttributes({clearChangedFlags: true});\n    this.updateAttributes(changedAttributes);\n  }\n\n  // Update attribute transitions. This is called in drawLayer, no model updates required.\n  _updateAttributeTransition() {\n    const attributeManager = this.getAttributeManager();\n    if (attributeManager) {\n      attributeManager.updateTransition();\n    }\n  }\n\n  // Update uniform (prop) transitions. This is called in updateState, may result in model updates.\n  _updateUniformTransition() {\n    const {uniformTransitions} = this.internalState;\n    if (uniformTransitions.active) {\n      // clone props\n      const propsInTransition = uniformTransitions.update();\n      const props = Object.create(this.props);\n      for (const key in propsInTransition) {\n        Object.defineProperty(props, key, {value: propsInTransition[key]});\n      }\n      return props;\n    }\n    return this.props;\n  }\n\n  calculateInstancePickingColors(attribute, {numInstances}) {\n    if (attribute.constant) {\n      return;\n    }\n\n    // calculateInstancePickingColors always generates the same sequence.\n    // pickingColorCache saves the largest generated sequence for reuse\n    const cacheSize = Math.floor(pickingColorCache.length / 3);\n\n    // Record when using the picking buffer cache, so that layers can always point at the most recently allocated cache\n    this.internalState.usesPickingColorCache = true;\n\n    if (cacheSize < numInstances) {\n      if (numInstances > MAX_PICKING_COLOR_CACHE_SIZE) {\n        log.warn(\n          'Layer has too many data objects. Picking might not be able to distinguish all objects.'\n        )();\n      }\n\n      pickingColorCache = typedArrayManager.allocate(pickingColorCache, numInstances, {\n        size: 3,\n        copy: true,\n        maxCount: Math.max(numInstances, MAX_PICKING_COLOR_CACHE_SIZE)\n      });\n\n      // If the attribute is larger than the cache, resize the cache and populate the missing chunk\n      const newCacheSize = Math.floor(pickingColorCache.length / 3);\n      const pickingColor = [];\n      for (let i = cacheSize; i < newCacheSize; i++) {\n        this.encodePickingColor(i, pickingColor);\n        pickingColorCache[i * 3 + 0] = pickingColor[0];\n        pickingColorCache[i * 3 + 1] = pickingColor[1];\n        pickingColorCache[i * 3 + 2] = pickingColor[2];\n      }\n    }\n\n    attribute.value = pickingColorCache.subarray(0, numInstances * 3);\n  }\n\n  _setModelAttributes(model, changedAttributes) {\n    const attributeManager = this.getAttributeManager();\n    const excludeAttributes = model.userData.excludeAttributes || {};\n    const shaderAttributes = attributeManager.getShaderAttributes(\n      changedAttributes,\n      excludeAttributes\n    );\n\n    model.setAttributes(shaderAttributes);\n  }\n\n  // Sets the picking color at the specified index to null picking color. Used for multi-depth picking.\n  // This method may be overriden by layer implementations\n  disablePickingIndex(objectIndex) {\n    this._disablePickingIndex(objectIndex);\n  }\n\n  _disablePickingIndex(objectIndex) {\n    const {pickingColors, instancePickingColors} = this.getAttributeManager().attributes;\n    const colors = pickingColors || instancePickingColors;\n\n    const start = colors.getVertexOffset(objectIndex);\n    const end = colors.getVertexOffset(objectIndex + 1);\n\n    // Fill the sub buffer with 0s\n    colors.buffer.subData({\n      data: new Uint8Array(end - start),\n      offset: start // 1 byte per element\n    });\n  }\n\n  restorePickingColors() {\n    const {pickingColors, instancePickingColors} = this.getAttributeManager().attributes;\n    const colors = pickingColors || instancePickingColors;\n    // The picking color cache may have been freed and then reallocated. This ensures we read from the currently allocated cache.\n    if (\n      this.internalState.usesPickingColorCache &&\n      colors.value.buffer !== pickingColorCache.buffer\n    ) {\n      colors.value = pickingColorCache.subarray(0, colors.value.length);\n    }\n    colors.updateSubBuffer({startOffset: 0});\n  }\n\n  // Deduces numer of instances. Intention is to support:\n  // - Explicit setting of numInstances\n  // - Auto-deduction for ES6 containers that define a size member\n  // - Auto-deduction for Classic Arrays via the built-in length attribute\n  // - Auto-deduction via arrays\n  getNumInstances(props) {\n    props = props || this.props;\n\n    // First Check if app has provided an explicit value\n    if (props.numInstances !== undefined) {\n      return props.numInstances;\n    }\n\n    // Second check if the layer has set its own value\n    if (this.state && this.state.numInstances !== undefined) {\n      return this.state.numInstances;\n    }\n\n    // Use container library to get a count for any ES6 container or object\n    return count(props.data);\n  }\n\n  // Buffer layout describes how many attribute values are packed for each data object\n  // The default (null) is one value each object.\n  // Some data formats (e.g. paths, polygons) have various length. Their buffer layout\n  //  is in the form of [L0, L1, L2, ...]\n  getStartIndices(props) {\n    props = props || this.props;\n\n    // First Check if startIndices is provided as an explicit value\n    if (props.startIndices !== undefined) {\n      return props.startIndices;\n    }\n\n    // Second check if the layer has set its own value\n    if (this.state && this.state.startIndices) {\n      return this.state.startIndices;\n    }\n\n    return null;\n  }\n\n  // LAYER MANAGER API\n  // Should only be called by the deck.gl LayerManager class\n\n  // Called by layer manager when a new layer is found\n  /* eslint-disable max-statements */\n  _initialize() {\n    debug(TRACE_INITIALIZE, this);\n\n    this._initState();\n\n    // Call subclass lifecycle methods\n    this.initializeState(this.context);\n    // Initialize extensions\n    for (const extension of this.props.extensions) {\n      extension.initializeState.call(this, this.context, extension);\n    }\n    // End subclass lifecycle methods\n\n    // initializeState callback tends to clear state\n    this.setChangeFlags({\n      dataChanged: true,\n      propsChanged: true,\n      viewportChanged: true,\n      extensionsChanged: true\n    });\n\n    this._updateState();\n  }\n\n  // Called by layer manager\n  // if this layer is new (not matched with an existing layer) oldProps will be empty object\n  _update() {\n    // Call subclass lifecycle method\n    const stateNeedsUpdate = this.needsUpdate();\n    // End lifecycle method\n    debug(TRACE_UPDATE, this, stateNeedsUpdate);\n\n    if (stateNeedsUpdate) {\n      this._updateState();\n    }\n  }\n\n  // Common code for _initialize and _update\n  _updateState() {\n    const currentProps = this.props;\n    const currentViewport = this.context.viewport;\n    const propsInTransition = this._updateUniformTransition();\n    this.internalState.propsInTransition = propsInTransition;\n    // Overwrite this.context.viewport during update to use the last activated viewport on this layer\n    // In multi-view applications, a layer may only be drawn in one of the views\n    // Which would make the \"active\" viewport different from the shared context\n    this.context.viewport = this.internalState.viewport || currentViewport;\n    // Overwrite this.props during update to use in-transition prop values\n    this.props = propsInTransition;\n\n    try {\n      const updateParams = this._getUpdateParams();\n      const oldModels = this.getModels();\n\n      // Safely call subclass lifecycle methods\n      if (this.context.gl) {\n        this.updateState(updateParams);\n      } else {\n        try {\n          this.updateState(updateParams);\n        } catch (error) {\n          // ignore error if gl context is missing\n        }\n      }\n      // Execute extension updates\n      for (const extension of this.props.extensions) {\n        extension.updateState.call(this, updateParams, extension);\n      }\n\n      const modelChanged = this.getModels()[0] !== oldModels[0];\n      this._updateModules(updateParams, modelChanged);\n      // End subclass lifecycle methods\n\n      if (this.isComposite) {\n        // Render or update previously rendered sublayers\n        this._renderLayers(updateParams);\n      } else {\n        this.setNeedsRedraw();\n        // Add any subclass attributes\n        this._updateAttributes(this.props);\n\n        // Note: Automatic instance count update only works for single layers\n        if (this.state.model) {\n          this.state.model.setInstanceCount(this.getNumInstances());\n        }\n      }\n    } finally {\n      // Restore shared context\n      this.context.viewport = currentViewport;\n      this.props = currentProps;\n      this.clearChangeFlags();\n      this.internalState.needsUpdate = false;\n      this.internalState.resetOldProps();\n    }\n  }\n  /* eslint-enable max-statements */\n\n  // Called by manager when layer is about to be disposed\n  // Note: not guaranteed to be called on application shutdown\n  _finalize() {\n    debug(TRACE_FINALIZE, this);\n\n    // Call subclass lifecycle method\n    this.finalizeState(this.context);\n    // Finalize extensions\n    for (const extension of this.props.extensions) {\n      extension.finalizeState.call(this, extension);\n    }\n  }\n\n  // Calculates uniforms\n  drawLayer({moduleParameters = null, uniforms = {}, parameters = {}}) {\n    this._updateAttributeTransition();\n\n    const currentProps = this.props;\n    // Overwrite this.props during redraw to use in-transition prop values\n    // `internalState.propsInTransition` could be missing if `updateState` failed\n    this.props = this.internalState.propsInTransition || currentProps;\n\n    const {opacity} = this.props;\n    // apply gamma to opacity to make it visually \"linear\"\n    uniforms.opacity = Math.pow(opacity, 1 / 2.2);\n\n    try {\n      // TODO/ib - hack move to luma Model.draw\n      if (moduleParameters) {\n        this.setModuleParameters(moduleParameters);\n      }\n\n      // Apply polygon offset to avoid z-fighting\n      // TODO - move to draw-layers\n      const {getPolygonOffset} = this.props;\n      const offsets = (getPolygonOffset && getPolygonOffset(uniforms)) || [0, 0];\n\n      setParameters(this.context.gl, {polygonOffset: offsets});\n\n      // Call subclass lifecycle method\n      withParameters(this.context.gl, parameters, () => {\n        const opts = {moduleParameters, uniforms, parameters, context: this.context};\n\n        // extensions\n        for (const extension of this.props.extensions) {\n          extension.draw.call(this, opts, extension);\n        }\n\n        this.draw(opts);\n      });\n    } finally {\n      this.props = currentProps;\n    }\n\n    // End lifecycle method\n  }\n\n  // Helper methods\n  getChangeFlags() {\n    return this.internalState.changeFlags;\n  }\n\n  // Dirty some change flags, will be handled by updateLayer\n  /* eslint-disable complexity */\n  setChangeFlags(flags) {\n    const {changeFlags} = this.internalState;\n\n    /* eslint-disable no-fallthrough, max-depth */\n    for (const key in flags) {\n      if (flags[key]) {\n        let flagChanged = false;\n        switch (key) {\n          case 'dataChanged':\n            // changeFlags.dataChanged may be `false`, a string (reason) or an array of ranges\n            if (Array.isArray(changeFlags[key])) {\n              changeFlags[key] = Array.isArray(flags[key])\n                ? changeFlags[key].concat(flags[key])\n                : flags[key];\n              flagChanged = true;\n            }\n\n          default:\n            if (!changeFlags[key]) {\n              changeFlags[key] = flags[key];\n              flagChanged = true;\n            }\n        }\n        if (flagChanged) {\n          debug(TRACE_CHANGE_FLAG, this, key, flags);\n        }\n      }\n    }\n    /* eslint-enable no-fallthrough, max-depth */\n\n    // Update composite flags\n    const propsOrDataChanged =\n      changeFlags.dataChanged ||\n      changeFlags.updateTriggersChanged ||\n      changeFlags.propsChanged ||\n      changeFlags.extensionsChanged;\n    changeFlags.propsOrDataChanged = propsOrDataChanged;\n    changeFlags.somethingChanged =\n      propsOrDataChanged || flags.viewportChanged || flags.stateChanged;\n  }\n  /* eslint-enable complexity */\n\n  // Clear all changeFlags, typically after an update\n  clearChangeFlags() {\n    this.internalState.changeFlags = {\n      // Primary changeFlags, can be strings stating reason for change\n      dataChanged: false,\n      propsChanged: false,\n      updateTriggersChanged: false,\n      viewportChanged: false,\n      stateChanged: false,\n      extensionsChanged: false,\n\n      // Derived changeFlags\n      propsOrDataChanged: false,\n      somethingChanged: false\n    };\n  }\n\n  // Compares the layers props with old props from a matched older layer\n  // and extracts change flags that describe what has change so that state\n  // can be update correctly with minimal effort\n  diffProps(newProps, oldProps) {\n    const changeFlags = diffProps(newProps, oldProps);\n\n    // iterate over changedTriggers\n    if (changeFlags.updateTriggersChanged) {\n      for (const key in changeFlags.updateTriggersChanged) {\n        if (changeFlags.updateTriggersChanged[key]) {\n          this.invalidateAttribute(key);\n        }\n      }\n    }\n\n    // trigger uniform transitions\n    if (changeFlags.transitionsChanged) {\n      for (const key in changeFlags.transitionsChanged) {\n        // prop changed and transition is enabled\n        this.internalState.uniformTransitions.add(\n          key,\n          oldProps[key],\n          newProps[key],\n          newProps.transitions[key]\n        );\n      }\n    }\n\n    return this.setChangeFlags(changeFlags);\n  }\n\n  // Called by layer manager to validate props (in development)\n  validateProps() {\n    validateProps(this.props);\n  }\n\n  setModuleParameters(moduleParameters) {\n    for (const model of this.getModels()) {\n      model.updateModuleSettings(moduleParameters);\n    }\n  }\n\n  updateAutoHighlight(info) {\n    if (this.props.autoHighlight) {\n      this._updateAutoHighlight(info);\n    }\n  }\n\n  // May be overriden by classes\n  _updateAutoHighlight(info) {\n    const pickingModuleParameters = {\n      pickingSelectedColor: info.picked ? info.color : null\n    };\n    const {highlightColor} = this.props;\n    if (info.picked && typeof highlightColor === 'function') {\n      pickingModuleParameters.pickingHighlightColor = highlightColor(info);\n    }\n    this.setModuleParameters(pickingModuleParameters);\n    // setModuleParameters does not trigger redraw\n    this.setNeedsRedraw();\n  }\n\n  // PRIVATE METHODS\n  _updateModules({props, oldProps}, forceUpdate) {\n    // Picking module parameters\n    const {autoHighlight, highlightedObjectIndex, highlightColor} = props;\n    if (\n      forceUpdate ||\n      oldProps.autoHighlight !== autoHighlight ||\n      oldProps.highlightedObjectIndex !== highlightedObjectIndex ||\n      oldProps.highlightColor !== highlightColor\n    ) {\n      const parameters = {};\n      if (!autoHighlight) {\n        parameters.pickingSelectedColor = null;\n      }\n      if (Array.isArray(highlightColor)) {\n        parameters.pickingHighlightColor = highlightColor;\n      }\n\n      // highlightedObjectIndex will overwrite any settings from auto highlighting.\n      if (Number.isInteger(highlightedObjectIndex)) {\n        parameters.pickingSelectedColor =\n          highlightedObjectIndex >= 0 ? this.encodePickingColor(highlightedObjectIndex) : null;\n      }\n\n      this.setModuleParameters(parameters);\n    }\n  }\n\n  _getUpdateParams() {\n    return {\n      props: this.props,\n      oldProps: this.internalState.getOldProps(),\n      context: this.context,\n      changeFlags: this.internalState.changeFlags\n    };\n  }\n\n  // Checks state of attributes and model\n  _getNeedsRedraw(opts) {\n    // this method may be called by the render loop as soon a the layer\n    // has been created, so guard against uninitialized state\n    if (!this.internalState) {\n      return false;\n    }\n\n    let redraw = false;\n    redraw = redraw || (this.internalState.needsRedraw && this.id);\n    this.internalState.needsRedraw = this.internalState.needsRedraw && !opts.clearRedrawFlags;\n\n    // TODO - is attribute manager needed? - Model should be enough.\n    const attributeManager = this.getAttributeManager();\n    const attributeManagerNeedsRedraw = attributeManager && attributeManager.getNeedsRedraw(opts);\n    redraw = redraw || attributeManagerNeedsRedraw;\n\n    return redraw;\n  }\n\n  // Create new attribute manager\n  _getAttributeManager() {\n    return new AttributeManager(this.context.gl, {\n      id: this.props.id,\n      stats: this.context.stats,\n      timeline: this.context.timeline\n    });\n  }\n\n  _initState() {\n    assert(!this.internalState && !this.state); // finalized layer cannot be reused\n    assert(isFinite(this.props.coordinateSystem)); // invalid coordinateSystem\n\n    const attributeManager = this._getAttributeManager();\n\n    if (attributeManager) {\n      // All instanced layers get instancePickingColors attribute by default\n      // Their shaders can use it to render a picking scene\n      // TODO - this slightly slows down non instanced layers\n      attributeManager.addInstanced({\n        instancePickingColors: {\n          type: GL.UNSIGNED_BYTE,\n          size: 3,\n          noAlloc: true,\n          update: this.calculateInstancePickingColors\n        }\n      });\n    }\n\n    this.internalState = new LayerState({\n      attributeManager,\n      layer: this\n    });\n    this.clearChangeFlags(); // populate this.internalState.changeFlags\n\n    this.state = {};\n    // for backwards compatibility with older layers\n    // TODO - remove in next release\n    /* eslint-disable accessor-pairs */\n    Object.defineProperty(this.state, 'attributeManager', {\n      get: () => {\n        log.deprecated('layer.state.attributeManager', 'layer.getAttributeManager()');\n        return attributeManager;\n      }\n    });\n    /* eslint-enable accessor-pairs */\n\n    this.internalState.layer = this;\n    this.internalState.uniformTransitions = new UniformTransitionManager(this.context.timeline);\n    this.internalState.onAsyncPropUpdated = this._onAsyncPropUpdated.bind(this);\n\n    // Ensure any async props are updated\n    this.internalState.setAsyncProps(this.props);\n  }\n\n  // Called by layer manager to transfer state from an old layer\n  _transferState(oldLayer) {\n    debug(TRACE_MATCHED, this, this === oldLayer);\n\n    const {state, internalState} = oldLayer;\n\n    if (this === oldLayer) {\n      return;\n    }\n\n    // Move internalState\n    this.internalState = internalState;\n    this.internalState.layer = this;\n\n    // Move state\n    this.state = state;\n    // We keep the state ref on old layers to support async actions\n    // oldLayer.state = null;\n\n    // Ensure any async props are updated\n    this.internalState.setAsyncProps(this.props);\n\n    this.diffProps(this.props, this.internalState.getOldProps());\n  }\n\n  _onAsyncPropUpdated() {\n    this.diffProps(this.props, this.internalState.getOldProps());\n    this.setNeedsUpdate();\n  }\n}\n\nLayer.layerName = 'Layer';\nLayer.defaultProps = defaultProps;\n"]},"metadata":{},"sourceType":"module"}