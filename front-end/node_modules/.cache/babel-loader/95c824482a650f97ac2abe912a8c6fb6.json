{"ast":null,"code":"import { isWebGL2, assertWebGL2Context, withParameters, log } from '@luma.gl/gltools';\nimport { global } from 'probe.gl/env';\nimport Resource from './resource';\nimport Buffer from './buffer';\nimport { TEXTURE_FORMATS, DATA_FORMAT_CHANNELS, TYPE_SIZES, isFormatSupported, isLinearFilteringSupported } from './texture-formats';\nimport { assert } from '../utils/assert';\nimport { uid, isPowerOfTwo } from '../utils/utils';\nconst NPOT_MIN_FILTERS = [9729, 9728];\n\nconst WebGLBuffer = global.WebGLBuffer || function WebGLBuffer() {};\n\nexport default class Texture extends Resource {\n  static isSupported(gl) {\n    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const {\n      format,\n      linearFiltering\n    } = opts;\n    let supported = true;\n\n    if (format) {\n      supported = supported && isFormatSupported(gl, format);\n      supported = supported && (!linearFiltering || isLinearFilteringSupported(gl, format));\n    }\n\n    return supported;\n  }\n\n  constructor(gl, props) {\n    const {\n      id = uid('texture'),\n      handle,\n      target\n    } = props;\n    super(gl, {\n      id,\n      handle\n    });\n    this.target = target;\n    this.textureUnit = undefined;\n    this.loaded = false;\n    this.width = undefined;\n    this.height = undefined;\n    this.depth = undefined;\n    this.format = undefined;\n    this.type = undefined;\n    this.dataFormat = undefined;\n    this.border = undefined;\n    this.textureUnit = undefined;\n    this.mipmaps = undefined;\n  }\n\n  toString() {\n    return `Texture(${this.id},${this.width}x${this.height})`;\n  }\n\n  initialize() {\n    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let data = props.data;\n\n    if (data instanceof Promise) {\n      data.then(resolvedImageData => this.initialize(Object.assign({}, props, {\n        pixels: resolvedImageData,\n        data: resolvedImageData\n      })));\n      return this;\n    }\n\n    const isVideo = typeof HTMLVideoElement !== 'undefined' && data instanceof HTMLVideoElement;\n\n    if (isVideo && data.readyState < HTMLVideoElement.HAVE_METADATA) {\n      this._video = null;\n      data.addEventListener('loadeddata', () => this.initialize(props));\n      return this;\n    }\n\n    const {\n      pixels = null,\n      format = 6408,\n      border = 0,\n      recreate = false,\n      parameters = {},\n      pixelStore = {},\n      textureUnit = undefined\n    } = props;\n\n    if (!data) {\n      data = pixels;\n    }\n\n    let {\n      width,\n      height,\n      dataFormat,\n      type,\n      compressed = false,\n      mipmaps = true\n    } = props;\n    const {\n      depth = 0\n    } = props;\n    ({\n      width,\n      height,\n      compressed,\n      dataFormat,\n      type\n    } = this._deduceParameters({\n      format,\n      type,\n      dataFormat,\n      compressed,\n      data,\n      width,\n      height\n    }));\n    this.width = width;\n    this.height = height;\n    this.depth = depth;\n    this.format = format;\n    this.type = type;\n    this.dataFormat = dataFormat;\n    this.border = border;\n    this.textureUnit = textureUnit;\n\n    if (Number.isFinite(this.textureUnit)) {\n      this.gl.activeTexture(33984 + this.textureUnit);\n      this.gl.bindTexture(this.target, this.handle);\n    }\n\n    if (mipmaps && this._isNPOT()) {\n      log.warn(`texture: ${this} is Non-Power-Of-Two, disabling mipmaping`)();\n      mipmaps = false;\n\n      this._updateForNPOT(parameters);\n    }\n\n    this.mipmaps = mipmaps;\n    this.setImageData({\n      data,\n      width,\n      height,\n      depth,\n      format,\n      type,\n      dataFormat,\n      border,\n      mipmaps,\n      parameters: pixelStore,\n      compressed\n    });\n\n    if (mipmaps) {\n      this.generateMipmap();\n    }\n\n    this.setParameters(parameters);\n\n    if (recreate) {\n      this.data = data;\n    }\n\n    if (isVideo) {\n      this._video = {\n        video: data,\n        parameters,\n        lastTime: data.readyState >= HTMLVideoElement.HAVE_CURRENT_DATA ? data.currentTime : -1\n      };\n    }\n\n    return this;\n  }\n\n  update() {\n    if (this._video) {\n      const {\n        video,\n        parameters,\n        lastTime\n      } = this._video;\n\n      if (lastTime === video.currentTime || video.readyState < HTMLVideoElement.HAVE_CURRENT_DATA) {\n        return;\n      }\n\n      this.setSubImageData({\n        data: video,\n        parameters\n      });\n\n      if (this.mipmaps) {\n        this.generateMipmap();\n      }\n\n      this._video.lastTime = video.currentTime;\n    }\n  }\n\n  resize(_ref) {\n    let {\n      height,\n      width,\n      mipmaps = false\n    } = _ref;\n\n    if (width !== this.width || height !== this.height) {\n      return this.initialize({\n        width,\n        height,\n        format: this.format,\n        type: this.type,\n        dataFormat: this.dataFormat,\n        border: this.border,\n        mipmaps\n      });\n    }\n\n    return this;\n  }\n\n  generateMipmap() {\n    let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (this._isNPOT()) {\n      log.warn(`texture: ${this} is Non-Power-Of-Two, disabling mipmaping`)();\n      return this;\n    }\n\n    this.mipmaps = true;\n    this.gl.bindTexture(this.target, this.handle);\n    withParameters(this.gl, params, () => {\n      this.gl.generateMipmap(this.target);\n    });\n    this.gl.bindTexture(this.target, null);\n    return this;\n  }\n\n  setImageData(options) {\n    this._trackDeallocatedMemory('Texture');\n\n    const {\n      target = this.target,\n      pixels = null,\n      level = 0,\n      format = this.format,\n      border = this.border,\n      offset = 0,\n      parameters = {}\n    } = options;\n    let {\n      data = null,\n      type = this.type,\n      width = this.width,\n      height = this.height,\n      dataFormat = this.dataFormat,\n      compressed = false\n    } = options;\n\n    if (!data) {\n      data = pixels;\n    }\n\n    ({\n      type,\n      dataFormat,\n      compressed,\n      width,\n      height\n    } = this._deduceParameters({\n      format,\n      type,\n      dataFormat,\n      compressed,\n      data,\n      width,\n      height\n    }));\n    const {\n      gl\n    } = this;\n    gl.bindTexture(this.target, this.handle);\n    let dataType = null;\n    ({\n      data,\n      dataType\n    } = this._getDataType({\n      data,\n      compressed\n    }));\n    let gl2;\n    withParameters(this.gl, parameters, () => {\n      switch (dataType) {\n        case 'null':\n          gl.texImage2D(target, level, format, width, height, border, dataFormat, type, data);\n          break;\n\n        case 'typed-array':\n          gl.texImage2D(target, level, format, width, height, border, dataFormat, type, data, offset);\n          break;\n\n        case 'buffer':\n          gl2 = assertWebGL2Context(gl);\n          gl2.bindBuffer(35052, data.handle || data);\n          gl2.texImage2D(target, level, format, width, height, border, dataFormat, type, offset);\n          gl2.bindBuffer(35052, null);\n          break;\n\n        case 'browser-object':\n          if (isWebGL2(gl)) {\n            gl.texImage2D(target, level, format, width, height, border, dataFormat, type, data);\n          } else {\n            gl.texImage2D(target, level, format, dataFormat, type, data);\n          }\n\n          break;\n\n        case 'compressed':\n          for (const [levelIndex, levelData] of data.entries()) {\n            gl.compressedTexImage2D(target, levelIndex, levelData.format, levelData.width, levelData.height, border, levelData.data);\n          }\n\n          break;\n\n        default:\n          assert(false, 'Unknown image data type');\n      }\n    });\n\n    if (data && data.byteLength) {\n      this._trackAllocatedMemory(data.byteLength, 'Texture');\n    } else {\n      const channels = DATA_FORMAT_CHANNELS[this.dataFormat] || 4;\n      const channelSize = TYPE_SIZES[this.type] || 1;\n\n      this._trackAllocatedMemory(this.width * this.height * channels * channelSize, 'Texture');\n    }\n\n    this.loaded = true;\n    return this;\n  }\n\n  setSubImageData(_ref2) {\n    let {\n      target = this.target,\n      pixels = null,\n      data = null,\n      x = 0,\n      y = 0,\n      width = this.width,\n      height = this.height,\n      level = 0,\n      format = this.format,\n      type = this.type,\n      dataFormat = this.dataFormat,\n      compressed = false,\n      offset = 0,\n      border = this.border,\n      parameters = {}\n    } = _ref2;\n    ({\n      type,\n      dataFormat,\n      compressed,\n      width,\n      height\n    } = this._deduceParameters({\n      format,\n      type,\n      dataFormat,\n      compressed,\n      data,\n      width,\n      height\n    }));\n    assert(this.depth === 0, 'texSubImage not supported for 3D textures');\n\n    if (!data) {\n      data = pixels;\n    }\n\n    if (data && data.data) {\n      const ndarray = data;\n      data = ndarray.data;\n      width = ndarray.shape[0];\n      height = ndarray.shape[1];\n    }\n\n    if (data instanceof Buffer) {\n      data = data.handle;\n    }\n\n    this.gl.bindTexture(this.target, this.handle);\n    withParameters(this.gl, parameters, () => {\n      if (compressed) {\n        this.gl.compressedTexSubImage2D(target, level, x, y, width, height, format, data);\n      } else if (data === null) {\n        this.gl.texSubImage2D(target, level, x, y, width, height, dataFormat, type, null);\n      } else if (ArrayBuffer.isView(data)) {\n        this.gl.texSubImage2D(target, level, x, y, width, height, dataFormat, type, data, offset);\n      } else if (data instanceof WebGLBuffer) {\n        const gl2 = assertWebGL2Context(this.gl);\n        gl2.bindBuffer(35052, data);\n        gl2.texSubImage2D(target, level, x, y, width, height, dataFormat, type, offset);\n        gl2.bindBuffer(35052, null);\n      } else if (isWebGL2(this.gl)) {\n        const gl2 = assertWebGL2Context(this.gl);\n        gl2.texSubImage2D(target, level, x, y, width, height, dataFormat, type, data);\n      } else {\n        this.gl.texSubImage2D(target, level, x, y, dataFormat, type, data);\n      }\n    });\n    this.gl.bindTexture(this.target, null);\n  }\n\n  copyFramebuffer() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    log.error('Texture.copyFramebuffer({...}) is no logner supported, use copyToTexture(source, target, opts})')();\n    return null;\n  }\n\n  getActiveUnit() {\n    return this.gl.getParameter(34016) - 33984;\n  }\n\n  bind() {\n    let textureUnit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.textureUnit;\n    const {\n      gl\n    } = this;\n\n    if (textureUnit !== undefined) {\n      this.textureUnit = textureUnit;\n      gl.activeTexture(33984 + textureUnit);\n    }\n\n    gl.bindTexture(this.target, this.handle);\n    return textureUnit;\n  }\n\n  unbind() {\n    let textureUnit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.textureUnit;\n    const {\n      gl\n    } = this;\n\n    if (textureUnit !== undefined) {\n      this.textureUnit = textureUnit;\n      gl.activeTexture(33984 + textureUnit);\n    }\n\n    gl.bindTexture(this.target, null);\n    return textureUnit;\n  }\n\n  _getDataType(_ref3) {\n    let {\n      data,\n      compressed = false\n    } = _ref3;\n\n    if (compressed) {\n      return {\n        data,\n        dataType: 'compressed'\n      };\n    }\n\n    if (data === null) {\n      return {\n        data,\n        dataType: 'null'\n      };\n    }\n\n    if (ArrayBuffer.isView(data)) {\n      return {\n        data,\n        dataType: 'typed-array'\n      };\n    }\n\n    if (data instanceof Buffer) {\n      return {\n        data: data.handle,\n        dataType: 'buffer'\n      };\n    }\n\n    if (data instanceof WebGLBuffer) {\n      return {\n        data,\n        dataType: 'buffer'\n      };\n    }\n\n    return {\n      data,\n      dataType: 'browser-object'\n    };\n  }\n\n  _deduceParameters(opts) {\n    const {\n      format,\n      data\n    } = opts;\n    let {\n      width,\n      height,\n      dataFormat,\n      type,\n      compressed\n    } = opts;\n    const textureFormat = TEXTURE_FORMATS[format];\n    dataFormat = dataFormat || textureFormat && textureFormat.dataFormat;\n    type = type || textureFormat && textureFormat.types[0];\n    compressed = compressed || textureFormat && textureFormat.compressed;\n    ({\n      width,\n      height\n    } = this._deduceImageSize(data, width, height));\n    return {\n      dataFormat,\n      type,\n      compressed,\n      width,\n      height,\n      format,\n      data\n    };\n  }\n\n  _deduceImageSize(data, width, height) {\n    let size;\n\n    if (typeof ImageData !== 'undefined' && data instanceof ImageData) {\n      size = {\n        width: data.width,\n        height: data.height\n      };\n    } else if (typeof HTMLImageElement !== 'undefined' && data instanceof HTMLImageElement) {\n      size = {\n        width: data.naturalWidth,\n        height: data.naturalHeight\n      };\n    } else if (typeof HTMLCanvasElement !== 'undefined' && data instanceof HTMLCanvasElement) {\n      size = {\n        width: data.width,\n        height: data.height\n      };\n    } else if (typeof ImageBitmap !== 'undefined' && data instanceof ImageBitmap) {\n      size = {\n        width: data.width,\n        height: data.height\n      };\n    } else if (typeof HTMLVideoElement !== 'undefined' && data instanceof HTMLVideoElement) {\n      size = {\n        width: data.videoWidth,\n        height: data.videoHeight\n      };\n    } else if (!data) {\n      size = {\n        width: width >= 0 ? width : 1,\n        height: height >= 0 ? height : 1\n      };\n    } else {\n      size = {\n        width,\n        height\n      };\n    }\n\n    assert(size, 'Could not deduced texture size');\n    assert(width === undefined || size.width === width, 'Deduced texture width does not match supplied width');\n    assert(height === undefined || size.height === height, 'Deduced texture height does not match supplied height');\n    return size;\n  }\n\n  _createHandle() {\n    return this.gl.createTexture();\n  }\n\n  _deleteHandle() {\n    this.gl.deleteTexture(this.handle);\n\n    this._trackDeallocatedMemory('Texture');\n  }\n\n  _getParameter(pname) {\n    switch (pname) {\n      case 4096:\n        return this.width;\n\n      case 4097:\n        return this.height;\n\n      default:\n        this.gl.bindTexture(this.target, this.handle);\n        const value = this.gl.getTexParameter(this.target, pname);\n        this.gl.bindTexture(this.target, null);\n        return value;\n    }\n  }\n\n  _setParameter(pname, param) {\n    this.gl.bindTexture(this.target, this.handle);\n    param = this._getNPOTParam(pname, param);\n\n    switch (pname) {\n      case 33082:\n      case 33083:\n        this.gl.texParameterf(this.handle, pname, param);\n        break;\n\n      case 4096:\n      case 4097:\n        assert(false);\n        break;\n\n      default:\n        this.gl.texParameteri(this.target, pname, param);\n        break;\n    }\n\n    this.gl.bindTexture(this.target, null);\n    return this;\n  }\n\n  _isNPOT() {\n    if (isWebGL2(this.gl)) {\n      return false;\n    }\n\n    if (!this.width || !this.height) {\n      return false;\n    }\n\n    return !isPowerOfTwo(this.width) || !isPowerOfTwo(this.height);\n  }\n\n  _updateForNPOT(parameters) {\n    if (parameters[this.gl.TEXTURE_MIN_FILTER] === undefined) {\n      parameters[this.gl.TEXTURE_MIN_FILTER] = this.gl.LINEAR;\n    }\n\n    if (parameters[this.gl.TEXTURE_WRAP_S] === undefined) {\n      parameters[this.gl.TEXTURE_WRAP_S] = this.gl.CLAMP_TO_EDGE;\n    }\n\n    if (parameters[this.gl.TEXTURE_WRAP_T] === undefined) {\n      parameters[this.gl.TEXTURE_WRAP_T] = this.gl.CLAMP_TO_EDGE;\n    }\n  }\n\n  _getNPOTParam(pname, param) {\n    if (this._isNPOT()) {\n      switch (pname) {\n        case 10241:\n          if (NPOT_MIN_FILTERS.indexOf(param) === -1) {\n            param = 9729;\n          }\n\n          break;\n\n        case 10242:\n        case 10243:\n          if (param !== 33071) {\n            param = 33071;\n          }\n\n          break;\n\n        default:\n          break;\n      }\n    }\n\n    return param;\n  }\n\n}","map":{"version":3,"sources":["../../../src/classes/texture.js"],"names":["NPOT_MIN_FILTERS","WebGLBuffer","global","isSupported","opts","linearFiltering","supported","isFormatSupported","isLinearFilteringSupported","constructor","id","uid","target","handle","toString","width","height","initialize","props","data","resolvedImageData","pixels","isVideo","HTMLVideoElement","format","border","recreate","parameters","pixelStore","textureUnit","undefined","compressed","mipmaps","depth","type","Number","log","video","lastTime","update","resize","dataFormat","generateMipmap","params","withParameters","setImageData","level","offset","gl","dataType","gl2","assertWebGL2Context","isWebGL2","levelData","assert","channels","DATA_FORMAT_CHANNELS","channelSize","TYPE_SIZES","setSubImageData","x","y","ndarray","ArrayBuffer","copyFramebuffer","getActiveUnit","bind","unbind","_getDataType","_deduceParameters","textureFormat","TEXTURE_FORMATS","_deduceImageSize","size","naturalHeight","videoHeight","_createHandle","_deleteHandle","_getParameter","value","_setParameter","param","_isNPOT","isPowerOfTwo","_updateForNPOT","_getNPOTParam"],"mappings":"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","sourcesContent":["import GL from '@luma.gl/constants';\nimport {isWebGL2, assertWebGL2Context, withParameters, log} from '@luma.gl/gltools';\nimport {global} from 'probe.gl/env';\n\nimport Resource from './resource';\nimport Buffer from './buffer';\nimport {\n  TEXTURE_FORMATS,\n  DATA_FORMAT_CHANNELS,\n  TYPE_SIZES,\n  isFormatSupported,\n  isLinearFilteringSupported\n} from './texture-formats';\nimport {assert} from '../utils/assert';\nimport {uid, isPowerOfTwo} from '../utils/utils';\n\n// Supported min filters for NPOT texture.\nconst NPOT_MIN_FILTERS = [GL.LINEAR, GL.NEAREST];\n\n// Polyfill\n// Note (Tarek): Do we really need to support this API?\nconst WebGLBuffer = global.WebGLBuffer || function WebGLBuffer() {};\n\nexport default class Texture extends Resource {\n  static isSupported(gl, opts = {}) {\n    const {format, linearFiltering} = opts;\n    let supported = true;\n    if (format) {\n      supported = supported && isFormatSupported(gl, format);\n      supported = supported && (!linearFiltering || isLinearFilteringSupported(gl, format));\n    }\n    return supported;\n  }\n\n  // target cannot be modified by bind:\n  // textures are special because when you first bind them to a target,\n  // they get special information. When you first bind a texture as a\n  // GL_TEXTURE_2D, you are actually setting special state in the texture.\n  // You are saying that this texture is a 2D texture.\n  // And it will always be a 2D texture; this state cannot be changed ever.\n  // If you have a texture that was first bound as a GL_TEXTURE_2D,\n  // you must always bind it as a GL_TEXTURE_2D;\n  // attempting to bind it as GL_TEXTURE_1D will give rise to an error\n  // (while run-time).\n  constructor(gl, props) {\n    const {\n      id = uid('texture'),\n      handle,\n      target\n      // , magFilter, minFilter, wrapS, wrapT\n    } = props;\n\n    super(gl, {id, handle});\n\n    this.target = target;\n    this.textureUnit = undefined;\n\n    // Program.draw() checks the loaded flag of all textures to avoid\n    // Textures that are still loading from promises\n    // Set to true as soon as texture has been initialized with valid data\n    this.loaded = false;\n\n    this.width = undefined;\n    this.height = undefined;\n    this.depth = undefined;\n    this.format = undefined;\n    this.type = undefined;\n    this.dataFormat = undefined;\n    this.border = undefined;\n    this.textureUnit = undefined;\n    this.mipmaps = undefined;\n  }\n\n  toString() {\n    return `Texture(${this.id},${this.width}x${this.height})`;\n  }\n\n  /* eslint-disable max-len, max-statements */\n  initialize(props = {}) {\n    let data = props.data;\n\n    if (data instanceof Promise) {\n      data.then(resolvedImageData =>\n        this.initialize(\n          Object.assign({}, props, {\n            pixels: resolvedImageData,\n            data: resolvedImageData\n          })\n        )\n      );\n      return this;\n    }\n    const isVideo = typeof HTMLVideoElement !== 'undefined' && data instanceof HTMLVideoElement;\n    // @ts-ignore\n    if (isVideo && data.readyState < HTMLVideoElement.HAVE_METADATA) {\n      this._video = null; // Declare member before the object is sealed\n      data.addEventListener('loadeddata', () => this.initialize(props));\n      return this;\n    }\n\n    const {\n      pixels = null,\n      format = GL.RGBA,\n      border = 0,\n      recreate = false,\n      parameters = {},\n      pixelStore = {},\n      textureUnit = undefined\n    } = props;\n\n    // pixels variable is for API compatibility purpose\n    if (!data) {\n      // TODO - This looks backwards? Commenting out for now until we decide\n      // which prop to use\n      // log.deprecated('data', 'pixels')();\n      data = pixels;\n    }\n\n    let {width, height, dataFormat, type, compressed = false, mipmaps = true} = props;\n    const {depth = 0} = props;\n\n    // Deduce width and height\n    ({width, height, compressed, dataFormat, type} = this._deduceParameters({\n      format,\n      type,\n      dataFormat,\n      compressed,\n      data,\n      width,\n      height\n    }));\n\n    // Store opts for accessors\n    this.width = width;\n    this.height = height;\n    this.depth = depth;\n    this.format = format;\n    this.type = type;\n    this.dataFormat = dataFormat;\n    this.border = border;\n    this.textureUnit = textureUnit;\n\n    if (Number.isFinite(this.textureUnit)) {\n      this.gl.activeTexture(GL.TEXTURE0 + this.textureUnit);\n      this.gl.bindTexture(this.target, this.handle);\n    }\n\n    if (mipmaps && this._isNPOT()) {\n      log.warn(`texture: ${this} is Non-Power-Of-Two, disabling mipmaping`)();\n      mipmaps = false;\n\n      this._updateForNPOT(parameters);\n    }\n\n    this.mipmaps = mipmaps;\n\n    this.setImageData({\n      data,\n      width,\n      height,\n      depth,\n      format,\n      type,\n      dataFormat,\n      border,\n      mipmaps,\n      parameters: pixelStore,\n      compressed\n    });\n\n    if (mipmaps) {\n      this.generateMipmap();\n    }\n\n    // Set texture sampler parameters\n    this.setParameters(parameters);\n\n    // TODO - Store data to enable auto recreate on context loss\n    if (recreate) {\n      this.data = data;\n    }\n    if (isVideo) {\n      this._video = {\n        video: data,\n        parameters,\n        // @ts-ignore\n        lastTime: data.readyState >= HTMLVideoElement.HAVE_CURRENT_DATA ? data.currentTime : -1\n      };\n    }\n\n    return this;\n  }\n\n  update() {\n    if (this._video) {\n      const {video, parameters, lastTime} = this._video;\n      // @ts-ignore\n      if (lastTime === video.currentTime || video.readyState < HTMLVideoElement.HAVE_CURRENT_DATA) {\n        return;\n      }\n      this.setSubImageData({\n        data: video,\n        parameters\n      });\n      if (this.mipmaps) {\n        this.generateMipmap();\n      }\n      this._video.lastTime = video.currentTime;\n    }\n  }\n\n  // If size has changed, reinitializes with current format\n  // note clears image and mipmaps\n  resize({height, width, mipmaps = false}) {\n    if (width !== this.width || height !== this.height) {\n      return this.initialize({\n        width,\n        height,\n        format: this.format,\n        type: this.type,\n        dataFormat: this.dataFormat,\n        border: this.border,\n        mipmaps\n      });\n    }\n    return this;\n  }\n\n  // Call to regenerate mipmaps after modifying texture(s)\n  generateMipmap(params = {}) {\n    if (this._isNPOT()) {\n      log.warn(`texture: ${this} is Non-Power-Of-Two, disabling mipmaping`)();\n      return this;\n    }\n\n    this.mipmaps = true;\n\n    this.gl.bindTexture(this.target, this.handle);\n    withParameters(this.gl, params, () => {\n      this.gl.generateMipmap(this.target);\n    });\n    this.gl.bindTexture(this.target, null);\n    return this;\n  }\n\n  /*\n   * Allocates storage\n   * @param {*} pixels -\n   *  null - create empty texture of specified format\n   *  Typed array - init from image data in typed array\n   *  Buffer|WebGLBuffer - (WEBGL2) init from image data in WebGLBuffer\n   *  HTMLImageElement|Image - Inits with content of image. Auto width/height\n   *  HTMLCanvasElement - Inits with contents of canvas. Auto width/height\n   *  HTMLVideoElement - Creates video texture. Auto width/height\n   *\n   * @param {GLint} width -\n   * @param {GLint} height -\n   * @param {GLint} mipMapLevel -\n   * @param {GLenum} format - format of image data.\n   * @param {GLenum} type\n   *  - format of array (autodetect from type) or\n   *  - (WEBGL2) format of buffer\n   * @param {Number} offset - (WEBGL2) offset from start of buffer\n   * @param {GLint} border - must be 0.\n   * @parameters - temporary settings to be applied, can be used to supply pixel store settings.\n   */\n  /* eslint-disable max-len, max-statements, complexity */\n  setImageData(options) {\n    this._trackDeallocatedMemory('Texture');\n\n    const {\n      target = this.target,\n      pixels = null,\n      level = 0,\n      format = this.format,\n      border = this.border,\n      offset = 0,\n      parameters = {}\n    } = options;\n\n    let {\n      data = null,\n      type = this.type,\n      width = this.width,\n      height = this.height,\n      dataFormat = this.dataFormat,\n      compressed = false\n    } = options;\n\n    // pixels variable is  for API compatibility purpose\n    if (!data) {\n      data = pixels;\n    }\n\n    ({type, dataFormat, compressed, width, height} = this._deduceParameters({\n      format,\n      type,\n      dataFormat,\n      compressed,\n      data,\n      width,\n      height\n    }));\n\n    const {gl} = this;\n    gl.bindTexture(this.target, this.handle);\n\n    let dataType = null;\n    ({data, dataType} = this._getDataType({data, compressed}));\n\n    let gl2;\n\n    withParameters(this.gl, parameters, () => {\n      switch (dataType) {\n        case 'null':\n          gl.texImage2D(target, level, format, width, height, border, dataFormat, type, data);\n          break;\n        case 'typed-array':\n          // Looks like this assert is not necessary, as offset is ignored under WebGL1\n          // assert((offset === 0 || isWebGL2(gl)), 'offset supported in WebGL2 only');\n          // @ts-ignore\n          gl.texImage2D(\n            target,\n            level,\n            format,\n            width,\n            height,\n            border,\n            dataFormat,\n            type,\n            data,\n            // @ts-ignore\n            offset\n          );\n          break;\n        case 'buffer':\n          // WebGL2 enables creating textures directly from a WebGL buffer\n          gl2 = assertWebGL2Context(gl);\n          gl2.bindBuffer(GL.PIXEL_UNPACK_BUFFER, data.handle || data);\n          gl2.texImage2D(target, level, format, width, height, border, dataFormat, type, offset);\n          gl2.bindBuffer(GL.PIXEL_UNPACK_BUFFER, null);\n          break;\n        case 'browser-object':\n          if (isWebGL2(gl)) {\n            gl.texImage2D(target, level, format, width, height, border, dataFormat, type, data);\n          } else {\n            gl.texImage2D(target, level, format, dataFormat, type, data);\n          }\n          break;\n        case 'compressed':\n          for (const [levelIndex, levelData] of data.entries()) {\n            gl.compressedTexImage2D(\n              target,\n              levelIndex,\n              levelData.format,\n              levelData.width,\n              levelData.height,\n              border,\n              levelData.data\n            );\n          }\n\n          break;\n        default:\n          assert(false, 'Unknown image data type');\n      }\n    });\n\n    if (data && data.byteLength) {\n      this._trackAllocatedMemory(data.byteLength, 'Texture');\n    } else {\n      // NOTE(Tarek): Default to RGBA bytes\n      const channels = DATA_FORMAT_CHANNELS[this.dataFormat] || 4;\n      const channelSize = TYPE_SIZES[this.type] || 1;\n\n      this._trackAllocatedMemory(this.width * this.height * channels * channelSize, 'Texture');\n    }\n\n    this.loaded = true;\n\n    return this;\n  }\n  /* eslint-enable max-len, max-statements, complexity */\n\n  /**\n   * Redefines an area of an existing texture\n   * Note: does not allocate storage\n   */\n  /*\n   * Redefines an area of an existing texture\n   * @param {*} pixels, data -\n   *  null - create empty texture of specified format\n   *  Typed array - init from image data in typed array\n   *  Buffer|WebGLBuffer - (WEBGL2) init from image data in WebGLBuffer\n   *  HTMLImageElement|Image - Inits with content of image. Auto width/height\n   *  HTMLCanvasElement - Inits with contents of canvas. Auto width/height\n   *  HTMLVideoElement - Creates video texture. Auto width/height\n   *\n   * @param {GLint} x - xOffset from where texture to be updated\n   * @param {GLint} y - yOffset from where texture to be updated\n   * @param {GLint} width - width of the sub image to be updated\n   * @param {GLint} height - height of the sub image to be updated\n   * @param {GLint} level - mip level to be updated\n   * @param {GLenum} format - internal format of image data.\n   * @param {GLenum} type\n   *  - format of array (autodetect from type) or\n   *  - (WEBGL2) format of buffer or ArrayBufferView\n   * @param {GLenum} dataFormat - format of image data.\n   * @param {Number} offset - (WEBGL2) offset from start of buffer\n   * @param {GLint} border - must be 0.\n   * @parameters - temporary settings to be applied, can be used to supply pixel store settings.\n   */\n  setSubImageData({\n    target = this.target,\n    pixels = null,\n    data = null,\n    x = 0,\n    y = 0,\n    width = this.width,\n    height = this.height,\n    level = 0,\n    format = this.format,\n    type = this.type,\n    dataFormat = this.dataFormat,\n    compressed = false,\n    offset = 0,\n    border = this.border,\n    parameters = {}\n  }) {\n    ({type, dataFormat, compressed, width, height} = this._deduceParameters({\n      format,\n      type,\n      dataFormat,\n      compressed,\n      data,\n      width,\n      height\n    }));\n\n    assert(this.depth === 0, 'texSubImage not supported for 3D textures');\n\n    // pixels variable is  for API compatibility purpose\n    if (!data) {\n      data = pixels;\n    }\n\n    // Support ndarrays\n    if (data && data.data) {\n      const ndarray = data;\n      data = ndarray.data;\n      width = ndarray.shape[0];\n      height = ndarray.shape[1];\n    }\n\n    // Support buffers\n    if (data instanceof Buffer) {\n      data = data.handle;\n    }\n\n    this.gl.bindTexture(this.target, this.handle);\n\n    withParameters(this.gl, parameters, () => {\n      // TODO - x,y parameters\n      if (compressed) {\n        this.gl.compressedTexSubImage2D(target, level, x, y, width, height, format, data);\n      } else if (data === null) {\n        this.gl.texSubImage2D(target, level, x, y, width, height, dataFormat, type, null);\n      } else if (ArrayBuffer.isView(data)) {\n        // const gl2 = assertWebGL2Context(this.gl);\n        // @ts-ignore last offset parameter is ignored under WebGL1\n        this.gl.texSubImage2D(target, level, x, y, width, height, dataFormat, type, data, offset);\n      } else if (data instanceof WebGLBuffer) {\n        // WebGL2 allows us to create texture directly from a WebGL buffer\n        const gl2 = assertWebGL2Context(this.gl);\n        // This texImage2D signature uses currently bound GL.PIXEL_UNPACK_BUFFER\n        gl2.bindBuffer(GL.PIXEL_UNPACK_BUFFER, data);\n        gl2.texSubImage2D(target, level, x, y, width, height, dataFormat, type, offset);\n        gl2.bindBuffer(GL.PIXEL_UNPACK_BUFFER, null);\n      } else if (isWebGL2(this.gl)) {\n        // Assume data is a browser supported object (ImageData, Canvas, ...)\n        const gl2 = assertWebGL2Context(this.gl);\n        gl2.texSubImage2D(target, level, x, y, width, height, dataFormat, type, data);\n      } else {\n        this.gl.texSubImage2D(target, level, x, y, dataFormat, type, data);\n      }\n    });\n\n    this.gl.bindTexture(this.target, null);\n  }\n  /* eslint-enable max-len, max-statements, complexity */\n\n  /**\n   * Defines a two-dimensional texture image or cube-map texture image with\n   * pixels from the current framebuffer (rather than from client memory).\n   * (gl.copyTexImage2D wrapper)\n   *\n   * Note that binding a texture into a Framebuffer's color buffer and\n   * rendering can be faster.\n   */\n  copyFramebuffer(opts = {}) {\n    log.error(\n      'Texture.copyFramebuffer({...}) is no logner supported, use copyToTexture(source, target, opts})'\n    )();\n    return null;\n  }\n\n  getActiveUnit() {\n    return this.gl.getParameter(GL.ACTIVE_TEXTURE) - GL.TEXTURE0;\n  }\n\n  // target cannot be modified by bind:\n  // textures are special because when you first bind them to a target,\n  // they get special information. When you first bind a texture as a\n  // GL_TEXTURE_2D, you are actually setting special state in the texture.\n  // You are saying that this texture is a 2D texture.\n  // And it will always be a 2D texture; this state cannot be changed ever.\n  // If you have a texture that was first bound as a GL_TEXTURE_2D,\n  // you must always bind it as a GL_TEXTURE_2D;\n  // attempting to bind it as GL_TEXTURE_1D will give rise to an error\n  // (while run-time).\n\n  bind(textureUnit = this.textureUnit) {\n    const {gl} = this;\n\n    if (textureUnit !== undefined) {\n      this.textureUnit = textureUnit;\n      gl.activeTexture(gl.TEXTURE0 + textureUnit);\n    }\n\n    gl.bindTexture(this.target, this.handle);\n    return textureUnit;\n  }\n\n  unbind(textureUnit = this.textureUnit) {\n    const {gl} = this;\n\n    if (textureUnit !== undefined) {\n      this.textureUnit = textureUnit;\n      gl.activeTexture(gl.TEXTURE0 + textureUnit);\n    }\n\n    gl.bindTexture(this.target, null);\n    return textureUnit;\n  }\n\n  // PRIVATE METHODS\n\n  _getDataType({data, compressed = false}) {\n    if (compressed) {\n      return {data, dataType: 'compressed'};\n    }\n    if (data === null) {\n      return {data, dataType: 'null'};\n    }\n    if (ArrayBuffer.isView(data)) {\n      return {data, dataType: 'typed-array'};\n    }\n    if (data instanceof Buffer) {\n      return {data: data.handle, dataType: 'buffer'};\n    }\n    if (data instanceof WebGLBuffer) {\n      return {data, dataType: 'buffer'};\n    }\n    // Assume data is a browser supported object (ImageData, Canvas, ...)\n    return {data, dataType: 'browser-object'};\n  }\n\n  /* Copied from texture-2d.js\n  // WebGL2\n  setPixels(opts = {}) {\n    const {\n      buffer,\n      width = null,\n      height = null,\n      mipmapLevel = 0,\n      format = GL.RGBA,\n      type = GL.UNSIGNED_BYTE,\n      border = 0\n    } = opts;\n\n    const {gl} = this;\n\n    // This signature of texImage2D uses currently bound GL.PIXEL_UNPACK_BUFFER\n    gl.bindBuffer(GL.PIXEL_UNPACK_BUFFER, buffer.target);\n    // And as always, we must also bind the texture itself\n    this.bind();\n\n    gl.texImage2D(gl.TEXTURE_2D,\n      mipmapLevel, format, width, height, border, format, type, buffer.target);\n\n    this.unbind();\n    gl.bindBuffer(GL.GL.PIXEL_UNPACK_BUFFER, null);\n    return this;\n  }\n\n  setImageDataFromCompressedBuffer(opts) {\n    const {\n      buffer,\n      // offset = 0,\n      width = null,\n      height = null,\n      mipmapLevel = 0,\n      internalFormat = GL.RGBA,\n      // format = GL.RGBA,\n      // type = GL.UNSIGNED_BYTE,\n      border = 0\n    } = opts;\n\n    const {gl} = this;\n    gl.compressedTexImage2D(this.target,\n      mipmapLevel, internalFormat, width, height, border, buffer);\n    // gl.compressedTexSubImage2D(target,\n    //   level, xoffset, yoffset, width, height, format, ArrayBufferView? pixels);\n    return this;\n  }\n\n  copySubImage(opts) {\n    const {\n      // pixels,\n      // offset = 0,\n      // x,\n      // y,\n      // width,\n      // height,\n      // mipmapLevel = 0,\n      // internalFormat = GL.RGBA,\n      // type = GL.UNSIGNED_BYTE,\n      // border = 0\n    } = opts;\n\n    // if (pixels instanceof ArrayBufferView) {\n    //   gl.texSubImage2D(target, level, x, y, width, height, format, type, pixels);\n    // }\n    // gl.texSubImage2D(target, level, x, y, format, type, ? pixels);\n    // gl.texSubImage2D(target, level, x, y, format, type, HTMLImageElement pixels);\n    // gl.texSubImage2D(target, level, x, y, format, type, HTMLCanvasElement pixels);\n    // gl.texSubImage2D(target, level, x, y, format, type, HTMLVideoElement pixels);\n    // // Additional signature in a WebGL 2 context:\n    // gl.texSubImage2D(target, level, x, y, format, type, GLintptr offset);\n  }\n  */\n\n  // HELPER METHODS\n\n  _deduceParameters(opts) {\n    const {format, data} = opts;\n    let {width, height, dataFormat, type, compressed} = opts;\n\n    // Deduce format and type from format\n    const textureFormat = TEXTURE_FORMATS[format];\n    dataFormat = dataFormat || (textureFormat && textureFormat.dataFormat);\n    type = type || (textureFormat && textureFormat.types[0]);\n\n    // Deduce compression from format\n    compressed = compressed || (textureFormat && textureFormat.compressed);\n\n    ({width, height} = this._deduceImageSize(data, width, height));\n\n    return {dataFormat, type, compressed, width, height, format, data};\n  }\n\n  // eslint-disable-next-line complexity\n  _deduceImageSize(data, width, height) {\n    let size;\n\n    if (typeof ImageData !== 'undefined' && data instanceof ImageData) {\n      size = {width: data.width, height: data.height};\n    } else if (typeof HTMLImageElement !== 'undefined' && data instanceof HTMLImageElement) {\n      size = {width: data.naturalWidth, height: data.naturalHeight};\n    } else if (typeof HTMLCanvasElement !== 'undefined' && data instanceof HTMLCanvasElement) {\n      size = {width: data.width, height: data.height};\n    } else if (typeof ImageBitmap !== 'undefined' && data instanceof ImageBitmap) {\n      size = {width: data.width, height: data.height};\n    } else if (typeof HTMLVideoElement !== 'undefined' && data instanceof HTMLVideoElement) {\n      size = {width: data.videoWidth, height: data.videoHeight};\n    } else if (!data) {\n      size = {width: width >= 0 ? width : 1, height: height >= 0 ? height : 1};\n    } else {\n      size = {width, height};\n    }\n\n    assert(size, 'Could not deduced texture size');\n    assert(\n      width === undefined || size.width === width,\n      'Deduced texture width does not match supplied width'\n    );\n    assert(\n      height === undefined || size.height === height,\n      'Deduced texture height does not match supplied height'\n    );\n\n    return size;\n  }\n\n  // RESOURCE METHODS\n\n  _createHandle() {\n    return this.gl.createTexture();\n  }\n\n  _deleteHandle() {\n    this.gl.deleteTexture(this.handle);\n    this._trackDeallocatedMemory('Texture');\n  }\n\n  _getParameter(pname) {\n    switch (pname) {\n      case GL.TEXTURE_WIDTH:\n        return this.width;\n      case GL.TEXTURE_HEIGHT:\n        return this.height;\n      default:\n        this.gl.bindTexture(this.target, this.handle);\n        const value = this.gl.getTexParameter(this.target, pname);\n        this.gl.bindTexture(this.target, null);\n        return value;\n    }\n  }\n\n  _setParameter(pname, param) {\n    this.gl.bindTexture(this.target, this.handle);\n\n    // NOTE: Apply NPOT workaround\n    param = this._getNPOTParam(pname, param);\n\n    // Apparently there are some integer/float conversion rules that made\n    // the WebGL committe expose two parameter setting functions in JavaScript.\n    // For now, pick the float version for parameters specified as GLfloat.\n    switch (pname) {\n      case GL.TEXTURE_MIN_LOD:\n      case GL.TEXTURE_MAX_LOD:\n        this.gl.texParameterf(this.handle, pname, param);\n        break;\n\n      case GL.TEXTURE_WIDTH:\n      case GL.TEXTURE_HEIGHT:\n        assert(false);\n        break;\n\n      default:\n        this.gl.texParameteri(this.target, pname, param);\n        break;\n    }\n\n    this.gl.bindTexture(this.target, null);\n    return this;\n  }\n\n  _isNPOT() {\n    if (isWebGL2(this.gl)) {\n      // NPOT restriction is only for WebGL1\n      return false;\n    }\n    // Width and height not available, consider it is not NPOT texture\n    if (!this.width || !this.height) {\n      return false;\n    }\n    return !isPowerOfTwo(this.width) || !isPowerOfTwo(this.height);\n  }\n\n  // Update default settings which are not supported by NPOT textures.\n  _updateForNPOT(parameters) {\n    if (parameters[this.gl.TEXTURE_MIN_FILTER] === undefined) {\n      // log.warn(`texture: ${this} is Non-Power-Of-Two, forcing TEXTURE_MIN_FILTER to LINEAR`)();\n      parameters[this.gl.TEXTURE_MIN_FILTER] = this.gl.LINEAR;\n    }\n    if (parameters[this.gl.TEXTURE_WRAP_S] === undefined) {\n      // log.warn(`texture: ${this} is Non-Power-Of-Two, forcing TEXTURE_WRAP_S to CLAMP_TO_EDGE`)();\n      parameters[this.gl.TEXTURE_WRAP_S] = this.gl.CLAMP_TO_EDGE;\n    }\n    if (parameters[this.gl.TEXTURE_WRAP_T] === undefined) {\n      // log.warn(`texture: ${this} is Non-Power-Of-Two, forcing TEXTURE_WRAP_T to CLAMP_TO_EDGE`)();\n      parameters[this.gl.TEXTURE_WRAP_T] = this.gl.CLAMP_TO_EDGE;\n    }\n  }\n\n  _getNPOTParam(pname, param) {\n    if (this._isNPOT()) {\n      switch (pname) {\n        case GL.TEXTURE_MIN_FILTER:\n          if (NPOT_MIN_FILTERS.indexOf(param) === -1) {\n            // log.warn(`texture: ${this} is Non-Power-Of-Two, forcing TEXTURE_MIN_FILTER to LINEAR`)();\n            param = GL.LINEAR;\n          }\n          break;\n        case GL.TEXTURE_WRAP_S:\n        case GL.TEXTURE_WRAP_T:\n          if (param !== GL.CLAMP_TO_EDGE) {\n            // log.warn(`texture: ${this} is Non-Power-Of-Two, ${getKey(this.gl, pname)} to CLAMP_TO_EDGE`)();\n            param = GL.CLAMP_TO_EDGE;\n          }\n          break;\n        default:\n          break;\n      }\n    }\n    return param;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}