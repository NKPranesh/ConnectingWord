{"ast":null,"code":"import { toHilbertQuadkey, FromHilbertQuadKey, IJToST, STToUV, FaceUVToXYZ, XYZToLngLat } from './s2-geometry';\nimport Long from 'long';\n\nfunction getIdFromToken(token) {\n  const paddedToken = token.padEnd(16, '0');\n  return Long.fromString(paddedToken, 16);\n}\n\nconst MAX_RESOLUTION = 100;\n\nfunction getGeoBounds(_ref) {\n  let {\n    face,\n    ij,\n    level\n  } = _ref;\n  const offsets = [[0, 0], [0, 1], [1, 1], [1, 0], [0, 0]];\n  const resolution = Math.max(1, Math.ceil(MAX_RESOLUTION * Math.pow(2, -level)));\n  const result = new Float64Array(4 * resolution * 2 + 2);\n  let ptIndex = 0;\n  let prevLng = 0;\n\n  for (let i = 0; i < 4; i++) {\n    const offset = offsets[i].slice(0);\n    const nextOffset = offsets[i + 1];\n    const stepI = (nextOffset[0] - offset[0]) / resolution;\n    const stepJ = (nextOffset[1] - offset[1]) / resolution;\n\n    for (let j = 0; j < resolution; j++) {\n      offset[0] += stepI;\n      offset[1] += stepJ;\n      const st = IJToST(ij, level, offset);\n      const uv = STToUV(st);\n      const xyz = FaceUVToXYZ(face, uv);\n      const lngLat = XYZToLngLat(xyz);\n\n      if (Math.abs(lngLat[1]) > 89.999) {\n        lngLat[0] = prevLng;\n      }\n\n      const deltaLng = lngLat[0] - prevLng;\n      lngLat[0] += deltaLng > 180 ? -360 : deltaLng < -180 ? 360 : 0;\n      result[ptIndex++] = lngLat[0];\n      result[ptIndex++] = lngLat[1];\n      prevLng = lngLat[0];\n    }\n  }\n\n  result[ptIndex++] = result[0];\n  result[ptIndex++] = result[1];\n  return result;\n}\n\nexport function getS2QuadKey(token) {\n  if (typeof token === 'string') {\n    if (token.indexOf('/') > 0) {\n      return token;\n    }\n\n    token = getIdFromToken(token);\n  }\n\n  return toHilbertQuadkey(token.toString());\n}\nexport function getS2Polygon(token) {\n  const key = getS2QuadKey(token);\n  const s2cell = FromHilbertQuadKey(key);\n  return getGeoBounds(s2cell);\n}","map":{"version":3,"sources":["../../../src/s2-layer/s2-utils.js"],"names":["paddedToken","token","Long","MAX_RESOLUTION","level","offsets","resolution","Math","result","ptIndex","prevLng","i","offset","nextOffset","stepI","stepJ","j","st","IJToST","uv","STToUV","xyz","FaceUVToXYZ","lngLat","XYZToLngLat","deltaLng","getIdFromToken","toHilbertQuadkey","key","getS2QuadKey","s2cell","FromHilbertQuadKey","getGeoBounds"],"mappings":"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","sourcesContent":["// s2-geometry is a pure JavaScript port of Google/Niantic's S2 Geometry library\n// which is perfect since it works in the browser.\nimport {\n  toHilbertQuadkey,\n  FromHilbertQuadKey,\n  IJToST,\n  STToUV,\n  FaceUVToXYZ,\n  XYZToLngLat\n} from './s2-geometry';\nimport Long from 'long';\n\n/**\n * Given an S2 token this function convert the token to 64 bit id\n   https://github.com/google/s2-geometry-library-java/blob/c04b68bf3197a9c34082327eeb3aec7ab7c85da1/src/com/google/common/geometry/S2CellId.java#L439\n * */\nfunction getIdFromToken(token) {\n  // pad token with zeros to make the length 16\n  const paddedToken = token.padEnd(16, '0');\n  return Long.fromString(paddedToken, 16);\n}\n\nconst MAX_RESOLUTION = 100;\n\n/* Adapted from s2-geometry's S2Cell.getCornerLatLngs */\n/* eslint-disable max-statements */\nfunction getGeoBounds({face, ij, level}) {\n  const offsets = [[0, 0], [0, 1], [1, 1], [1, 0], [0, 0]];\n\n  // The S2 cell edge is curved: http://s2geometry.io/\n  // This is more prominent at lower levels\n  // resolution is the number of segments to generate per edge.\n  // We exponentially reduce resolution as level increases so it doesn't affect perf\n  // when there are a large number of cells\n  const resolution = Math.max(1, Math.ceil(MAX_RESOLUTION * Math.pow(2, -level)));\n  const result = new Float64Array(4 * resolution * 2 + 2);\n  let ptIndex = 0;\n  let prevLng = 0;\n\n  for (let i = 0; i < 4; i++) {\n    const offset = offsets[i].slice(0);\n    const nextOffset = offsets[i + 1];\n    const stepI = (nextOffset[0] - offset[0]) / resolution;\n    const stepJ = (nextOffset[1] - offset[1]) / resolution;\n\n    for (let j = 0; j < resolution; j++) {\n      offset[0] += stepI;\n      offset[1] += stepJ;\n      // Cell can be represented by coordinates IJ, ST, UV, XYZ\n      // http://s2geometry.io/devguide/s2cell_hierarchy#coordinate-systems\n      const st = IJToST(ij, level, offset);\n      const uv = STToUV(st);\n      const xyz = FaceUVToXYZ(face, uv);\n      const lngLat = XYZToLngLat(xyz);\n\n      // Adjust longitude for Web Mercator projection\n      if (Math.abs(lngLat[1]) > 89.999) {\n        lngLat[0] = prevLng;\n      }\n      const deltaLng = lngLat[0] - prevLng;\n      lngLat[0] += deltaLng > 180 ? -360 : deltaLng < -180 ? 360 : 0;\n\n      result[ptIndex++] = lngLat[0];\n      result[ptIndex++] = lngLat[1];\n      prevLng = lngLat[0];\n    }\n  }\n  // close the loop\n  result[ptIndex++] = result[0];\n  result[ptIndex++] = result[1];\n  return result;\n}\n/* eslint-enable max-statements */\n\nexport function getS2QuadKey(token) {\n  if (typeof token === 'string') {\n    if (token.indexOf('/') > 0) {\n      // is Hilbert quad key\n      return token;\n    }\n    // is S2 token\n    token = getIdFromToken(token);\n  }\n  // is Long id\n  return toHilbertQuadkey(token.toString());\n}\n\n/**\n * Get a polygon with corner coordinates for an s2 cell\n * @param {*} cell - This can be an S2 key or token\n * @return {Array} - a simple polygon in array format: [[lng, lat], ...]\n *   - each coordinate is an array [lng, lat]\n *   - the polygon is closed, i.e. last coordinate is a copy of the first coordinate\n */\nexport function getS2Polygon(token) {\n  const key = getS2QuadKey(token);\n  const s2cell = FromHilbertQuadKey(key);\n\n  return getGeoBounds(s2cell);\n}\n"]},"metadata":{},"sourceType":"module"}