{"ast":null,"code":"export function binaryToFeatureForAccesor(data, index) {\n  if (!data) {\n    return null;\n  }\n\n  const featureIndex = 'startIndices' in data ? data.startIndices[index] : index;\n  const geometryIndex = data.featureIds.value[featureIndex];\n\n  if (featureIndex !== -1) {\n    return getPropertiesForIndex(data, geometryIndex, featureIndex);\n  }\n\n  return null;\n}\n\nfunction getPropertiesForIndex(data, propertiesIndex, numericPropsIndex) {\n  const feature = {\n    properties: { ...data.properties[propertiesIndex]\n    }\n  };\n\n  for (const prop in data.numericProps) {\n    feature.properties[prop] = data.numericProps[prop].value[numericPropsIndex];\n  }\n\n  return feature;\n}\n\nexport function calculatePickingColors(geojsonBinary, encodePickingColor) {\n  const pickingColors = {\n    points: null,\n    lines: null,\n    polygons: null\n  };\n\n  for (const key in pickingColors) {\n    const featureIds = geojsonBinary[key].globalFeatureIds.value;\n    pickingColors[key] = new Uint8ClampedArray(featureIds.length * 3);\n    const pickingColor = [];\n\n    for (let i = 0; i < featureIds.length; i++) {\n      encodePickingColor(featureIds[i], pickingColor);\n      pickingColors[key][i * 3 + 0] = pickingColor[0];\n      pickingColors[key][i * 3 + 1] = pickingColor[1];\n      pickingColors[key][i * 3 + 2] = pickingColor[2];\n    }\n  }\n\n  return pickingColors;\n}","map":{"version":3,"sources":["../../../src/geojson-layer/geojson-binary.js"],"names":["featureIndex","data","geometryIndex","getPropertiesForIndex","feature","properties","pickingColors","points","lines","polygons","featureIds","geojsonBinary","pickingColor","i","encodePickingColor"],"mappings":"AAUA,OAAO,SAAA,yBAAA,CAAA,IAAA,EAAA,KAAA,EAAgD;AACrD,MAAI,CAAJ,IAAA,EAAW;AACT,WAAA,IAAA;AACD;;AAED,QAAMA,YAAY,GAAG,kBAAA,IAAA,GAAyBC,IAAI,CAAJA,YAAAA,CAAzB,KAAyBA,CAAzB,GAArB,KAAA;AACA,QAAMC,aAAa,GAAGD,IAAI,CAAJA,UAAAA,CAAAA,KAAAA,CAAtB,YAAsBA,CAAtB;;AAEA,MAAID,YAAY,KAAK,CAArB,CAAA,EAAyB;AACvB,WAAOG,qBAAqB,CAAA,IAAA,EAAA,aAAA,EAA5B,YAA4B,CAA5B;AACD;;AAED,SAAA,IAAA;AACD;;AAED,SAAA,qBAAA,CAAA,IAAA,EAAA,eAAA,EAAA,iBAAA,EAAyE;AACvE,QAAMC,OAAO,GAAG;AACdC,IAAAA,UAAU,EAAE,EAAC,GAAGJ,IAAI,CAAJA,UAAAA,CAAAA,eAAAA;AAAJ;AADE,GAAhB;;AAIA,OAAK,MAAL,IAAA,IAAmBA,IAAI,CAAvB,YAAA,EAAsC;AACpCG,IAAAA,OAAO,CAAPA,UAAAA,CAAAA,IAAAA,IAA2BH,IAAI,CAAJA,YAAAA,CAAAA,IAAAA,EAAAA,KAAAA,CAA3BG,iBAA2BH,CAA3BG;AACD;;AAED,SAAA,OAAA;AACD;;AAGD,OAAO,SAAA,sBAAA,CAAA,aAAA,EAAA,kBAAA,EAAmE;AACxE,QAAME,aAAa,GAAG;AACpBC,IAAAA,MAAM,EADc,IAAA;AAEpBC,IAAAA,KAAK,EAFe,IAAA;AAGpBC,IAAAA,QAAQ,EAAE;AAHU,GAAtB;;AAKA,OAAK,MAAL,GAAA,IAAA,aAAA,EAAiC;AAC/B,UAAMC,UAAU,GAAGC,aAAa,CAAbA,GAAa,CAAbA,CAAAA,gBAAAA,CAAnB,KAAA;AACAL,IAAAA,aAAa,CAAbA,GAAa,CAAbA,GAAqB,IAAA,iBAAA,CAAsBI,UAAU,CAAVA,MAAAA,GAA3CJ,CAAqB,CAArBA;AACA,UAAMM,YAAY,GAAlB,EAAA;;AACA,SAAK,IAAIC,CAAC,GAAV,CAAA,EAAgBA,CAAC,GAAGH,UAAU,CAA9B,MAAA,EAAuCG,CAAvC,EAAA,EAA4C;AAC1CC,MAAAA,kBAAkB,CAACJ,UAAU,CAAX,CAAW,CAAX,EAAlBI,YAAkB,CAAlBA;AACAR,MAAAA,aAAa,CAAbA,GAAa,CAAbA,CAAmBO,CAAC,GAADA,CAAAA,GAAnBP,CAAAA,IAAgCM,YAAY,CAA5CN,CAA4C,CAA5CA;AACAA,MAAAA,aAAa,CAAbA,GAAa,CAAbA,CAAmBO,CAAC,GAADA,CAAAA,GAAnBP,CAAAA,IAAgCM,YAAY,CAA5CN,CAA4C,CAA5CA;AACAA,MAAAA,aAAa,CAAbA,GAAa,CAAbA,CAAmBO,CAAC,GAADA,CAAAA,GAAnBP,CAAAA,IAAgCM,YAAY,CAA5CN,CAA4C,CAA5CA;AACD;AACF;;AAED,SAAA,aAAA;AACD","sourcesContent":["// This module implement some utility functions to work with\n// the geojson-binary format defined at loaders.gl:\n// https://github.com/visgl/loaders.gl/blob/master/modules/gis/docs/api-reference/geojson-to-binary.md\n\n/**\n * Return the feature for an accesor\n *\n * @param {Object} data - The data in binary format\n * @param {Number} index - The requested index\n */\nexport function binaryToFeatureForAccesor(data, index) {\n  if (!data) {\n    return null;\n  }\n\n  const featureIndex = 'startIndices' in data ? data.startIndices[index] : index;\n  const geometryIndex = data.featureIds.value[featureIndex];\n\n  if (featureIndex !== -1) {\n    return getPropertiesForIndex(data, geometryIndex, featureIndex);\n  }\n\n  return null;\n}\n\nfunction getPropertiesForIndex(data, propertiesIndex, numericPropsIndex) {\n  const feature = {\n    properties: {...data.properties[propertiesIndex]}\n  };\n\n  for (const prop in data.numericProps) {\n    feature.properties[prop] = data.numericProps[prop].value[numericPropsIndex];\n  }\n\n  return feature;\n}\n\n// Custom picking color to keep binary indexes\nexport function calculatePickingColors(geojsonBinary, encodePickingColor) {\n  const pickingColors = {\n    points: null,\n    lines: null,\n    polygons: null\n  };\n  for (const key in pickingColors) {\n    const featureIds = geojsonBinary[key].globalFeatureIds.value;\n    pickingColors[key] = new Uint8ClampedArray(featureIds.length * 3);\n    const pickingColor = [];\n    for (let i = 0; i < featureIds.length; i++) {\n      encodePickingColor(featureIds[i], pickingColor);\n      pickingColors[key][i * 3 + 0] = pickingColor[0];\n      pickingColors[key][i * 3 + 1] = pickingColor[1];\n      pickingColors[key][i * 3 + 2] = pickingColor[2];\n    }\n  }\n\n  return pickingColors;\n}\n"]},"metadata":{},"sourceType":"module"}