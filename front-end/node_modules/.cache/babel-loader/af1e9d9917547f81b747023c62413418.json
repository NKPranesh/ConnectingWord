{"ast":null,"code":"import { getMeshBoundingBox } from '@loaders.gl/schema';\nimport Martini from '@mapbox/martini';\nimport Delatin from './delatin';\nimport { addSkirt } from './helpers/skirt';\n\nfunction getTerrain(imageData, width, height, elevationDecoder, tesselator) {\n  const {\n    rScaler,\n    bScaler,\n    gScaler,\n    offset\n  } = elevationDecoder;\n  const terrain = new Float32Array((width + 1) * (height + 1));\n\n  for (let i = 0, y = 0; y < height; y++) {\n    for (let x = 0; x < width; x++, i++) {\n      const k = i * 4;\n      const r = imageData[k + 0];\n      const g = imageData[k + 1];\n      const b = imageData[k + 2];\n      terrain[i + y] = r * rScaler + g * gScaler + b * bScaler + offset;\n    }\n  }\n\n  if (tesselator === 'martini') {\n    for (let i = (width + 1) * width, x = 0; x < width; x++, i++) {\n      terrain[i] = terrain[i - width - 1];\n    }\n\n    for (let i = height, y = 0; y < height + 1; y++, i += height + 1) {\n      terrain[i] = terrain[i - 1];\n    }\n  }\n\n  return terrain;\n}\n\nfunction getMeshAttributes(vertices, terrain, width, height, bounds) {\n  const gridSize = width + 1;\n  const numOfVerticies = vertices.length / 2;\n  const positions = new Float32Array(numOfVerticies * 3);\n  const texCoords = new Float32Array(numOfVerticies * 2);\n  const [minX, minY, maxX, maxY] = bounds || [0, 0, width, height];\n  const xScale = (maxX - minX) / width;\n  const yScale = (maxY - minY) / height;\n\n  for (let i = 0; i < numOfVerticies; i++) {\n    const x = vertices[i * 2];\n    const y = vertices[i * 2 + 1];\n    const pixelIdx = y * gridSize + x;\n    positions[3 * i + 0] = x * xScale + minX;\n    positions[3 * i + 1] = -y * yScale + maxY;\n    positions[3 * i + 2] = terrain[pixelIdx];\n    texCoords[2 * i + 0] = x / width;\n    texCoords[2 * i + 1] = y / height;\n  }\n\n  return {\n    POSITION: {\n      value: positions,\n      size: 3\n    },\n    TEXCOORD_0: {\n      value: texCoords,\n      size: 2\n    }\n  };\n}\n\nfunction getMesh(terrainImage, terrainOptions) {\n  if (terrainImage === null) {\n    return null;\n  }\n\n  const {\n    meshMaxError,\n    bounds,\n    elevationDecoder\n  } = terrainOptions;\n  const {\n    data,\n    width,\n    height\n  } = terrainImage;\n  let terrain;\n  let mesh;\n\n  switch (terrainOptions.tesselator) {\n    case 'martini':\n      terrain = getTerrain(data, width, height, elevationDecoder, terrainOptions.tesselator);\n      mesh = getMartiniTileMesh(meshMaxError, width, terrain);\n      break;\n\n    case 'delatin':\n      terrain = getTerrain(data, width, height, elevationDecoder, terrainOptions.tesselator);\n      mesh = getDelatinTileMesh(meshMaxError, width, height, terrain);\n      break;\n\n    default:\n      if (width === height && !(height & width - 1)) {\n        terrain = getTerrain(data, width, height, elevationDecoder, 'martini');\n        mesh = getMartiniTileMesh(meshMaxError, width, terrain);\n      } else {\n        terrain = getTerrain(data, width, height, elevationDecoder, 'delatin');\n        mesh = getDelatinTileMesh(meshMaxError, width, height, terrain);\n      }\n\n      break;\n  }\n\n  const {\n    vertices\n  } = mesh;\n  let {\n    triangles\n  } = mesh;\n  let attributes = getMeshAttributes(vertices, terrain, width, height, bounds);\n  const boundingBox = getMeshBoundingBox(attributes);\n\n  if (terrainOptions.skirtHeight) {\n    const {\n      attributes: newAttributes,\n      triangles: newTriangles\n    } = addSkirt(attributes, triangles, terrainOptions.skirtHeight);\n    attributes = newAttributes;\n    triangles = newTriangles;\n  }\n\n  return {\n    loaderData: {\n      header: {}\n    },\n    header: {\n      vertexCount: triangles.length,\n      boundingBox\n    },\n    mode: 4,\n    indices: {\n      value: Uint32Array.from(triangles),\n      size: 1\n    },\n    attributes\n  };\n}\n\nfunction getMartiniTileMesh(meshMaxError, width, terrain) {\n  const gridSize = width + 1;\n  const martini = new Martini(gridSize);\n  const tile = martini.createTile(terrain);\n  const {\n    vertices,\n    triangles\n  } = tile.getMesh(meshMaxError);\n  return {\n    vertices,\n    triangles\n  };\n}\n\nfunction getDelatinTileMesh(meshMaxError, width, height, terrain) {\n  const tin = new Delatin(terrain, width + 1, height + 1);\n  tin.run(meshMaxError);\n  const {\n    coords,\n    triangles\n  } = tin;\n  const vertices = coords;\n  return {\n    vertices,\n    triangles\n  };\n}\n\nexport default async function loadTerrain(arrayBuffer, options, context) {\n  options.image = options.image || {};\n  options.image.type = 'data';\n  const image = await context.parse(arrayBuffer, options, options.baseUri);\n  return getMesh(image, options.terrain);\n}","map":{"version":3,"sources":["../../../src/lib/parse-terrain.js"],"names":["offset","terrain","width","height","i","y","x","k","r","imageData","g","b","tesselator","gridSize","numOfVerticies","vertices","positions","texCoords","bounds","xScale","maxX","yScale","maxY","pixelIdx","POSITION","value","size","TEXCOORD_0","terrainImage","elevationDecoder","terrainOptions","getTerrain","mesh","getMartiniTileMesh","getDelatinTileMesh","triangles","attributes","getMeshAttributes","boundingBox","getMeshBoundingBox","newTriangles","addSkirt","loaderData","header","vertexCount","mode","indices","Uint32Array","martini","tile","tin","options","image","context","getMesh"],"mappings":"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","sourcesContent":["import {getMeshBoundingBox} from '@loaders.gl/schema';\nimport Martini from '@mapbox/martini';\nimport Delatin from './delatin';\nimport {addSkirt} from './helpers/skirt';\n\nfunction getTerrain(imageData, width, height, elevationDecoder, tesselator) {\n  const {rScaler, bScaler, gScaler, offset} = elevationDecoder;\n\n  // From Martini demo\n  // https://observablehq.com/@mourner/martin-real-time-rtin-terrain-mesh\n  const terrain = new Float32Array((width + 1) * (height + 1));\n  // decode terrain values\n  for (let i = 0, y = 0; y < height; y++) {\n    for (let x = 0; x < width; x++, i++) {\n      const k = i * 4;\n      const r = imageData[k + 0];\n      const g = imageData[k + 1];\n      const b = imageData[k + 2];\n      terrain[i + y] = r * rScaler + g * gScaler + b * bScaler + offset;\n    }\n  }\n\n  if (tesselator === 'martini') {\n    // backfill bottom border\n    for (let i = (width + 1) * width, x = 0; x < width; x++, i++) {\n      terrain[i] = terrain[i - width - 1];\n    }\n    // backfill right border\n    for (let i = height, y = 0; y < height + 1; y++, i += height + 1) {\n      terrain[i] = terrain[i - 1];\n    }\n  }\n\n  return terrain;\n}\n\nfunction getMeshAttributes(vertices, terrain, width, height, bounds) {\n  const gridSize = width + 1;\n  const numOfVerticies = vertices.length / 2;\n  // vec3. x, y in pixels, z in meters\n  const positions = new Float32Array(numOfVerticies * 3);\n  // vec2. 1 to 1 relationship with position. represents the uv on the texture image. 0,0 to 1,1.\n  const texCoords = new Float32Array(numOfVerticies * 2);\n\n  const [minX, minY, maxX, maxY] = bounds || [0, 0, width, height];\n  const xScale = (maxX - minX) / width;\n  const yScale = (maxY - minY) / height;\n\n  for (let i = 0; i < numOfVerticies; i++) {\n    const x = vertices[i * 2];\n    const y = vertices[i * 2 + 1];\n    const pixelIdx = y * gridSize + x;\n\n    positions[3 * i + 0] = x * xScale + minX;\n    positions[3 * i + 1] = -y * yScale + maxY;\n    positions[3 * i + 2] = terrain[pixelIdx];\n\n    texCoords[2 * i + 0] = x / width;\n    texCoords[2 * i + 1] = y / height;\n  }\n\n  return {\n    POSITION: {value: positions, size: 3},\n    TEXCOORD_0: {value: texCoords, size: 2}\n    // NORMAL: {}, - optional, but creates the high poly look with lighting\n  };\n}\n\n/**\n * Returns generated mesh object from image data\n *\n * @param {object} terrainImage terrain image data\n * @param {object} terrainOptions terrain options\n * @returns mesh object\n */\nfunction getMesh(terrainImage, terrainOptions) {\n  if (terrainImage === null) {\n    return null;\n  }\n  const {meshMaxError, bounds, elevationDecoder} = terrainOptions;\n\n  const {data, width, height} = terrainImage;\n\n  let terrain;\n  let mesh;\n  switch (terrainOptions.tesselator) {\n    case 'martini':\n      terrain = getTerrain(data, width, height, elevationDecoder, terrainOptions.tesselator);\n      mesh = getMartiniTileMesh(meshMaxError, width, terrain);\n      break;\n    case 'delatin':\n      terrain = getTerrain(data, width, height, elevationDecoder, terrainOptions.tesselator);\n      mesh = getDelatinTileMesh(meshMaxError, width, height, terrain);\n      break;\n    // auto\n    default:\n      if (width === height && !(height & (width - 1))) {\n        terrain = getTerrain(data, width, height, elevationDecoder, 'martini');\n        mesh = getMartiniTileMesh(meshMaxError, width, terrain);\n      } else {\n        terrain = getTerrain(data, width, height, elevationDecoder, 'delatin');\n        mesh = getDelatinTileMesh(meshMaxError, width, height, terrain);\n      }\n      break;\n  }\n\n  const {vertices} = mesh;\n  let {triangles} = mesh;\n  let attributes = getMeshAttributes(vertices, terrain, width, height, bounds);\n\n  // Compute bounding box before adding skirt so that z values are not skewed\n  const boundingBox = getMeshBoundingBox(attributes);\n\n  if (terrainOptions.skirtHeight) {\n    const {attributes: newAttributes, triangles: newTriangles} = addSkirt(\n      attributes,\n      triangles,\n      terrainOptions.skirtHeight\n    );\n    attributes = newAttributes;\n    triangles = newTriangles;\n  }\n\n  return {\n    // Data return by this loader implementation\n    loaderData: {\n      header: {}\n    },\n    header: {\n      vertexCount: triangles.length,\n      boundingBox\n    },\n    mode: 4, // TRIANGLES\n    indices: {value: Uint32Array.from(triangles), size: 1},\n    attributes\n  };\n}\n\n/**\n * Get Martini generated vertices and triangles\n *\n * @param {number} meshMaxError threshold for simplifying mesh\n * @param {number} width width of the input data\n * @param {number[] | Float32Array} terrain elevation data\n * @returns {{vertices: Uint16Array, triangles: Uint32Array}} vertices and triangles data\n */\nfunction getMartiniTileMesh(meshMaxError, width, terrain) {\n  const gridSize = width + 1;\n  const martini = new Martini(gridSize);\n  const tile = martini.createTile(terrain);\n  const {vertices, triangles} = tile.getMesh(meshMaxError);\n\n  return {vertices, triangles};\n}\n\n/**\n * Get Delatin generated vertices and triangles\n *\n * @param {number} meshMaxError threshold for simplifying mesh\n * @param {number} width width of the input data array\n * @param {number} height height of the input data array\n * @param {number[] | Float32Array} terrain elevation data\n * @returns {{vertices: number[], triangles: number[]}} vertices and triangles data\n */\nfunction getDelatinTileMesh(meshMaxError, width, height, terrain) {\n  const tin = new Delatin(terrain, width + 1, height + 1);\n  tin.run(meshMaxError);\n  const {coords, triangles} = tin;\n  const vertices = coords;\n  return {vertices, triangles};\n}\n\nexport default async function loadTerrain(arrayBuffer, options, context) {\n  options.image = options.image || {};\n  options.image.type = 'data';\n  const image = await context.parse(arrayBuffer, options, options.baseUri);\n  // Extend function to support additional mesh generation options (square grid or delatin)\n  return getMesh(image, options.terrain);\n}\n"]},"metadata":{},"sourceType":"module"}