{"ast":null,"code":"import { getPolygonSignedArea } from './polygon-utils';\nexport function earcut(data, holeIndices, dim, areas) {\n  dim = dim || 2;\n  const hasHoles = holeIndices && holeIndices.length;\n  const outerLen = hasHoles ? holeIndices[0] * dim : data.length;\n  let outerNode = linkedList(data, 0, outerLen, dim, true, areas && areas[0]);\n  const triangles = [];\n  if (!outerNode || outerNode.next === outerNode.prev) return triangles;\n  let invSize;\n  let maxX;\n  let maxY;\n  let minX;\n  let minY;\n  let x;\n  let y;\n  if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim, areas);\n\n  if (data.length > 80 * dim) {\n    minX = maxX = data[0];\n    minY = maxY = data[1];\n\n    for (let i = dim; i < outerLen; i += dim) {\n      x = data[i];\n      y = data[i + 1];\n      if (x < minX) minX = x;\n      if (y < minY) minY = y;\n      if (x > maxX) maxX = x;\n      if (y > maxY) maxY = y;\n    }\n\n    invSize = Math.max(maxX - minX, maxY - minY);\n    invSize = invSize !== 0 ? 1 / invSize : 0;\n  }\n\n  earcutLinked(outerNode, triangles, dim, minX, minY, invSize);\n  return triangles;\n}\n\nfunction linkedList(data, start, end, dim, clockwise, area) {\n  let i;\n  let last;\n\n  if (area === undefined) {\n    area = getPolygonSignedArea(data, {\n      start,\n      end,\n      size: dim\n    });\n  }\n\n  if (clockwise === area < 0) {\n    for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);\n  } else {\n    for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);\n  }\n\n  if (last && equals(last, last.next)) {\n    removeNode(last);\n    last = last.next;\n  }\n\n  return last;\n}\n\nfunction filterPoints(start, end) {\n  if (!start) return start;\n  if (!end) end = start;\n  let p = start;\n  let again;\n\n  do {\n    again = false;\n\n    if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {\n      removeNode(p);\n      p = end = p.prev;\n      if (p === p.next) break;\n      again = true;\n    } else {\n      p = p.next;\n    }\n  } while (again || p !== end);\n\n  return end;\n}\n\nfunction earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {\n  if (!ear) return;\n  if (!pass && invSize) indexCurve(ear, minX, minY, invSize);\n  let stop = ear;\n  let prev;\n  let next;\n\n  while (ear.prev !== ear.next) {\n    prev = ear.prev;\n    next = ear.next;\n\n    if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {\n      triangles.push(prev.i / dim);\n      triangles.push(ear.i / dim);\n      triangles.push(next.i / dim);\n      removeNode(ear);\n      ear = next.next;\n      stop = next.next;\n      continue;\n    }\n\n    ear = next;\n\n    if (ear === stop) {\n      if (!pass) {\n        earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);\n      } else if (pass === 1) {\n        ear = cureLocalIntersections(filterPoints(ear), triangles, dim);\n        earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);\n      } else if (pass === 2) {\n        splitEarcut(ear, triangles, dim, minX, minY, invSize);\n      }\n\n      break;\n    }\n  }\n}\n\nfunction isEar(ear) {\n  const a = ear.prev;\n  const b = ear;\n  const c = ear.next;\n  if (area(a, b, c) >= 0) return false;\n  let p = ear.next.next;\n\n  while (p !== ear.prev) {\n    if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n    p = p.next;\n  }\n\n  return true;\n}\n\nfunction isEarHashed(ear, minX, minY, invSize) {\n  const a = ear.prev;\n  const b = ear;\n  const c = ear.next;\n  if (area(a, b, c) >= 0) return false;\n  const minTX = a.x < b.x ? a.x < c.x ? a.x : c.x : b.x < c.x ? b.x : c.x;\n  const minTY = a.y < b.y ? a.y < c.y ? a.y : c.y : b.y < c.y ? b.y : c.y;\n  const maxTX = a.x > b.x ? a.x > c.x ? a.x : c.x : b.x > c.x ? b.x : c.x;\n  const maxTY = a.y > b.y ? a.y > c.y ? a.y : c.y : b.y > c.y ? b.y : c.y;\n  const minZ = zOrder(minTX, minTY, minX, minY, invSize);\n  const maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);\n  let p = ear.prevZ;\n  let n = ear.nextZ;\n\n  while (p && p.z >= minZ && n && n.z <= maxZ) {\n    if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n    p = p.prevZ;\n    if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;\n    n = n.nextZ;\n  }\n\n  while (p && p.z >= minZ) {\n    if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n    p = p.prevZ;\n  }\n\n  while (n && n.z <= maxZ) {\n    if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;\n    n = n.nextZ;\n  }\n\n  return true;\n}\n\nfunction cureLocalIntersections(start, triangles, dim) {\n  let p = start;\n\n  do {\n    const a = p.prev;\n    const b = p.next.next;\n\n    if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {\n      triangles.push(a.i / dim);\n      triangles.push(p.i / dim);\n      triangles.push(b.i / dim);\n      removeNode(p);\n      removeNode(p.next);\n      p = start = b;\n    }\n\n    p = p.next;\n  } while (p !== start);\n\n  return filterPoints(p);\n}\n\nfunction splitEarcut(start, triangles, dim, minX, minY, invSize) {\n  let a = start;\n\n  do {\n    let b = a.next.next;\n\n    while (b !== a.prev) {\n      if (a.i !== b.i && isValidDiagonal(a, b)) {\n        let c = splitPolygon(a, b);\n        a = filterPoints(a, a.next);\n        c = filterPoints(c, c.next);\n        earcutLinked(a, triangles, dim, minX, minY, invSize);\n        earcutLinked(c, triangles, dim, minX, minY, invSize);\n        return;\n      }\n\n      b = b.next;\n    }\n\n    a = a.next;\n  } while (a !== start);\n}\n\nfunction eliminateHoles(data, holeIndices, outerNode, dim, areas) {\n  const queue = [];\n  let i;\n  let len;\n  let start;\n  let end;\n  let list;\n\n  for (i = 0, len = holeIndices.length; i < len; i++) {\n    start = holeIndices[i] * dim;\n    end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n    list = linkedList(data, start, end, dim, false, areas && areas[i + 1]);\n    if (list === list.next) list.steiner = true;\n    queue.push(getLeftmost(list));\n  }\n\n  queue.sort(compareX);\n\n  for (i = 0; i < queue.length; i++) {\n    eliminateHole(queue[i], outerNode);\n    outerNode = filterPoints(outerNode, outerNode.next);\n  }\n\n  return outerNode;\n}\n\nfunction compareX(a, b) {\n  return a.x - b.x;\n}\n\nfunction eliminateHole(hole, outerNode) {\n  outerNode = findHoleBridge(hole, outerNode);\n\n  if (outerNode) {\n    const b = splitPolygon(outerNode, hole);\n    filterPoints(outerNode, outerNode.next);\n    filterPoints(b, b.next);\n  }\n}\n\nfunction findHoleBridge(hole, outerNode) {\n  let p = outerNode;\n  const hx = hole.x;\n  const hy = hole.y;\n  let qx = -Infinity;\n  let m;\n\n  do {\n    if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {\n      const x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);\n\n      if (x <= hx && x > qx) {\n        qx = x;\n\n        if (x === hx) {\n          if (hy === p.y) return p;\n          if (hy === p.next.y) return p.next;\n        }\n\n        m = p.x < p.next.x ? p : p.next;\n      }\n    }\n\n    p = p.next;\n  } while (p !== outerNode);\n\n  if (!m) return null;\n  if (hx === qx) return m;\n  const stop = m;\n  const mx = m.x;\n  const my = m.y;\n  let tanMin = Infinity;\n  let tan;\n  p = m;\n\n  do {\n    if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {\n      tan = Math.abs(hy - p.y) / (hx - p.x);\n\n      if (locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {\n        m = p;\n        tanMin = tan;\n      }\n    }\n\n    p = p.next;\n  } while (p !== stop);\n\n  return m;\n}\n\nfunction sectorContainsSector(m, p) {\n  return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;\n}\n\nfunction indexCurve(start, minX, minY, invSize) {\n  let p = start;\n\n  do {\n    if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, invSize);\n    p.prevZ = p.prev;\n    p.nextZ = p.next;\n    p = p.next;\n  } while (p !== start);\n\n  p.prevZ.nextZ = null;\n  p.prevZ = null;\n  sortLinked(p);\n}\n\nfunction sortLinked(list) {\n  let e;\n  let i;\n  let inSize = 1;\n  let numMerges;\n  let p;\n  let pSize;\n  let q;\n  let qSize;\n  let tail;\n\n  do {\n    p = list;\n    list = null;\n    tail = null;\n    numMerges = 0;\n\n    while (p) {\n      numMerges++;\n      q = p;\n      pSize = 0;\n\n      for (i = 0; i < inSize; i++) {\n        pSize++;\n        q = q.nextZ;\n        if (!q) break;\n      }\n\n      qSize = inSize;\n\n      while (pSize > 0 || qSize > 0 && q) {\n        if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {\n          e = p;\n          p = p.nextZ;\n          pSize--;\n        } else {\n          e = q;\n          q = q.nextZ;\n          qSize--;\n        }\n\n        if (tail) tail.nextZ = e;else list = e;\n        e.prevZ = tail;\n        tail = e;\n      }\n\n      p = q;\n    }\n\n    tail.nextZ = null;\n    inSize *= 2;\n  } while (numMerges > 1);\n\n  return list;\n}\n\nfunction zOrder(x, y, minX, minY, invSize) {\n  x = 32767 * (x - minX) * invSize;\n  y = 32767 * (y - minY) * invSize;\n  x = (x | x << 8) & 0x00ff00ff;\n  x = (x | x << 4) & 0x0f0f0f0f;\n  x = (x | x << 2) & 0x33333333;\n  x = (x | x << 1) & 0x55555555;\n  y = (y | y << 8) & 0x00ff00ff;\n  y = (y | y << 4) & 0x0f0f0f0f;\n  y = (y | y << 2) & 0x33333333;\n  y = (y | y << 1) & 0x55555555;\n  return x | y << 1;\n}\n\nfunction getLeftmost(start) {\n  let p = start;\n  let leftmost = start;\n\n  do {\n    if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y) leftmost = p;\n    p = p.next;\n  } while (p !== start);\n\n  return leftmost;\n}\n\nfunction pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {\n  return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;\n}\n\nfunction isValidDiagonal(a, b) {\n  return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && (area(a.prev, a, b.prev) || area(a, b.prev, b)) || equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0);\n}\n\nfunction area(p, q, r) {\n  return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n}\n\nfunction equals(p1, p2) {\n  return p1.x === p2.x && p1.y === p2.y;\n}\n\nfunction intersects(p1, q1, p2, q2) {\n  const o1 = sign(area(p1, q1, p2));\n  const o2 = sign(area(p1, q1, q2));\n  const o3 = sign(area(p2, q2, p1));\n  const o4 = sign(area(p2, q2, q1));\n  if (o1 !== o2 && o3 !== o4) return true;\n  if (o1 === 0 && onSegment(p1, p2, q1)) return true;\n  if (o2 === 0 && onSegment(p1, q2, q1)) return true;\n  if (o3 === 0 && onSegment(p2, p1, q2)) return true;\n  if (o4 === 0 && onSegment(p2, q1, q2)) return true;\n  return false;\n}\n\nfunction onSegment(p, q, r) {\n  return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);\n}\n\nfunction sign(num) {\n  return num > 0 ? 1 : num < 0 ? -1 : 0;\n}\n\nfunction intersectsPolygon(a, b) {\n  let p = a;\n\n  do {\n    if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) return true;\n    p = p.next;\n  } while (p !== a);\n\n  return false;\n}\n\nfunction locallyInside(a, b) {\n  return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;\n}\n\nfunction middleInside(a, b) {\n  let p = a;\n  let inside = false;\n  const px = (a.x + b.x) / 2;\n  const py = (a.y + b.y) / 2;\n\n  do {\n    if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x) inside = !inside;\n    p = p.next;\n  } while (p !== a);\n\n  return inside;\n}\n\nfunction splitPolygon(a, b) {\n  const a2 = new Node(a.i, a.x, a.y);\n  const b2 = new Node(b.i, b.x, b.y);\n  const an = a.next;\n  const bp = b.prev;\n  a.next = b;\n  b.prev = a;\n  a2.next = an;\n  an.prev = a2;\n  b2.next = a2;\n  a2.prev = b2;\n  bp.next = b2;\n  b2.prev = bp;\n  return b2;\n}\n\nfunction insertNode(i, x, y, last) {\n  const p = new Node(i, x, y);\n\n  if (!last) {\n    p.prev = p;\n    p.next = p;\n  } else {\n    p.next = last.next;\n    p.prev = last;\n    last.next.prev = p;\n    last.next = p;\n  }\n\n  return p;\n}\n\nfunction removeNode(p) {\n  p.next.prev = p.prev;\n  p.prev.next = p.next;\n  if (p.prevZ) p.prevZ.nextZ = p.nextZ;\n  if (p.nextZ) p.nextZ.prevZ = p.prevZ;\n}\n\nfunction Node(i, x, y) {\n  this.i = i;\n  this.x = x;\n  this.y = y;\n  this.prev = null;\n  this.next = null;\n  this.z = null;\n  this.prevZ = null;\n  this.nextZ = null;\n  this.steiner = false;\n}","map":{"version":3,"sources":["../../src/earcut.js"],"names":["dim","hasHoles","holeIndices","outerLen","data","outerNode","linkedList","areas","triangles","eliminateHoles","minX","maxX","minY","maxY","i","x","y","invSize","Math","earcutLinked","area","getPolygonSignedArea","size","clockwise","last","insertNode","end","equals","removeNode","p","again","indexCurve","stop","ear","prev","next","isEarHashed","isEar","filterPoints","pass","cureLocalIntersections","splitEarcut","a","b","c","pointInTriangle","minTX","minTY","maxTX","maxTY","minZ","zOrder","maxZ","n","intersects","locallyInside","start","isValidDiagonal","splitPolygon","queue","len","list","getLeftmost","eliminateHole","findHoleBridge","hx","hole","hy","qx","m","mx","my","tanMin","tan","sectorContainsSector","sortLinked","inSize","tail","numMerges","q","pSize","qSize","e","leftmost","cx","ay","ax","cy","by","bx","intersectsPolygon","middleInside","r","p1","p2","o1","sign","o2","o3","o4","onSegment","num","inside","px","py","a2","b2","an","bp"],"mappings":"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","sourcesContent":["/*\n  Adapted from https://github.com/mapbox/earcut to allow passing in\n  of outline and hole areas using the `areas` parameter. As the\n  areas are calcuted as part of classifying the polygon rings\n  we can pass them in again to avoid recomputation\n\n  ISC License\n\n  Copyright (c) 2016, Mapbox\n\n  Permission to use, copy, modify, and/or distribute this software for any purpose\n  with or without fee is hereby granted, provided that the above copyright notice\n  and this permission notice appear in all copies.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND\n  FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS\n  OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER\n  TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF\n  THIS SOFTWARE.\n\n */\n\n/* eslint-disable complexity, max-params, max-statements, max-depth, no-continue, no-shadow */\n\nimport {getPolygonSignedArea} from './polygon-utils';\n\nexport function earcut(data, holeIndices, dim, areas) {\n  dim = dim || 2;\n\n  const hasHoles = holeIndices && holeIndices.length;\n  const outerLen = hasHoles ? holeIndices[0] * dim : data.length;\n  let outerNode = linkedList(data, 0, outerLen, dim, true, areas && areas[0]);\n  const triangles = [];\n\n  if (!outerNode || outerNode.next === outerNode.prev) return triangles;\n\n  let invSize;\n  let maxX;\n  let maxY;\n  let minX;\n  let minY;\n  let x;\n  let y;\n\n  if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim, areas);\n\n  // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\n  if (data.length > 80 * dim) {\n    minX = maxX = data[0];\n    minY = maxY = data[1];\n\n    for (let i = dim; i < outerLen; i += dim) {\n      x = data[i];\n      y = data[i + 1];\n      if (x < minX) minX = x;\n      if (y < minY) minY = y;\n      if (x > maxX) maxX = x;\n      if (y > maxY) maxY = y;\n    }\n\n    // minX, minY and invSize are later used to transform coords into integers for z-order calculation\n    invSize = Math.max(maxX - minX, maxY - minY);\n    invSize = invSize !== 0 ? 1 / invSize : 0;\n  }\n\n  earcutLinked(outerNode, triangles, dim, minX, minY, invSize);\n\n  return triangles;\n}\n\n// create a circular doubly linked list from polygon points in the specified winding order\nfunction linkedList(data, start, end, dim, clockwise, area) {\n  let i;\n  let last;\n  if (area === undefined) {\n    area = getPolygonSignedArea(data, {start, end, size: dim});\n  }\n\n  // Note that the signed area calculation in math.gl\n  // has the opposite sign to that which was originally\n  // present in earcut, thus the `< 0` is reversed\n  if (clockwise === area < 0) {\n    for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);\n  } else {\n    for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);\n  }\n\n  if (last && equals(last, last.next)) {\n    removeNode(last);\n    last = last.next;\n  }\n\n  return last;\n}\n\n// eliminate colinear or duplicate points\nfunction filterPoints(start, end) {\n  if (!start) return start;\n  if (!end) end = start;\n\n  let p = start;\n  let again;\n  do {\n    again = false;\n\n    if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {\n      removeNode(p);\n      p = end = p.prev;\n      if (p === p.next) break;\n      again = true;\n    } else {\n      p = p.next;\n    }\n  } while (again || p !== end);\n\n  return end;\n}\n\n// main ear slicing loop which triangulates a polygon (given as a linked list)\nfunction earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {\n  if (!ear) return;\n\n  // interlink polygon nodes in z-order\n  if (!pass && invSize) indexCurve(ear, minX, minY, invSize);\n\n  let stop = ear;\n  let prev;\n  let next;\n\n  // iterate through ears, slicing them one by one\n  while (ear.prev !== ear.next) {\n    prev = ear.prev;\n    next = ear.next;\n\n    if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {\n      // cut off the triangle\n      triangles.push(prev.i / dim);\n      triangles.push(ear.i / dim);\n      triangles.push(next.i / dim);\n\n      removeNode(ear);\n\n      // skipping the next vertex leads to less sliver triangles\n      ear = next.next;\n      stop = next.next;\n\n      continue;\n    }\n\n    ear = next;\n\n    // if we looped through the whole remaining polygon and can't find any more ears\n    if (ear === stop) {\n      // try filtering points and slicing again\n      if (!pass) {\n        earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);\n\n        // if this didn't work, try curing all small self-intersections locally\n      } else if (pass === 1) {\n        ear = cureLocalIntersections(filterPoints(ear), triangles, dim);\n        earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);\n\n        // as a last resort, try splitting the remaining polygon into two\n      } else if (pass === 2) {\n        splitEarcut(ear, triangles, dim, minX, minY, invSize);\n      }\n\n      break;\n    }\n  }\n}\n\n// check whether a polygon node forms a valid ear with adjacent nodes\nfunction isEar(ear) {\n  const a = ear.prev;\n  const b = ear;\n  const c = ear.next;\n\n  if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n  // now make sure we don't have other points inside the potential ear\n  let p = ear.next.next;\n\n  while (p !== ear.prev) {\n    if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0)\n      return false;\n    p = p.next;\n  }\n\n  return true;\n}\n\nfunction isEarHashed(ear, minX, minY, invSize) {\n  const a = ear.prev;\n  const b = ear;\n  const c = ear.next;\n\n  if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n  // triangle bbox; min & max are calculated like this for speed\n  const minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : b.x < c.x ? b.x : c.x;\n  const minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : b.y < c.y ? b.y : c.y;\n  const maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : b.x > c.x ? b.x : c.x;\n  const maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : b.y > c.y ? b.y : c.y;\n\n  // z-order range for the current triangle bbox;\n  const minZ = zOrder(minTX, minTY, minX, minY, invSize);\n  const maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);\n\n  let p = ear.prevZ;\n  let n = ear.nextZ;\n\n  // look for points inside the triangle in both directions\n  while (p && p.z >= minZ && n && n.z <= maxZ) {\n    if (\n      p !== ear.prev &&\n      p !== ear.next &&\n      pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&\n      area(p.prev, p, p.next) >= 0\n    )\n      return false;\n    p = p.prevZ;\n\n    if (\n      n !== ear.prev &&\n      n !== ear.next &&\n      pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&\n      area(n.prev, n, n.next) >= 0\n    )\n      return false;\n    n = n.nextZ;\n  }\n\n  // look for remaining points in decreasing z-order\n  while (p && p.z >= minZ) {\n    if (\n      p !== ear.prev &&\n      p !== ear.next &&\n      pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&\n      area(p.prev, p, p.next) >= 0\n    )\n      return false;\n    p = p.prevZ;\n  }\n\n  // look for remaining points in increasing z-order\n  while (n && n.z <= maxZ) {\n    if (\n      n !== ear.prev &&\n      n !== ear.next &&\n      pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&\n      area(n.prev, n, n.next) >= 0\n    )\n      return false;\n    n = n.nextZ;\n  }\n\n  return true;\n}\n\n// go through all polygon nodes and cure small local self-intersections\nfunction cureLocalIntersections(start, triangles, dim) {\n  let p = start;\n  do {\n    const a = p.prev;\n    const b = p.next.next;\n\n    if (\n      !equals(a, b) &&\n      intersects(a, p, p.next, b) &&\n      locallyInside(a, b) &&\n      locallyInside(b, a)\n    ) {\n      triangles.push(a.i / dim);\n      triangles.push(p.i / dim);\n      triangles.push(b.i / dim);\n\n      // remove two nodes involved\n      removeNode(p);\n      removeNode(p.next);\n\n      p = start = b;\n    }\n    p = p.next;\n  } while (p !== start);\n\n  return filterPoints(p);\n}\n\n// try splitting polygon into two and triangulate them independently\nfunction splitEarcut(start, triangles, dim, minX, minY, invSize) {\n  // look for a valid diagonal that divides the polygon into two\n  let a = start;\n  do {\n    let b = a.next.next;\n    while (b !== a.prev) {\n      if (a.i !== b.i && isValidDiagonal(a, b)) {\n        // split the polygon in two by the diagonal\n        let c = splitPolygon(a, b);\n\n        // filter colinear points around the cuts\n        a = filterPoints(a, a.next);\n        c = filterPoints(c, c.next);\n\n        // run earcut on each half\n        earcutLinked(a, triangles, dim, minX, minY, invSize);\n        earcutLinked(c, triangles, dim, minX, minY, invSize);\n        return;\n      }\n      b = b.next;\n    }\n    a = a.next;\n  } while (a !== start);\n}\n\n// link every hole into the outer loop, producing a single-ring polygon without holes\nfunction eliminateHoles(data, holeIndices, outerNode, dim, areas) {\n  const queue = [];\n  let i;\n  let len;\n  let start;\n  let end;\n  let list;\n\n  for (i = 0, len = holeIndices.length; i < len; i++) {\n    start = holeIndices[i] * dim;\n    end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n    list = linkedList(data, start, end, dim, false, areas && areas[i + 1]);\n    if (list === list.next) list.steiner = true;\n    queue.push(getLeftmost(list));\n  }\n\n  queue.sort(compareX);\n\n  // process holes from left to right\n  for (i = 0; i < queue.length; i++) {\n    eliminateHole(queue[i], outerNode);\n    outerNode = filterPoints(outerNode, outerNode.next);\n  }\n\n  return outerNode;\n}\n\nfunction compareX(a, b) {\n  return a.x - b.x;\n}\n\n// find a bridge between vertices that connects hole with an outer ring and and link it\nfunction eliminateHole(hole, outerNode) {\n  outerNode = findHoleBridge(hole, outerNode);\n  if (outerNode) {\n    const b = splitPolygon(outerNode, hole);\n\n    // filter collinear points around the cuts\n    filterPoints(outerNode, outerNode.next);\n    filterPoints(b, b.next);\n  }\n}\n\n// David Eberly's algorithm for finding a bridge between hole and outer polygon\nfunction findHoleBridge(hole, outerNode) {\n  let p = outerNode;\n  const hx = hole.x;\n  const hy = hole.y;\n  let qx = -Infinity;\n  let m;\n\n  // find a segment intersected by a ray from the hole's leftmost point to the left;\n  // segment's endpoint with lesser x will be potential connection point\n  do {\n    if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {\n      const x = p.x + ((hy - p.y) * (p.next.x - p.x)) / (p.next.y - p.y);\n      if (x <= hx && x > qx) {\n        qx = x;\n        if (x === hx) {\n          if (hy === p.y) return p;\n          if (hy === p.next.y) return p.next;\n        }\n        m = p.x < p.next.x ? p : p.next;\n      }\n    }\n    p = p.next;\n  } while (p !== outerNode);\n\n  if (!m) return null;\n\n  if (hx === qx) return m; // hole touches outer segment; pick leftmost endpoint\n\n  // look for points inside the triangle of hole point, segment intersection and endpoint;\n  // if there are no points found, we have a valid connection;\n  // otherwise choose the point of the minimum angle with the ray as connection point\n\n  const stop = m;\n  const mx = m.x;\n  const my = m.y;\n  let tanMin = Infinity;\n  let tan;\n\n  p = m;\n\n  do {\n    if (\n      hx >= p.x &&\n      p.x >= mx &&\n      hx !== p.x &&\n      pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)\n    ) {\n      tan = Math.abs(hy - p.y) / (hx - p.x); // tangential\n\n      if (\n        locallyInside(p, hole) &&\n        (tan < tanMin ||\n          (tan === tanMin && (p.x > m.x || (p.x === m.x && sectorContainsSector(m, p)))))\n      ) {\n        m = p;\n        tanMin = tan;\n      }\n    }\n\n    p = p.next;\n  } while (p !== stop);\n\n  return m;\n}\n\n// whether sector in vertex m contains sector in vertex p in the same coordinates\nfunction sectorContainsSector(m, p) {\n  return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;\n}\n\n// interlink polygon nodes in z-order\nfunction indexCurve(start, minX, minY, invSize) {\n  let p = start;\n  do {\n    if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, invSize);\n    p.prevZ = p.prev;\n    p.nextZ = p.next;\n    p = p.next;\n  } while (p !== start);\n\n  p.prevZ.nextZ = null;\n  p.prevZ = null;\n\n  sortLinked(p);\n}\n\n// Simon Tatham's linked list merge sort algorithm\n// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\nfunction sortLinked(list) {\n  let e;\n  let i;\n  let inSize = 1;\n  let numMerges;\n  let p;\n  let pSize;\n  let q;\n  let qSize;\n  let tail;\n\n  do {\n    p = list;\n    list = null;\n    tail = null;\n    numMerges = 0;\n\n    while (p) {\n      numMerges++;\n      q = p;\n      pSize = 0;\n      for (i = 0; i < inSize; i++) {\n        pSize++;\n        q = q.nextZ;\n        if (!q) break;\n      }\n      qSize = inSize;\n\n      while (pSize > 0 || (qSize > 0 && q)) {\n        if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {\n          e = p;\n          p = p.nextZ;\n          pSize--;\n        } else {\n          e = q;\n          q = q.nextZ;\n          qSize--;\n        }\n\n        if (tail) tail.nextZ = e;\n        else list = e;\n\n        e.prevZ = tail;\n        tail = e;\n      }\n\n      p = q;\n    }\n\n    tail.nextZ = null;\n    inSize *= 2;\n  } while (numMerges > 1);\n\n  return list;\n}\n\n// z-order of a point given coords and inverse of the longer side of data bbox\nfunction zOrder(x, y, minX, minY, invSize) {\n  // coords are transformed into non-negative 15-bit integer range\n  x = 32767 * (x - minX) * invSize;\n  y = 32767 * (y - minY) * invSize;\n\n  x = (x | (x << 8)) & 0x00ff00ff;\n  x = (x | (x << 4)) & 0x0f0f0f0f;\n  x = (x | (x << 2)) & 0x33333333;\n  x = (x | (x << 1)) & 0x55555555;\n\n  y = (y | (y << 8)) & 0x00ff00ff;\n  y = (y | (y << 4)) & 0x0f0f0f0f;\n  y = (y | (y << 2)) & 0x33333333;\n  y = (y | (y << 1)) & 0x55555555;\n\n  return x | (y << 1);\n}\n\n// find the leftmost node of a polygon ring\nfunction getLeftmost(start) {\n  let p = start;\n  let leftmost = start;\n  do {\n    if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y)) leftmost = p;\n    p = p.next;\n  } while (p !== start);\n\n  return leftmost;\n}\n\n// check if a point lies within a convex triangle\nfunction pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {\n  return (\n    (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&\n    (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&\n    (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0\n  );\n}\n\n// check if a diagonal between two polygon nodes is valid (lies in polygon interior)\nfunction isValidDiagonal(a, b) {\n  return (\n    a.next.i !== b.i &&\n    a.prev.i !== b.i &&\n    !intersectsPolygon(a, b) && // dones't intersect other edges\n    ((locallyInside(a, b) &&\n      locallyInside(b, a) &&\n      middleInside(a, b) && // locally visible\n      (area(a.prev, a, b.prev) || area(a, b.prev, b))) || // does not create opposite-facing sectors\n      (equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0))\n  ); // special zero-length case\n}\n\n// signed area of a triangle\nfunction area(p, q, r) {\n  return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n}\n\n// check if two points are equal\nfunction equals(p1, p2) {\n  return p1.x === p2.x && p1.y === p2.y;\n}\n\n// check if two segments intersect\nfunction intersects(p1, q1, p2, q2) {\n  const o1 = sign(area(p1, q1, p2));\n  const o2 = sign(area(p1, q1, q2));\n  const o3 = sign(area(p2, q2, p1));\n  const o4 = sign(area(p2, q2, q1));\n\n  if (o1 !== o2 && o3 !== o4) return true; // general case\n\n  if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1\n  if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1\n  if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2\n  if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2\n\n  return false;\n}\n\n// for collinear points p, q, r, check if point q lies on segment pr\nfunction onSegment(p, q, r) {\n  return (\n    q.x <= Math.max(p.x, r.x) &&\n    q.x >= Math.min(p.x, r.x) &&\n    q.y <= Math.max(p.y, r.y) &&\n    q.y >= Math.min(p.y, r.y)\n  );\n}\n\nfunction sign(num) {\n  return num > 0 ? 1 : num < 0 ? -1 : 0;\n}\n\n// check if a polygon diagonal intersects any polygon segments\nfunction intersectsPolygon(a, b) {\n  let p = a;\n  do {\n    if (\n      p.i !== a.i &&\n      p.next.i !== a.i &&\n      p.i !== b.i &&\n      p.next.i !== b.i &&\n      intersects(p, p.next, a, b)\n    )\n      return true;\n    p = p.next;\n  } while (p !== a);\n\n  return false;\n}\n\n// check if a polygon diagonal is locally inside the polygon\nfunction locallyInside(a, b) {\n  return area(a.prev, a, a.next) < 0\n    ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0\n    : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;\n}\n\n// check if the middle point of a polygon diagonal is inside the polygon\nfunction middleInside(a, b) {\n  let p = a;\n  let inside = false;\n  const px = (a.x + b.x) / 2;\n  const py = (a.y + b.y) / 2;\n  do {\n    if (\n      p.y > py !== p.next.y > py &&\n      p.next.y !== p.y &&\n      px < ((p.next.x - p.x) * (py - p.y)) / (p.next.y - p.y) + p.x\n    )\n      inside = !inside;\n    p = p.next;\n  } while (p !== a);\n\n  return inside;\n}\n\n// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\n// if one belongs to the outer ring and another to a hole, it merges it into a single ring\nfunction splitPolygon(a, b) {\n  const a2 = new Node(a.i, a.x, a.y);\n  const b2 = new Node(b.i, b.x, b.y);\n  const an = a.next;\n  const bp = b.prev;\n\n  a.next = b;\n  b.prev = a;\n\n  a2.next = an;\n  an.prev = a2;\n\n  b2.next = a2;\n  a2.prev = b2;\n\n  bp.next = b2;\n  b2.prev = bp;\n\n  return b2;\n}\n\n// create a node and optionally link it with previous one (in a circular doubly linked list)\nfunction insertNode(i, x, y, last) {\n  const p = new Node(i, x, y);\n\n  if (!last) {\n    p.prev = p;\n    p.next = p;\n  } else {\n    p.next = last.next;\n    p.prev = last;\n    last.next.prev = p;\n    last.next = p;\n  }\n  return p;\n}\n\nfunction removeNode(p) {\n  p.next.prev = p.prev;\n  p.prev.next = p.next;\n\n  if (p.prevZ) p.prevZ.nextZ = p.nextZ;\n  if (p.nextZ) p.nextZ.prevZ = p.prevZ;\n}\n\nfunction Node(i, x, y) {\n  // vertex index in coordinates array\n  this.i = i;\n\n  // vertex coordinates\n  this.x = x;\n  this.y = y;\n\n  // previous and next vertex nodes in a polygon ring\n  this.prev = null;\n  this.next = null;\n\n  // z-order curve value\n  this.z = null;\n\n  // previous and next nodes in z-order\n  this.prevZ = null;\n  this.nextZ = null;\n\n  // indicates whether this is a steiner point\n  this.steiner = false;\n}\n"]},"metadata":{},"sourceType":"module"}