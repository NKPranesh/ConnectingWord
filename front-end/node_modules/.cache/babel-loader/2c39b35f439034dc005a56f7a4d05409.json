{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport ManagedArray from '../../utils/managed-array';\nimport { TILE_REFINEMENT } from '../../constants';\nexport const DEFAULT_PROPS = {\n  loadSiblings: false,\n  skipLevelOfDetail: false,\n  maximumScreenSpaceError: 2,\n  updateTransforms: true,\n  onTraversalEnd: () => {},\n  viewportTraversersMap: {},\n  basePath: ''\n};\nexport default class TilesetTraverser {\n  constructor(options) {\n    _defineProperty(this, \"options\", void 0);\n\n    _defineProperty(this, \"root\", void 0);\n\n    _defineProperty(this, \"requestedTiles\", void 0);\n\n    _defineProperty(this, \"selectedTiles\", void 0);\n\n    _defineProperty(this, \"emptyTiles\", void 0);\n\n    _defineProperty(this, \"_traversalStack\", void 0);\n\n    _defineProperty(this, \"_emptyTraversalStack\", void 0);\n\n    _defineProperty(this, \"_frameNumber\", void 0);\n\n    this.options = { ...DEFAULT_PROPS,\n      ...options\n    };\n    this._traversalStack = new ManagedArray();\n    this._emptyTraversalStack = new ManagedArray();\n    this._frameNumber = null;\n    this.root = null;\n    this.selectedTiles = {};\n    this.requestedTiles = {};\n    this.emptyTiles = {};\n  }\n\n  traverse(root, frameState, options) {\n    this.root = root;\n    this.options = { ...this.options,\n      ...options\n    };\n    this.reset();\n    this.updateTile(root, frameState);\n    this._frameNumber = frameState.frameNumber;\n    this.executeTraversal(root, frameState);\n  }\n\n  reset() {\n    this.requestedTiles = {};\n    this.selectedTiles = {};\n    this.emptyTiles = {};\n\n    this._traversalStack.reset();\n\n    this._emptyTraversalStack.reset();\n  }\n\n  executeTraversal(root, frameState) {\n    const stack = this._traversalStack;\n    root._selectionDepth = 1;\n    stack.push(root);\n\n    while (stack.length > 0) {\n      const tile = stack.pop();\n      let shouldRefine = false;\n\n      if (this.canTraverse(tile, frameState)) {\n        this.updateChildTiles(tile, frameState);\n        shouldRefine = this.updateAndPushChildren(tile, frameState, stack, tile.hasRenderContent ? tile._selectionDepth + 1 : tile._selectionDepth);\n      }\n\n      const parent = tile.parent;\n      const parentRefines = Boolean(!parent || parent._shouldRefine);\n      const stoppedRefining = !shouldRefine;\n\n      if (!tile.hasRenderContent) {\n        this.emptyTiles[tile.id] = tile;\n        this.loadTile(tile, frameState);\n\n        if (stoppedRefining) {\n          this.selectTile(tile, frameState);\n        }\n      } else if (tile.refine === TILE_REFINEMENT.ADD) {\n        this.loadTile(tile, frameState);\n        this.selectTile(tile, frameState);\n      } else if (tile.refine === TILE_REFINEMENT.REPLACE) {\n        this.loadTile(tile, frameState);\n\n        if (stoppedRefining) {\n          this.selectTile(tile, frameState);\n        }\n      }\n\n      this.touchTile(tile, frameState);\n      tile._shouldRefine = shouldRefine && parentRefines;\n    }\n\n    this.options.onTraversalEnd(frameState);\n  }\n\n  updateChildTiles(tile, frameState) {\n    const children = tile.children;\n\n    for (const child of children) {\n      this.updateTile(child, frameState);\n    }\n\n    return true;\n  }\n\n  updateAndPushChildren(tile, frameState, stack, depth) {\n    const {\n      loadSiblings,\n      skipLevelOfDetail\n    } = this.options;\n    const children = tile.children;\n    children.sort(this.compareDistanceToCamera.bind(this));\n    const checkRefines = tile.refine === TILE_REFINEMENT.REPLACE && tile.hasRenderContent && !skipLevelOfDetail;\n    let hasVisibleChild = false;\n    let refines = true;\n\n    for (const child of children) {\n      child._selectionDepth = depth;\n\n      if (child.isVisibleAndInRequestVolume) {\n        if (stack.find(child)) {\n          stack.delete(child);\n        }\n\n        stack.push(child);\n        hasVisibleChild = true;\n      } else if (checkRefines || loadSiblings) {\n        this.loadTile(child, frameState);\n        this.touchTile(child, frameState);\n      }\n\n      if (checkRefines) {\n        let childRefines;\n\n        if (!child._inRequestVolume) {\n          childRefines = false;\n        } else if (!child.hasRenderContent) {\n          childRefines = this.executeEmptyTraversal(child, frameState);\n        } else {\n          childRefines = child.contentAvailable;\n        }\n\n        refines = refines && childRefines;\n\n        if (!refines) {\n          return false;\n        }\n      }\n    }\n\n    if (!hasVisibleChild) {\n      refines = false;\n    }\n\n    return refines;\n  }\n\n  updateTile(tile, frameState) {\n    this.updateTileVisibility(tile, frameState);\n  }\n\n  selectTile(tile, frameState) {\n    if (this.shouldSelectTile(tile)) {\n      tile._selectedFrame = frameState.frameNumber;\n      this.selectedTiles[tile.id] = tile;\n    }\n  }\n\n  loadTile(tile, frameState) {\n    if (this.shouldLoadTile(tile)) {\n      tile._requestedFrame = frameState.frameNumber;\n      tile._priority = tile._getPriority();\n      this.requestedTiles[tile.id] = tile;\n    }\n  }\n\n  touchTile(tile, frameState) {\n    tile.tileset._cache.touch(tile);\n\n    tile._touchedFrame = frameState.frameNumber;\n  }\n\n  canTraverse(tile, frameState) {\n    let useParentMetric = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let ignoreVisibility = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n    if (!tile.hasChildren) {\n      return false;\n    }\n\n    if (tile.hasTilesetContent) {\n      return !tile.contentExpired;\n    }\n\n    if (!ignoreVisibility && !tile.isVisibleAndInRequestVolume) {\n      return false;\n    }\n\n    return this.shouldRefine(tile, frameState, useParentMetric);\n  }\n\n  shouldLoadTile(tile) {\n    return tile.hasUnloadedContent || tile.contentExpired;\n  }\n\n  shouldSelectTile(tile) {\n    return tile.contentAvailable && !this.options.skipLevelOfDetail;\n  }\n\n  shouldRefine(tile, frameState, useParentMetric) {\n    let screenSpaceError = tile._screenSpaceError;\n\n    if (useParentMetric) {\n      screenSpaceError = tile.getScreenSpaceError(frameState, true);\n    }\n\n    return screenSpaceError > this.options.maximumScreenSpaceError;\n  }\n\n  updateTileVisibility(tile, frameState) {\n    const viewportIds = [];\n\n    if (this.options.viewportTraversersMap) {\n      for (const key in this.options.viewportTraversersMap) {\n        const value = this.options.viewportTraversersMap[key];\n\n        if (value === frameState.viewport.id) {\n          viewportIds.push(key);\n        }\n      }\n    } else {\n      viewportIds.push(frameState.viewport.id);\n    }\n\n    tile.updateVisibility(frameState, viewportIds);\n  }\n\n  compareDistanceToCamera(b, a) {\n    return b._distanceToCamera - a._distanceToCamera;\n  }\n\n  anyChildrenVisible(tile, frameState) {\n    let anyVisible = false;\n\n    for (const child of tile.children) {\n      child.updateVisibility(frameState);\n      anyVisible = anyVisible || child.isVisibleAndInRequestVolume;\n    }\n\n    return anyVisible;\n  }\n\n  executeEmptyTraversal(root, frameState) {\n    let allDescendantsLoaded = true;\n    const stack = this._emptyTraversalStack;\n    stack.push(root);\n\n    while (stack.length > 0 && allDescendantsLoaded) {\n      const tile = stack.pop();\n      this.updateTile(tile, frameState);\n\n      if (!tile.isVisibleAndInRequestVolume) {\n        this.loadTile(tile, frameState);\n      }\n\n      this.touchTile(tile, frameState);\n      const traverse = !tile.hasRenderContent && this.canTraverse(tile, frameState, false, true);\n\n      if (traverse) {\n        const children = tile.children;\n\n        for (const child of children) {\n          if (stack.find(child)) {\n            stack.delete(child);\n          }\n\n          stack.push(child);\n        }\n      } else if (!tile.contentAvailable) {\n        allDescendantsLoaded = false;\n      }\n    }\n\n    return allDescendantsLoaded;\n  }\n\n}","map":{"version":3,"sources":["../../../../src/tileset/traversers/tileset-traverser.ts"],"names":["DEFAULT_PROPS","loadSiblings","skipLevelOfDetail","maximumScreenSpaceError","updateTransforms","onTraversalEnd","viewportTraversersMap","basePath","constructor","options","traverse","frameState","reset","executeTraversal","stack","root","tile","shouldRefine","parent","parentRefines","Boolean","stoppedRefining","TILE_REFINEMENT","updateChildTiles","children","updateAndPushChildren","checkRefines","hasVisibleChild","refines","child","childRefines","updateTile","selectTile","loadTile","touchTile","canTraverse","useParentMetric","ignoreVisibility","shouldLoadTile","shouldSelectTile","screenSpaceError","updateTileVisibility","viewportIds","value","compareDistanceToCamera","b","a","anyChildrenVisible","anyVisible","executeEmptyTraversal","allDescendantsLoaded"],"mappings":"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","sourcesContent":["import ManagedArray from '../../utils/managed-array';\nimport {TILE_REFINEMENT} from '../../constants';\n\nexport type TilesetTraverserProps = {\n  loadSiblings?: boolean;\n  skipLevelOfDetail?: boolean;\n  maximumScreenSpaceError?: number;\n  onTraversalEnd?: (frameState) => any;\n  viewportTraversersMap?: {[key: string]: any};\n  basePath?: string;\n};\n\nexport type Props = {\n  loadSiblings: boolean;\n  skipLevelOfDetail: boolean;\n  updateTransforms: boolean;\n  maximumScreenSpaceError: number;\n  onTraversalEnd: (frameState) => any;\n  viewportTraversersMap: {[key: string]: any};\n  basePath: string;\n};\n\nexport const DEFAULT_PROPS: Props = {\n  loadSiblings: false,\n  skipLevelOfDetail: false,\n  maximumScreenSpaceError: 2,\n  updateTransforms: true,\n  onTraversalEnd: () => {},\n  viewportTraversersMap: {},\n  basePath: ''\n};\n\nexport default class TilesetTraverser {\n  options: Props;\n\n  root: any;\n  requestedTiles: object;\n  selectedTiles: object;\n  emptyTiles: object;\n\n  protected _traversalStack: ManagedArray;\n  protected _emptyTraversalStack: ManagedArray;\n  protected _frameNumber: number | null;\n\n  // TODO nested props\n  constructor(options: TilesetTraverserProps) {\n    this.options = {...DEFAULT_PROPS, ...options};\n    // TRAVERSAL\n    // temporary storage to hold the traversed tiles during a traversal\n    this._traversalStack = new ManagedArray();\n    this._emptyTraversalStack = new ManagedArray();\n\n    // set in every traverse cycle\n    this._frameNumber = null;\n\n    // fulfill in traverse call\n    this.root = null;\n\n    // RESULT\n    // tiles should be rendered\n    this.selectedTiles = {};\n    // tiles should be loaded from server\n    this.requestedTiles = {};\n    // tiles does not have render content\n    this.emptyTiles = {};\n  }\n\n  // tiles should be visible\n  traverse(root, frameState, options) {\n    this.root = root; // for root screen space error\n    this.options = {...this.options, ...options};\n\n    // reset result\n    this.reset();\n\n    // update tile (visibility and expiration)\n    this.updateTile(root, frameState);\n\n    this._frameNumber = frameState.frameNumber;\n    this.executeTraversal(root, frameState);\n  }\n\n  reset() {\n    this.requestedTiles = {};\n    this.selectedTiles = {};\n    this.emptyTiles = {};\n    this._traversalStack.reset();\n    this._emptyTraversalStack.reset();\n  }\n\n  // execute traverse\n  // Depth-first traversal that traverses all visible tiles and marks tiles for selection.\n  // If skipLevelOfDetail is off then a tile does not refine until all children are loaded.\n  // This is the traditional replacement refinement approach and is called the base traversal.\n  // Tiles that have a greater screen space error than the base screen space error are part of the base traversal,\n  // all other tiles are part of the skip traversal. The skip traversal allows for skipping levels of the tree\n  // and rendering children and parent tiles simultaneously.\n  /* eslint-disable-next-line complexity, max-statements */\n  executeTraversal(root, frameState) {\n    // stack to store traversed tiles, only visible tiles should be added to stack\n    // visible: visible in the current view frustum\n    const stack = this._traversalStack;\n    root._selectionDepth = 1;\n\n    stack.push(root);\n    while (stack.length > 0) {\n      // 1. pop tile\n      const tile = stack.pop();\n\n      // 2. check if tile needs to be refine, needs refine if a tile's LoD is not sufficient and tile has available children (available content)\n      let shouldRefine = false;\n      if (this.canTraverse(tile, frameState)) {\n        this.updateChildTiles(tile, frameState);\n        shouldRefine = this.updateAndPushChildren(\n          tile,\n          frameState,\n          stack,\n          tile.hasRenderContent ? tile._selectionDepth + 1 : tile._selectionDepth\n        );\n      }\n\n      // 3. decide if should render (select) this tile\n      //   - tile does not have render content\n      //   - tile has render content and tile is `add` type (pointcloud)\n      //   - tile has render content and tile is `replace` type (photogrammetry) and can't refine any further\n      const parent = tile.parent;\n      const parentRefines = Boolean(!parent || parent._shouldRefine);\n      const stoppedRefining = !shouldRefine;\n\n      if (!tile.hasRenderContent) {\n        this.emptyTiles[tile.id] = tile;\n        this.loadTile(tile, frameState);\n        if (stoppedRefining) {\n          this.selectTile(tile, frameState);\n        }\n        // additive tiles\n      } else if (tile.refine === TILE_REFINEMENT.ADD) {\n        // Additive tiles are always loaded and selected\n        this.loadTile(tile, frameState);\n        this.selectTile(tile, frameState);\n\n        // replace tiles\n      } else if (tile.refine === TILE_REFINEMENT.REPLACE) {\n        // Always load tiles in the base traversal\n        // Select tiles that can't refine further\n        this.loadTile(tile, frameState);\n        if (stoppedRefining) {\n          this.selectTile(tile, frameState);\n        }\n      }\n\n      // 3. update cache, most recent touched tiles have higher priority to be fetched from server\n      this.touchTile(tile, frameState);\n\n      // 4. update tile refine prop and parent refinement status to trickle down to the descendants\n      tile._shouldRefine = shouldRefine && parentRefines;\n    }\n\n    this.options.onTraversalEnd(frameState);\n  }\n\n  updateChildTiles(tile, frameState) {\n    const children = tile.children;\n    for (const child of children) {\n      this.updateTile(child, frameState);\n    }\n    return true;\n  }\n\n  /* eslint-disable complexity, max-statements */\n  updateAndPushChildren(tile, frameState, stack, depth) {\n    const {loadSiblings, skipLevelOfDetail} = this.options;\n\n    const children = tile.children;\n\n    // sort children tiles\n    children.sort(this.compareDistanceToCamera.bind(this));\n\n    // For traditional replacement refinement only refine if all children are loaded.\n    // Empty tiles are exempt since it looks better if children stream in as they are loaded to fill the empty space.\n    const checkRefines =\n      tile.refine === TILE_REFINEMENT.REPLACE && tile.hasRenderContent && !skipLevelOfDetail;\n\n    let hasVisibleChild = false;\n    let refines = true;\n\n    for (const child of children) {\n      child._selectionDepth = depth;\n      if (child.isVisibleAndInRequestVolume) {\n        if (stack.find(child)) {\n          stack.delete(child);\n        }\n        stack.push(child);\n        hasVisibleChild = true;\n      } else if (checkRefines || loadSiblings) {\n        // Keep non-visible children loaded since they are still needed before the parent can refine.\n        // Or loadSiblings is true so always load tiles regardless of visibility.\n        this.loadTile(child, frameState);\n        this.touchTile(child, frameState);\n      }\n\n      if (checkRefines) {\n        let childRefines;\n        if (!child._inRequestVolume) {\n          childRefines = false;\n        } else if (!child.hasRenderContent) {\n          childRefines = this.executeEmptyTraversal(child, frameState);\n        } else {\n          childRefines = child.contentAvailable;\n        }\n        refines = refines && childRefines;\n\n        if (!refines) {\n          return false;\n        }\n      }\n    }\n\n    if (!hasVisibleChild) {\n      refines = false;\n    }\n    return refines;\n  }\n  /* eslint-enable complexity, max-statements */\n\n  updateTile(tile, frameState) {\n    this.updateTileVisibility(tile, frameState);\n  }\n\n  // tile to render in the browser\n  selectTile(tile, frameState) {\n    if (this.shouldSelectTile(tile)) {\n      // The tile can be selected right away and does not require traverseAndSelect\n      tile._selectedFrame = frameState.frameNumber;\n      this.selectedTiles[tile.id] = tile;\n    }\n  }\n\n  // tile to load from server\n  loadTile(tile, frameState) {\n    if (this.shouldLoadTile(tile)) {\n      tile._requestedFrame = frameState.frameNumber;\n      tile._priority = tile._getPriority();\n      this.requestedTiles[tile.id] = tile;\n    }\n  }\n\n  // cache tile\n  touchTile(tile, frameState) {\n    tile.tileset._cache.touch(tile);\n    tile._touchedFrame = frameState.frameNumber;\n  }\n\n  // tile should be visible\n  // tile should have children\n  // tile LoD (level of detail) is not sufficient under current viewport\n  canTraverse(tile, frameState, useParentMetric = false, ignoreVisibility = false) {\n    if (!tile.hasChildren) {\n      return false;\n    }\n\n    // cesium specific\n    if (tile.hasTilesetContent) {\n      // Traverse external this to visit its root tile\n      // Don't traverse if the subtree is expired because it will be destroyed\n      return !tile.contentExpired;\n    }\n\n    if (!ignoreVisibility && !tile.isVisibleAndInRequestVolume) {\n      return false;\n    }\n\n    return this.shouldRefine(tile, frameState, useParentMetric);\n  }\n\n  shouldLoadTile(tile) {\n    // if request tile is in current frame\n    // and has unexpired render content\n    return tile.hasUnloadedContent || tile.contentExpired;\n  }\n\n  shouldSelectTile(tile) {\n    // if select tile is in current frame\n    // and content available\n    return tile.contentAvailable && !this.options.skipLevelOfDetail;\n  }\n\n  // Decide if tile LoD (level of detail) is not sufficient under current viewport\n  shouldRefine(tile, frameState, useParentMetric) {\n    let screenSpaceError = tile._screenSpaceError;\n    if (useParentMetric) {\n      screenSpaceError = tile.getScreenSpaceError(frameState, true);\n    }\n\n    return screenSpaceError > this.options.maximumScreenSpaceError;\n  }\n\n  updateTileVisibility(tile, frameState) {\n    const viewportIds: string[] = [];\n    if (this.options.viewportTraversersMap) {\n      for (const key in this.options.viewportTraversersMap) {\n        const value = this.options.viewportTraversersMap[key];\n        if (value === frameState.viewport.id) {\n          viewportIds.push(key);\n        }\n      }\n    } else {\n      viewportIds.push(frameState.viewport.id);\n    }\n    tile.updateVisibility(frameState, viewportIds);\n  }\n\n  // UTILITIES\n\n  compareDistanceToCamera(b, a) {\n    return b._distanceToCamera - a._distanceToCamera;\n  }\n\n  anyChildrenVisible(tile, frameState) {\n    let anyVisible = false;\n    for (const child of tile.children) {\n      child.updateVisibility(frameState);\n      anyVisible = anyVisible || child.isVisibleAndInRequestVolume;\n    }\n    return anyVisible;\n  }\n\n  // Depth-first traversal that checks if all nearest descendants with content are loaded.\n  // Ignores visibility.\n  executeEmptyTraversal(root, frameState) {\n    let allDescendantsLoaded = true;\n    const stack = this._emptyTraversalStack;\n\n    stack.push(root);\n\n    while (stack.length > 0 && allDescendantsLoaded) {\n      const tile = stack.pop();\n\n      this.updateTile(tile, frameState);\n\n      if (!tile.isVisibleAndInRequestVolume) {\n        // Load tiles that aren't visible since they are still needed for the parent to refine\n        this.loadTile(tile, frameState);\n      }\n\n      this.touchTile(tile, frameState);\n\n      // Only traverse if the tile is empty - traversal stop at descendants with content\n      const traverse = !tile.hasRenderContent && this.canTraverse(tile, frameState, false, true);\n\n      if (traverse) {\n        const children = tile.children;\n        for (const child of children) {\n          // eslint-disable-next-line max-depth\n          if (stack.find(child)) {\n            stack.delete(child);\n          }\n          stack.push(child);\n        }\n      } else if (!tile.contentAvailable) {\n        allDescendantsLoaded = false;\n      }\n    }\n\n    return allDescendantsLoaded;\n  }\n}\n\n// TODO\n// enable expiration\n// enable optimization hint\n"]},"metadata":{},"sourceType":"module"}