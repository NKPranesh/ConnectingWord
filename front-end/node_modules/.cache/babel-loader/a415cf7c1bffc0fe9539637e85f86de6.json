{"ast":null,"code":"import { assert, validateWorkerVersion } from '@loaders.gl/worker-utils';\nimport { parseWithWorker, canParseWithWorker } from '@loaders.gl/loader-utils';\nimport { isLoaderObject } from '../loader-utils/normalize-loader';\nimport { normalizeOptions } from '../loader-utils/option-utils';\nimport { getArrayBufferOrStringFromData } from '../loader-utils/get-data';\nimport { getLoaderContext, getLoadersFromContext } from '../loader-utils/loader-context';\nimport { getResourceUrlAndType } from '../utils/resource-utils';\nimport { selectLoader } from './select-loader';\nexport async function parse(data, loaders, options, context) {\n  assert(!context || typeof context === 'object');\n\n  if (loaders && !Array.isArray(loaders) && !isLoaderObject(loaders)) {\n    context = undefined;\n    options = loaders;\n    loaders = undefined;\n  }\n\n  data = await data;\n  options = options || {};\n  const {\n    url\n  } = getResourceUrlAndType(data);\n  const typedLoaders = loaders;\n  const candidateLoaders = getLoadersFromContext(typedLoaders, context);\n  const loader = await selectLoader(data, candidateLoaders, options);\n\n  if (!loader) {\n    return null;\n  }\n\n  options = normalizeOptions(options, loader, candidateLoaders, url);\n  context = getLoaderContext({\n    url,\n    parse,\n    loaders: candidateLoaders\n  }, options, context);\n  return await parseWithLoader(loader, data, options, context);\n}\n\nasync function parseWithLoader(loader, data, options, context) {\n  validateWorkerVersion(loader);\n  data = await getArrayBufferOrStringFromData(data, loader, options);\n\n  if (loader.parseTextSync && typeof data === 'string') {\n    options.dataType = 'text';\n    return loader.parseTextSync(data, options, context, loader);\n  }\n\n  if (canParseWithWorker(loader, options)) {\n    return await parseWithWorker(loader, data, options, context, parse);\n  }\n\n  if (loader.parseText && typeof data === 'string') {\n    return await loader.parseText(data, options, context, loader);\n  }\n\n  if (loader.parse) {\n    return await loader.parse(data, options, context, loader);\n  }\n\n  assert(!loader.parseSync);\n  throw new Error(\"\".concat(loader.id, \" loader - no parser found and worker is disabled\"));\n}","map":{"version":3,"sources":["../../../../src/lib/api/parse.ts"],"names":["assert","loaders","Array","isLoaderObject","context","options","data","url","getResourceUrlAndType","typedLoaders","candidateLoaders","getLoadersFromContext","loader","selectLoader","normalizeOptions","getLoaderContext","parseWithLoader","validateWorkerVersion","getArrayBufferOrStringFromData","canParseWithWorker","parseWithWorker"],"mappings":"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","sourcesContent":["import type {DataType, Loader, LoaderContext, LoaderOptions} from '@loaders.gl/loader-utils';\nimport {assert, validateWorkerVersion} from '@loaders.gl/worker-utils';\nimport {parseWithWorker, canParseWithWorker} from '@loaders.gl/loader-utils';\nimport {isLoaderObject} from '../loader-utils/normalize-loader';\nimport {normalizeOptions} from '../loader-utils/option-utils';\nimport {getArrayBufferOrStringFromData} from '../loader-utils/get-data';\nimport {getLoaderContext, getLoadersFromContext} from '../loader-utils/loader-context';\nimport {getResourceUrlAndType} from '../utils/resource-utils';\nimport {selectLoader} from './select-loader';\n\n/**\n * Parses `data` using a specified loader\n * @param data\n * @param loaders\n * @param options\n * @param context\n */\nexport async function parse(\n  data: DataType | Promise<DataType>,\n  loaders?: Loader | Loader[] | LoaderOptions,\n  options?: LoaderOptions,\n  context?: LoaderContext\n): Promise<any> {\n  assert(!context || typeof context === 'object'); // parse no longer accepts final url\n\n  // Signature: parse(data, options, context | url)\n  // Uses registered loaders\n  if (loaders && !Array.isArray(loaders) && !isLoaderObject(loaders)) {\n    context = undefined; // context not supported in short signature\n    options = loaders as LoaderOptions;\n    loaders = undefined;\n  }\n\n  data = await data; // Resolve any promise\n  options = options || {};\n\n  // Extract a url for auto detection\n  const {url} = getResourceUrlAndType(data);\n\n  // Chooses a loader (and normalizes it)\n  // Also use any loaders in the context, new loaders take priority\n  const typedLoaders = loaders as Loader | Loader[] | undefined;\n  const candidateLoaders = getLoadersFromContext(typedLoaders, context);\n  // todo hacky type cast\n  const loader = await selectLoader(data as ArrayBuffer, candidateLoaders, options);\n  // Note: if no loader was found, if so just return null\n  if (!loader) {\n    return null;\n  }\n\n  // Normalize options\n  options = normalizeOptions(options, loader, candidateLoaders, url);\n\n  // Get a context (if already present, will be unchanged)\n  context = getLoaderContext({url, parse, loaders: candidateLoaders}, options, context);\n\n  return await parseWithLoader(loader, data, options, context);\n}\n\n// TODO: support progress and abort\n// TODO - should accept loader.parseAsyncIterator and concatenate.\nasync function parseWithLoader(loader, data, options, context) {\n  validateWorkerVersion(loader);\n\n  data = await getArrayBufferOrStringFromData(data, loader, options);\n\n  // First check for synchronous text parser, wrap results in promises\n  if (loader.parseTextSync && typeof data === 'string') {\n    options.dataType = 'text';\n    return loader.parseTextSync(data, options, context, loader);\n  }\n\n  // If we have a workerUrl and the loader can parse the given options efficiently in a worker\n  if (canParseWithWorker(loader, options)) {\n    return await parseWithWorker(loader, data, options, context, parse);\n  }\n\n  // Check for asynchronous parser\n  if (loader.parseText && typeof data === 'string') {\n    return await loader.parseText(data, options, context, loader);\n  }\n\n  if (loader.parse) {\n    return await loader.parse(data, options, context, loader);\n  }\n\n  // This should not happen, all sync loaders should also offer `parse` function\n  assert(!loader.parseSync);\n\n  // TBD - If asynchronous parser not available, return null\n  throw new Error(`${loader.id} loader - no parser found and worker is disabled`);\n}\n"]},"metadata":{},"sourceType":"module"}