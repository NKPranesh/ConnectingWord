{"ast":null,"code":"import { Vector3 } from '@math.gl/core';\nimport BoundingSphere from '../bounding-volumes/bounding-sphere';\nconst fromPointsXMin = new Vector3();\nconst fromPointsYMin = new Vector3();\nconst fromPointsZMin = new Vector3();\nconst fromPointsXMax = new Vector3();\nconst fromPointsYMax = new Vector3();\nconst fromPointsZMax = new Vector3();\nconst fromPointsCurrentPos = new Vector3();\nconst fromPointsScratch = new Vector3();\nconst fromPointsRitterCenter = new Vector3();\nconst fromPointsMinBoxPt = new Vector3();\nconst fromPointsMaxBoxPt = new Vector3();\nconst fromPointsNaiveCenterScratch = new Vector3();\nconst volumeConstant = 4.0 / 3.0 * Math.PI;\nexport default function makeBoundingSphereFromPoints(positions) {\n  let result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new BoundingSphere();\n\n  if (!positions || positions.length === 0) {\n    return result.fromCenterRadius([0, 0, 0], 0);\n  }\n\n  const currentPos = fromPointsCurrentPos.copy(positions[0]);\n  const xMin = fromPointsXMin.copy(currentPos);\n  const yMin = fromPointsYMin.copy(currentPos);\n  const zMin = fromPointsZMin.copy(currentPos);\n  const xMax = fromPointsXMax.copy(currentPos);\n  const yMax = fromPointsYMax.copy(currentPos);\n  const zMax = fromPointsZMax.copy(currentPos);\n\n  for (const position of positions) {\n    currentPos.copy(position);\n    const x = currentPos.x;\n    const y = currentPos.y;\n    const z = currentPos.z;\n\n    if (x < xMin.x) {\n      xMin.copy(currentPos);\n    }\n\n    if (x > xMax.x) {\n      xMax.copy(currentPos);\n    }\n\n    if (y < yMin.y) {\n      yMin.copy(currentPos);\n    }\n\n    if (y > yMax.y) {\n      yMax.copy(currentPos);\n    }\n\n    if (z < zMin.z) {\n      zMin.copy(currentPos);\n    }\n\n    if (z > zMax.z) {\n      zMax.copy(currentPos);\n    }\n  }\n\n  const xSpan = fromPointsScratch.copy(xMax).subtract(xMin).magnitudeSquared();\n  const ySpan = fromPointsScratch.copy(yMax).subtract(yMin).magnitudeSquared();\n  const zSpan = fromPointsScratch.copy(zMax).subtract(zMin).magnitudeSquared();\n  let diameter1 = xMin;\n  let diameter2 = xMax;\n  let maxSpan = xSpan;\n\n  if (ySpan > maxSpan) {\n    maxSpan = ySpan;\n    diameter1 = yMin;\n    diameter2 = yMax;\n  }\n\n  if (zSpan > maxSpan) {\n    maxSpan = zSpan;\n    diameter1 = zMin;\n    diameter2 = zMax;\n  }\n\n  const ritterCenter = fromPointsRitterCenter;\n  ritterCenter.x = (diameter1.x + diameter2.x) * 0.5;\n  ritterCenter.y = (diameter1.y + diameter2.y) * 0.5;\n  ritterCenter.z = (diameter1.z + diameter2.z) * 0.5;\n  let radiusSquared = fromPointsScratch.copy(diameter2).subtract(ritterCenter).magnitudeSquared();\n  let ritterRadius = Math.sqrt(radiusSquared);\n  const minBoxPt = fromPointsMinBoxPt;\n  minBoxPt.x = xMin.x;\n  minBoxPt.y = yMin.y;\n  minBoxPt.z = zMin.z;\n  const maxBoxPt = fromPointsMaxBoxPt;\n  maxBoxPt.x = xMax.x;\n  maxBoxPt.y = yMax.y;\n  maxBoxPt.z = zMax.z;\n  const naiveCenter = fromPointsNaiveCenterScratch.copy(minBoxPt).add(maxBoxPt).multiplyByScalar(0.5);\n  let naiveRadius = 0;\n\n  for (const position of positions) {\n    currentPos.copy(position);\n    const r = fromPointsScratch.copy(currentPos).subtract(naiveCenter).magnitude();\n\n    if (r > naiveRadius) {\n      naiveRadius = r;\n    }\n\n    const oldCenterToPointSquared = fromPointsScratch.copy(currentPos).subtract(ritterCenter).magnitudeSquared();\n\n    if (oldCenterToPointSquared > radiusSquared) {\n      const oldCenterToPoint = Math.sqrt(oldCenterToPointSquared);\n      ritterRadius = (ritterRadius + oldCenterToPoint) * 0.5;\n      radiusSquared = ritterRadius * ritterRadius;\n      const oldToNew = oldCenterToPoint - ritterRadius;\n      ritterCenter.x = (ritterRadius * ritterCenter.x + oldToNew * currentPos.x) / oldCenterToPoint;\n      ritterCenter.y = (ritterRadius * ritterCenter.y + oldToNew * currentPos.y) / oldCenterToPoint;\n      ritterCenter.z = (ritterRadius * ritterCenter.z + oldToNew * currentPos.z) / oldCenterToPoint;\n    }\n  }\n\n  if (ritterRadius < naiveRadius) {\n    ritterCenter.to(result.center);\n    result.radius = ritterRadius;\n  } else {\n    naiveCenter.to(result.center);\n    result.radius = naiveRadius;\n  }\n\n  return result;\n}","map":{"version":3,"sources":["../../../../src/lib/algorithms/bounding-sphere-from-points.js"],"names":["fromPointsXMin","fromPointsYMin","fromPointsZMin","fromPointsXMax","fromPointsYMax","fromPointsZMax","fromPointsCurrentPos","fromPointsScratch","fromPointsRitterCenter","fromPointsMinBoxPt","fromPointsMaxBoxPt","fromPointsNaiveCenterScratch","volumeConstant","Math","result","positions","currentPos","xMin","yMin","zMin","xMax","yMax","zMax","x","y","z","xSpan","ySpan","zSpan","diameter1","diameter2","maxSpan","ritterCenter","radiusSquared","ritterRadius","minBoxPt","maxBoxPt","naiveCenter","naiveRadius","r","oldCenterToPointSquared","oldCenterToPoint","oldToNew"],"mappings":"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","sourcesContent":["// This file is derived from the Cesium math library under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\nimport {Vector3} from '@math.gl/core';\nimport BoundingSphere from '../bounding-volumes/bounding-sphere';\n\n/* eslint-disable */\nconst fromPointsXMin = new Vector3();\nconst fromPointsYMin = new Vector3();\nconst fromPointsZMin = new Vector3();\nconst fromPointsXMax = new Vector3();\nconst fromPointsYMax = new Vector3();\nconst fromPointsZMax = new Vector3();\nconst fromPointsCurrentPos = new Vector3();\nconst fromPointsScratch = new Vector3();\nconst fromPointsRitterCenter = new Vector3();\nconst fromPointsMinBoxPt = new Vector3();\nconst fromPointsMaxBoxPt = new Vector3();\nconst fromPointsNaiveCenterScratch = new Vector3();\nconst volumeConstant = (4.0 / 3.0) * Math.PI;\n\nexport default function makeBoundingSphereFromPoints(positions, result = new BoundingSphere()) {\n  if (!positions || positions.length === 0) {\n    return result.fromCenterRadius([0, 0, 0], 0);\n  }\n\n  const currentPos = fromPointsCurrentPos.copy(positions[0]);\n\n  const xMin = fromPointsXMin.copy(currentPos);\n  const yMin = fromPointsYMin.copy(currentPos);\n  const zMin = fromPointsZMin.copy(currentPos);\n\n  const xMax = fromPointsXMax.copy(currentPos);\n  const yMax = fromPointsYMax.copy(currentPos);\n  const zMax = fromPointsZMax.copy(currentPos);\n\n  for (const position of positions) {\n    currentPos.copy(position);\n\n    const x = currentPos.x;\n    const y = currentPos.y;\n    const z = currentPos.z;\n\n    // Store points containing the the smallest and largest components\n    if (x < xMin.x) {\n      xMin.copy(currentPos);\n    }\n\n    if (x > xMax.x) {\n      xMax.copy(currentPos);\n    }\n\n    if (y < yMin.y) {\n      yMin.copy(currentPos);\n    }\n\n    if (y > yMax.y) {\n      yMax.copy(currentPos);\n    }\n\n    if (z < zMin.z) {\n      zMin.copy(currentPos);\n    }\n\n    if (z > zMax.z) {\n      zMax.copy(currentPos);\n    }\n  }\n\n  // Compute x-, y-, and z-spans (Squared distances b/n each component's min. and max.).\n  const xSpan = fromPointsScratch.copy(xMax).subtract(xMin).magnitudeSquared();\n  const ySpan = fromPointsScratch.copy(yMax).subtract(yMin).magnitudeSquared();\n  const zSpan = fromPointsScratch.copy(zMax).subtract(zMin).magnitudeSquared();\n\n  // Set the diameter endpoints to the largest span.\n  let diameter1 = xMin;\n  let diameter2 = xMax;\n  let maxSpan = xSpan;\n  if (ySpan > maxSpan) {\n    maxSpan = ySpan;\n    diameter1 = yMin;\n    diameter2 = yMax;\n  }\n  if (zSpan > maxSpan) {\n    maxSpan = zSpan;\n    diameter1 = zMin;\n    diameter2 = zMax;\n  }\n\n  // Calculate the center of the initial sphere found by Ritter's algorithm\n  const ritterCenter = fromPointsRitterCenter;\n  ritterCenter.x = (diameter1.x + diameter2.x) * 0.5;\n  ritterCenter.y = (diameter1.y + diameter2.y) * 0.5;\n  ritterCenter.z = (diameter1.z + diameter2.z) * 0.5;\n\n  // Calculate the radius of the initial sphere found by Ritter's algorithm\n  let radiusSquared = fromPointsScratch.copy(diameter2).subtract(ritterCenter).magnitudeSquared();\n  let ritterRadius = Math.sqrt(radiusSquared);\n\n  // Find the center of the sphere found using the Naive method.\n  const minBoxPt = fromPointsMinBoxPt;\n  minBoxPt.x = xMin.x;\n  minBoxPt.y = yMin.y;\n  minBoxPt.z = zMin.z;\n\n  const maxBoxPt = fromPointsMaxBoxPt;\n  maxBoxPt.x = xMax.x;\n  maxBoxPt.y = yMax.y;\n  maxBoxPt.z = zMax.z;\n\n  const naiveCenter = fromPointsNaiveCenterScratch\n    .copy(minBoxPt)\n    .add(maxBoxPt)\n    .multiplyByScalar(0.5);\n\n  // Begin 2nd pass to find naive radius and modify the ritter sphere.\n  let naiveRadius = 0;\n  for (const position of positions) {\n    currentPos.copy(position);\n\n    // Find the furthest point from the naive center to calculate the naive radius.\n    const r = fromPointsScratch.copy(currentPos).subtract(naiveCenter).magnitude();\n    if (r > naiveRadius) {\n      naiveRadius = r;\n    }\n\n    // Make adjustments to the Ritter Sphere to include all points.\n    const oldCenterToPointSquared = fromPointsScratch\n      .copy(currentPos)\n      .subtract(ritterCenter)\n      .magnitudeSquared();\n\n    if (oldCenterToPointSquared > radiusSquared) {\n      const oldCenterToPoint = Math.sqrt(oldCenterToPointSquared);\n      // Calculate new radius to include the point that lies outside\n      ritterRadius = (ritterRadius + oldCenterToPoint) * 0.5;\n      radiusSquared = ritterRadius * ritterRadius;\n      // Calculate center of new Ritter sphere\n      const oldToNew = oldCenterToPoint - ritterRadius;\n      ritterCenter.x = (ritterRadius * ritterCenter.x + oldToNew * currentPos.x) / oldCenterToPoint;\n      ritterCenter.y = (ritterRadius * ritterCenter.y + oldToNew * currentPos.y) / oldCenterToPoint;\n      ritterCenter.z = (ritterRadius * ritterCenter.z + oldToNew * currentPos.z) / oldCenterToPoint;\n    }\n  }\n\n  if (ritterRadius < naiveRadius) {\n    ritterCenter.to(result.center);\n    // @ts-ignore TS2540: Cannot assign to 'radius' because it is a read-only property.\n    result.radius = ritterRadius;\n  } else {\n    naiveCenter.to(result.center);\n    // @ts-ignore TS2540: Cannot assign to 'radius' because it is a read-only property.\n    result.radius = naiveRadius;\n  }\n\n  return result;\n}\n"]},"metadata":{},"sourceType":"module"}