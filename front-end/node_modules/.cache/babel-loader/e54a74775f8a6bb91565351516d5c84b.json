{"ast":null,"code":"import { createMat4 } from './math-utils';\nimport { zoomToScale, pixelsToWorld, lngLatToWorld, worldToLngLat, worldToPixels, altitudeToFovy, fovyToAltitude, DEFAULT_ALTITUDE, getProjectionMatrix, getDistanceScales, getViewMatrix } from './web-mercator-utils';\nimport fitBounds from './fit-bounds';\nimport getBounds from './get-bounds';\nimport * as mat4 from 'gl-matrix/mat4';\nimport * as vec2 from 'gl-matrix/vec2';\nimport * as vec3 from 'gl-matrix/vec3';\nexport default class WebMercatorViewport {\n  constructor() {\n    let {\n      width,\n      height,\n      latitude = 0,\n      longitude = 0,\n      zoom = 0,\n      pitch = 0,\n      bearing = 0,\n      altitude = null,\n      fovy = null,\n      position = null,\n      nearZMultiplier = 0.02,\n      farZMultiplier = 1.01\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      width: 1,\n      height: 1\n    };\n    width = width || 1;\n    height = height || 1;\n\n    if (fovy === null && altitude === null) {\n      altitude = DEFAULT_ALTITUDE;\n      fovy = altitudeToFovy(altitude);\n    } else if (fovy === null) {\n      fovy = altitudeToFovy(altitude);\n    } else if (altitude === null) {\n      altitude = fovyToAltitude(fovy);\n    }\n\n    const scale = zoomToScale(zoom);\n    altitude = Math.max(0.75, altitude);\n    const distanceScales = getDistanceScales({\n      longitude,\n      latitude\n    });\n    const center = lngLatToWorld([longitude, latitude]);\n    center[2] = 0;\n\n    if (position) {\n      vec3.add(center, center, vec3.mul([], position, distanceScales.unitsPerMeter));\n    }\n\n    this.projectionMatrix = getProjectionMatrix({\n      width,\n      height,\n      pitch,\n      fovy,\n      nearZMultiplier,\n      farZMultiplier\n    });\n    this.viewMatrix = getViewMatrix({\n      height,\n      scale,\n      center,\n      pitch,\n      bearing,\n      altitude\n    });\n    this.width = width;\n    this.height = height;\n    this.scale = scale;\n    this.latitude = latitude;\n    this.longitude = longitude;\n    this.zoom = zoom;\n    this.pitch = pitch;\n    this.bearing = bearing;\n    this.altitude = altitude;\n    this.fovy = fovy;\n    this.center = center;\n    this.meterOffset = position || [0, 0, 0];\n    this.distanceScales = distanceScales;\n\n    this._initMatrices();\n\n    this.equals = this.equals.bind(this);\n    this.project = this.project.bind(this);\n    this.unproject = this.unproject.bind(this);\n    this.projectPosition = this.projectPosition.bind(this);\n    this.unprojectPosition = this.unprojectPosition.bind(this);\n    Object.freeze(this);\n  }\n\n  _initMatrices() {\n    const {\n      width,\n      height,\n      projectionMatrix,\n      viewMatrix\n    } = this;\n    const vpm = createMat4();\n    mat4.multiply(vpm, vpm, projectionMatrix);\n    mat4.multiply(vpm, vpm, viewMatrix);\n    this.viewProjectionMatrix = vpm;\n    const m = createMat4();\n    mat4.scale(m, m, [width / 2, -height / 2, 1]);\n    mat4.translate(m, m, [1, -1, 0]);\n    mat4.multiply(m, m, vpm);\n    const mInverse = mat4.invert(createMat4(), m);\n\n    if (!mInverse) {\n      throw new Error('Pixel project matrix not invertible');\n    }\n\n    this.pixelProjectionMatrix = m;\n    this.pixelUnprojectionMatrix = mInverse;\n  }\n\n  equals(viewport) {\n    if (!(viewport instanceof WebMercatorViewport)) {\n      return false;\n    }\n\n    return viewport.width === this.width && viewport.height === this.height && mat4.equals(viewport.projectionMatrix, this.projectionMatrix) && mat4.equals(viewport.viewMatrix, this.viewMatrix);\n  }\n\n  project(xyz) {\n    let {\n      topLeft = true\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const worldPosition = this.projectPosition(xyz);\n    const coord = worldToPixels(worldPosition, this.pixelProjectionMatrix);\n    const [x, y] = coord;\n    const y2 = topLeft ? y : this.height - y;\n    return xyz.length === 2 ? [x, y2] : [x, y2, coord[2]];\n  }\n\n  unproject(xyz) {\n    let {\n      topLeft = true,\n      targetZ = undefined\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const [x, y, z] = xyz;\n    const y2 = topLeft ? y : this.height - y;\n    const targetZWorld = targetZ && targetZ * this.distanceScales.unitsPerMeter[2];\n    const coord = pixelsToWorld([x, y2, z], this.pixelUnprojectionMatrix, targetZWorld);\n    const [X, Y, Z] = this.unprojectPosition(coord);\n\n    if (Number.isFinite(z)) {\n      return [X, Y, Z];\n    }\n\n    return Number.isFinite(targetZ) ? [X, Y, targetZ] : [X, Y];\n  }\n\n  projectPosition(xyz) {\n    const [X, Y] = lngLatToWorld(xyz);\n    const Z = (xyz[2] || 0) * this.distanceScales.unitsPerMeter[2];\n    return [X, Y, Z];\n  }\n\n  unprojectPosition(xyz) {\n    const [X, Y] = worldToLngLat(xyz);\n    const Z = (xyz[2] || 0) * this.distanceScales.metersPerUnit[2];\n    return [X, Y, Z];\n  }\n\n  projectFlat(lngLat) {\n    return lngLatToWorld(lngLat);\n  }\n\n  unprojectFlat(xy) {\n    return worldToLngLat(xy);\n  }\n\n  getMapCenterByLngLatPosition(_ref) {\n    let {\n      lngLat,\n      pos\n    } = _ref;\n    const fromLocation = pixelsToWorld(pos, this.pixelUnprojectionMatrix);\n    const toLocation = lngLatToWorld(lngLat);\n    const translate = vec2.add([], toLocation, vec2.negate([], fromLocation));\n    const newCenter = vec2.add([], this.center, translate);\n    return worldToLngLat(newCenter);\n  }\n\n  getLocationAtPoint(_ref2) {\n    let {\n      lngLat,\n      pos\n    } = _ref2;\n    return this.getMapCenterByLngLatPosition({\n      lngLat,\n      pos\n    });\n  }\n\n  fitBounds(bounds) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const {\n      width,\n      height\n    } = this;\n    const {\n      longitude,\n      latitude,\n      zoom\n    } = fitBounds(Object.assign({\n      width,\n      height,\n      bounds\n    }, options));\n    return new WebMercatorViewport({\n      width,\n      height,\n      longitude,\n      latitude,\n      zoom\n    });\n  }\n\n  getBounds(options) {\n    const corners = this.getBoundingRegion(options);\n    const west = Math.min(...corners.map(p => p[0]));\n    const east = Math.max(...corners.map(p => p[0]));\n    const south = Math.min(...corners.map(p => p[1]));\n    const north = Math.max(...corners.map(p => p[1]));\n    return [[west, south], [east, north]];\n  }\n\n  getBoundingRegion() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return getBounds(this, options.z || 0);\n  }\n\n}","map":{"version":3,"sources":["../../src/web-mercator-viewport.js"],"names":["constructor","latitude","longitude","zoom","pitch","bearing","altitude","fovy","position","nearZMultiplier","farZMultiplier","width","height","altitudeToFovy","fovyToAltitude","scale","zoomToScale","Math","distanceScales","getDistanceScales","center","lngLatToWorld","vec3","getProjectionMatrix","getViewMatrix","Object","_initMatrices","viewMatrix","vpm","createMat4","mat4","m","mInverse","equals","viewport","project","topLeft","worldPosition","coord","worldToPixels","y2","xyz","unproject","targetZ","undefined","targetZWorld","pixelsToWorld","Number","projectPosition","Z","unprojectPosition","worldToLngLat","projectFlat","unprojectFlat","getMapCenterByLngLatPosition","pos","fromLocation","toLocation","translate","vec2","newCenter","getLocationAtPoint","fitBounds","options","bounds","getBounds","corners","west","p","east","south","north","getBoundingRegion"],"mappings":"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","sourcesContent":["// View and Projection Matrix calculations for mapbox-js style map view properties\nimport {createMat4} from './math-utils';\n\nimport {\n  zoomToScale,\n  pixelsToWorld,\n  lngLatToWorld,\n  worldToLngLat,\n  worldToPixels,\n  altitudeToFovy,\n  fovyToAltitude,\n  DEFAULT_ALTITUDE,\n  getProjectionMatrix,\n  getDistanceScales,\n  getViewMatrix\n} from './web-mercator-utils';\nimport fitBounds from './fit-bounds';\nimport getBounds from './get-bounds';\n\nimport * as mat4 from 'gl-matrix/mat4';\nimport * as vec2 from 'gl-matrix/vec2';\nimport * as vec3 from 'gl-matrix/vec3';\n\nexport default class WebMercatorViewport {\n  // eslint-disable-next-line max-statements\n  constructor(\n    {\n      // Map state\n      width,\n      height,\n      latitude = 0,\n      longitude = 0,\n      zoom = 0,\n      pitch = 0,\n      bearing = 0,\n      altitude = null,\n      fovy = null,\n      position = null,\n      nearZMultiplier = 0.02,\n      farZMultiplier = 1.01\n    } = {width: 1, height: 1}\n  ) {\n    // Silently allow apps to send in 0,0 to facilitate isomorphic render etc\n    width = width || 1;\n    height = height || 1;\n\n    // `fovy` & `altitude` are independent parameters, one for the\n    // projection and the latter for the view matrix. In the past,\n    // the `fovy` was always derived from the `altitude`\n    if (fovy === null && altitude === null) {\n      altitude = DEFAULT_ALTITUDE;\n      fovy = altitudeToFovy(altitude);\n    } else if (fovy === null) {\n      fovy = altitudeToFovy(altitude);\n    } else if (altitude === null) {\n      altitude = fovyToAltitude(fovy);\n    }\n\n    const scale = zoomToScale(zoom);\n    // Altitude - prevent division by 0\n    // TODO - just throw an Error instead?\n    altitude = Math.max(0.75, altitude);\n\n    const distanceScales = getDistanceScales({longitude, latitude});\n\n    const center = lngLatToWorld([longitude, latitude]);\n    center[2] = 0;\n\n    if (position) {\n      vec3.add(center, center, vec3.mul([], position, distanceScales.unitsPerMeter));\n    }\n\n    this.projectionMatrix = getProjectionMatrix({\n      width,\n      height,\n      pitch,\n      fovy,\n      nearZMultiplier,\n      farZMultiplier\n    });\n\n    this.viewMatrix = getViewMatrix({\n      height,\n      scale,\n      center,\n      pitch,\n      bearing,\n      altitude\n    });\n\n    // Save parameters\n    this.width = width;\n    this.height = height;\n    this.scale = scale;\n\n    this.latitude = latitude;\n    this.longitude = longitude;\n    this.zoom = zoom;\n    this.pitch = pitch;\n    this.bearing = bearing;\n    this.altitude = altitude;\n    this.fovy = fovy;\n    this.center = center;\n    this.meterOffset = position || [0, 0, 0];\n\n    this.distanceScales = distanceScales;\n\n    this._initMatrices();\n\n    // Bind methods for easy access\n    this.equals = this.equals.bind(this);\n    this.project = this.project.bind(this);\n    this.unproject = this.unproject.bind(this);\n    this.projectPosition = this.projectPosition.bind(this);\n    this.unprojectPosition = this.unprojectPosition.bind(this);\n\n    Object.freeze(this);\n  }\n\n  _initMatrices() {\n    const {width, height, projectionMatrix, viewMatrix} = this;\n\n    // Note: As usual, matrix operations should be applied in \"reverse\" order\n    // since vectors will be multiplied in from the right during transformation\n    const vpm = createMat4();\n    mat4.multiply(vpm, vpm, projectionMatrix);\n    mat4.multiply(vpm, vpm, viewMatrix);\n    this.viewProjectionMatrix = vpm;\n\n    // Calculate matrices and scales needed for projection\n    /**\n     * Builds matrices that converts preprojected lngLats to screen pixels\n     * and vice versa.\n     * Note: Currently returns bottom-left coordinates!\n     * Note: Starts with the GL projection matrix and adds steps to the\n     *       scale and translate that matrix onto the window.\n     * Note: WebGL controls clip space to screen projection with gl.viewport\n     *       and does not need this step.\n     */\n    const m = createMat4();\n\n    // matrix for conversion from location to screen coordinates\n    mat4.scale(m, m, [width / 2, -height / 2, 1]);\n    mat4.translate(m, m, [1, -1, 0]);\n    mat4.multiply(m, m, vpm);\n\n    const mInverse = mat4.invert(createMat4(), m);\n    if (!mInverse) {\n      throw new Error('Pixel project matrix not invertible');\n    }\n\n    this.pixelProjectionMatrix = m;\n    this.pixelUnprojectionMatrix = mInverse;\n  }\n\n  // Two viewports are equal if width and height are identical, and if\n  // their view and projection matrices are (approximately) equal.\n  equals(viewport) {\n    if (!(viewport instanceof WebMercatorViewport)) {\n      return false;\n    }\n\n    return (\n      viewport.width === this.width &&\n      viewport.height === this.height &&\n      mat4.equals(viewport.projectionMatrix, this.projectionMatrix) &&\n      mat4.equals(viewport.viewMatrix, this.viewMatrix)\n    );\n  }\n\n  // Projects xyz (possibly latitude and longitude) to pixel coordinates in window\n  // using viewport projection parameters\n  project(xyz, {topLeft = true} = {}) {\n    const worldPosition = this.projectPosition(xyz);\n    const coord = worldToPixels(worldPosition, this.pixelProjectionMatrix);\n\n    const [x, y] = coord;\n    const y2 = topLeft ? y : this.height - y;\n    return xyz.length === 2 ? [x, y2] : [x, y2, coord[2]];\n  }\n\n  // Unproject pixel coordinates on screen onto world coordinates,\n  // (possibly [lon, lat]) on map.\n  unproject(xyz, {topLeft = true, targetZ = undefined} = {}) {\n    const [x, y, z] = xyz;\n\n    const y2 = topLeft ? y : this.height - y;\n    const targetZWorld = targetZ && targetZ * this.distanceScales.unitsPerMeter[2];\n    const coord = pixelsToWorld([x, y2, z], this.pixelUnprojectionMatrix, targetZWorld);\n    const [X, Y, Z] = this.unprojectPosition(coord);\n\n    if (Number.isFinite(z)) {\n      return [X, Y, Z];\n    }\n    return Number.isFinite(targetZ) ? [X, Y, targetZ] : [X, Y];\n  }\n\n  // NON_LINEAR PROJECTION HOOKS\n  // Used for web meractor projection\n\n  projectPosition(xyz) {\n    const [X, Y] = lngLatToWorld(xyz);\n    const Z = (xyz[2] || 0) * this.distanceScales.unitsPerMeter[2];\n    return [X, Y, Z];\n  }\n\n  unprojectPosition(xyz) {\n    const [X, Y] = worldToLngLat(xyz);\n    const Z = (xyz[2] || 0) * this.distanceScales.metersPerUnit[2];\n    return [X, Y, Z];\n  }\n\n  // Project [lng,lat] on sphere onto [x,y] on 512*512 Mercator Zoom 0 tile.\n  projectFlat(lngLat) {\n    return lngLatToWorld(lngLat);\n  }\n\n  // Unproject world point [x,y] on map onto {lat, lon} on sphere\n  unprojectFlat(xy) {\n    return worldToLngLat(xy);\n  }\n\n  // Get the map center that place a given [lng, lat] coordinate at screen point [x, y]\n  getMapCenterByLngLatPosition({lngLat, pos}) {\n    const fromLocation = pixelsToWorld(pos, this.pixelUnprojectionMatrix);\n    const toLocation = lngLatToWorld(lngLat);\n\n    const translate = vec2.add([], toLocation, vec2.negate([], fromLocation));\n    const newCenter = vec2.add([], this.center, translate);\n\n    return worldToLngLat(newCenter);\n  }\n\n  // Legacy method name\n  getLocationAtPoint({lngLat, pos}) {\n    return this.getMapCenterByLngLatPosition({lngLat, pos});\n  }\n\n  // Returns a new viewport that fit around the given rectangle.\n  fitBounds(bounds, options = {}) {\n    const {width, height} = this;\n    const {longitude, latitude, zoom} = fitBounds(Object.assign({width, height, bounds}, options));\n    return new WebMercatorViewport({width, height, longitude, latitude, zoom});\n  }\n\n  getBounds(options) {\n    const corners = this.getBoundingRegion(options);\n\n    const west = Math.min(...corners.map((p) => p[0]));\n    const east = Math.max(...corners.map((p) => p[0]));\n    const south = Math.min(...corners.map((p) => p[1]));\n    const north = Math.max(...corners.map((p) => p[1]));\n    return [\n      [west, south],\n      [east, north]\n    ];\n  }\n\n  getBoundingRegion(options = {}) {\n    return getBounds(this, options.z || 0);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}