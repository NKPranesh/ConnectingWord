{"ast":null,"code":"let nodes = [\"pranesh@gmail.com\", \"vamshi@gmail.com\", \"mahesh@gmail.com\", \"virat@gmail.com\", \"rohit@gmail.com\", \"tarak@gmail.com\", \"charan@gmail.com\"];\nlet adjList = [[3, 5, 1], [0], [3, 6], [2, 4, 0], [3], [6, 0], [5, 2]];\nlet v = nodes.length;\nlet pathLists = [];\nlet pathcount = 0;\n\nfunction printAllPaths(s, d) {\n  let isVisited = new Array(v);\n\n  for (let i = 0; i < v; i++) isVisited[i] = false;\n\n  let pathList = [];\n  pathList.push(nodes[s]);\n  printAllPathsUtil(s, d, isVisited, pathList);\n}\n\nfunction printAllPathsUtil(u, d, isVisited, localPathList) {\n  if (u === d) {\n    pathLists[pathcount] = [];\n    localPathList.map(node => {\n      pathLists[pathcount].push(node);\n    });\n    ++pathcount;\n    return;\n  } // Mark the current node\n\n\n  isVisited[u] = true;\n\n  for (let i = 0; i < adjList[u].length; i++) {\n    if (!isVisited[adjList[u][i]]) {\n      localPathList.push(nodes[adjList[u][i]]);\n      printAllPathsUtil(adjList[u][i], d, isVisited, localPathList);\n      localPathList.splice(localPathList.indexOf(nodes[adjList[u][i]]), 1);\n    }\n  }\n\n  isVisited[u] = false;\n}\n\nconst GITlist = (source, destination) => {\n  printAllPaths(nodes.indexOf(source), nodes.indexOf(destination));\n  return pathLists;\n};\n\n_c = GITlist;\nexport default GITlist;\n\nvar _c;\n\n$RefreshReg$(_c, \"GITlist\");","map":{"version":3,"sources":["P:/projects/ConnectingWord/front-end/src/calc/GITfunc.js"],"names":["nodes","adjList","v","length","pathLists","pathcount","printAllPaths","s","d","isVisited","Array","i","pathList","push","printAllPathsUtil","u","localPathList","map","node","splice","indexOf","GITlist","source","destination"],"mappings":"AAAA,IAAIA,KAAK,GAAC,CAAC,mBAAD,EAAqB,kBAArB,EAAwC,kBAAxC,EAA2D,iBAA3D,EAA6E,iBAA7E,EAA+F,iBAA/F,EAAiH,kBAAjH,CAAV;AACA,IAAIC,OAAO,GAAC,CACR,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,CADQ,EAER,CAAC,CAAD,CAFQ,EAGR,CAAC,CAAD,EAAG,CAAH,CAHQ,EAIR,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,CAJQ,EAKR,CAAC,CAAD,CALQ,EAMR,CAAC,CAAD,EAAG,CAAH,CANQ,EAOR,CAAC,CAAD,EAAG,CAAH,CAPQ,CAAZ;AASA,IAAIC,CAAC,GAACF,KAAK,CAACG,MAAZ;AACA,IAAIC,SAAS,GAAC,EAAd;AACA,IAAIC,SAAS,GAAC,CAAd;;AACA,SAASC,aAAT,CAAuBC,CAAvB,EAAyBC,CAAzB,EACA;AACK,MAAIC,SAAS,GAAG,IAAIC,KAAJ,CAAUR,CAAV,CAAhB;;AACA,OAAI,IAAIS,CAAC,GAAC,CAAV,EAAYA,CAAC,GAACT,CAAd,EAAgBS,CAAC,EAAjB,EACIF,SAAS,CAACE,CAAD,CAAT,GAAa,KAAb;;AACD,MAAIC,QAAQ,GAAG,EAAf;AAEAA,EAAAA,QAAQ,CAACC,IAAT,CAAcb,KAAK,CAACO,CAAD,CAAnB;AACAO,EAAAA,iBAAiB,CAACP,CAAD,EAAIC,CAAJ,EAAOC,SAAP,EAAkBG,QAAlB,CAAjB;AAEP;;AACD,SAASE,iBAAT,CAA2BC,CAA3B,EAA6BP,CAA7B,EAA+BC,SAA/B,EAAyCO,aAAzC,EACA;AACI,MAAID,CAAC,KAAKP,CAAV,EAAa;AAEJJ,IAAAA,SAAS,CAACC,SAAD,CAAT,GAAqB,EAArB;AACAW,IAAAA,aAAa,CAACC,GAAd,CAAmBC,IAAD,IAAQ;AACtBd,MAAAA,SAAS,CAACC,SAAD,CAAT,CAAqBQ,IAArB,CAA0BK,IAA1B;AACH,KAFD;AAGD,MAAEb,SAAF;AACA;AAEH,GAVT,CAYQ;;;AACAI,EAAAA,SAAS,CAACM,CAAD,CAAT,GAAe,IAAf;;AACA,OAAK,IAAIJ,CAAC,GAAC,CAAX,EAAaA,CAAC,GAAEV,OAAO,CAACc,CAAD,CAAP,CAAWZ,MAA3B,EAAkCQ,CAAC,EAAnC,EAAuC;AACnC,QAAI,CAACF,SAAS,CAACR,OAAO,CAACc,CAAD,CAAP,CAAWJ,CAAX,CAAD,CAAd,EAA+B;AAC3BK,MAAAA,aAAa,CAACH,IAAd,CAAmBb,KAAK,CAACC,OAAO,CAACc,CAAD,CAAP,CAAWJ,CAAX,CAAD,CAAxB;AACAG,MAAAA,iBAAiB,CAACb,OAAO,CAACc,CAAD,CAAP,CAAWJ,CAAX,CAAD,EAAgBH,CAAhB,EACjBC,SADiB,EACNO,aADM,CAAjB;AAGAA,MAAAA,aAAa,CAACG,MAAd,CAAqBH,aAAa,CAACI,OAAd,CACpBpB,KAAK,CAACC,OAAO,CAACc,CAAD,CAAP,CAAWJ,CAAX,CAAD,CADe,CAArB,EACuB,CADvB;AAEH;AACJ;;AACDF,EAAAA,SAAS,CAACM,CAAD,CAAT,GAAe,KAAf;AACP;;AAED,MAAMM,OAAO,GAAG,CAACC,MAAD,EAAQC,WAAR,KAAwB;AACpCjB,EAAAA,aAAa,CAACN,KAAK,CAACoB,OAAN,CAAcE,MAAd,CAAD,EAAuBtB,KAAK,CAACoB,OAAN,CAAcG,WAAd,CAAvB,CAAb;AACA,SAAOnB,SAAP;AACH,CAHD;;KAAMiB,O;AAIN,eAAeA,OAAf","sourcesContent":["let nodes=[\"pranesh@gmail.com\",\"vamshi@gmail.com\",\"mahesh@gmail.com\",\"virat@gmail.com\",\"rohit@gmail.com\",\"tarak@gmail.com\",\"charan@gmail.com\"];\r\nlet adjList=[\r\n    [3,5,1],\r\n    [0],\r\n    [3,6],\r\n    [2,4,0],\r\n    [3],\r\n    [6,0],\r\n    [5,2]\r\n];\r\nlet v=nodes.length;\r\nlet pathLists=[];\r\nlet pathcount=0;\r\nfunction printAllPaths(s,d)\r\n{\r\n     let isVisited = new Array(v);\r\n     for(let i=0;i<v;i++)\r\n         isVisited[i]=false;\r\n        let pathList = [];\r\n  \r\n        pathList.push(nodes[s]);\r\n        printAllPathsUtil(s, d, isVisited, pathList);\r\n \r\n}\r\nfunction printAllPathsUtil(u,d,isVisited,localPathList)\r\n{\r\n    if (u === d) {\r\n            \r\n             pathLists[pathcount]=[];\r\n             localPathList.map((node)=>{\r\n                 pathLists[pathcount].push(node);\r\n             })\r\n            ++pathcount;\r\n            return ;\r\n            \r\n        }\r\n  \r\n        // Mark the current node\r\n        isVisited[u] = true;\r\n        for (let i=0;i< adjList[u].length;i++) {\r\n            if (!isVisited[adjList[u][i]]) {\r\n                localPathList.push(nodes[adjList[u][i]]);\r\n                printAllPathsUtil(adjList[u][i], d,\r\n                isVisited, localPathList);\r\n  \r\n                localPathList.splice(localPathList.indexOf\r\n                (nodes[adjList[u][i]]),1);\r\n            }\r\n        }\r\n        isVisited[u] = false;\r\n}\r\n\r\nconst GITlist = (source,destination) => {\r\n    printAllPaths(nodes.indexOf(source),nodes.indexOf(destination))\r\n    return pathLists;\r\n}\r\nexport default GITlist;"]},"metadata":{},"sourceType":"module"}