{"ast":null,"code":"import { MAGIC_ARRAY } from '../constants';\nimport { encode3DTileHeader, encode3DTileByteLength } from './helpers/encode-3d-tile-header';\nimport { padStringToByteAlignment, copyStringToDataView, copyBinaryToDataView } from '@loaders.gl/loader-utils';\nconst DEFAULT_FEATURE_TABLE_JSON = {\n  POINTS_LENGTH: 1,\n  POSITIONS: {\n    byteOffset: 0\n  }\n};\nexport function encodePointCloud3DTile(tile, dataView, byteOffset, options) {\n  const {\n    featureTableJson = DEFAULT_FEATURE_TABLE_JSON\n  } = tile;\n  let featureTableJsonString = JSON.stringify(featureTableJson);\n  featureTableJsonString = padStringToByteAlignment(featureTableJsonString, 4);\n  const {\n    featureTableJsonByteLength = featureTableJsonString.length\n  } = tile;\n  const featureTableBinary = new ArrayBuffer(12);\n  const featureTableBinaryByteLength = featureTableBinary.byteLength;\n  tile = {\n    magic: MAGIC_ARRAY.POINT_CLOUD,\n    ...tile\n  };\n  const byteOffsetStart = byteOffset;\n  byteOffset += encode3DTileHeader(tile, dataView, 0);\n\n  if (dataView) {\n    dataView.setUint32(byteOffset + 0, featureTableJsonByteLength, true);\n    dataView.setUint32(byteOffset + 4, featureTableBinaryByteLength, true);\n    dataView.setUint32(byteOffset + 8, 0, true);\n    dataView.setUint32(byteOffset + 12, 0, true);\n  }\n\n  byteOffset += 16;\n  byteOffset += copyStringToDataView(dataView, byteOffset, featureTableJsonString, featureTableJsonByteLength);\n  byteOffset += copyBinaryToDataView(dataView, byteOffset, featureTableBinary, featureTableBinaryByteLength);\n  encode3DTileByteLength(dataView, byteOffsetStart, byteOffset - byteOffsetStart);\n  return byteOffset;\n}","map":{"version":3,"sources":["../../../../src/lib/encoders/encode-3d-tile-point-cloud.js"],"names":["DEFAULT_FEATURE_TABLE_JSON","POINTS_LENGTH","POSITIONS","byteOffset","featureTableJson","featureTableJsonString","JSON","padStringToByteAlignment","featureTableJsonByteLength","length","featureTableBinary","featureTableBinaryByteLength","tile","magic","MAGIC_ARRAY","byteOffsetStart","encode3DTileHeader","dataView","copyStringToDataView","copyBinaryToDataView","encode3DTileByteLength"],"mappings":"AAGA,SAAA,WAAA,QAAA,cAAA;AACA,SAAA,kBAAA,EAAA,sBAAA,QAAA,iCAAA;AACA,SAAA,wBAAA,EAAA,oBAAA,EAAA,oBAAA,QAAA,0BAAA;AAMA,MAAMA,0BAA0B,GAAG;AACjCC,EAAAA,aAAa,EADoB,CAAA;AAEjCC,EAAAA,SAAS,EAAE;AACTC,IAAAA,UAAU,EAAE;AADH;AAFsB,CAAnC;AAOA,OAAO,SAAA,sBAAA,CAAA,IAAA,EAAA,QAAA,EAAA,UAAA,EAAA,OAAA,EAAqE;AAC1E,QAAM;AAACC,IAAAA,gBAAgB,GAAGJ;AAApB,MAAN,IAAA;AAEA,MAAIK,sBAAsB,GAAGC,IAAI,CAAJA,SAAAA,CAA7B,gBAA6BA,CAA7B;AACAD,EAAAA,sBAAsB,GAAGE,wBAAwB,CAAA,sBAAA,EAAjDF,CAAiD,CAAjDA;AAEA,QAAM;AAACG,IAAAA,0BAA0B,GAAGH,sBAAsB,CAACI;AAArD,MAAN,IAAA;AAEA,QAAMC,kBAAkB,GAAG,IAAA,WAAA,CAA3B,EAA2B,CAA3B;AACA,QAAMC,4BAA4B,GAAGD,kBAAkB,CAAvD,UAAA;AAGAE,EAAAA,IAAI,GAAG;AAACC,IAAAA,KAAK,EAAEC,WAAW,CAAnB,WAAA;AAAiC,OAAGF;AAApC,GAAPA;AAEA,QAAMG,eAAe,GAArB,UAAA;AAEAZ,EAAAA,UAAU,IAAIa,kBAAkB,CAAA,IAAA,EAAA,QAAA,EAAhCb,CAAgC,CAAhCA;;AAEA,MAAA,QAAA,EAAc;AACZc,IAAAA,QAAQ,CAARA,SAAAA,CAAmBd,UAAU,GAA7Bc,CAAAA,EAAAA,0BAAAA,EAAAA,IAAAA;AACAA,IAAAA,QAAQ,CAARA,SAAAA,CAAmBd,UAAU,GAA7Bc,CAAAA,EAAAA,4BAAAA,EAAAA,IAAAA;AACAA,IAAAA,QAAQ,CAARA,SAAAA,CAAmBd,UAAU,GAA7Bc,CAAAA,EAAAA,CAAAA,EAAAA,IAAAA;AACAA,IAAAA,QAAQ,CAARA,SAAAA,CAAmBd,UAAU,GAA7Bc,EAAAA,EAAAA,CAAAA,EAAAA,IAAAA;AACD;;AACDd,EAAAA,UAAU,IAAVA,EAAAA;AAEAA,EAAAA,UAAU,IAAIe,oBAAoB,CAAA,QAAA,EAAA,UAAA,EAAA,sBAAA,EAAlCf,0BAAkC,CAAlCA;AAMAA,EAAAA,UAAU,IAAIgB,oBAAoB,CAAA,QAAA,EAAA,UAAA,EAAA,kBAAA,EAAlChB,4BAAkC,CAAlCA;AAQAiB,EAAAA,sBAAsB,CAAA,QAAA,EAAA,eAAA,EAA4BjB,UAAU,GAA5DiB,eAAsB,CAAtBA;AAEA,SAAA,UAAA;AACD","sourcesContent":["// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\nimport {MAGIC_ARRAY} from '../constants';\nimport {encode3DTileHeader, encode3DTileByteLength} from './helpers/encode-3d-tile-header';\nimport {\n  padStringToByteAlignment,\n  copyStringToDataView,\n  copyBinaryToDataView\n} from '@loaders.gl/loader-utils';\n\nconst DEFAULT_FEATURE_TABLE_JSON = {\n  POINTS_LENGTH: 1,\n  POSITIONS: {\n    byteOffset: 0\n  }\n};\n\nexport function encodePointCloud3DTile(tile, dataView, byteOffset, options) {\n  const {featureTableJson = DEFAULT_FEATURE_TABLE_JSON} = tile;\n\n  let featureTableJsonString = JSON.stringify(featureTableJson);\n  featureTableJsonString = padStringToByteAlignment(featureTableJsonString, 4);\n\n  const {featureTableJsonByteLength = featureTableJsonString.length} = tile;\n\n  const featureTableBinary = new ArrayBuffer(12); // Enough space to hold 3 floats\n  const featureTableBinaryByteLength = featureTableBinary.byteLength;\n\n  // Add default magic for this tile type\n  tile = {magic: MAGIC_ARRAY.POINT_CLOUD, ...tile};\n\n  const byteOffsetStart = byteOffset;\n\n  byteOffset += encode3DTileHeader(tile, dataView, 0);\n\n  if (dataView) {\n    dataView.setUint32(byteOffset + 0, featureTableJsonByteLength, true); // featureTableJsonByteLength\n    dataView.setUint32(byteOffset + 4, featureTableBinaryByteLength, true); // featureTableBinaryByteLength\n    dataView.setUint32(byteOffset + 8, 0, true); // batchTableJsonByteLength\n    dataView.setUint32(byteOffset + 12, 0, true); // batchTableBinaryByteLength\n  }\n  byteOffset += 16;\n\n  byteOffset += copyStringToDataView(\n    dataView,\n    byteOffset,\n    featureTableJsonString,\n    featureTableJsonByteLength\n  );\n  byteOffset += copyBinaryToDataView(\n    dataView,\n    byteOffset,\n    featureTableBinary,\n    featureTableBinaryByteLength\n  );\n\n  // Go \"back\" and rewrite the tile's `byteLength` now that we know the value\n  encode3DTileByteLength(dataView, byteOffsetStart, byteOffset - byteOffsetStart);\n\n  return byteOffset;\n}\n"]},"metadata":{},"sourceType":"module"}