{"ast":null,"code":"import * as node from './buffer-utils';\nexport function toArrayBuffer(data) {\n  if (node.isBuffer(data)) {\n    data = node.bufferToArrayBuffer(data);\n  }\n\n  if (data instanceof ArrayBuffer) {\n    return data;\n  }\n\n  if (ArrayBuffer.isView(data)) {\n    if (data.byteOffset === 0 && data.byteLength === data.buffer.byteLength) {\n      return data.buffer;\n    }\n\n    return data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength);\n  }\n\n  if (typeof data === 'string') {\n    const text = data;\n    const uint8Array = new TextEncoder().encode(text);\n    return uint8Array.buffer;\n  }\n\n  if (data && typeof data === 'object' && data._toArrayBuffer) {\n    return data._toArrayBuffer();\n  }\n\n  throw new Error('toArrayBuffer');\n}\nexport function compareArrayBuffers(arrayBuffer1, arrayBuffer2, byteLength) {\n  byteLength = byteLength || arrayBuffer1.byteLength;\n\n  if (arrayBuffer1.byteLength < byteLength || arrayBuffer2.byteLength < byteLength) {\n    return false;\n  }\n\n  const array1 = new Uint8Array(arrayBuffer1);\n  const array2 = new Uint8Array(arrayBuffer2);\n\n  for (let i = 0; i < array1.length; ++i) {\n    if (array1[i] !== array2[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\nexport function concatenateArrayBuffers() {\n  for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {\n    sources[_key] = arguments[_key];\n  }\n\n  const sourceArrays = sources.map(source2 => source2 instanceof ArrayBuffer ? new Uint8Array(source2) : source2);\n  const byteLength = sourceArrays.reduce((length, typedArray) => length + typedArray.byteLength, 0);\n  const result = new Uint8Array(byteLength);\n  let offset = 0;\n\n  for (const sourceArray of sourceArrays) {\n    result.set(sourceArray, offset);\n    offset += sourceArray.byteLength;\n  }\n\n  return result.buffer;\n}\nexport function concatenateTypedArrays() {\n  for (var _len2 = arguments.length, typedArrays = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    typedArrays[_key2] = arguments[_key2];\n  }\n\n  const arrays = typedArrays;\n  const TypedArrayConstructor = arrays && arrays.length > 1 && arrays[0].constructor || null;\n\n  if (!TypedArrayConstructor) {\n    throw new Error('\"concatenateTypedArrays\" - incorrect quantity of arguments or arguments have incompatible data types');\n  }\n\n  const sumLength = arrays.reduce((acc, value) => acc + value.length, 0);\n  const result = new TypedArrayConstructor(sumLength);\n  let offset = 0;\n\n  for (const array of arrays) {\n    result.set(array, offset);\n    offset += array.length;\n  }\n\n  return result;\n}\nexport function sliceArrayBuffer(arrayBuffer, byteOffset, byteLength) {\n  const subArray = byteLength !== undefined ? new Uint8Array(arrayBuffer).subarray(byteOffset, byteOffset + byteLength) : new Uint8Array(arrayBuffer).subarray(byteOffset);\n  const arrayCopy = new Uint8Array(subArray);\n  return arrayCopy.buffer;\n}","map":{"version":3,"sources":["../../../../src/lib/binary-utils/array-buffer-utils.ts"],"names":["node","data","ArrayBuffer","text","uint8Array","byteLength","arrayBuffer1","arrayBuffer2","array1","array2","i","sourceArrays","sources","source2","length","typedArray","result","offset","sourceArray","arrays","TypedArrayConstructor","sumLength","acc","value","array","subArray","byteOffset","arrayCopy"],"mappings":"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","sourcesContent":["import {TypedArray} from '../../types';\nimport * as node from './buffer-utils';\n\n/**\n * Convert an object to an array buffer\n */\nexport function toArrayBuffer(data: any): ArrayBuffer {\n  // Note: Should be called first, Buffers can trigger other detections below\n  if (node.isBuffer(data)) {\n    // TODO - per docs we should just be able to call buffer.buffer, but there are issues\n    data = node.bufferToArrayBuffer(data);\n  }\n\n  if (data instanceof ArrayBuffer) {\n    return data;\n  }\n\n  // Careful - Node Buffers look like Uint8Arrays (keep after isBuffer)\n  if (ArrayBuffer.isView(data)) {\n    if (data.byteOffset === 0 && data.byteLength === data.buffer.byteLength) {\n      return data.buffer;\n    }\n    return data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength);\n  }\n\n  if (typeof data === 'string') {\n    const text = data;\n    const uint8Array = new TextEncoder().encode(text);\n    return uint8Array.buffer;\n  }\n\n  // HACK to support Blob polyfill\n  if (data && typeof data === 'object' && data._toArrayBuffer) {\n    return data._toArrayBuffer();\n  }\n\n  throw new Error('toArrayBuffer');\n}\n\n/**\n * compare two binary arrays for equality\n * @param {ArrayBuffer} a\n * @param {ArrayBuffer} b\n * @param {number} byteLength\n */\nexport function compareArrayBuffers(\n  arrayBuffer1: ArrayBuffer,\n  arrayBuffer2: ArrayBuffer,\n  byteLength?: number\n): boolean {\n  byteLength = byteLength || arrayBuffer1.byteLength;\n  if (arrayBuffer1.byteLength < byteLength || arrayBuffer2.byteLength < byteLength) {\n    return false;\n  }\n  const array1 = new Uint8Array(arrayBuffer1);\n  const array2 = new Uint8Array(arrayBuffer2);\n  for (let i = 0; i < array1.length; ++i) {\n    if (array1[i] !== array2[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Concatenate a sequence of ArrayBuffers\n * @return A concatenated ArrayBuffer\n */\nexport function concatenateArrayBuffers(...sources: (ArrayBuffer | Uint8Array)[]): ArrayBuffer {\n  // Make sure all inputs are wrapped in typed arrays\n  const sourceArrays = sources.map((source2) =>\n    source2 instanceof ArrayBuffer ? new Uint8Array(source2) : source2\n  );\n\n  // Get length of all inputs\n  const byteLength = sourceArrays.reduce((length, typedArray) => length + typedArray.byteLength, 0);\n\n  // Allocate array with space for all inputs\n  const result = new Uint8Array(byteLength);\n\n  // Copy the subarrays\n  let offset = 0;\n  for (const sourceArray of sourceArrays) {\n    result.set(sourceArray, offset);\n    offset += sourceArray.byteLength;\n  }\n\n  // We work with ArrayBuffers, discard the typed array wrapper\n  return result.buffer;\n}\n\n/**\n * Concatenate arbitrary count of typed arrays\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Typed_arrays\n * @param {...*} arrays - list of arrays. All arrays should be the same type\n * @return A concatenated TypedArray\n */\nexport function concatenateTypedArrays<T>(...typedArrays: T[]): T {\n  // @ts-ignore\n  const arrays = typedArrays as TypedArray[];\n  // @ts-ignore\n  const TypedArrayConstructor = (arrays && arrays.length > 1 && arrays[0].constructor) || null;\n  if (!TypedArrayConstructor) {\n    throw new Error(\n      '\"concatenateTypedArrays\" - incorrect quantity of arguments or arguments have incompatible data types'\n    );\n  }\n\n  const sumLength = arrays.reduce((acc, value) => acc + value.length, 0);\n  // @ts-ignore typescript does not like dynamic constructors\n  const result = new TypedArrayConstructor(sumLength);\n  let offset = 0;\n  for (const array of arrays) {\n    result.set(array, offset);\n    offset += array.length;\n  }\n  return result;\n}\n\n/**\n * Copy a view of an ArrayBuffer into new ArrayBuffer with byteOffset = 0\n * @param arrayBuffer\n * @param byteOffset\n * @param byteLength\n */\nexport function sliceArrayBuffer(\n  arrayBuffer: ArrayBuffer,\n  byteOffset: number,\n  byteLength?: number\n): ArrayBuffer {\n  const subArray =\n    byteLength !== undefined\n      ? new Uint8Array(arrayBuffer).subarray(byteOffset, byteOffset + byteLength)\n      : new Uint8Array(arrayBuffer).subarray(byteOffset);\n  const arrayCopy = new Uint8Array(subArray);\n  return arrayCopy.buffer;\n}\n"]},"metadata":{},"sourceType":"module"}