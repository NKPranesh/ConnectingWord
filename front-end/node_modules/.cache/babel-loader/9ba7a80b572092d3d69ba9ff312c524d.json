{"ast":null,"code":"import { isWebGL2 } from '@luma.gl/gltools';\nimport { Buffer, TransformFeedback } from '@luma.gl/webgl';\nimport { assert } from '@luma.gl/webgl';\nexport default class BufferTransform {\n  constructor(gl) {\n    let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.gl = gl;\n    this.currentIndex = 0;\n    this.feedbackMap = {};\n    this.varyings = null;\n    this.bindings = [];\n    this.resources = {};\n\n    this._initialize(props);\n\n    Object.seal(this);\n  }\n\n  setupResources(opts) {\n    for (const binding of this.bindings) {\n      this._setupTransformFeedback(binding, opts);\n    }\n  }\n\n  updateModelProps() {\n    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const {\n      varyings\n    } = this;\n\n    if (varyings.length > 0) {\n      props = Object.assign({}, props, {\n        varyings\n      });\n    }\n\n    return props;\n  }\n\n  getDrawOptions() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const binding = this.bindings[this.currentIndex];\n    const {\n      sourceBuffers,\n      transformFeedback\n    } = binding;\n    const attributes = Object.assign({}, sourceBuffers, opts.attributes);\n    return {\n      attributes,\n      transformFeedback\n    };\n  }\n\n  swap() {\n    if (this.feedbackMap) {\n      this.currentIndex = this._getNextIndex();\n      return true;\n    }\n\n    return false;\n  }\n\n  update() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    this._setupBuffers(opts);\n  }\n\n  getBuffer(varyingName) {\n    const {\n      feedbackBuffers\n    } = this.bindings[this.currentIndex];\n    const bufferOrParams = varyingName ? feedbackBuffers[varyingName] : null;\n\n    if (!bufferOrParams) {\n      return null;\n    }\n\n    return bufferOrParams instanceof Buffer ? bufferOrParams : bufferOrParams.buffer;\n  }\n\n  getData() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const {\n      varyingName\n    } = options;\n    const buffer = this.getBuffer(varyingName);\n\n    if (buffer) {\n      return buffer.getData();\n    }\n\n    return null;\n  }\n\n  delete() {\n    for (const name in this.resources) {\n      this.resources[name].delete();\n    }\n  }\n\n  _initialize() {\n    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    this._setupBuffers(props);\n\n    this.varyings = props.varyings || Object.keys(this.bindings[this.currentIndex].feedbackBuffers);\n\n    if (this.varyings.length > 0) {\n      assert(isWebGL2(this.gl));\n    }\n  }\n\n  _getFeedbackBuffers(props) {\n    const {\n      sourceBuffers = {}\n    } = props;\n    const feedbackBuffers = {};\n\n    if (this.bindings[this.currentIndex]) {\n      Object.assign(feedbackBuffers, this.bindings[this.currentIndex].feedbackBuffers);\n    }\n\n    if (this.feedbackMap) {\n      for (const sourceName in this.feedbackMap) {\n        const feedbackName = this.feedbackMap[sourceName];\n\n        if (sourceName in sourceBuffers) {\n          feedbackBuffers[feedbackName] = sourceName;\n        }\n      }\n    }\n\n    Object.assign(feedbackBuffers, props.feedbackBuffers);\n\n    for (const bufferName in feedbackBuffers) {\n      const bufferOrRef = feedbackBuffers[bufferName];\n\n      if (typeof bufferOrRef === 'string') {\n        const sourceBuffer = sourceBuffers[bufferOrRef];\n        const {\n          byteLength,\n          usage,\n          accessor\n        } = sourceBuffer;\n        feedbackBuffers[bufferName] = this._createNewBuffer(bufferName, {\n          byteLength,\n          usage,\n          accessor\n        });\n      }\n    }\n\n    return feedbackBuffers;\n  }\n\n  _setupBuffers() {\n    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const {\n      sourceBuffers = null\n    } = props;\n    Object.assign(this.feedbackMap, props.feedbackMap);\n\n    const feedbackBuffers = this._getFeedbackBuffers(props);\n\n    this._updateBindings({\n      sourceBuffers,\n      feedbackBuffers\n    });\n  }\n\n  _setupTransformFeedback(binding, _ref) {\n    let {\n      model\n    } = _ref;\n    const {\n      program\n    } = model;\n    binding.transformFeedback = new TransformFeedback(this.gl, {\n      program,\n      buffers: binding.feedbackBuffers\n    });\n  }\n\n  _updateBindings(opts) {\n    this.bindings[this.currentIndex] = this._updateBinding(this.bindings[this.currentIndex], opts);\n\n    if (this.feedbackMap) {\n      const {\n        sourceBuffers,\n        feedbackBuffers\n      } = this._swapBuffers(this.bindings[this.currentIndex]);\n\n      const nextIndex = this._getNextIndex();\n\n      this.bindings[nextIndex] = this._updateBinding(this.bindings[nextIndex], {\n        sourceBuffers,\n        feedbackBuffers\n      });\n    }\n  }\n\n  _updateBinding(binding, opts) {\n    if (!binding) {\n      return {\n        sourceBuffers: Object.assign({}, opts.sourceBuffers),\n        feedbackBuffers: Object.assign({}, opts.feedbackBuffers)\n      };\n    }\n\n    Object.assign(binding.sourceBuffers, opts.sourceBuffers);\n    Object.assign(binding.feedbackBuffers, opts.feedbackBuffers);\n\n    if (binding.transformFeedback) {\n      binding.transformFeedback.setBuffers(binding.feedbackBuffers);\n    }\n\n    return binding;\n  }\n\n  _swapBuffers(opts) {\n    if (!this.feedbackMap) {\n      return null;\n    }\n\n    const sourceBuffers = Object.assign({}, opts.sourceBuffers);\n    const feedbackBuffers = Object.assign({}, opts.feedbackBuffers);\n\n    for (const srcName in this.feedbackMap) {\n      const dstName = this.feedbackMap[srcName];\n      sourceBuffers[srcName] = opts.feedbackBuffers[dstName];\n      feedbackBuffers[dstName] = opts.sourceBuffers[srcName];\n      assert(feedbackBuffers[dstName] instanceof Buffer);\n    }\n\n    return {\n      sourceBuffers,\n      feedbackBuffers\n    };\n  }\n\n  _createNewBuffer(name, opts) {\n    const buffer = new Buffer(this.gl, opts);\n\n    if (this.resources[name]) {\n      this.resources[name].delete();\n    }\n\n    this.resources[name] = buffer;\n    return buffer;\n  }\n\n  _getNextIndex() {\n    return (this.currentIndex + 1) % 2;\n  }\n\n}","map":{"version":3,"sources":["../../../src/transform/buffer-transform.js"],"names":["constructor","props","Object","setupResources","updateModelProps","varyings","getDrawOptions","opts","binding","transformFeedback","attributes","swap","update","getBuffer","feedbackBuffers","bufferOrParams","varyingName","getData","options","buffer","delete","_initialize","assert","isWebGL2","_getFeedbackBuffers","sourceBuffers","feedbackName","sourceName","bufferOrRef","sourceBuffer","accessor","_setupBuffers","_setupTransformFeedback","model","program","buffers","_updateBindings","nextIndex","_updateBinding","_swapBuffers","dstName","_createNewBuffer","_getNextIndex"],"mappings":"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","sourcesContent":["import {isWebGL2} from '@luma.gl/gltools';\nimport {Buffer, TransformFeedback} from '@luma.gl/webgl';\nimport {assert} from '@luma.gl/webgl';\n\nexport default class BufferTransform {\n  constructor(gl, props = {}) {\n    this.gl = gl;\n    this.currentIndex = 0;\n    this.feedbackMap = {};\n    this.varyings = null; // varyings array\n    this.bindings = []; // each element is an object : {sourceBuffers, feedbackBuffers, transformFeedback}\n\n    this.resources = {}; // resources to be deleted\n\n    this._initialize(props);\n    Object.seal(this);\n  }\n\n  setupResources(opts) {\n    for (const binding of this.bindings) {\n      this._setupTransformFeedback(binding, opts);\n    }\n  }\n\n  updateModelProps(props = {}) {\n    const {varyings} = this;\n    if (varyings.length > 0) {\n      props = Object.assign({}, props, {varyings});\n    }\n    return props;\n  }\n\n  getDrawOptions(opts = {}) {\n    const binding = this.bindings[this.currentIndex];\n    const {sourceBuffers, transformFeedback} = binding;\n    const attributes = Object.assign({}, sourceBuffers, opts.attributes);\n\n    return {attributes, transformFeedback};\n  }\n\n  swap() {\n    if (this.feedbackMap) {\n      this.currentIndex = this._getNextIndex();\n      return true;\n    }\n    return false;\n  }\n\n  // update source and/or feedbackBuffers\n  update(opts = {}) {\n    this._setupBuffers(opts);\n  }\n\n  // returns current feedbackBuffer of given name\n  getBuffer(varyingName) {\n    const {feedbackBuffers} = this.bindings[this.currentIndex];\n    const bufferOrParams = varyingName ? feedbackBuffers[varyingName] : null;\n    if (!bufferOrParams) {\n      return null;\n    }\n    return bufferOrParams instanceof Buffer ? bufferOrParams : bufferOrParams.buffer;\n  }\n\n  getData(options = {}) {\n    const {varyingName} = options;\n    const buffer = this.getBuffer(varyingName);\n    if (buffer) {\n      return buffer.getData();\n    }\n    return null;\n  }\n\n  // Delete owned resources.\n  delete() {\n    for (const name in this.resources) {\n      this.resources[name].delete();\n    }\n  }\n\n  // Private\n\n  _initialize(props = {}) {\n    this._setupBuffers(props);\n    this.varyings = props.varyings || Object.keys(this.bindings[this.currentIndex].feedbackBuffers);\n    if (this.varyings.length > 0) {\n      // if writting to buffers make sure it is WebGL2\n      assert(isWebGL2(this.gl));\n    }\n  }\n\n  // auto create feedback buffers if requested\n  _getFeedbackBuffers(props) {\n    const {sourceBuffers = {}} = props;\n    const feedbackBuffers = {};\n    if (this.bindings[this.currentIndex]) {\n      // this gurantees a partial feedback buffer set doesn't update\n      // previously set buffers during auto creation mode.\n      Object.assign(feedbackBuffers, this.bindings[this.currentIndex].feedbackBuffers);\n    }\n    if (this.feedbackMap) {\n      // feedbackMap is defined as sourceBuffer as key and feedbackBuffer name as object\n      for (const sourceName in this.feedbackMap) {\n        const feedbackName = this.feedbackMap[sourceName];\n        if (sourceName in sourceBuffers) {\n          feedbackBuffers[feedbackName] = sourceName;\n        }\n      }\n    }\n    Object.assign(feedbackBuffers, props.feedbackBuffers);\n    for (const bufferName in feedbackBuffers) {\n      const bufferOrRef = feedbackBuffers[bufferName];\n      if (typeof bufferOrRef === 'string') {\n        // Create new buffer with same layout and settings as source buffer\n        const sourceBuffer = sourceBuffers[bufferOrRef];\n        const {byteLength, usage, accessor} = sourceBuffer;\n        feedbackBuffers[bufferName] = this._createNewBuffer(bufferName, {\n          byteLength,\n          usage,\n          accessor\n        });\n      }\n    }\n\n    return feedbackBuffers;\n  }\n\n  _setupBuffers(props = {}) {\n    const {sourceBuffers = null} = props;\n    Object.assign(this.feedbackMap, props.feedbackMap);\n    const feedbackBuffers = this._getFeedbackBuffers(props);\n    this._updateBindings({sourceBuffers, feedbackBuffers});\n  }\n\n  _setupTransformFeedback(binding, {model}) {\n    const {program} = model;\n    binding.transformFeedback = new TransformFeedback(this.gl, {\n      program,\n      buffers: binding.feedbackBuffers\n    });\n  }\n\n  _updateBindings(opts) {\n    this.bindings[this.currentIndex] = this._updateBinding(this.bindings[this.currentIndex], opts);\n    if (this.feedbackMap) {\n      const {sourceBuffers, feedbackBuffers} = this._swapBuffers(this.bindings[this.currentIndex]);\n      const nextIndex = this._getNextIndex();\n      this.bindings[nextIndex] = this._updateBinding(this.bindings[nextIndex], {\n        sourceBuffers,\n        feedbackBuffers\n      });\n    }\n  }\n\n  _updateBinding(binding, opts) {\n    if (!binding) {\n      return {\n        sourceBuffers: Object.assign({}, opts.sourceBuffers),\n        feedbackBuffers: Object.assign({}, opts.feedbackBuffers)\n      };\n    }\n    Object.assign(binding.sourceBuffers, opts.sourceBuffers);\n    Object.assign(binding.feedbackBuffers, opts.feedbackBuffers);\n    if (binding.transformFeedback) {\n      binding.transformFeedback.setBuffers(binding.feedbackBuffers);\n    }\n    return binding;\n  }\n\n  _swapBuffers(opts) {\n    if (!this.feedbackMap) {\n      return null;\n    }\n    const sourceBuffers = Object.assign({}, opts.sourceBuffers);\n    const feedbackBuffers = Object.assign({}, opts.feedbackBuffers);\n    for (const srcName in this.feedbackMap) {\n      const dstName = this.feedbackMap[srcName];\n      sourceBuffers[srcName] = opts.feedbackBuffers[dstName];\n      feedbackBuffers[dstName] = opts.sourceBuffers[srcName];\n\n      // make sure the new destination buffer is a Buffer object\n      assert(feedbackBuffers[dstName] instanceof Buffer);\n    }\n    return {sourceBuffers, feedbackBuffers};\n  }\n\n  // Create a buffer and add to list of buffers to be deleted.\n  _createNewBuffer(name, opts) {\n    const buffer = new Buffer(this.gl, opts);\n    if (this.resources[name]) {\n      this.resources[name].delete();\n    }\n    this.resources[name] = buffer;\n    return buffer;\n  }\n\n  _getNextIndex() {\n    return (this.currentIndex + 1) % 2;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}