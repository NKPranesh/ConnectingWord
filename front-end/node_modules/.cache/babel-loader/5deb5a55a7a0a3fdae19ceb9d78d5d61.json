{"ast":null,"code":"const QUANTIZED_MESH_HEADER = new Map([['centerX', Float64Array.BYTES_PER_ELEMENT], ['centerY', Float64Array.BYTES_PER_ELEMENT], ['centerZ', Float64Array.BYTES_PER_ELEMENT], ['minHeight', Float32Array.BYTES_PER_ELEMENT], ['maxHeight', Float32Array.BYTES_PER_ELEMENT], ['boundingSphereCenterX', Float64Array.BYTES_PER_ELEMENT], ['boundingSphereCenterY', Float64Array.BYTES_PER_ELEMENT], ['boundingSphereCenterZ', Float64Array.BYTES_PER_ELEMENT], ['boundingSphereRadius', Float64Array.BYTES_PER_ELEMENT], ['horizonOcclusionPointX', Float64Array.BYTES_PER_ELEMENT], ['horizonOcclusionPointY', Float64Array.BYTES_PER_ELEMENT], ['horizonOcclusionPointZ', Float64Array.BYTES_PER_ELEMENT]]);\n\nfunction decodeZigZag(value) {\n  return value >> 1 ^ -(value & 1);\n}\n\nfunction decodeHeader(dataView) {\n  let position = 0;\n  const header = {};\n\n  for (const [key, bytesCount] of QUANTIZED_MESH_HEADER) {\n    const getter = bytesCount === 8 ? dataView.getFloat64 : dataView.getFloat32;\n    header[key] = getter.call(dataView, position, true);\n    position += bytesCount;\n  }\n\n  return {\n    header,\n    headerEndPosition: position\n  };\n}\n\nfunction decodeVertexData(dataView, headerEndPosition) {\n  let position = headerEndPosition;\n  const elementsPerVertex = 3;\n  const vertexCount = dataView.getUint32(position, true);\n  const vertexData = new Uint16Array(vertexCount * elementsPerVertex);\n  position += Uint32Array.BYTES_PER_ELEMENT;\n  const bytesPerArrayElement = Uint16Array.BYTES_PER_ELEMENT;\n  const elementArrayLength = vertexCount * bytesPerArrayElement;\n  const uArrayStartPosition = position;\n  const vArrayStartPosition = uArrayStartPosition + elementArrayLength;\n  const heightArrayStartPosition = vArrayStartPosition + elementArrayLength;\n  let u = 0;\n  let v = 0;\n  let height = 0;\n\n  for (let i = 0; i < vertexCount; i++) {\n    u += decodeZigZag(dataView.getUint16(uArrayStartPosition + bytesPerArrayElement * i, true));\n    v += decodeZigZag(dataView.getUint16(vArrayStartPosition + bytesPerArrayElement * i, true));\n    height += decodeZigZag(dataView.getUint16(heightArrayStartPosition + bytesPerArrayElement * i, true));\n    vertexData[i] = u;\n    vertexData[i + vertexCount] = v;\n    vertexData[i + vertexCount * 2] = height;\n  }\n\n  position += elementArrayLength * 3;\n  return {\n    vertexData,\n    vertexDataEndPosition: position\n  };\n}\n\nfunction decodeIndex(buffer, position, indicesCount, bytesPerIndex) {\n  let encoded = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n  let indices;\n\n  if (bytesPerIndex === 2) {\n    indices = new Uint16Array(buffer, position, indicesCount);\n  } else {\n    indices = new Uint32Array(buffer, position, indicesCount);\n  }\n\n  if (!encoded) {\n    return indices;\n  }\n\n  let highest = 0;\n\n  for (let i = 0; i < indices.length; ++i) {\n    const code = indices[i];\n    indices[i] = highest - code;\n\n    if (code === 0) {\n      ++highest;\n    }\n  }\n\n  return indices;\n}\n\nfunction decodeTriangleIndices(dataView, vertexData, vertexDataEndPosition) {\n  let position = vertexDataEndPosition;\n  const elementsPerVertex = 3;\n  const vertexCount = vertexData.length / elementsPerVertex;\n  const bytesPerIndex = vertexCount > 65536 ? Uint32Array.BYTES_PER_ELEMENT : Uint16Array.BYTES_PER_ELEMENT;\n\n  if (position % bytesPerIndex !== 0) {\n    position += bytesPerIndex - position % bytesPerIndex;\n  }\n\n  const triangleCount = dataView.getUint32(position, true);\n  position += Uint32Array.BYTES_PER_ELEMENT;\n  const triangleIndicesCount = triangleCount * 3;\n  const triangleIndices = decodeIndex(dataView.buffer, position, triangleIndicesCount, bytesPerIndex);\n  position += triangleIndicesCount * bytesPerIndex;\n  return {\n    triangleIndicesEndPosition: position,\n    triangleIndices\n  };\n}\n\nfunction decodeEdgeIndices(dataView, vertexData, triangleIndicesEndPosition) {\n  let position = triangleIndicesEndPosition;\n  const elementsPerVertex = 3;\n  const vertexCount = vertexData.length / elementsPerVertex;\n  const bytesPerIndex = vertexCount > 65536 ? Uint32Array.BYTES_PER_ELEMENT : Uint16Array.BYTES_PER_ELEMENT;\n  const westVertexCount = dataView.getUint32(position, true);\n  position += Uint32Array.BYTES_PER_ELEMENT;\n  const westIndices = decodeIndex(dataView.buffer, position, westVertexCount, bytesPerIndex, false);\n  position += westVertexCount * bytesPerIndex;\n  const southVertexCount = dataView.getUint32(position, true);\n  position += Uint32Array.BYTES_PER_ELEMENT;\n  const southIndices = decodeIndex(dataView.buffer, position, southVertexCount, bytesPerIndex, false);\n  position += southVertexCount * bytesPerIndex;\n  const eastVertexCount = dataView.getUint32(position, true);\n  position += Uint32Array.BYTES_PER_ELEMENT;\n  const eastIndices = decodeIndex(dataView.buffer, position, eastVertexCount, bytesPerIndex, false);\n  position += eastVertexCount * bytesPerIndex;\n  const northVertexCount = dataView.getUint32(position, true);\n  position += Uint32Array.BYTES_PER_ELEMENT;\n  const northIndices = decodeIndex(dataView.buffer, position, northVertexCount, bytesPerIndex, false);\n  position += northVertexCount * bytesPerIndex;\n  return {\n    edgeIndicesEndPosition: position,\n    westIndices,\n    southIndices,\n    eastIndices,\n    northIndices\n  };\n}\n\nfunction decodeVertexNormalsExtension(extensionDataView) {\n  return new Uint8Array(extensionDataView.buffer, extensionDataView.byteOffset, extensionDataView.byteLength);\n}\n\nfunction decodeWaterMaskExtension(extensionDataView) {\n  return extensionDataView.buffer.slice(extensionDataView.byteOffset, extensionDataView.byteOffset + extensionDataView.byteLength);\n}\n\nfunction decodeExtensions(dataView, indicesEndPosition) {\n  const extensions = {};\n\n  if (dataView.byteLength <= indicesEndPosition) {\n    return {\n      extensions,\n      extensionsEndPosition: indicesEndPosition\n    };\n  }\n\n  let position = indicesEndPosition;\n\n  while (position < dataView.byteLength) {\n    const extensionId = dataView.getUint8(position, true);\n    position += Uint8Array.BYTES_PER_ELEMENT;\n    const extensionLength = dataView.getUint32(position, true);\n    position += Uint32Array.BYTES_PER_ELEMENT;\n    const extensionView = new DataView(dataView.buffer, position, extensionLength);\n\n    switch (extensionId) {\n      case 1:\n        {\n          extensions.vertexNormals = decodeVertexNormalsExtension(extensionView);\n          break;\n        }\n\n      case 2:\n        {\n          extensions.waterMask = decodeWaterMaskExtension(extensionView);\n          break;\n        }\n\n      default:\n        {}\n    }\n\n    position += extensionLength;\n  }\n\n  return {\n    extensions,\n    extensionsEndPosition: position\n  };\n}\n\nexport const DECODING_STEPS = {\n  header: 0,\n  vertices: 1,\n  triangleIndices: 2,\n  edgeIndices: 3,\n  extensions: 4\n};\nconst DEFAULT_OPTIONS = {\n  maxDecodingStep: DECODING_STEPS.extensions\n};\nexport default function decode(data, userOptions) {\n  const options = Object.assign({}, DEFAULT_OPTIONS, userOptions);\n  const view = new DataView(data);\n  const {\n    header,\n    headerEndPosition\n  } = decodeHeader(view);\n\n  if (options.maxDecodingStep < DECODING_STEPS.vertices) {\n    return {\n      header\n    };\n  }\n\n  const {\n    vertexData,\n    vertexDataEndPosition\n  } = decodeVertexData(view, headerEndPosition);\n\n  if (options.maxDecodingStep < DECODING_STEPS.triangleIndices) {\n    return {\n      header,\n      vertexData\n    };\n  }\n\n  const {\n    triangleIndices,\n    triangleIndicesEndPosition\n  } = decodeTriangleIndices(view, vertexData, vertexDataEndPosition);\n\n  if (options.maxDecodingStep < DECODING_STEPS.edgeIndices) {\n    return {\n      header,\n      vertexData,\n      triangleIndices\n    };\n  }\n\n  const {\n    westIndices,\n    southIndices,\n    eastIndices,\n    northIndices,\n    edgeIndicesEndPosition\n  } = decodeEdgeIndices(view, vertexData, triangleIndicesEndPosition);\n\n  if (options.maxDecodingStep < DECODING_STEPS.extensions) {\n    return {\n      header,\n      vertexData,\n      triangleIndices,\n      westIndices,\n      northIndices,\n      eastIndices,\n      southIndices\n    };\n  }\n\n  const {\n    extensions\n  } = decodeExtensions(view, edgeIndicesEndPosition);\n  return {\n    header,\n    vertexData,\n    triangleIndices,\n    westIndices,\n    northIndices,\n    eastIndices,\n    southIndices,\n    extensions\n  };\n}","map":{"version":3,"sources":["../../../src/lib/decode-quantized-mesh.js"],"names":["QUANTIZED_MESH_HEADER","Float64Array","Float32Array","value","position","header","getter","bytesCount","dataView","headerEndPosition","elementsPerVertex","vertexCount","vertexData","Uint32Array","bytesPerArrayElement","Uint16Array","elementArrayLength","uArrayStartPosition","vArrayStartPosition","heightArrayStartPosition","u","v","height","i","decodeZigZag","vertexDataEndPosition","encoded","bytesPerIndex","indices","highest","code","triangleCount","triangleIndicesCount","triangleIndices","decodeIndex","triangleIndicesEndPosition","westVertexCount","westIndices","southVertexCount","southIndices","eastVertexCount","eastIndices","northVertexCount","northIndices","edgeIndicesEndPosition","extensionDataView","extensions","extensionsEndPosition","indicesEndPosition","extensionId","Uint8Array","extensionLength","extensionView","decodeVertexNormalsExtension","decodeWaterMaskExtension","DECODING_STEPS","vertices","edgeIndices","DEFAULT_OPTIONS","maxDecodingStep","options","Object","view","decodeHeader","decodeVertexData","decodeTriangleIndices","decodeEdgeIndices","decodeExtensions"],"mappings":"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","sourcesContent":["// Copyright (C) 2018-2019 HERE Europe B.V.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\nconst QUANTIZED_MESH_HEADER = new Map([\n  ['centerX', Float64Array.BYTES_PER_ELEMENT],\n  ['centerY', Float64Array.BYTES_PER_ELEMENT],\n  ['centerZ', Float64Array.BYTES_PER_ELEMENT],\n\n  ['minHeight', Float32Array.BYTES_PER_ELEMENT],\n  ['maxHeight', Float32Array.BYTES_PER_ELEMENT],\n\n  ['boundingSphereCenterX', Float64Array.BYTES_PER_ELEMENT],\n  ['boundingSphereCenterY', Float64Array.BYTES_PER_ELEMENT],\n  ['boundingSphereCenterZ', Float64Array.BYTES_PER_ELEMENT],\n  ['boundingSphereRadius', Float64Array.BYTES_PER_ELEMENT],\n\n  ['horizonOcclusionPointX', Float64Array.BYTES_PER_ELEMENT],\n  ['horizonOcclusionPointY', Float64Array.BYTES_PER_ELEMENT],\n  ['horizonOcclusionPointZ', Float64Array.BYTES_PER_ELEMENT]\n]);\n\nfunction decodeZigZag(value) {\n  return (value >> 1) ^ -(value & 1);\n}\n\nfunction decodeHeader(dataView) {\n  let position = 0;\n  const header = {};\n\n  for (const [key, bytesCount] of QUANTIZED_MESH_HEADER) {\n    const getter = bytesCount === 8 ? dataView.getFloat64 : dataView.getFloat32;\n\n    header[key] = getter.call(dataView, position, true);\n    position += bytesCount;\n  }\n\n  return {header, headerEndPosition: position};\n}\n\nfunction decodeVertexData(dataView, headerEndPosition) {\n  let position = headerEndPosition;\n  const elementsPerVertex = 3;\n  const vertexCount = dataView.getUint32(position, true);\n  const vertexData = new Uint16Array(vertexCount * elementsPerVertex);\n\n  position += Uint32Array.BYTES_PER_ELEMENT;\n\n  const bytesPerArrayElement = Uint16Array.BYTES_PER_ELEMENT;\n  const elementArrayLength = vertexCount * bytesPerArrayElement;\n  const uArrayStartPosition = position;\n  const vArrayStartPosition = uArrayStartPosition + elementArrayLength;\n  const heightArrayStartPosition = vArrayStartPosition + elementArrayLength;\n\n  let u = 0;\n  let v = 0;\n  let height = 0;\n\n  for (let i = 0; i < vertexCount; i++) {\n    u += decodeZigZag(dataView.getUint16(uArrayStartPosition + bytesPerArrayElement * i, true));\n    v += decodeZigZag(dataView.getUint16(vArrayStartPosition + bytesPerArrayElement * i, true));\n    height += decodeZigZag(\n      dataView.getUint16(heightArrayStartPosition + bytesPerArrayElement * i, true)\n    );\n\n    vertexData[i] = u;\n    vertexData[i + vertexCount] = v;\n    vertexData[i + vertexCount * 2] = height;\n  }\n\n  position += elementArrayLength * 3;\n\n  return {vertexData, vertexDataEndPosition: position};\n}\n\nfunction decodeIndex(buffer, position, indicesCount, bytesPerIndex, encoded = true) {\n  let indices;\n\n  if (bytesPerIndex === 2) {\n    indices = new Uint16Array(buffer, position, indicesCount);\n  } else {\n    indices = new Uint32Array(buffer, position, indicesCount);\n  }\n\n  if (!encoded) {\n    return indices;\n  }\n\n  let highest = 0;\n\n  for (let i = 0; i < indices.length; ++i) {\n    const code = indices[i];\n\n    indices[i] = highest - code;\n\n    if (code === 0) {\n      ++highest;\n    }\n  }\n\n  return indices;\n}\n\nfunction decodeTriangleIndices(dataView, vertexData, vertexDataEndPosition) {\n  let position = vertexDataEndPosition;\n  const elementsPerVertex = 3;\n  const vertexCount = vertexData.length / elementsPerVertex;\n  const bytesPerIndex =\n    vertexCount > 65536 ? Uint32Array.BYTES_PER_ELEMENT : Uint16Array.BYTES_PER_ELEMENT;\n\n  if (position % bytesPerIndex !== 0) {\n    position += bytesPerIndex - (position % bytesPerIndex);\n  }\n\n  const triangleCount = dataView.getUint32(position, true);\n  position += Uint32Array.BYTES_PER_ELEMENT;\n\n  const triangleIndicesCount = triangleCount * 3;\n  const triangleIndices = decodeIndex(\n    dataView.buffer,\n    position,\n    triangleIndicesCount,\n    bytesPerIndex\n  );\n  position += triangleIndicesCount * bytesPerIndex;\n\n  return {\n    triangleIndicesEndPosition: position,\n    triangleIndices\n  };\n}\n\nfunction decodeEdgeIndices(dataView, vertexData, triangleIndicesEndPosition) {\n  let position = triangleIndicesEndPosition;\n  const elementsPerVertex = 3;\n  const vertexCount = vertexData.length / elementsPerVertex;\n  const bytesPerIndex =\n    vertexCount > 65536 ? Uint32Array.BYTES_PER_ELEMENT : Uint16Array.BYTES_PER_ELEMENT;\n\n  const westVertexCount = dataView.getUint32(position, true);\n  position += Uint32Array.BYTES_PER_ELEMENT;\n\n  const westIndices = decodeIndex(dataView.buffer, position, westVertexCount, bytesPerIndex, false);\n  position += westVertexCount * bytesPerIndex;\n\n  const southVertexCount = dataView.getUint32(position, true);\n  position += Uint32Array.BYTES_PER_ELEMENT;\n\n  const southIndices = decodeIndex(\n    dataView.buffer,\n    position,\n    southVertexCount,\n    bytesPerIndex,\n    false\n  );\n  position += southVertexCount * bytesPerIndex;\n\n  const eastVertexCount = dataView.getUint32(position, true);\n  position += Uint32Array.BYTES_PER_ELEMENT;\n\n  const eastIndices = decodeIndex(dataView.buffer, position, eastVertexCount, bytesPerIndex, false);\n  position += eastVertexCount * bytesPerIndex;\n\n  const northVertexCount = dataView.getUint32(position, true);\n  position += Uint32Array.BYTES_PER_ELEMENT;\n\n  const northIndices = decodeIndex(\n    dataView.buffer,\n    position,\n    northVertexCount,\n    bytesPerIndex,\n    false\n  );\n  position += northVertexCount * bytesPerIndex;\n\n  return {\n    edgeIndicesEndPosition: position,\n    westIndices,\n    southIndices,\n    eastIndices,\n    northIndices\n  };\n}\n\nfunction decodeVertexNormalsExtension(extensionDataView) {\n  return new Uint8Array(\n    extensionDataView.buffer,\n    extensionDataView.byteOffset,\n    extensionDataView.byteLength\n  );\n}\n\nfunction decodeWaterMaskExtension(extensionDataView) {\n  return extensionDataView.buffer.slice(\n    extensionDataView.byteOffset,\n    extensionDataView.byteOffset + extensionDataView.byteLength\n  );\n}\n\nfunction decodeExtensions(dataView, indicesEndPosition) {\n  const extensions = {};\n\n  if (dataView.byteLength <= indicesEndPosition) {\n    return {extensions, extensionsEndPosition: indicesEndPosition};\n  }\n\n  let position = indicesEndPosition;\n\n  while (position < dataView.byteLength) {\n    const extensionId = dataView.getUint8(position, true);\n    position += Uint8Array.BYTES_PER_ELEMENT;\n\n    const extensionLength = dataView.getUint32(position, true);\n    position += Uint32Array.BYTES_PER_ELEMENT;\n\n    const extensionView = new DataView(dataView.buffer, position, extensionLength);\n\n    switch (extensionId) {\n      case 1: {\n        extensions.vertexNormals = decodeVertexNormalsExtension(extensionView);\n\n        break;\n      }\n      case 2: {\n        extensions.waterMask = decodeWaterMaskExtension(extensionView);\n\n        break;\n      }\n      default: {\n        // console.warn(`Unknown extension with id ${extensionId}`)\n      }\n    }\n\n    position += extensionLength;\n  }\n\n  return {extensions, extensionsEndPosition: position};\n}\n\nexport const DECODING_STEPS = {\n  header: 0,\n  vertices: 1,\n  triangleIndices: 2,\n  edgeIndices: 3,\n  extensions: 4\n};\n\nconst DEFAULT_OPTIONS = {\n  maxDecodingStep: DECODING_STEPS.extensions\n};\n\nexport default function decode(data, userOptions) {\n  const options = Object.assign({}, DEFAULT_OPTIONS, userOptions);\n  const view = new DataView(data);\n  const {header, headerEndPosition} = decodeHeader(view);\n\n  if (options.maxDecodingStep < DECODING_STEPS.vertices) {\n    return {header};\n  }\n\n  const {vertexData, vertexDataEndPosition} = decodeVertexData(view, headerEndPosition);\n\n  if (options.maxDecodingStep < DECODING_STEPS.triangleIndices) {\n    return {header, vertexData};\n  }\n\n  const {triangleIndices, triangleIndicesEndPosition} = decodeTriangleIndices(\n    view,\n    vertexData,\n    vertexDataEndPosition\n  );\n\n  if (options.maxDecodingStep < DECODING_STEPS.edgeIndices) {\n    return {header, vertexData, triangleIndices};\n  }\n\n  const {westIndices, southIndices, eastIndices, northIndices, edgeIndicesEndPosition} =\n    decodeEdgeIndices(view, vertexData, triangleIndicesEndPosition);\n\n  if (options.maxDecodingStep < DECODING_STEPS.extensions) {\n    return {\n      header,\n      vertexData,\n      triangleIndices,\n      westIndices,\n      northIndices,\n      eastIndices,\n      southIndices\n    };\n  }\n\n  const {extensions} = decodeExtensions(view, edgeIndicesEndPosition);\n\n  return {\n    header,\n    vertexData,\n    triangleIndices,\n    westIndices,\n    northIndices,\n    eastIndices,\n    southIndices,\n    extensions\n  };\n}\n"]},"metadata":{},"sourceType":"module"}