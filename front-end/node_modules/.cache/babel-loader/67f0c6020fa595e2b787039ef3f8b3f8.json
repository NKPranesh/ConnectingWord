{"ast":null,"code":"import { hasFeature, FEATURES, Buffer } from '@luma.gl/core';\nimport ShaderAttribute from './shader-attribute';\nimport { glArrayFromType } from './gl-utils';\nimport typedArrayManager from '../../utils/typed-array-manager';\nimport { toDoublePrecisionArray } from '../../utils/math-utils';\nimport log from '../../utils/log';\n\nfunction getStride(accessor) {\n  return accessor.stride || accessor.size * accessor.bytesPerElement;\n}\n\nfunction resolveShaderAttribute(baseAccessor, shaderAttributeOptions) {\n  if (shaderAttributeOptions.offset) {\n    log.removed('shaderAttribute.offset', 'vertexOffset, elementOffset')();\n  }\n\n  const stride = getStride(baseAccessor);\n  const vertexOffset = 'vertexOffset' in shaderAttributeOptions ? shaderAttributeOptions.vertexOffset : baseAccessor.vertexOffset || 0;\n  const elementOffset = shaderAttributeOptions.elementOffset || 0;\n  const offset = vertexOffset * stride + elementOffset * baseAccessor.bytesPerElement + (baseAccessor.offset || 0);\n  return { ...shaderAttributeOptions,\n    offset,\n    stride\n  };\n}\n\nfunction resolveDoublePrecisionShaderAttributes(baseAccessor, shaderAttributeOptions) {\n  const resolvedOptions = resolveShaderAttribute(baseAccessor, shaderAttributeOptions);\n  return {\n    high: resolvedOptions,\n    low: { ...resolvedOptions,\n      offset: resolvedOptions.offset + baseAccessor.size * 4\n    }\n  };\n}\n\nexport default class DataColumn {\n  constructor(gl, opts) {\n    this.gl = gl;\n    this.id = opts.id;\n    this.size = opts.size;\n    const logicalType = opts.logicalType || opts.type;\n    const doublePrecision = logicalType === 5130;\n    let {\n      defaultValue\n    } = opts;\n    defaultValue = Number.isFinite(defaultValue) ? [defaultValue] : defaultValue || new Array(this.size).fill(0);\n    opts.defaultValue = defaultValue;\n    let bufferType = logicalType;\n\n    if (doublePrecision) {\n      bufferType = 5126;\n    } else if (!bufferType && opts.isIndexed) {\n      bufferType = gl && hasFeature(gl, FEATURES.ELEMENT_INDEX_UINT32) ? 5125 : 5123;\n    } else if (!bufferType) {\n      bufferType = 5126;\n    }\n\n    opts.logicalType = logicalType;\n    opts.type = bufferType;\n    let defaultType = glArrayFromType(logicalType || bufferType || 5126);\n    this.shaderAttributes = {};\n    this.doublePrecision = doublePrecision;\n\n    if (doublePrecision && opts.fp64 === false) {\n      defaultType = Float32Array;\n    }\n\n    opts.bytesPerElement = defaultType.BYTES_PER_ELEMENT;\n    this.defaultType = defaultType;\n    this.value = null;\n    this.settings = opts;\n    this.state = {\n      externalBuffer: null,\n      bufferAccessor: opts,\n      allocatedValue: null,\n      constant: false\n    };\n    this._buffer = null;\n    this.setData(opts);\n  }\n\n  get buffer() {\n    if (!this._buffer) {\n      const {\n        isIndexed,\n        type\n      } = this.settings;\n      this._buffer = new Buffer(this.gl, {\n        id: this.id,\n        target: isIndexed ? 34963 : 34962,\n        accessor: {\n          type\n        }\n      });\n    }\n\n    return this._buffer;\n  }\n\n  get byteOffset() {\n    const accessor = this.getAccessor();\n\n    if (accessor.vertexOffset) {\n      return accessor.vertexOffset * getStride(accessor);\n    }\n\n    return 0;\n  }\n\n  delete() {\n    if (this._buffer) {\n      this._buffer.delete();\n\n      this._buffer = null;\n    }\n\n    typedArrayManager.release(this.state.allocatedValue);\n  }\n\n  getShaderAttributes(id, options) {\n    if (this.doublePrecision) {\n      const shaderAttributes = {};\n      const isBuffer64Bit = this.value instanceof Float64Array;\n      const doubleShaderAttributeDefs = resolveDoublePrecisionShaderAttributes(this.getAccessor(), options || {});\n      shaderAttributes[id] = new ShaderAttribute(this, doubleShaderAttributeDefs.high);\n      shaderAttributes[\"\".concat(id, \"64Low\")] = isBuffer64Bit ? new ShaderAttribute(this, doubleShaderAttributeDefs.low) : new Float32Array(this.size);\n      return shaderAttributes;\n    }\n\n    if (options) {\n      const shaderAttributeDef = resolveShaderAttribute(this.getAccessor(), options);\n      return {\n        [id]: new ShaderAttribute(this, shaderAttributeDef)\n      };\n    }\n\n    return {\n      [id]: this\n    };\n  }\n\n  getBuffer() {\n    if (this.state.constant) {\n      return null;\n    }\n\n    return this.state.externalBuffer || this._buffer;\n  }\n\n  getValue() {\n    if (this.state.constant) {\n      return this.value;\n    }\n\n    return [this.getBuffer(), this.getAccessor()];\n  }\n\n  getAccessor() {\n    return this.state.bufferAccessor;\n  }\n\n  setData(opts) {\n    const {\n      state\n    } = this;\n\n    if (ArrayBuffer.isView(opts)) {\n      opts = {\n        value: opts\n      };\n    } else if (opts instanceof Buffer) {\n      opts = {\n        buffer: opts\n      };\n    }\n\n    const accessor = { ...this.settings,\n      ...opts\n    };\n    state.bufferAccessor = accessor;\n\n    if (opts.constant) {\n      let value = opts.value;\n      value = this._normalizeValue(value, [], 0);\n\n      if (this.settings.normalized) {\n        value = this._normalizeConstant(value);\n      }\n\n      const hasChanged = !state.constant || !this._areValuesEqual(value, this.value);\n\n      if (!hasChanged) {\n        return false;\n      }\n\n      state.externalBuffer = null;\n      state.constant = true;\n      this.value = value;\n    } else if (opts.buffer) {\n      const buffer = opts.buffer;\n      state.externalBuffer = buffer;\n      state.constant = false;\n      this.value = opts.value;\n      const isBuffer64Bit = opts.value instanceof Float64Array;\n      accessor.type = opts.type || buffer.accessor.type;\n      accessor.bytesPerElement = buffer.accessor.BYTES_PER_ELEMENT * (isBuffer64Bit ? 2 : 1);\n      accessor.stride = getStride(accessor);\n    } else if (opts.value) {\n      this._checkExternalBuffer(opts);\n\n      let value = opts.value;\n      state.externalBuffer = null;\n      state.constant = false;\n      this.value = value;\n      accessor.bytesPerElement = value.BYTES_PER_ELEMENT;\n      accessor.stride = getStride(accessor);\n      const {\n        buffer,\n        byteOffset\n      } = this;\n\n      if (this.doublePrecision && value instanceof Float64Array) {\n        value = toDoublePrecisionArray(value, accessor);\n      }\n\n      const requiredBufferSize = value.byteLength + byteOffset + accessor.stride * 2;\n\n      if (buffer.byteLength < requiredBufferSize) {\n        buffer.reallocate(requiredBufferSize);\n      }\n\n      buffer.setAccessor(null);\n      buffer.subData({\n        data: value,\n        offset: byteOffset\n      });\n      accessor.type = opts.type || buffer.accessor.type;\n    }\n\n    return true;\n  }\n\n  updateSubBuffer() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const {\n      value\n    } = this;\n    const {\n      startOffset = 0,\n      endOffset\n    } = opts;\n    this.buffer.subData({\n      data: this.doublePrecision && value instanceof Float64Array ? toDoublePrecisionArray(value, {\n        size: this.size,\n        startIndex: startOffset,\n        endIndex: endOffset\n      }) : value.subarray(startOffset, endOffset),\n      offset: startOffset * value.BYTES_PER_ELEMENT + this.byteOffset\n    });\n  }\n\n  allocate(_ref) {\n    let {\n      numInstances,\n      copy = false\n    } = _ref;\n    const {\n      state\n    } = this;\n    const oldValue = state.allocatedValue;\n    const value = typedArrayManager.allocate(oldValue, numInstances + 1, {\n      size: this.size,\n      type: this.defaultType,\n      copy\n    });\n    this.value = value;\n    const {\n      buffer,\n      byteOffset\n    } = this;\n\n    if (buffer.byteLength < value.byteLength + byteOffset) {\n      buffer.reallocate(value.byteLength + byteOffset);\n\n      if (copy && oldValue) {\n        buffer.subData({\n          data: oldValue instanceof Float64Array ? toDoublePrecisionArray(oldValue, this) : oldValue,\n          offset: byteOffset\n        });\n      }\n    }\n\n    state.allocatedValue = value;\n    state.constant = false;\n    state.externalBuffer = null;\n    state.bufferAccessor = this.settings;\n    return true;\n  }\n\n  _checkExternalBuffer(opts) {\n    const {\n      value\n    } = opts;\n\n    if (!opts.constant && value) {\n      const ArrayType = this.defaultType;\n      let illegalArrayType = false;\n\n      if (this.doublePrecision) {\n        illegalArrayType = value.BYTES_PER_ELEMENT < 4;\n      }\n\n      if (illegalArrayType) {\n        throw new Error(\"Attribute \".concat(this.id, \" does not support \").concat(value.constructor.name));\n      }\n\n      if (!(value instanceof ArrayType) && this.settings.normalized && !('normalized' in opts)) {\n        log.warn(\"Attribute \".concat(this.id, \" is normalized\"))();\n      }\n    }\n  }\n\n  _normalizeConstant(value) {\n    switch (this.settings.type) {\n      case 5120:\n        return new Float32Array(value).map(x => (x + 128) / 255 * 2 - 1);\n\n      case 5122:\n        return new Float32Array(value).map(x => (x + 32768) / 65535 * 2 - 1);\n\n      case 5121:\n        return new Float32Array(value).map(x => x / 255);\n\n      case 5123:\n        return new Float32Array(value).map(x => x / 65535);\n\n      default:\n        return value;\n    }\n  }\n\n  _normalizeValue(value, out, start) {\n    const {\n      defaultValue,\n      size\n    } = this.settings;\n\n    if (Number.isFinite(value)) {\n      out[start] = value;\n      return out;\n    }\n\n    if (!value) {\n      out[start] = defaultValue[0];\n      return out;\n    }\n\n    switch (size) {\n      case 4:\n        out[start + 3] = Number.isFinite(value[3]) ? value[3] : defaultValue[3];\n\n      case 3:\n        out[start + 2] = Number.isFinite(value[2]) ? value[2] : defaultValue[2];\n\n      case 2:\n        out[start + 1] = Number.isFinite(value[1]) ? value[1] : defaultValue[1];\n\n      case 1:\n        out[start + 0] = Number.isFinite(value[0]) ? value[0] : defaultValue[0];\n        break;\n\n      default:\n        let i = size;\n\n        while (--i >= 0) {\n          out[start + i] = Number.isFinite(value[i]) ? value[i] : defaultValue[i];\n        }\n\n    }\n\n    return out;\n  }\n\n  _areValuesEqual(value1, value2) {\n    if (!value1 || !value2) {\n      return false;\n    }\n\n    const {\n      size\n    } = this;\n\n    for (let i = 0; i < size; i++) {\n      if (value1[i] !== value2[i]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n}","map":{"version":3,"sources":["../../../../src/lib/attribute/data-column.js"],"names":["accessor","shaderAttributeOptions","log","stride","getStride","vertexOffset","baseAccessor","elementOffset","offset","resolvedOptions","resolveShaderAttribute","high","low","constructor","opts","logicalType","doublePrecision","defaultValue","Number","bufferType","gl","hasFeature","FEATURES","defaultType","glArrayFromType","externalBuffer","bufferAccessor","allocatedValue","constant","buffer","type","id","target","isIndexed","byteOffset","delete","typedArrayManager","getShaderAttributes","shaderAttributes","isBuffer64Bit","doubleShaderAttributeDefs","resolveDoublePrecisionShaderAttributes","options","shaderAttributeDef","getBuffer","getValue","getAccessor","setData","state","ArrayBuffer","value","hasChanged","toDoublePrecisionArray","requiredBufferSize","data","updateSubBuffer","startOffset","endOffset","size","startIndex","endIndex","allocate","copy","oldValue","numInstances","_checkExternalBuffer","ArrayType","illegalArrayType","_normalizeConstant","x","_normalizeValue","out","start","i","_areValuesEqual","value1","value2"],"mappings":"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","sourcesContent":["/* eslint-disable complexity */\nimport GL from '@luma.gl/constants';\nimport {hasFeature, FEATURES, Buffer} from '@luma.gl/core';\nimport ShaderAttribute from './shader-attribute';\nimport {glArrayFromType} from './gl-utils';\nimport typedArrayManager from '../../utils/typed-array-manager';\nimport {toDoublePrecisionArray} from '../../utils/math-utils';\nimport log from '../../utils/log';\n\nfunction getStride(accessor) {\n  return accessor.stride || accessor.size * accessor.bytesPerElement;\n}\n\nfunction resolveShaderAttribute(baseAccessor, shaderAttributeOptions) {\n  if (shaderAttributeOptions.offset) {\n    log.removed('shaderAttribute.offset', 'vertexOffset, elementOffset')();\n  }\n\n  // All shader attributes share the parent's stride\n  const stride = getStride(baseAccessor);\n  // `vertexOffset` is used to access the neighboring vertex's value\n  // e.g. `nextPositions` in polygon\n  const vertexOffset =\n    'vertexOffset' in shaderAttributeOptions\n      ? shaderAttributeOptions.vertexOffset\n      : baseAccessor.vertexOffset || 0;\n  // `elementOffset` is defined when shader attribute's size is smaller than the parent's\n  // e.g. `translations` in transform matrix\n  const elementOffset = shaderAttributeOptions.elementOffset || 0;\n  const offset =\n    // offsets defined by the attribute\n    vertexOffset * stride +\n    elementOffset * baseAccessor.bytesPerElement +\n    // offsets defined by external buffers if any\n    (baseAccessor.offset || 0);\n\n  return {\n    ...shaderAttributeOptions,\n    offset,\n    stride\n  };\n}\n\nfunction resolveDoublePrecisionShaderAttributes(baseAccessor, shaderAttributeOptions) {\n  const resolvedOptions = resolveShaderAttribute(baseAccessor, shaderAttributeOptions);\n\n  return {\n    high: resolvedOptions,\n    low: {\n      ...resolvedOptions,\n      offset: resolvedOptions.offset + baseAccessor.size * 4\n    }\n  };\n}\n\nexport default class DataColumn {\n  /* eslint-disable max-statements */\n  constructor(gl, opts) {\n    this.gl = gl;\n    this.id = opts.id;\n    this.size = opts.size;\n\n    const logicalType = opts.logicalType || opts.type;\n    const doublePrecision = logicalType === GL.DOUBLE;\n\n    let {defaultValue} = opts;\n    defaultValue = Number.isFinite(defaultValue)\n      ? [defaultValue]\n      : defaultValue || new Array(this.size).fill(0);\n    opts.defaultValue = defaultValue;\n\n    let bufferType = logicalType;\n    if (doublePrecision) {\n      bufferType = GL.FLOAT;\n    } else if (!bufferType && opts.isIndexed) {\n      bufferType =\n        gl && hasFeature(gl, FEATURES.ELEMENT_INDEX_UINT32) ? GL.UNSIGNED_INT : GL.UNSIGNED_SHORT;\n    } else if (!bufferType) {\n      bufferType = GL.FLOAT;\n    }\n    opts.logicalType = logicalType;\n    opts.type = bufferType;\n\n    // This is the attribute type defined by the layer\n    // If an external buffer is provided, this.type may be overwritten\n    // But we always want to use defaultType for allocation\n    let defaultType = glArrayFromType(logicalType || bufferType || GL.FLOAT);\n    this.shaderAttributes = {};\n    this.doublePrecision = doublePrecision;\n\n    // `fp64: false` tells a double-precision attribute to allocate Float32Arrays\n    // by default when using auto-packing. This is more efficient in use cases where\n    // high precision is unnecessary, but the `64Low` attribute is still required\n    // by the shader.\n    if (doublePrecision && opts.fp64 === false) {\n      defaultType = Float32Array;\n    }\n    opts.bytesPerElement = defaultType.BYTES_PER_ELEMENT;\n\n    this.defaultType = defaultType;\n    this.value = null;\n    this.settings = opts;\n    this.state = {\n      externalBuffer: null,\n      bufferAccessor: opts,\n      allocatedValue: null,\n      constant: false\n    };\n    this._buffer = null;\n\n    this.setData(opts);\n  }\n  /* eslint-enable max-statements */\n\n  get buffer() {\n    if (!this._buffer) {\n      const {isIndexed, type} = this.settings;\n      this._buffer = new Buffer(this.gl, {\n        id: this.id,\n        target: isIndexed ? GL.ELEMENT_ARRAY_BUFFER : GL.ARRAY_BUFFER,\n        accessor: {type}\n      });\n    }\n    return this._buffer;\n  }\n\n  get byteOffset() {\n    const accessor = this.getAccessor();\n    if (accessor.vertexOffset) {\n      return accessor.vertexOffset * getStride(accessor);\n    }\n    return 0;\n  }\n\n  delete() {\n    if (this._buffer) {\n      this._buffer.delete();\n      this._buffer = null;\n    }\n    typedArrayManager.release(this.state.allocatedValue);\n  }\n\n  getShaderAttributes(id, options) {\n    if (this.doublePrecision) {\n      const shaderAttributes = {};\n      const isBuffer64Bit = this.value instanceof Float64Array;\n\n      const doubleShaderAttributeDefs = resolveDoublePrecisionShaderAttributes(\n        this.getAccessor(),\n        options || {}\n      );\n\n      shaderAttributes[id] = new ShaderAttribute(this, doubleShaderAttributeDefs.high);\n      shaderAttributes[`${id}64Low`] = isBuffer64Bit\n        ? new ShaderAttribute(this, doubleShaderAttributeDefs.low)\n        : new Float32Array(this.size); // use constant for low part if buffer is 32-bit\n      return shaderAttributes;\n    }\n    if (options) {\n      const shaderAttributeDef = resolveShaderAttribute(this.getAccessor(), options);\n      return {[id]: new ShaderAttribute(this, shaderAttributeDef)};\n    }\n    return {[id]: this};\n  }\n\n  getBuffer() {\n    if (this.state.constant) {\n      return null;\n    }\n    return this.state.externalBuffer || this._buffer;\n  }\n\n  getValue() {\n    if (this.state.constant) {\n      return this.value;\n    }\n    return [this.getBuffer(), this.getAccessor()];\n  }\n\n  getAccessor() {\n    return this.state.bufferAccessor;\n  }\n\n  // returns true if success\n  // eslint-disable-next-line max-statements\n  setData(opts) {\n    const {state} = this;\n    if (ArrayBuffer.isView(opts)) {\n      opts = {value: opts};\n    } else if (opts instanceof Buffer) {\n      opts = {buffer: opts};\n    }\n\n    const accessor = {...this.settings, ...opts};\n    state.bufferAccessor = accessor;\n\n    if (opts.constant) {\n      // set constant\n      let value = opts.value;\n      value = this._normalizeValue(value, [], 0);\n      if (this.settings.normalized) {\n        value = this._normalizeConstant(value);\n      }\n      const hasChanged = !state.constant || !this._areValuesEqual(value, this.value);\n\n      if (!hasChanged) {\n        return false;\n      }\n      state.externalBuffer = null;\n      state.constant = true;\n      this.value = value;\n    } else if (opts.buffer) {\n      const buffer = opts.buffer;\n      state.externalBuffer = buffer;\n      state.constant = false;\n      this.value = opts.value;\n      const isBuffer64Bit = opts.value instanceof Float64Array;\n\n      // Copy the type of the buffer into the accessor\n      accessor.type = opts.type || buffer.accessor.type;\n      accessor.bytesPerElement = buffer.accessor.BYTES_PER_ELEMENT * (isBuffer64Bit ? 2 : 1);\n      accessor.stride = getStride(accessor);\n    } else if (opts.value) {\n      this._checkExternalBuffer(opts);\n\n      let value = opts.value;\n      state.externalBuffer = null;\n      state.constant = false;\n      this.value = value;\n\n      accessor.bytesPerElement = value.BYTES_PER_ELEMENT;\n      accessor.stride = getStride(accessor);\n\n      const {buffer, byteOffset} = this;\n\n      if (this.doublePrecision && value instanceof Float64Array) {\n        value = toDoublePrecisionArray(value, accessor);\n      }\n\n      // A small over allocation is used as safety margin\n      // Shader attributes may try to access this buffer with bigger offsets\n      const requiredBufferSize = value.byteLength + byteOffset + accessor.stride * 2;\n      if (buffer.byteLength < requiredBufferSize) {\n        buffer.reallocate(requiredBufferSize);\n      }\n      // Hack: force Buffer to infer data type\n      buffer.setAccessor(null);\n      buffer.subData({data: value, offset: byteOffset});\n      accessor.type = opts.type || buffer.accessor.type;\n    }\n\n    return true;\n  }\n\n  updateSubBuffer(opts = {}) {\n    const {value} = this;\n    const {startOffset = 0, endOffset} = opts;\n    this.buffer.subData({\n      data:\n        this.doublePrecision && value instanceof Float64Array\n          ? toDoublePrecisionArray(value, {\n              size: this.size,\n              startIndex: startOffset,\n              endIndex: endOffset\n            })\n          : value.subarray(startOffset, endOffset),\n      offset: startOffset * value.BYTES_PER_ELEMENT + this.byteOffset\n    });\n  }\n\n  allocate({numInstances, copy = false}) {\n    const {state} = this;\n    const oldValue = state.allocatedValue;\n\n    // Allocate at least one element to ensure a valid buffer\n    const value = typedArrayManager.allocate(oldValue, numInstances + 1, {\n      size: this.size,\n      type: this.defaultType,\n      copy\n    });\n\n    this.value = value;\n\n    const {buffer, byteOffset} = this;\n\n    if (buffer.byteLength < value.byteLength + byteOffset) {\n      buffer.reallocate(value.byteLength + byteOffset);\n\n      if (copy && oldValue) {\n        // Upload the full existing attribute value to the GPU, so that updateBuffer\n        // can choose to only update a partial range.\n        // TODO - copy old buffer to new buffer on the GPU\n        buffer.subData({\n          data:\n            oldValue instanceof Float64Array ? toDoublePrecisionArray(oldValue, this) : oldValue,\n          offset: byteOffset\n        });\n      }\n    }\n\n    state.allocatedValue = value;\n    state.constant = false;\n    state.externalBuffer = null;\n    state.bufferAccessor = this.settings;\n    return true;\n  }\n\n  // PRIVATE HELPER METHODS\n  _checkExternalBuffer(opts) {\n    const {value} = opts;\n    if (!opts.constant && value) {\n      const ArrayType = this.defaultType;\n\n      let illegalArrayType = false;\n      if (this.doublePrecision) {\n        // not 32bit or 64bit\n        illegalArrayType = value.BYTES_PER_ELEMENT < 4;\n      }\n      if (illegalArrayType) {\n        throw new Error(`Attribute ${this.id} does not support ${value.constructor.name}`);\n      }\n      if (!(value instanceof ArrayType) && this.settings.normalized && !('normalized' in opts)) {\n        log.warn(`Attribute ${this.id} is normalized`)();\n      }\n    }\n  }\n\n  // https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/vertexAttribPointer\n  _normalizeConstant(value) {\n    switch (this.settings.type) {\n      case GL.BYTE:\n        // normalize [-128, 127] to [-1, 1]\n        return new Float32Array(value).map(x => ((x + 128) / 255) * 2 - 1);\n\n      case GL.SHORT:\n        // normalize [-32768, 32767] to [-1, 1]\n        return new Float32Array(value).map(x => ((x + 32768) / 65535) * 2 - 1);\n\n      case GL.UNSIGNED_BYTE:\n        // normalize [0, 255] to [0, 1]\n        return new Float32Array(value).map(x => x / 255);\n\n      case GL.UNSIGNED_SHORT:\n        // normalize [0, 65535] to [0, 1]\n        return new Float32Array(value).map(x => x / 65535);\n\n      default:\n        // No normalization for gl.FLOAT and gl.HALF_FLOAT\n        return value;\n    }\n  }\n\n  /* check user supplied values and apply fallback */\n  _normalizeValue(value, out, start) {\n    const {defaultValue, size} = this.settings;\n\n    if (Number.isFinite(value)) {\n      out[start] = value;\n      return out;\n    }\n    if (!value) {\n      out[start] = defaultValue[0];\n      return out;\n    }\n\n    // Important - switch cases are 5x more performant than a for loop!\n    /* eslint-disable no-fallthrough, default-case */\n    switch (size) {\n      case 4:\n        out[start + 3] = Number.isFinite(value[3]) ? value[3] : defaultValue[3];\n      case 3:\n        out[start + 2] = Number.isFinite(value[2]) ? value[2] : defaultValue[2];\n      case 2:\n        out[start + 1] = Number.isFinite(value[1]) ? value[1] : defaultValue[1];\n      case 1:\n        out[start + 0] = Number.isFinite(value[0]) ? value[0] : defaultValue[0];\n        break;\n\n      default:\n        // In the rare case where the attribute size > 4, do it the slow way\n        // This is used for e.g. transform matrices\n        let i = size;\n        while (--i >= 0) {\n          out[start + i] = Number.isFinite(value[i]) ? value[i] : defaultValue[i];\n        }\n    }\n\n    return out;\n  }\n\n  _areValuesEqual(value1, value2) {\n    if (!value1 || !value2) {\n      return false;\n    }\n    const {size} = this;\n    for (let i = 0; i < size; i++) {\n      if (value1[i] !== value2[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}