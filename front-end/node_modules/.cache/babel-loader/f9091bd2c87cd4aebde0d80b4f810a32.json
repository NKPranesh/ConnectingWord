{"ast":null,"code":"import { LayerExtension } from '@deck.gl/core';\nimport { Texture2D } from '@luma.gl/core';\nimport { patternShaders } from './shaders.glsl';\nconst defaultProps = {\n  fillPatternEnabled: true,\n  fillPatternAtlas: null,\n  fillPatternMapping: null,\n  fillPatternMask: true,\n  getFillPattern: {\n    type: 'accessor',\n    value: d => d.pattern\n  },\n  getFillPatternScale: {\n    type: 'accessor',\n    value: 1\n  },\n  getFillPatternOffset: {\n    type: 'accessor',\n    value: [0, 0]\n  }\n};\nconst DEFAULT_TEXTURE_PARAMETERS = {\n  [10241]: 9729,\n  [10240]: 9729,\n  [10242]: 33071,\n  [10243]: 33071\n};\nexport default class FillStyleExtension extends LayerExtension {\n  constructor() {\n    let {\n      pattern = false\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super({\n      pattern\n    });\n  }\n\n  isEnabled(layer) {\n    return layer.getAttributeManager() && !layer.state.pathTesselator;\n  }\n\n  getShaders(extension) {\n    if (!extension.isEnabled(this)) {\n      return null;\n    }\n\n    return {\n      modules: [extension.opts.pattern && patternShaders].filter(Boolean)\n    };\n  }\n\n  initializeState(context, extension) {\n    if (!extension.isEnabled(this)) {\n      return;\n    }\n\n    const attributeManager = this.getAttributeManager();\n\n    if (extension.opts.pattern) {\n      attributeManager.add({\n        fillPatternFrames: {\n          size: 4,\n          accessor: 'getFillPattern',\n          transform: extension.getPatternFrame.bind(this),\n          shaderAttributes: {\n            fillPatternFrames: {\n              divisor: 0\n            },\n            instanceFillPatternFrames: {\n              divisor: 1\n            }\n          }\n        },\n        fillPatternScales: {\n          size: 1,\n          accessor: 'getFillPatternScale',\n          defaultValue: 1,\n          shaderAttributes: {\n            fillPatternScales: {\n              divisor: 0\n            },\n            instanceFillPatternScales: {\n              divisor: 1\n            }\n          }\n        },\n        fillPatternOffsets: {\n          size: 2,\n          accessor: 'getFillPatternOffset',\n          shaderAttributes: {\n            fillPatternOffsets: {\n              divisor: 0\n            },\n            instanceFillPatternOffsets: {\n              divisor: 1\n            }\n          }\n        }\n      });\n    }\n\n    this.setState({\n      emptyTexture: new Texture2D(this.context.gl, {\n        data: new Uint8Array(4),\n        width: 1,\n        height: 1\n      })\n    });\n  }\n\n  updateState(_ref, extension) {\n    let {\n      props,\n      oldProps\n    } = _ref;\n\n    if (!extension.isEnabled(this)) {\n      return;\n    }\n\n    if (props.fillPatternAtlas && props.fillPatternAtlas !== oldProps.fillPatternAtlas) {\n      extension.loadPatternAtlas.call(this, props);\n    }\n\n    if (props.fillPatternMapping && props.fillPatternMapping !== oldProps.fillPatternMapping) {\n      extension.loadPatternMapping.call(this, props);\n    }\n  }\n\n  draw(params, extension) {\n    if (!extension.isEnabled(this)) {\n      return;\n    }\n\n    const {\n      patternTexture\n    } = this.state;\n    this.setModuleParameters({\n      fillPatternTexture: patternTexture || this.state.emptyTexture\n    });\n  }\n\n  finalizeState() {\n    const {\n      patternTexture,\n      emptyTexture\n    } = this.state;\n    patternTexture === null || patternTexture === void 0 ? void 0 : patternTexture.delete();\n    emptyTexture === null || emptyTexture === void 0 ? void 0 : emptyTexture.delete();\n  }\n\n  async loadPatternAtlas(_ref2) {\n    let {\n      fillPatternAtlas,\n      fetch\n    } = _ref2;\n\n    var _this$state$patternTe;\n\n    (_this$state$patternTe = this.state.patternTexture) === null || _this$state$patternTe === void 0 ? void 0 : _this$state$patternTe.delete();\n    this.setState({\n      patternTexture: null\n    });\n    let image = fillPatternAtlas;\n\n    if (typeof image === 'string') {\n      image = await fetch(image, {\n        propName: 'fillPatternAtlas',\n        layer: this\n      });\n    }\n\n    const patternTexture = image instanceof Texture2D ? image : new Texture2D(this.context.gl, {\n      data: image,\n      parameters: DEFAULT_TEXTURE_PARAMETERS\n    });\n    this.setState({\n      patternTexture\n    });\n  }\n\n  async loadPatternMapping(_ref3) {\n    let {\n      fillPatternMapping,\n      fetch\n    } = _ref3;\n    this.setState({\n      patternMapping: null\n    });\n    let patternMapping = fillPatternMapping;\n\n    if (typeof patternMapping === 'string') {\n      patternMapping = await fetch(patternMapping, {\n        propName: 'fillPatternMapping',\n        layer: this\n      });\n    }\n\n    this.setState({\n      patternMapping\n    });\n    this.getAttributeManager().invalidate('getFillPattern');\n    this.setNeedsUpdate();\n  }\n\n  getPatternFrame(name) {\n    const {\n      patternMapping\n    } = this.state;\n    const def = patternMapping && patternMapping[name];\n    return def ? [def.x, def.y, def.width, def.height] : [0, 0, 0, 0];\n  }\n\n}\nFillStyleExtension.extensionName = 'FillStyleExtension';\nFillStyleExtension.defaultProps = defaultProps;","map":{"version":3,"sources":["../../../src/fill-style/fill-style.js"],"names":["defaultProps","fillPatternEnabled","fillPatternAtlas","fillPatternMapping","fillPatternMask","getFillPattern","type","value","d","pattern","getFillPatternScale","getFillPatternOffset","DEFAULT_TEXTURE_PARAMETERS","constructor","isEnabled","layer","getShaders","extension","modules","initializeState","attributeManager","fillPatternFrames","size","accessor","transform","shaderAttributes","divisor","instanceFillPatternFrames","fillPatternScales","defaultValue","instanceFillPatternScales","fillPatternOffsets","instanceFillPatternOffsets","emptyTexture","data","width","height","updateState","oldProps","props","draw","patternTexture","fillPatternTexture","finalizeState","loadPatternAtlas","fetch","image","propName","parameters","loadPatternMapping","patternMapping","getPatternFrame","def","FillStyleExtension"],"mappings":"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","sourcesContent":["import {LayerExtension} from '@deck.gl/core';\nimport {Texture2D} from '@luma.gl/core';\nimport GL from '@luma.gl/constants';\n\nimport {patternShaders} from './shaders.glsl';\n\nconst defaultProps = {\n  fillPatternEnabled: true,\n  fillPatternAtlas: null,\n  fillPatternMapping: null,\n  fillPatternMask: true,\n  getFillPattern: {type: 'accessor', value: d => d.pattern},\n  getFillPatternScale: {type: 'accessor', value: 1},\n  getFillPatternOffset: {type: 'accessor', value: [0, 0]}\n};\n\nconst DEFAULT_TEXTURE_PARAMETERS = {\n  [GL.TEXTURE_MIN_FILTER]: GL.LINEAR,\n  // GL.LINEAR is the default value but explicitly set it here\n  [GL.TEXTURE_MAG_FILTER]: GL.LINEAR,\n  // for texture boundary artifact\n  [GL.TEXTURE_WRAP_S]: GL.CLAMP_TO_EDGE,\n  [GL.TEXTURE_WRAP_T]: GL.CLAMP_TO_EDGE\n};\n\nexport default class FillStyleExtension extends LayerExtension {\n  constructor({pattern = false} = {}) {\n    super({pattern});\n  }\n\n  isEnabled(layer) {\n    return layer.getAttributeManager() && !layer.state.pathTesselator;\n  }\n\n  getShaders(extension) {\n    if (!extension.isEnabled(this)) {\n      return null;\n    }\n\n    return {\n      modules: [extension.opts.pattern && patternShaders].filter(Boolean)\n    };\n  }\n\n  initializeState(context, extension) {\n    if (!extension.isEnabled(this)) {\n      return;\n    }\n\n    const attributeManager = this.getAttributeManager();\n\n    if (extension.opts.pattern) {\n      attributeManager.add({\n        fillPatternFrames: {\n          size: 4,\n          accessor: 'getFillPattern',\n          transform: extension.getPatternFrame.bind(this),\n          shaderAttributes: {\n            fillPatternFrames: {\n              divisor: 0\n            },\n            instanceFillPatternFrames: {\n              divisor: 1\n            }\n          }\n        },\n        fillPatternScales: {\n          size: 1,\n          accessor: 'getFillPatternScale',\n          defaultValue: 1,\n          shaderAttributes: {\n            fillPatternScales: {\n              divisor: 0\n            },\n            instanceFillPatternScales: {\n              divisor: 1\n            }\n          }\n        },\n        fillPatternOffsets: {\n          size: 2,\n          accessor: 'getFillPatternOffset',\n          shaderAttributes: {\n            fillPatternOffsets: {\n              divisor: 0\n            },\n            instanceFillPatternOffsets: {\n              divisor: 1\n            }\n          }\n        }\n      });\n    }\n    this.setState({\n      emptyTexture: new Texture2D(this.context.gl, {\n        data: new Uint8Array(4),\n        width: 1,\n        height: 1\n      })\n    });\n  }\n\n  updateState({props, oldProps}, extension) {\n    if (!extension.isEnabled(this)) {\n      return;\n    }\n\n    if (props.fillPatternAtlas && props.fillPatternAtlas !== oldProps.fillPatternAtlas) {\n      extension.loadPatternAtlas.call(this, props);\n    }\n    if (props.fillPatternMapping && props.fillPatternMapping !== oldProps.fillPatternMapping) {\n      extension.loadPatternMapping.call(this, props);\n    }\n  }\n\n  draw(params, extension) {\n    if (!extension.isEnabled(this)) {\n      return;\n    }\n\n    const {patternTexture} = this.state;\n    this.setModuleParameters({\n      fillPatternTexture: patternTexture || this.state.emptyTexture\n    });\n  }\n\n  finalizeState() {\n    const {patternTexture, emptyTexture} = this.state;\n    patternTexture?.delete();\n    emptyTexture?.delete();\n  }\n\n  async loadPatternAtlas({fillPatternAtlas, fetch}) {\n    this.state.patternTexture?.delete();\n    this.setState({patternTexture: null});\n    let image = fillPatternAtlas;\n    if (typeof image === 'string') {\n      image = await fetch(image, {propName: 'fillPatternAtlas', layer: this});\n    }\n    const patternTexture =\n      image instanceof Texture2D\n        ? image\n        : new Texture2D(this.context.gl, {\n            data: image,\n            parameters: DEFAULT_TEXTURE_PARAMETERS\n          });\n    this.setState({patternTexture});\n  }\n\n  async loadPatternMapping({fillPatternMapping, fetch}) {\n    this.setState({patternMapping: null});\n    let patternMapping = fillPatternMapping;\n    if (typeof patternMapping === 'string') {\n      patternMapping = await fetch(patternMapping, {\n        propName: 'fillPatternMapping',\n        layer: this\n      });\n    }\n    this.setState({patternMapping});\n    this.getAttributeManager().invalidate('getFillPattern');\n    this.setNeedsUpdate();\n  }\n\n  getPatternFrame(name) {\n    const {patternMapping} = this.state;\n    const def = patternMapping && patternMapping[name];\n    return def ? [def.x, def.y, def.width, def.height] : [0, 0, 0, 0];\n  }\n}\n\nFillStyleExtension.extensionName = 'FillStyleExtension';\nFillStyleExtension.defaultProps = defaultProps;\n"]},"metadata":{},"sourceType":"module"}