{"ast":null,"code":"import { Vector3, Matrix3, Matrix4, Quaternion } from '@math.gl/core';\nimport { Ellipsoid } from '@math.gl/geospatial';\nimport { GL } from '@loaders.gl/math';\nimport Tile3DFeatureTable from '../classes/tile-3d-feature-table';\nimport Tile3DBatchTable from '../classes/tile-3d-batch-table';\nimport { parse3DTileHeaderSync } from './helpers/parse-3d-tile-header';\nimport { parse3DTileTablesHeaderSync, parse3DTileTablesSync } from './helpers/parse-3d-tile-tables';\nimport { parse3DTileGLTFViewSync, extractGLTF } from './helpers/parse-3d-tile-gltf-view';\nexport async function parseInstancedModel3DTile(tile, arrayBuffer, byteOffset, options, context) {\n  byteOffset = parseInstancedModel(tile, arrayBuffer, byteOffset, options, context);\n  await extractGLTF(tile, tile.gltfFormat, options, context);\n  return byteOffset;\n}\n\nfunction parseInstancedModel(tile, arrayBuffer, byteOffset, options, context) {\n  byteOffset = parse3DTileHeaderSync(tile, arrayBuffer, byteOffset);\n\n  if (tile.version !== 1) {\n    throw new Error(\"Instanced 3D Model version \".concat(tile.version, \" is not supported\"));\n  }\n\n  byteOffset = parse3DTileTablesHeaderSync(tile, arrayBuffer, byteOffset);\n  const view = new DataView(arrayBuffer);\n  tile.gltfFormat = view.getUint32(byteOffset, true);\n  byteOffset += 4;\n  byteOffset = parse3DTileTablesSync(tile, arrayBuffer, byteOffset, options);\n  byteOffset = parse3DTileGLTFViewSync(tile, arrayBuffer, byteOffset, options);\n\n  if (tile.featureTableJsonByteLength === 0) {\n    throw new Error('i3dm parser: featureTableJsonByteLength is zero.');\n  }\n\n  const featureTable = new Tile3DFeatureTable(tile.featureTableJson, tile.featureTableBinary);\n  const instancesLength = featureTable.getGlobalProperty('INSTANCES_LENGTH');\n  featureTable.featuresLength = instancesLength;\n\n  if (!Number.isFinite(instancesLength)) {\n    throw new Error('i3dm parser: INSTANCES_LENGTH must be defined');\n  }\n\n  tile.eastNorthUp = featureTable.getGlobalProperty('EAST_NORTH_UP');\n  tile.rtcCenter = featureTable.getGlobalProperty('RTC_CENTER', GL.FLOAT, 3);\n  const batchTable = new Tile3DBatchTable(tile.batchTableJson, tile.batchTableBinary, instancesLength);\n  extractInstancedAttributes(tile, featureTable, batchTable, instancesLength);\n  return byteOffset;\n}\n\nfunction extractInstancedAttributes(tile, featureTable, batchTable, instancesLength) {\n  const collectionOptions = {\n    instances: new Array(instancesLength),\n    batchTable: tile._batchTable,\n    cull: false,\n    url: undefined,\n    gltf: undefined,\n    basePath: undefined,\n    incrementallyLoadTextures: false,\n    forwardAxis: [1, 0, 0]\n  };\n  const instances = collectionOptions.instances;\n  const instancePosition = new Vector3();\n  const instanceNormalRight = new Vector3();\n  const instanceNormalUp = new Vector3();\n  const instanceNormalForward = new Vector3();\n  const instanceRotation = new Matrix3();\n  const instanceQuaternion = new Quaternion();\n  const instanceScale = new Vector3();\n  const instanceTranslationRotationScale = {};\n  const instanceTransform = new Matrix4();\n  const scratch1 = [];\n  const scratch2 = [];\n  const scratchVector1 = new Vector3();\n  const scratchVector2 = new Vector3();\n\n  for (let i = 0; i < instancesLength; i++) {\n    let position;\n\n    if (featureTable.hasProperty('POSITION')) {\n      position = featureTable.getProperty('POSITION', GL.FLOAT, 3, i, instancePosition);\n    } else if (featureTable.hasProperty('POSITION_QUANTIZED')) {\n      position = featureTable.getProperty('POSITION_QUANTIZED', GL.UNSIGNED_SHORT, 3, i, instancePosition);\n      const quantizedVolumeOffset = featureTable.getGlobalProperty('QUANTIZED_VOLUME_OFFSET', GL.FLOAT, 3, scratchVector1);\n\n      if (!quantizedVolumeOffset) {\n        throw new Error('i3dm parser: QUANTIZED_VOLUME_OFFSET must be defined for quantized positions.');\n      }\n\n      const quantizedVolumeScale = featureTable.getGlobalProperty('QUANTIZED_VOLUME_SCALE', GL.FLOAT, 3, scratchVector2);\n\n      if (!quantizedVolumeScale) {\n        throw new Error('i3dm parser: QUANTIZED_VOLUME_SCALE must be defined for quantized positions.');\n      }\n\n      const MAX_UNSIGNED_SHORT = 65535.0;\n\n      for (let j = 0; j < 3; j++) {\n        position[j] = position[j] / MAX_UNSIGNED_SHORT * quantizedVolumeScale[j] + quantizedVolumeOffset[j];\n      }\n    }\n\n    if (!position) {\n      throw new Error('i3dm: POSITION or POSITION_QUANTIZED must be defined for each instance.');\n    }\n\n    instancePosition.copy(position);\n    instanceTranslationRotationScale.translation = instancePosition;\n    tile.normalUp = featureTable.getProperty('NORMAL_UP', GL.FLOAT, 3, i, scratch1);\n    tile.normalRight = featureTable.getProperty('NORMAL_RIGHT', GL.FLOAT, 3, i, scratch2);\n    const hasCustomOrientation = false;\n\n    if (tile.normalUp) {\n      if (!tile.normalRight) {\n        throw new Error('i3dm: Custom orientation requires both NORMAL_UP and NORMAL_RIGHT.');\n      }\n\n      tile.hasCustomOrientation = true;\n    } else {\n      tile.octNormalUp = featureTable.getProperty('NORMAL_UP_OCT32P', GL.UNSIGNED_SHORT, 2, scratch1);\n      tile.octNormalRight = featureTable.getProperty('NORMAL_RIGHT_OCT32P', GL.UNSIGNED_SHORT, 2, scratch2);\n\n      if (tile.octNormalUp) {\n        if (!tile.octNormalRight) {\n          throw new Error('i3dm: oct-encoded orientation requires NORMAL_UP_OCT32P and NORMAL_RIGHT_OCT32P');\n        }\n\n        throw new Error('i3dm: oct-encoded orientation not implemented');\n      } else if (tile.eastNorthUp) {\n        Ellipsoid.WGS84.eastNorthUpToFixedFrame(instancePosition, instanceTransform);\n        instanceTransform.getRotationMatrix3(instanceRotation);\n      } else {\n        instanceRotation.identity();\n      }\n    }\n\n    if (hasCustomOrientation) {\n      instanceNormalForward.copy(instanceNormalRight).cross(instanceNormalUp).normalize();\n      instanceRotation.setColumn(0, instanceNormalRight);\n      instanceRotation.setColumn(1, instanceNormalUp);\n      instanceRotation.setColumn(2, instanceNormalForward);\n    }\n\n    instanceQuaternion.fromMatrix3(instanceRotation);\n    instanceTranslationRotationScale.rotation = instanceQuaternion;\n    instanceScale.set(1.0, 1.0, 1.0);\n    const scale = featureTable.getProperty('SCALE', GL.FLOAT, 1, i);\n\n    if (Number.isFinite(scale)) {\n      instanceScale.multiplyByScalar(scale);\n    }\n\n    const nonUniformScale = featureTable.getProperty('SCALE_NON_UNIFORM', GL.FLOAT, 3, i, scratch1);\n\n    if (nonUniformScale) {\n      instanceScale.scale(nonUniformScale);\n    }\n\n    instanceTranslationRotationScale.scale = instanceScale;\n    let batchId = featureTable.getProperty('BATCH_ID', GL.UNSIGNED_SHORT, 1, i);\n\n    if (batchId === undefined) {\n      batchId = i;\n    }\n\n    const rotationMatrix = new Matrix4().fromQuaternion(instanceTranslationRotationScale.rotation);\n    instanceTransform.identity();\n    instanceTransform.translate(instanceTranslationRotationScale.translation);\n    instanceTransform.multiplyRight(rotationMatrix);\n    instanceTransform.scale(instanceTranslationRotationScale.scale);\n    const modelMatrix = instanceTransform.clone();\n    instances[i] = {\n      modelMatrix,\n      batchId\n    };\n  }\n\n  tile.instances = instances;\n}","map":{"version":3,"sources":["../../../../src/lib/parsers/parse-3d-tile-instanced-model.js"],"names":["byteOffset","parseInstancedModel","extractGLTF","tile","parse3DTileHeaderSync","parse3DTileTablesHeaderSync","view","parse3DTileTablesSync","parse3DTileGLTFViewSync","featureTable","instancesLength","Number","GL","batchTable","extractInstancedAttributes","collectionOptions","instances","cull","url","gltf","basePath","incrementallyLoadTextures","forwardAxis","instancePosition","instanceNormalRight","instanceNormalUp","instanceNormalForward","instanceRotation","instanceQuaternion","instanceScale","instanceTranslationRotationScale","instanceTransform","scratch1","scratch2","scratchVector1","scratchVector2","i","position","quantizedVolumeOffset","quantizedVolumeScale","MAX_UNSIGNED_SHORT","j","hasCustomOrientation","Ellipsoid","scale","nonUniformScale","batchId","rotationMatrix","modelMatrix"],"mappings":"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","sourcesContent":["// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\nimport {Vector3, Matrix3, Matrix4, Quaternion} from '@math.gl/core';\nimport {Ellipsoid} from '@math.gl/geospatial';\nimport {GL} from '@loaders.gl/math'; // 'math.gl/geometry';\nimport Tile3DFeatureTable from '../classes/tile-3d-feature-table';\nimport Tile3DBatchTable from '../classes/tile-3d-batch-table';\n\nimport {parse3DTileHeaderSync} from './helpers/parse-3d-tile-header';\nimport {parse3DTileTablesHeaderSync, parse3DTileTablesSync} from './helpers/parse-3d-tile-tables';\nimport {parse3DTileGLTFViewSync, extractGLTF} from './helpers/parse-3d-tile-gltf-view';\n\nexport async function parseInstancedModel3DTile(tile, arrayBuffer, byteOffset, options, context) {\n  byteOffset = parseInstancedModel(tile, arrayBuffer, byteOffset, options, context);\n  await extractGLTF(tile, tile.gltfFormat, options, context);\n  return byteOffset;\n}\n\nfunction parseInstancedModel(tile, arrayBuffer, byteOffset, options, context) {\n  byteOffset = parse3DTileHeaderSync(tile, arrayBuffer, byteOffset);\n  if (tile.version !== 1) {\n    throw new Error(`Instanced 3D Model version ${tile.version} is not supported`);\n  }\n\n  byteOffset = parse3DTileTablesHeaderSync(tile, arrayBuffer, byteOffset);\n\n  const view = new DataView(arrayBuffer);\n\n  tile.gltfFormat = view.getUint32(byteOffset, true);\n  byteOffset += 4;\n\n  // PARSE FEATURE TABLE\n  byteOffset = parse3DTileTablesSync(tile, arrayBuffer, byteOffset, options);\n\n  byteOffset = parse3DTileGLTFViewSync(tile, arrayBuffer, byteOffset, options);\n\n  // TODO - Is the feature table sometimes optional or can check be moved into table header parser?\n  if (tile.featureTableJsonByteLength === 0) {\n    throw new Error('i3dm parser: featureTableJsonByteLength is zero.');\n  }\n\n  const featureTable = new Tile3DFeatureTable(tile.featureTableJson, tile.featureTableBinary);\n\n  const instancesLength = featureTable.getGlobalProperty('INSTANCES_LENGTH');\n  featureTable.featuresLength = instancesLength;\n\n  if (!Number.isFinite(instancesLength)) {\n    throw new Error('i3dm parser: INSTANCES_LENGTH must be defined');\n  }\n\n  tile.eastNorthUp = featureTable.getGlobalProperty('EAST_NORTH_UP');\n  tile.rtcCenter = featureTable.getGlobalProperty('RTC_CENTER', GL.FLOAT, 3);\n\n  const batchTable = new Tile3DBatchTable(\n    tile.batchTableJson,\n    tile.batchTableBinary,\n    instancesLength\n  );\n\n  extractInstancedAttributes(tile, featureTable, batchTable, instancesLength);\n\n  return byteOffset;\n}\n\n// eslint-disable-next-line max-statements, complexity\nfunction extractInstancedAttributes(tile, featureTable, batchTable, instancesLength) {\n  // Create model instance collection\n  const collectionOptions = {\n    instances: new Array(instancesLength),\n    batchTable: tile._batchTable,\n    cull: false, // Already culled by 3D Tiles\n    url: undefined,\n    // requestType: RequestType.TILES3D,\n    gltf: undefined,\n    basePath: undefined,\n    incrementallyLoadTextures: false,\n    // TODO - tileset is not available at this stage, tile is parsed independently\n    // upAxis: (tileset && tileset._gltfUpAxis) || [0, 1, 0],\n    forwardAxis: [1, 0, 0]\n  };\n\n  const instances = collectionOptions.instances;\n  const instancePosition = new Vector3();\n  const instanceNormalRight = new Vector3();\n  const instanceNormalUp = new Vector3();\n  const instanceNormalForward = new Vector3();\n  const instanceRotation = new Matrix3();\n  const instanceQuaternion = new Quaternion();\n  const instanceScale = new Vector3();\n  const instanceTranslationRotationScale = {};\n  const instanceTransform = new Matrix4();\n  const scratch1 = [];\n  const scratch2 = [];\n  const scratchVector1 = new Vector3();\n  const scratchVector2 = new Vector3();\n\n  for (let i = 0; i < instancesLength; i++) {\n    let position;\n\n    // Get the instance position\n    if (featureTable.hasProperty('POSITION')) {\n      position = featureTable.getProperty('POSITION', GL.FLOAT, 3, i, instancePosition);\n    } else if (featureTable.hasProperty('POSITION_QUANTIZED')) {\n      position = featureTable.getProperty(\n        'POSITION_QUANTIZED',\n        GL.UNSIGNED_SHORT,\n        3,\n        i,\n        instancePosition\n      );\n\n      const quantizedVolumeOffset = featureTable.getGlobalProperty(\n        'QUANTIZED_VOLUME_OFFSET',\n        GL.FLOAT,\n        3,\n        scratchVector1\n      );\n      if (!quantizedVolumeOffset) {\n        throw new Error(\n          'i3dm parser: QUANTIZED_VOLUME_OFFSET must be defined for quantized positions.'\n        );\n      }\n\n      const quantizedVolumeScale = featureTable.getGlobalProperty(\n        'QUANTIZED_VOLUME_SCALE',\n        GL.FLOAT,\n        3,\n        scratchVector2\n      );\n      if (!quantizedVolumeScale) {\n        throw new Error(\n          'i3dm parser: QUANTIZED_VOLUME_SCALE must be defined for quantized positions.'\n        );\n      }\n\n      const MAX_UNSIGNED_SHORT = 65535.0;\n      for (let j = 0; j < 3; j++) {\n        position[j] =\n          (position[j] / MAX_UNSIGNED_SHORT) * quantizedVolumeScale[j] + quantizedVolumeOffset[j];\n      }\n    }\n\n    if (!position) {\n      throw new Error('i3dm: POSITION or POSITION_QUANTIZED must be defined for each instance.');\n    }\n\n    instancePosition.copy(position);\n    instanceTranslationRotationScale.translation = instancePosition;\n\n    // Get the instance rotation\n    tile.normalUp = featureTable.getProperty('NORMAL_UP', GL.FLOAT, 3, i, scratch1);\n    tile.normalRight = featureTable.getProperty('NORMAL_RIGHT', GL.FLOAT, 3, i, scratch2);\n\n    const hasCustomOrientation = false;\n    if (tile.normalUp) {\n      if (!tile.normalRight) {\n        throw new Error('i3dm: Custom orientation requires both NORMAL_UP and NORMAL_RIGHT.');\n      }\n      // Vector3.unpack(normalUp, 0, instanceNormalUp);\n      // Vector3.unpack(normalRight, 0, instanceNormalRight);\n      tile.hasCustomOrientation = true;\n    } else {\n      tile.octNormalUp = featureTable.getProperty(\n        'NORMAL_UP_OCT32P',\n        GL.UNSIGNED_SHORT,\n        2,\n        scratch1\n      );\n      tile.octNormalRight = featureTable.getProperty(\n        'NORMAL_RIGHT_OCT32P',\n        GL.UNSIGNED_SHORT,\n        2,\n        scratch2\n      );\n\n      if (tile.octNormalUp) {\n        if (!tile.octNormalRight) {\n          throw new Error(\n            'i3dm: oct-encoded orientation requires NORMAL_UP_OCT32P and NORMAL_RIGHT_OCT32P'\n          );\n        }\n\n        throw new Error('i3dm: oct-encoded orientation not implemented');\n        /*\n        AttributeCompression.octDecodeInRange(octNormalUp[0], octNormalUp[1], 65535, instanceNormalUp);\n        AttributeCompression.octDecodeInRange(octNormalRight[0], octNormalRight[1], 65535, instanceNormalRight);\n        hasCustomOrientation = true;\n        */\n      } else if (tile.eastNorthUp) {\n        Ellipsoid.WGS84.eastNorthUpToFixedFrame(instancePosition, instanceTransform);\n        instanceTransform.getRotationMatrix3(instanceRotation);\n      } else {\n        instanceRotation.identity();\n      }\n    }\n\n    if (hasCustomOrientation) {\n      instanceNormalForward.copy(instanceNormalRight).cross(instanceNormalUp).normalize();\n      instanceRotation.setColumn(0, instanceNormalRight);\n      instanceRotation.setColumn(1, instanceNormalUp);\n      instanceRotation.setColumn(2, instanceNormalForward);\n    }\n\n    instanceQuaternion.fromMatrix3(instanceRotation);\n    instanceTranslationRotationScale.rotation = instanceQuaternion;\n\n    // Get the instance scale\n    instanceScale.set(1.0, 1.0, 1.0);\n    const scale = featureTable.getProperty('SCALE', GL.FLOAT, 1, i);\n    if (Number.isFinite(scale)) {\n      instanceScale.multiplyByScalar(scale);\n    }\n    const nonUniformScale = featureTable.getProperty('SCALE_NON_UNIFORM', GL.FLOAT, 3, i, scratch1);\n    if (nonUniformScale) {\n      instanceScale.scale(nonUniformScale);\n    }\n\n    instanceTranslationRotationScale.scale = instanceScale;\n\n    // Get the batchId\n    let batchId = featureTable.getProperty('BATCH_ID', GL.UNSIGNED_SHORT, 1, i);\n    if (batchId === undefined) {\n      // If BATCH_ID semantic is undefined, batchId is just the instance number\n      batchId = i;\n    }\n\n    const rotationMatrix = new Matrix4().fromQuaternion(instanceTranslationRotationScale.rotation);\n\n    // Create the model matrix and the instance\n    instanceTransform.identity();\n    instanceTransform.translate(instanceTranslationRotationScale.translation);\n    instanceTransform.multiplyRight(rotationMatrix);\n    instanceTransform.scale(instanceTranslationRotationScale.scale);\n\n    const modelMatrix = instanceTransform.clone();\n    instances[i] = {\n      modelMatrix,\n      batchId\n    };\n  }\n\n  tile.instances = instances;\n}\n"]},"metadata":{},"sourceType":"module"}