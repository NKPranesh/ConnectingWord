{"ast":null,"code":"import { getBlobOrSVGDataUrl } from './svg-utils';\nexport default async function parseToImage(arrayBuffer, options, url) {\n  const blobOrDataUrl = getBlobOrSVGDataUrl(arrayBuffer, url);\n  const URL = self.URL || self.webkitURL;\n  const objectUrl = typeof blobOrDataUrl !== 'string' && URL.createObjectURL(blobOrDataUrl);\n\n  try {\n    return await loadToImage(objectUrl || blobOrDataUrl, options);\n  } finally {\n    if (objectUrl) {\n      URL.revokeObjectURL(objectUrl);\n    }\n  }\n}\nexport async function loadToImage(url, options) {\n  const image = new Image();\n  image.src = url;\n\n  if (options.image && options.image.decode && image.decode) {\n    await image.decode();\n    return image;\n  }\n\n  return await new Promise((resolve, reject) => {\n    try {\n      image.onload = () => resolve(image);\n\n      image.onerror = err => reject(new Error(\"Could not load image \".concat(url, \": \").concat(err)));\n    } catch (error) {\n      reject(error);\n    }\n  });\n}","map":{"version":3,"sources":["../../../../src/lib/parsers/parse-to-image.ts"],"names":["blobOrDataUrl","getBlobOrSVGDataUrl","URL","self","objectUrl","loadToImage","image","options","resolve","err","reject"],"mappings":"AAAA,SAAA,mBAAA,QAAA,aAAA;AAGA,eAAe,eAAA,YAAA,CAAA,WAAA,EAAA,OAAA,EAAA,GAAA,EAAuD;AAKpE,QAAMA,aAAa,GAAGC,mBAAmB,CAAA,WAAA,EAAzC,GAAyC,CAAzC;AACA,QAAMC,GAAG,GAAGC,IAAI,CAAJA,GAAAA,IAAYA,IAAI,CAA5B,SAAA;AACA,QAAMC,SAAS,GAAG,OAAA,aAAA,KAAA,QAAA,IAAqCF,GAAG,CAAHA,eAAAA,CAAvD,aAAuDA,CAAvD;;AACA,MAAI;AACF,WAAO,MAAMG,WAAW,CAACD,SAAS,IAAV,aAAA,EAAxB,OAAwB,CAAxB;AADF,GAAA,SAEU;AACR,QAAA,SAAA,EAAe;AACbF,MAAAA,GAAG,CAAHA,eAAAA,CAAAA,SAAAA;AACD;AACF;AACF;AAED,OAAO,eAAA,WAAA,CAAA,GAAA,EAAA,OAAA,EAAyC;AAC9C,QAAMI,KAAK,GAAG,IAAd,KAAc,EAAd;AACAA,EAAAA,KAAK,CAALA,GAAAA,GAAAA,GAAAA;;AASA,MAAIC,OAAO,CAAPA,KAAAA,IAAiBA,OAAO,CAAPA,KAAAA,CAAjBA,MAAAA,IAAyCD,KAAK,CAAlD,MAAA,EAA2D;AACzD,UAAMA,KAAK,CAAX,MAAMA,EAAN;AACA,WAAA,KAAA;AACD;;AAGD,SAAO,MAAM,IAAA,OAAA,CAAY,CAAA,OAAA,EAAA,MAAA,KAAqB;AAC5C,QAAI;AACFA,MAAAA,KAAK,CAALA,MAAAA,GAAe,MAAME,OAAO,CAA5BF,KAA4B,CAA5BA;;AACAA,MAAAA,KAAK,CAALA,OAAAA,GAAiBG,GAAD,IAASC,MAAM,CAAC,IAAA,KAAA,CAAA,wBAAA,MAAA,CAAA,GAAA,EAAA,IAAA,EAAA,MAAA,CAAhCJ,GAAgC,CAAA,CAAD,CAA/BA;AAFF,KAAA,CAGE,OAAA,KAAA,EAAc;AACdI,MAAAA,MAAM,CAANA,KAAM,CAANA;AACD;AANH,GAAa,CAAb;AAQD","sourcesContent":["import {getBlobOrSVGDataUrl} from './svg-utils';\n\n// Parses html image from array buffer\nexport default async function parseToImage(arrayBuffer, options, url) {\n  // Note: image parsing requires conversion to Blob (for createObjectURL).\n  // Potentially inefficient for not using `response.blob()` (and for File / Blob inputs)...\n  // But presumably not worth adding 'blob' flag to loader objects?\n\n  const blobOrDataUrl = getBlobOrSVGDataUrl(arrayBuffer, url);\n  const URL = self.URL || self.webkitURL;\n  const objectUrl = typeof blobOrDataUrl !== 'string' && URL.createObjectURL(blobOrDataUrl);\n  try {\n    return await loadToImage(objectUrl || blobOrDataUrl, options);\n  } finally {\n    if (objectUrl) {\n      URL.revokeObjectURL(objectUrl);\n    }\n  }\n}\n\nexport async function loadToImage(url, options) {\n  const image = new Image();\n  image.src = url;\n\n  // The `image.onload()` callback does not guarantee that the image has been decoded\n  // so a main thread \"freeze\" can be incurred when using the image for the first time.\n  // `Image.decode()` returns a promise that completes when image is decoded.\n\n  // https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/decode\n  // Note: When calling `img.decode()`, we do not need to wait for `img.onload()`\n  // Note: `HTMLImageElement.decode()` is not available in Edge and IE11\n  if (options.image && options.image.decode && image.decode) {\n    await image.decode();\n    return image;\n  }\n\n  // Create a promise that tracks onload/onerror callbacks\n  return await new Promise((resolve, reject) => {\n    try {\n      image.onload = () => resolve(image);\n      image.onerror = (err) => reject(new Error(`Could not load image ${url}: ${err}`));\n    } catch (error) {\n      reject(error);\n    }\n  });\n}\n"]},"metadata":{},"sourceType":"module"}