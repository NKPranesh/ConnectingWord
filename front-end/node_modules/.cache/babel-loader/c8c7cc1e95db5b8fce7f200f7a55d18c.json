{"ast":null,"code":"import { copyStringToDataView } from '@loaders.gl/loader-utils';\nimport { MAGIC_ARRAY } from '../constants';\nimport { encode3DTileHeader, encode3DTileByteLength } from './helpers/encode-3d-tile-header';\nexport function encodeInstancedModel3DTile(tile, dataView, byteOffset, options) {\n  const {\n    featuresLength = 1,\n    gltfFormat = 1,\n    gltfUri = ''\n  } = tile;\n  const gltfUriByteLength = gltfUri.length;\n  const featureTableJson = {\n    INSTANCES_LENGTH: featuresLength,\n    POSITION: new Array(featuresLength * 3).fill(0)\n  };\n  const featureTableJsonString = JSON.stringify(featureTableJson);\n  const featureTableJsonByteLength = featureTableJsonString.length;\n  tile = {\n    magic: MAGIC_ARRAY.INSTANCED_MODEL,\n    ...tile\n  };\n  const byteOffsetStart = byteOffset;\n  byteOffset = encode3DTileHeader(tile, dataView, 0);\n\n  if (dataView) {\n    dataView.setUint32(12, featureTableJsonByteLength, true);\n    dataView.setUint32(16, 0, true);\n    dataView.setUint32(20, 0, true);\n    dataView.setUint32(24, 0, true);\n    dataView.setUint32(28, gltfFormat, true);\n  }\n\n  byteOffset += 20;\n  byteOffset += copyStringToDataView(dataView, byteOffset, featureTableJsonString, featureTableJsonByteLength);\n  byteOffset += copyStringToDataView(dataView, byteOffset, gltfUri, gltfUriByteLength);\n  encode3DTileByteLength(dataView, byteOffsetStart, byteOffset - byteOffsetStart);\n  return byteOffset;\n}","map":{"version":3,"sources":["../../../../src/lib/encoders/encode-3d-tile-instanced-model.js"],"names":["featuresLength","gltfFormat","gltfUri","gltfUriByteLength","featureTableJson","INSTANCES_LENGTH","POSITION","featureTableJsonString","JSON","featureTableJsonByteLength","tile","magic","MAGIC_ARRAY","byteOffsetStart","byteOffset","encode3DTileHeader","dataView","copyStringToDataView","encode3DTileByteLength"],"mappings":"AAGA,SAAA,oBAAA,QAAA,0BAAA;AACA,SAAA,WAAA,QAAA,cAAA;AACA,SAAA,kBAAA,EAAA,sBAAA,QAAA,iCAAA;AAIA,OAAO,SAAA,0BAAA,CAAA,IAAA,EAAA,QAAA,EAAA,UAAA,EAAA,OAAA,EAAyE;AAC9E,QAAM;AAACA,IAAAA,cAAc,GAAf,CAAA;AAAqBC,IAAAA,UAAU,GAA/B,CAAA;AAAqCC,IAAAA,OAAO,GAAG;AAA/C,MAAN,IAAA;AAEA,QAAMC,iBAAiB,GAAGD,OAAO,CAAjC,MAAA;AAEA,QAAME,gBAAgB,GAAG;AACvBC,IAAAA,gBAAgB,EADO,cAAA;AAEvBC,IAAAA,QAAQ,EAAE,IAAA,KAAA,CAAUN,cAAc,GAAxB,CAAA,EAAA,IAAA,CAAA,CAAA;AAFa,GAAzB;AAIA,QAAMO,sBAAsB,GAAGC,IAAI,CAAJA,SAAAA,CAA/B,gBAA+BA,CAA/B;AACA,QAAMC,0BAA0B,GAAGF,sBAAsB,CAAzD,MAAA;AAGAG,EAAAA,IAAI,GAAG;AAACC,IAAAA,KAAK,EAAEC,WAAW,CAAnB,eAAA;AAAqC,OAAGF;AAAxC,GAAPA;AAEA,QAAMG,eAAe,GAArB,UAAA;AAEAC,EAAAA,UAAU,GAAGC,kBAAkB,CAAA,IAAA,EAAA,QAAA,EAA/BD,CAA+B,CAA/BA;;AAEA,MAAA,QAAA,EAAc;AACZE,IAAAA,QAAQ,CAARA,SAAAA,CAAAA,EAAAA,EAAAA,0BAAAA,EAAAA,IAAAA;AACAA,IAAAA,QAAQ,CAARA,SAAAA,CAAAA,EAAAA,EAAAA,CAAAA,EAAAA,IAAAA;AACAA,IAAAA,QAAQ,CAARA,SAAAA,CAAAA,EAAAA,EAAAA,CAAAA,EAAAA,IAAAA;AACAA,IAAAA,QAAQ,CAARA,SAAAA,CAAAA,EAAAA,EAAAA,CAAAA,EAAAA,IAAAA;AACAA,IAAAA,QAAQ,CAARA,SAAAA,CAAAA,EAAAA,EAAAA,UAAAA,EAAAA,IAAAA;AACD;;AAEDF,EAAAA,UAAU,IAAVA,EAAAA;AAEAA,EAAAA,UAAU,IAAIG,oBAAoB,CAAA,QAAA,EAAA,UAAA,EAAA,sBAAA,EAAlCH,0BAAkC,CAAlCA;AAMAA,EAAAA,UAAU,IAAIG,oBAAoB,CAAA,QAAA,EAAA,UAAA,EAAA,OAAA,EAAlCH,iBAAkC,CAAlCA;AAGAI,EAAAA,sBAAsB,CAAA,QAAA,EAAA,eAAA,EAA4BJ,UAAU,GAA5DI,eAAsB,CAAtBA;AAEA,SAAA,UAAA;AACD","sourcesContent":["// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\nimport {copyStringToDataView} from '@loaders.gl/loader-utils';\nimport {MAGIC_ARRAY} from '../constants';\nimport {encode3DTileHeader, encode3DTileByteLength} from './helpers/encode-3d-tile-header';\n\n// Procedurally encode the tile array buffer for testing purposes\n// eslint-disable-next-line max-statements\nexport function encodeInstancedModel3DTile(tile, dataView, byteOffset, options) {\n  const {featuresLength = 1, gltfFormat = 1, gltfUri = ''} = tile;\n\n  const gltfUriByteLength = gltfUri.length;\n\n  const featureTableJson = {\n    INSTANCES_LENGTH: featuresLength,\n    POSITION: new Array(featuresLength * 3).fill(0)\n  };\n  const featureTableJsonString = JSON.stringify(featureTableJson);\n  const featureTableJsonByteLength = featureTableJsonString.length;\n\n  // Add default magic for this tile type\n  tile = {magic: MAGIC_ARRAY.INSTANCED_MODEL, ...tile};\n\n  const byteOffsetStart = byteOffset;\n\n  byteOffset = encode3DTileHeader(tile, dataView, 0);\n\n  if (dataView) {\n    dataView.setUint32(12, featureTableJsonByteLength, true); // featureTableJsonByteLength\n    dataView.setUint32(16, 0, true); // featureTableBinaryByteLength\n    dataView.setUint32(20, 0, true); // batchTableJsonByteLength\n    dataView.setUint32(24, 0, true); // batchTableBinaryByteLength\n    dataView.setUint32(28, gltfFormat, true); // gltfFormat\n  }\n\n  byteOffset += 20;\n\n  byteOffset += copyStringToDataView(\n    dataView,\n    byteOffset,\n    featureTableJsonString,\n    featureTableJsonByteLength\n  );\n  byteOffset += copyStringToDataView(dataView, byteOffset, gltfUri, gltfUriByteLength);\n\n  // Go \"back\" and rewrite the tile's `byteLength` now that we know the value\n  encode3DTileByteLength(dataView, byteOffsetStart, byteOffset - byteOffsetStart);\n\n  return byteOffset;\n}\n"]},"metadata":{},"sourceType":"module"}