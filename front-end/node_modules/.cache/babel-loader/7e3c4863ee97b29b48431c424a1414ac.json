{"ast":null,"code":"export function deduceTableSchema(table, schema) {\n  const deducedSchema = Array.isArray(table) ? deduceSchemaForRowTable(table) : deduceSchemaForColumnarTable(table);\n  return Object.assign(deducedSchema, schema);\n}\n\nfunction deduceSchemaForColumnarTable(columnarTable) {\n  const schema = {};\n\n  for (const field in columnarTable) {\n    const column = columnarTable[field];\n\n    if (ArrayBuffer.isView(column)) {\n      schema[field] = column.constructor;\n    } else if (column.length) {\n      const value = column[0];\n      schema[field] = deduceTypeFromValue(value);\n    }\n\n    schema[field] = schema[field] || null;\n  }\n\n  return schema;\n}\n\nfunction deduceSchemaForRowTable(rowTable) {\n  const schema = {};\n\n  if (rowTable.length) {\n    const row = rowTable[0];\n\n    for (const field in row) {\n      const value = row[field];\n      schema[field] = deduceTypeFromValue(value);\n    }\n  }\n\n  return schema;\n}\n\nfunction deduceTypeFromValue(value) {\n  if (value instanceof Date) {\n    return Date;\n  } else if (value instanceof Number) {\n    return Float32Array;\n  } else if (typeof value === 'string') {\n    return String;\n  }\n\n  return null;\n}","map":{"version":3,"sources":["../../../../src/lib/schema-utils/deduce-table-schema.ts"],"names":["deducedSchema","Array","deduceSchemaForRowTable","deduceSchemaForColumnarTable","Object","schema","column","columnarTable","ArrayBuffer","value","deduceTypeFromValue","rowTable","row"],"mappings":"AAyCA,OAAO,SAAA,iBAAA,CAAA,KAAA,EAAA,MAAA,EAAmD;AACxD,QAAMA,aAAa,GAAGC,KAAK,CAALA,OAAAA,CAAAA,KAAAA,IAClBC,uBAAuB,CADLD,KACK,CADLA,GAElBE,4BAA4B,CAFhC,KAEgC,CAFhC;AAIA,SAAOC,MAAM,CAANA,MAAAA,CAAAA,aAAAA,EAAP,MAAOA,CAAP;AACD;;AAED,SAAA,4BAAA,CAAA,aAAA,EAAqD;AACnD,QAAMC,MAAM,GAAZ,EAAA;;AACA,OAAK,MAAL,KAAA,IAAA,aAAA,EAAmC;AACjC,UAAMC,MAAM,GAAGC,aAAa,CAA5B,KAA4B,CAA5B;;AAEA,QAAIC,WAAW,CAAXA,MAAAA,CAAJ,MAAIA,CAAJ,EAAgC;AAC9BH,MAAAA,MAAM,CAANA,KAAM,CAANA,GAAgBC,MAAM,CAAtBD,WAAAA;AADF,KAAA,MAGO,IAAIC,MAAM,CAAV,MAAA,EAAmB;AACxB,YAAMG,KAAK,GAAGH,MAAM,CAApB,CAAoB,CAApB;AACAD,MAAAA,MAAM,CAANA,KAAM,CAANA,GAAgBK,mBAAmB,CAAnCL,KAAmC,CAAnCA;AAED;;AAEDA,IAAAA,MAAM,CAANA,KAAM,CAANA,GAAgBA,MAAM,CAANA,KAAM,CAANA,IAAhBA,IAAAA;AACD;;AACD,SAAA,MAAA;AACD;;AAED,SAAA,uBAAA,CAAA,QAAA,EAA2C;AACzC,QAAMA,MAAM,GAAZ,EAAA;;AACA,MAAIM,QAAQ,CAAZ,MAAA,EAAqB;AACnB,UAAMC,GAAG,GAAGD,QAAQ,CAApB,CAAoB,CAApB;;AAEA,SAAK,MAAL,KAAA,IAAA,GAAA,EAAyB;AACvB,YAAMF,KAAK,GAAGG,GAAG,CAAjB,KAAiB,CAAjB;AACAP,MAAAA,MAAM,CAANA,KAAM,CAANA,GAAgBK,mBAAmB,CAAnCL,KAAmC,CAAnCA;AACD;AACF;;AACD,SAAA,MAAA;AACD;;AAED,SAAA,mBAAA,CAAA,KAAA,EAAoC;AAClC,MAAII,KAAK,YAAT,IAAA,EAA2B;AACzB,WAAA,IAAA;AADF,GAAA,MAEO,IAAIA,KAAK,YAAT,MAAA,EAA6B;AAClC,WAAA,YAAA;AADK,GAAA,MAEA,IAAI,OAAA,KAAA,KAAJ,QAAA,EAA+B;AACpC,WAAA,MAAA;AACD;;AACD,SAAA,IAAA;AACD","sourcesContent":["// Type deduction\nimport {\n  Schema\n  // Int,\n  // Int8,\n  // Int16,\n  // Int32,\n  // Uint8,\n  // Uint16,\n  // Uint32,\n  // Float32,\n  // Float64\n  // Bool,\n  // Utf8,\n  // TimestampMillisecond,\n  // Null\n} from '../schema';\n\n// const TYPED_ARRAY_TO_TYPE = {\n//   Int8Array: new Int8(),\n//   Int16Array: new Int16(),\n//   Int32Array: new Int32(),\n//   Uint8Array: new Uint8(),\n//   Uint8ClampedArray: new Uint8(),\n//   Uint16Array: new Uint16(),\n//   Uint32Array: new Uint32(),\n//   Float32Array: new Float32(),\n//   Float64Array: new Float64()\n// };\n\n// if (typeof BigInt64Array !== 'undefined') {\n//   TYPED_ARRAY_TO_TYPE.BigInt64Array = new Int64();\n//   TYPED_ARRAY_TO_TYPE.BigUint64Array = new Uint64();\n// }\n\n/**\n * SCHEMA SUPPORT - AUTODEDUCTION\n * @param {*} table\n * @param {*} schema\n * @returns\n */\nexport function deduceTableSchema(table, schema?: Schema) {\n  const deducedSchema = Array.isArray(table)\n    ? deduceSchemaForRowTable(table)\n    : deduceSchemaForColumnarTable(table);\n  // Deduced schema will fill in missing info from partial options.schema, if provided\n  return Object.assign(deducedSchema, schema);\n}\n\nfunction deduceSchemaForColumnarTable(columnarTable) {\n  const schema = {};\n  for (const field in columnarTable) {\n    const column = columnarTable[field];\n    // Check if column is typed, if so we are done\n    if (ArrayBuffer.isView(column)) {\n      schema[field] = column.constructor;\n      // else we need data\n    } else if (column.length) {\n      const value = column[0];\n      schema[field] = deduceTypeFromValue(value);\n      // TODO - support nested schemas?\n    }\n    // else we mark as present but unknow\n    schema[field] = schema[field] || null;\n  }\n  return schema;\n}\n\nfunction deduceSchemaForRowTable(rowTable) {\n  const schema = {};\n  if (rowTable.length) {\n    const row = rowTable[0];\n    // TODO - Could look at additional rows if nulls in first row\n    for (const field in row) {\n      const value = row[field];\n      schema[field] = deduceTypeFromValue(value);\n    }\n  }\n  return schema;\n}\n\nfunction deduceTypeFromValue(value) {\n  if (value instanceof Date) {\n    return Date;\n  } else if (value instanceof Number) {\n    return Float32Array;\n  } else if (typeof value === 'string') {\n    return String;\n  }\n  return null;\n}\n\n/*\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction deduceSchema(rows) {\n  const row = rows[0];\n\n  const schema = {};\n  let i = 0;\n  for (const columnName in row) {\n    const value = row[columnName];\n    switch (typeof value) {\n      case 'number':\n      case 'boolean':\n        // TODO - booleans could be handled differently...\n        schema[columnName] = {name: String(columnName), index: i, type: Float32Array};\n        break;\n\n      case 'object':\n        schema[columnName] = {name: String(columnName), index: i, type: Array};\n        break;\n\n      case 'string':\n      default:\n        schema[columnName] = {name: String(columnName), index: i, type: Array};\n      // We currently only handle numeric rows\n      // TODO we could offer a function to map strings to numbers?\n    }\n    i++;\n  }\n  return schema;\n}\n*/\n"]},"metadata":{},"sourceType":"module"}