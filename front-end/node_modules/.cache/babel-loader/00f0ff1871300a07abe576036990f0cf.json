{"ast":null,"code":"import { equals } from 'math.gl';\nimport assert from '../utils/assert';\nexport default class TransitionInterpolator {\n  constructor() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (Array.isArray(opts)) {\n      opts = {\n        compare: opts,\n        extract: opts,\n        required: opts\n      };\n    }\n\n    const {\n      compare,\n      extract,\n      required\n    } = opts;\n    this._propsToCompare = compare;\n    this._propsToExtract = extract;\n    this._requiredProps = required;\n  }\n\n  arePropsEqual(currentProps, nextProps) {\n    for (const key of this._propsToCompare || Object.keys(nextProps)) {\n      if (!(key in currentProps) || !(key in nextProps) || !equals(currentProps[key], nextProps[key])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  initializeProps(startProps, endProps) {\n    let result;\n\n    if (this._propsToExtract) {\n      const startViewStateProps = {};\n      const endViewStateProps = {};\n\n      for (const key of this._propsToExtract) {\n        startViewStateProps[key] = startProps[key];\n        endViewStateProps[key] = endProps[key];\n      }\n\n      result = {\n        start: startViewStateProps,\n        end: endViewStateProps\n      };\n    } else {\n      result = {\n        start: startProps,\n        end: endProps\n      };\n    }\n\n    this._checkRequiredProps(result.start);\n\n    this._checkRequiredProps(result.end);\n\n    return result;\n  }\n\n  interpolateProps(startProps, endProps, t) {\n    return endProps;\n  }\n\n  getDuration(startProps, endProps) {\n    return endProps.transitionDuration;\n  }\n\n  _checkRequiredProps(props) {\n    if (!this._requiredProps) {\n      return;\n    }\n\n    this._requiredProps.forEach(propName => {\n      const value = props[propName];\n      assert(Number.isFinite(value) || Array.isArray(value), \"\".concat(propName, \" is required for transition\"));\n    });\n  }\n\n}","map":{"version":3,"sources":["../../../src/transitions/transition-interpolator.js"],"names":["constructor","opts","Array","compare","extract","required","arePropsEqual","Object","key","equals","currentProps","nextProps","initializeProps","startViewStateProps","endViewStateProps","startProps","endProps","result","start","end","interpolateProps","getDuration","_checkRequiredProps","propName","value","props","assert","Number"],"mappings":"AAAA,SAAA,MAAA,QAAA,SAAA;AACA,OAAA,MAAA,MAAA,iBAAA;AAEA,eAAe,MAAA,sBAAA,CAA6B;AAQ1CA,EAAAA,WAAW,GAAY;AAAA,QAAXC,IAAW,uEAAZ,EAAY;;AACrB,QAAIC,KAAK,CAALA,OAAAA,CAAJ,IAAIA,CAAJ,EAAyB;AACvBD,MAAAA,IAAI,GAAG;AACLE,QAAAA,OAAO,EADF,IAAA;AAELC,QAAAA,OAAO,EAFF,IAAA;AAGLC,QAAAA,QAAQ,EAAEJ;AAHL,OAAPA;AAKD;;AACD,UAAM;AAAA,MAAA,OAAA;AAAA,MAAA,OAAA;AAAmBI,MAAAA;AAAnB,QAAN,IAAA;AAEA,SAAA,eAAA,GAAA,OAAA;AACA,SAAA,eAAA,GAAA,OAAA;AACA,SAAA,cAAA,GAAA,QAAA;AACD;;AAQDC,EAAAA,aAAa,CAAA,YAAA,EAAA,SAAA,EAA0B;AACrC,SAAK,MAAL,GAAA,IAAkB,KAAA,eAAA,IAAwBC,MAAM,CAANA,IAAAA,CAA1C,SAA0CA,CAA1C,EAAkE;AAChE,UACE,EAAEC,GAAG,IAAL,YAAA,KACA,EAAEA,GAAG,IADL,SACA,CADA,IAEA,CAACC,MAAM,CAACC,YAAY,CAAb,GAAa,CAAb,EAAoBC,SAAS,CAHtC,GAGsC,CAA7B,CAHT,EAIE;AACA,eAAA,KAAA;AACD;AACF;;AACD,WAAA,IAAA;AACD;;AASDC,EAAAA,eAAe,CAAA,UAAA,EAAA,QAAA,EAAuB;AACpC,QAAA,MAAA;;AAEA,QAAI,KAAJ,eAAA,EAA0B;AACxB,YAAMC,mBAAmB,GAAzB,EAAA;AACA,YAAMC,iBAAiB,GAAvB,EAAA;;AAEA,WAAK,MAAL,GAAA,IAAkB,KAAlB,eAAA,EAAwC;AACtCD,QAAAA,mBAAmB,CAAnBA,GAAmB,CAAnBA,GAA2BE,UAAU,CAArCF,GAAqC,CAArCA;AACAC,QAAAA,iBAAiB,CAAjBA,GAAiB,CAAjBA,GAAyBE,QAAQ,CAAjCF,GAAiC,CAAjCA;AACD;;AACDG,MAAAA,MAAM,GAAG;AAACC,QAAAA,KAAK,EAAN,mBAAA;AAA6BC,QAAAA,GAAG,EAAEL;AAAlC,OAATG;AARF,KAAA,MASO;AACLA,MAAAA,MAAM,GAAG;AAACC,QAAAA,KAAK,EAAN,UAAA;AAAoBC,QAAAA,GAAG,EAAEH;AAAzB,OAATC;AACD;;AAED,SAAA,mBAAA,CAAyBA,MAAM,CAA/B,KAAA;;AACA,SAAA,mBAAA,CAAyBA,MAAM,CAA/B,GAAA;;AAEA,WAAA,MAAA;AACD;;AASDG,EAAAA,gBAAgB,CAAA,UAAA,EAAA,QAAA,EAAA,CAAA,EAA0B;AACxC,WAAA,QAAA;AACD;;AAQDC,EAAAA,WAAW,CAAA,UAAA,EAAA,QAAA,EAAuB;AAChC,WAAOL,QAAQ,CAAf,kBAAA;AACD;;AAEDM,EAAAA,mBAAmB,CAAA,KAAA,EAAQ;AACzB,QAAI,CAAC,KAAL,cAAA,EAA0B;AACxB;AACD;;AAED,SAAA,cAAA,CAAA,OAAA,CAA4BC,QAAQ,IAAI;AACtC,YAAMC,KAAK,GAAGC,KAAK,CAAnB,QAAmB,CAAnB;AACAC,MAAAA,MAAM,CACJC,MAAM,CAANA,QAAAA,CAAAA,KAAAA,KAA0BzB,KAAK,CAALA,OAAAA,CADtB,KACsBA,CADtB,EAAA,GAAA,MAAA,CAAA,QAAA,EAANwB,6BAAM,CAAA,CAANA;AAFF,KAAA;AAOD;;AAxGyC","sourcesContent":["import {equals} from 'math.gl';\nimport assert from '../utils/assert';\n\nexport default class TransitionInterpolator {\n  /**\n   * @param opts {array|object}\n   * @param opts.compare {array} - prop names used in equality check\n   * @param opts.extract {array} - prop names needed for interpolation\n   * @param opts.required {array} - prop names that must be supplied\n   * alternatively, supply one list of prop names as `opts` if all of the above are the same.\n   */\n  constructor(opts = {}) {\n    if (Array.isArray(opts)) {\n      opts = {\n        compare: opts,\n        extract: opts,\n        required: opts\n      };\n    }\n    const {compare, extract, required} = opts;\n\n    this._propsToCompare = compare;\n    this._propsToExtract = extract;\n    this._requiredProps = required;\n  }\n\n  /**\n   * Checks if two sets of props need transition in between\n   * @param currentProps {object} - a list of viewport props\n   * @param nextProps {object} - a list of viewport props\n   * @returns {bool} - true if two props are equivalent\n   */\n  arePropsEqual(currentProps, nextProps) {\n    for (const key of this._propsToCompare || Object.keys(nextProps)) {\n      if (\n        !(key in currentProps) ||\n        !(key in nextProps) ||\n        !equals(currentProps[key], nextProps[key])\n      ) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Called before transition starts to validate/pre-process start and end props\n   * @param startProps {object} - a list of starting viewport props\n   * @param endProps {object} - a list of target viewport props\n   * @returns {Object} {start, end} - start and end props to be passed\n   *   to `interpolateProps`\n   */\n  initializeProps(startProps, endProps) {\n    let result;\n\n    if (this._propsToExtract) {\n      const startViewStateProps = {};\n      const endViewStateProps = {};\n\n      for (const key of this._propsToExtract) {\n        startViewStateProps[key] = startProps[key];\n        endViewStateProps[key] = endProps[key];\n      }\n      result = {start: startViewStateProps, end: endViewStateProps};\n    } else {\n      result = {start: startProps, end: endProps};\n    }\n\n    this._checkRequiredProps(result.start);\n    this._checkRequiredProps(result.end);\n\n    return result;\n  }\n\n  /**\n   * Returns viewport props in transition\n   * @param startProps {object} - a list of starting viewport props\n   * @param endProps {object} - a list of target viewport props\n   * @param t {number} - a time factor between [0, 1]\n   * @returns {object} - a list of interpolated viewport props\n   */\n  interpolateProps(startProps, endProps, t) {\n    return endProps;\n  }\n\n  /**\n   * Returns transition duration\n   * @param startProps {object} - a list of starting viewport props\n   * @param endProps {object} - a list of target viewport props\n   * @returns {Number} - transition duration in milliseconds\n   */\n  getDuration(startProps, endProps) {\n    return endProps.transitionDuration;\n  }\n\n  _checkRequiredProps(props) {\n    if (!this._requiredProps) {\n      return;\n    }\n\n    this._requiredProps.forEach(propName => {\n      const value = props[propName];\n      assert(\n        Number.isFinite(value) || Array.isArray(value),\n        `${propName} is required for transition`\n      );\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"module"}