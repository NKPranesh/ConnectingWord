{"ast":null,"code":"export function push(target, source) {\n  const size = source.length;\n  const startIndex = target.length;\n\n  if (startIndex > 0) {\n    let isDuplicate = true;\n\n    for (let i = 0; i < size; i++) {\n      if (target[startIndex - size + i] !== source[i]) {\n        isDuplicate = false;\n        break;\n      }\n    }\n\n    if (isDuplicate) {\n      return false;\n    }\n  }\n\n  for (let i = 0; i < size; i++) {\n    target[startIndex + i] = source[i];\n  }\n\n  return true;\n}\nexport function copy(target, source) {\n  const size = source.length;\n\n  for (let i = 0; i < size; i++) {\n    target[i] = source[i];\n  }\n}\nexport function getPointAtIndex(positions, index, size, offset) {\n  let out = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];\n  const startI = offset + index * size;\n\n  for (let i = 0; i < size; i++) {\n    out[i] = positions[startI + i];\n  }\n\n  return out;\n}","map":{"version":3,"sources":["../../src/utils.js"],"names":["size","source","startIndex","target","isDuplicate","i","out","startI","offset","index","positions"],"mappings":"AAAA,OAAO,SAAA,IAAA,CAAA,MAAA,EAAA,MAAA,EAA8B;AACnC,QAAMA,IAAI,GAAGC,MAAM,CAAnB,MAAA;AACA,QAAMC,UAAU,GAAGC,MAAM,CAAzB,MAAA;;AAGA,MAAID,UAAU,GAAd,CAAA,EAAoB;AAClB,QAAIE,WAAW,GAAf,IAAA;;AACA,SAAK,IAAIC,CAAC,GAAV,CAAA,EAAgBA,CAAC,GAAjB,IAAA,EAA0BA,CAA1B,EAAA,EAA+B;AAC7B,UAAIF,MAAM,CAACD,UAAU,GAAVA,IAAAA,GAAPC,CAAM,CAANA,KAAkCF,MAAM,CAA5C,CAA4C,CAA5C,EAAiD;AAC/CG,QAAAA,WAAW,GAAXA,KAAAA;AACA;AACD;AACF;;AACD,QAAA,WAAA,EAAiB;AACf,aAAA,KAAA;AACD;AACF;;AAED,OAAK,IAAIC,CAAC,GAAV,CAAA,EAAgBA,CAAC,GAAjB,IAAA,EAA0BA,CAA1B,EAAA,EAA+B;AAC7BF,IAAAA,MAAM,CAACD,UAAU,GAAjBC,CAAM,CAANA,GAAyBF,MAAM,CAA/BE,CAA+B,CAA/BA;AACD;;AACD,SAAA,IAAA;AACD;AAED,OAAO,SAAA,IAAA,CAAA,MAAA,EAAA,MAAA,EAA8B;AACnC,QAAMH,IAAI,GAAGC,MAAM,CAAnB,MAAA;;AACA,OAAK,IAAII,CAAC,GAAV,CAAA,EAAgBA,CAAC,GAAjB,IAAA,EAA0BA,CAA1B,EAAA,EAA+B;AAC7BF,IAAAA,MAAM,CAANA,CAAM,CAANA,GAAYF,MAAM,CAAlBE,CAAkB,CAAlBA;AACD;AACF;AAED,OAAO,SAAA,eAAA,CAAA,SAAA,EAAA,KAAA,EAAA,IAAA,EAAA,MAAA,EAAmE;AAAA,MAAVG,GAAU,uEAAnE,EAAmE;AACxE,QAAMC,MAAM,GAAGC,MAAM,GAAGC,KAAK,GAA7B,IAAA;;AACA,OAAK,IAAIJ,CAAC,GAAV,CAAA,EAAgBA,CAAC,GAAjB,IAAA,EAA0BA,CAA1B,EAAA,EAA+B;AAC7BC,IAAAA,GAAG,CAAHA,CAAG,CAAHA,GAASI,SAAS,CAACH,MAAM,GAAzBD,CAAkB,CAAlBA;AACD;;AACD,SAAA,GAAA;AACD","sourcesContent":["export function push(target, source) {\n  const size = source.length;\n  const startIndex = target.length;\n\n  // dedupe, if source is the same point as the last vertex\n  if (startIndex > 0) {\n    let isDuplicate = true;\n    for (let i = 0; i < size; i++) {\n      if (target[startIndex - size + i] !== source[i]) {\n        isDuplicate = false;\n        break;\n      }\n    }\n    if (isDuplicate) {\n      return false;\n    }\n  }\n\n  for (let i = 0; i < size; i++) {\n    target[startIndex + i] = source[i];\n  }\n  return true;\n}\n\nexport function copy(target, source) {\n  const size = source.length;\n  for (let i = 0; i < size; i++) {\n    target[i] = source[i];\n  }\n}\n\nexport function getPointAtIndex(positions, index, size, offset, out = []) {\n  const startI = offset + index * size;\n  for (let i = 0; i < size; i++) {\n    out[i] = positions[startI + i];\n  }\n  return out;\n}\n"]},"metadata":{},"sourceType":"module"}