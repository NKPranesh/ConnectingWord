{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nconst GLTF_TO_DRACO_ATTRIBUTE_NAME_MAP = {\n  POSITION: 'POSITION',\n  NORMAL: 'NORMAL',\n  COLOR_0: 'COLOR',\n  TEXCOORD_0: 'TEX_COORD'\n};\n\nconst noop = () => {};\n\nexport default class DracoBuilder {\n  constructor(draco) {\n    _defineProperty(this, \"draco\", void 0);\n\n    _defineProperty(this, \"dracoEncoder\", void 0);\n\n    _defineProperty(this, \"dracoMeshBuilder\", void 0);\n\n    _defineProperty(this, \"dracoMetadataBuilder\", void 0);\n\n    _defineProperty(this, \"log\", void 0);\n\n    this.draco = draco;\n    this.dracoEncoder = new this.draco.Encoder();\n    this.dracoMeshBuilder = new this.draco.MeshBuilder();\n    this.dracoMetadataBuilder = new this.draco.MetadataBuilder();\n  }\n\n  destroy() {\n    this.destroyEncodedObject(this.dracoMeshBuilder);\n    this.destroyEncodedObject(this.dracoEncoder);\n    this.destroyEncodedObject(this.dracoMetadataBuilder);\n    this.dracoMeshBuilder = null;\n    this.dracoEncoder = null;\n    this.draco = null;\n  }\n\n  destroyEncodedObject(object) {\n    if (object) {\n      this.draco.destroy(object);\n    }\n  }\n\n  encodeSync(mesh) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.log = noop;\n\n    this._setOptions(options);\n\n    return options.pointcloud ? this._encodePointCloud(mesh, options) : this._encodeMesh(mesh, options);\n  }\n\n  _getAttributesFromMesh(mesh) {\n    const attributes = { ...mesh,\n      ...mesh.attributes\n    };\n\n    if (mesh.indices) {\n      attributes.indices = mesh.indices;\n    }\n\n    return attributes;\n  }\n\n  _encodePointCloud(pointcloud, options) {\n    const dracoPointCloud = new this.draco.PointCloud();\n\n    if (options.metadata) {\n      this._addGeometryMetadata(dracoPointCloud, options.metadata);\n    }\n\n    const attributes = this._getAttributesFromMesh(pointcloud);\n\n    this._createDracoPointCloud(dracoPointCloud, attributes, options);\n\n    const dracoData = new this.draco.DracoInt8Array();\n\n    try {\n      const encodedLen = this.dracoEncoder.EncodePointCloudToDracoBuffer(dracoPointCloud, false, dracoData);\n\n      if (!(encodedLen > 0)) {\n        throw new Error('Draco encoding failed.');\n      }\n\n      this.log(\"DRACO encoded \".concat(dracoPointCloud.num_points(), \" points\\n        with \").concat(dracoPointCloud.num_attributes(), \" attributes into \").concat(encodedLen, \" bytes\"));\n      return dracoInt8ArrayToArrayBuffer(dracoData);\n    } finally {\n      this.destroyEncodedObject(dracoData);\n      this.destroyEncodedObject(dracoPointCloud);\n    }\n  }\n\n  _encodeMesh(mesh, options) {\n    const dracoMesh = new this.draco.Mesh();\n\n    if (options.metadata) {\n      this._addGeometryMetadata(dracoMesh, options.metadata);\n    }\n\n    const attributes = this._getAttributesFromMesh(mesh);\n\n    this._createDracoMesh(dracoMesh, attributes, options);\n\n    const dracoData = new this.draco.DracoInt8Array();\n\n    try {\n      const encodedLen = this.dracoEncoder.EncodeMeshToDracoBuffer(dracoMesh, dracoData);\n\n      if (encodedLen <= 0) {\n        throw new Error('Draco encoding failed.');\n      }\n\n      this.log(\"DRACO encoded \".concat(dracoMesh.num_points(), \" points\\n        with \").concat(dracoMesh.num_attributes(), \" attributes into \").concat(encodedLen, \" bytes\"));\n      return dracoInt8ArrayToArrayBuffer(dracoData);\n    } finally {\n      this.destroyEncodedObject(dracoData);\n      this.destroyEncodedObject(dracoMesh);\n    }\n  }\n\n  _setOptions(options) {\n    if ('speed' in options) {\n      this.dracoEncoder.SetSpeedOptions(...options.speed);\n    }\n\n    if ('method' in options) {\n      const dracoMethod = this.draco[options.method || 'MESH_SEQUENTIAL_ENCODING'];\n      this.dracoEncoder.SetEncodingMethod(dracoMethod);\n    }\n\n    if ('quantization' in options) {\n      for (const attribute in options.quantization) {\n        const bits = options.quantization[attribute];\n        const dracoPosition = this.draco[attribute];\n        this.dracoEncoder.SetAttributeQuantization(dracoPosition, bits);\n      }\n    }\n  }\n\n  _createDracoMesh(dracoMesh, attributes, options) {\n    const optionalMetadata = options.attributesMetadata || {};\n\n    try {\n      const positions = this._getPositionAttribute(attributes);\n\n      if (!positions) {\n        throw new Error('positions');\n      }\n\n      const vertexCount = positions.length / 3;\n\n      for (let attributeName in attributes) {\n        const attribute = attributes[attributeName];\n        attributeName = GLTF_TO_DRACO_ATTRIBUTE_NAME_MAP[attributeName] || attributeName;\n\n        const uniqueId = this._addAttributeToMesh(dracoMesh, attributeName, attribute, vertexCount);\n\n        if (uniqueId !== -1) {\n          this._addAttributeMetadata(dracoMesh, uniqueId, {\n            name: attributeName,\n            ...(optionalMetadata[attributeName] || {})\n          });\n        }\n      }\n    } catch (error) {\n      this.destroyEncodedObject(dracoMesh);\n      throw error;\n    }\n\n    return dracoMesh;\n  }\n\n  _createDracoPointCloud(dracoPointCloud, attributes, options) {\n    const optionalMetadata = options.attributesMetadata || {};\n\n    try {\n      const positions = this._getPositionAttribute(attributes);\n\n      if (!positions) {\n        throw new Error('positions');\n      }\n\n      const vertexCount = positions.length / 3;\n\n      for (let attributeName in attributes) {\n        const attribute = attributes[attributeName];\n        attributeName = GLTF_TO_DRACO_ATTRIBUTE_NAME_MAP[attributeName] || attributeName;\n\n        const uniqueId = this._addAttributeToMesh(dracoPointCloud, attributeName, attribute, vertexCount);\n\n        if (uniqueId !== -1) {\n          this._addAttributeMetadata(dracoPointCloud, uniqueId, {\n            name: attributeName,\n            ...(optionalMetadata[attributeName] || {})\n          });\n        }\n      }\n    } catch (error) {\n      this.destroyEncodedObject(dracoPointCloud);\n      throw error;\n    }\n\n    return dracoPointCloud;\n  }\n\n  _addAttributeToMesh(mesh, attributeName, attribute, vertexCount) {\n    if (!ArrayBuffer.isView(attribute)) {\n      return -1;\n    }\n\n    const type = this._getDracoAttributeType(attributeName);\n\n    const size = attribute.length / vertexCount;\n\n    if (type === 'indices') {\n      const numFaces = attribute.length / 3;\n      this.log(\"Adding attribute \".concat(attributeName, \", size \").concat(numFaces));\n      this.dracoMeshBuilder.AddFacesToMesh(mesh, numFaces, attribute);\n      return -1;\n    }\n\n    this.log(\"Adding attribute \".concat(attributeName, \", size \").concat(size));\n    const builder = this.dracoMeshBuilder;\n    const {\n      buffer\n    } = attribute;\n\n    switch (attribute.constructor) {\n      case Int8Array:\n        return builder.AddInt8Attribute(mesh, type, vertexCount, size, new Int8Array(buffer));\n\n      case Int16Array:\n        return builder.AddInt16Attribute(mesh, type, vertexCount, size, new Int16Array(buffer));\n\n      case Int32Array:\n        return builder.AddInt32Attribute(mesh, type, vertexCount, size, new Int32Array(buffer));\n\n      case Uint8Array:\n      case Uint8ClampedArray:\n        return builder.AddUInt8Attribute(mesh, type, vertexCount, size, new Uint8Array(buffer));\n\n      case Uint16Array:\n        return builder.AddUInt16Attribute(mesh, type, vertexCount, size, new Uint16Array(buffer));\n\n      case Uint32Array:\n        return builder.AddUInt32Attribute(mesh, type, vertexCount, size, new Uint32Array(buffer));\n\n      case Float32Array:\n      default:\n        return builder.AddFloatAttribute(mesh, type, vertexCount, size, new Float32Array(buffer));\n    }\n  }\n\n  _getDracoAttributeType(attributeName) {\n    switch (attributeName.toLowerCase()) {\n      case 'indices':\n        return 'indices';\n\n      case 'position':\n      case 'positions':\n      case 'vertices':\n        return this.draco.POSITION;\n\n      case 'normal':\n      case 'normals':\n        return this.draco.NORMAL;\n\n      case 'color':\n      case 'colors':\n        return this.draco.COLOR;\n\n      case 'texcoord':\n      case 'texcoords':\n        return this.draco.TEX_COORD;\n\n      default:\n        return this.draco.GENERIC;\n    }\n  }\n\n  _getPositionAttribute(attributes) {\n    for (const attributeName in attributes) {\n      const attribute = attributes[attributeName];\n\n      const dracoType = this._getDracoAttributeType(attributeName);\n\n      if (dracoType === this.draco.POSITION) {\n        return attribute;\n      }\n    }\n\n    return null;\n  }\n\n  _addGeometryMetadata(dracoGeometry, metadata) {\n    const dracoMetadata = new this.draco.Metadata();\n\n    this._populateDracoMetadata(dracoMetadata, metadata);\n\n    this.dracoMeshBuilder.AddMetadata(dracoGeometry, dracoMetadata);\n  }\n\n  _addAttributeMetadata(dracoGeometry, uniqueAttributeId, metadata) {\n    const dracoAttributeMetadata = new this.draco.Metadata();\n\n    this._populateDracoMetadata(dracoAttributeMetadata, metadata);\n\n    this.dracoMeshBuilder.SetMetadataForAttribute(dracoGeometry, uniqueAttributeId, dracoAttributeMetadata);\n  }\n\n  _populateDracoMetadata(dracoMetadata, metadata) {\n    for (const [key, value] of getEntries(metadata)) {\n      switch (typeof value) {\n        case 'number':\n          if (Math.trunc(value) === value) {\n            this.dracoMetadataBuilder.AddIntEntry(dracoMetadata, key, value);\n          } else {\n            this.dracoMetadataBuilder.AddDoubleEntry(dracoMetadata, key, value);\n          }\n\n          break;\n\n        case 'object':\n          if (value instanceof Int32Array) {\n            this.dracoMetadataBuilder.AddIntEntryArray(dracoMetadata, key, value, value.length);\n          }\n\n          break;\n\n        case 'string':\n        default:\n          this.dracoMetadataBuilder.AddStringEntry(dracoMetadata, key, value);\n      }\n    }\n  }\n\n}\n\nfunction dracoInt8ArrayToArrayBuffer(dracoData) {\n  const byteLength = dracoData.size();\n  const outputBuffer = new ArrayBuffer(byteLength);\n  const outputData = new Int8Array(outputBuffer);\n\n  for (let i = 0; i < byteLength; ++i) {\n    outputData[i] = dracoData.GetValue(i);\n  }\n\n  return outputBuffer;\n}\n\nfunction getEntries(container) {\n  const hasEntriesFunc = container.entries && !container.hasOwnProperty('entries');\n  return hasEntriesFunc ? container.entries() : Object.entries(container);\n}","map":{"version":3,"sources":["../../../src/lib/draco-builder.ts"],"names":["GLTF_TO_DRACO_ATTRIBUTE_NAME_MAP","POSITION","NORMAL","COLOR_0","TEXCOORD_0","noop","constructor","destroy","destroyEncodedObject","encodeSync","options","_getAttributesFromMesh","attributes","mesh","_encodePointCloud","dracoPointCloud","dracoData","encodedLen","dracoInt8ArrayToArrayBuffer","_encodeMesh","dracoMesh","_setOptions","dracoMethod","bits","dracoPosition","_createDracoMesh","optionalMetadata","positions","vertexCount","attribute","attributeName","uniqueId","name","_createDracoPointCloud","_addAttributeToMesh","ArrayBuffer","type","size","numFaces","builder","buffer","_getDracoAttributeType","_getPositionAttribute","dracoType","_addGeometryMetadata","dracoMetadata","_addAttributeMetadata","dracoAttributeMetadata","_populateDracoMetadata","getEntries","Math","value","byteLength","outputBuffer","outputData","i","hasEntriesFunc","container","Object"],"mappings":"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","sourcesContent":["/* eslint-disable camelcase */\n// This code is inspired by example code in the DRACO repository\nimport type {\n  Draco3D,\n  DracoInt8Array,\n  Encoder,\n  Mesh,\n  MeshBuilder,\n  PointCloud,\n  Metadata,\n  MetadataBuilder,\n  draco_GeometryAttribute_Type\n} from '../draco3d/draco3d-types';\n\nimport type {TypedArray, DracoMeshData} from './draco-types';\n\nexport type DracoBuildOptions = {\n  pointcloud?: boolean;\n  metadata?: {[key: string]: string};\n  attributesMetadata?: {};\n  log?: any;\n\n  // draco encoding options\n  speed?: [number, number];\n  method?: string;\n  quantization?: {[attributeName: string]: number};\n};\n\n// Native Draco attribute names to GLTF attribute names.\nconst GLTF_TO_DRACO_ATTRIBUTE_NAME_MAP = {\n  POSITION: 'POSITION',\n  NORMAL: 'NORMAL',\n  COLOR_0: 'COLOR',\n  TEXCOORD_0: 'TEX_COORD'\n};\n\nconst noop = () => {};\n\nexport default class DracoBuilder {\n  draco: Draco3D;\n  dracoEncoder: Encoder;\n  dracoMeshBuilder: MeshBuilder;\n  dracoMetadataBuilder: MetadataBuilder;\n  log: any;\n\n  // draco - the draco decoder, either import `draco3d` or load dynamically\n  constructor(draco: Draco3D) {\n    this.draco = draco;\n    this.dracoEncoder = new this.draco.Encoder();\n    this.dracoMeshBuilder = new this.draco.MeshBuilder();\n    this.dracoMetadataBuilder = new this.draco.MetadataBuilder();\n  }\n\n  destroy(): void {\n    this.destroyEncodedObject(this.dracoMeshBuilder);\n    this.destroyEncodedObject(this.dracoEncoder);\n    this.destroyEncodedObject(this.dracoMetadataBuilder);\n    // @ts-ignore\n    this.dracoMeshBuilder = null;\n    // @ts-ignore\n    this.dracoEncoder = null;\n    // @ts-ignore\n    this.draco = null;\n  }\n\n  // TBD - when does this need to be called?\n  destroyEncodedObject(object): void {\n    if (object) {\n      this.draco.destroy(object);\n    }\n  }\n\n  /**\n   * Encode mesh or point cloud\n   * @param mesh =({})\n   * @param options\n   */\n  encodeSync(mesh: DracoMeshData, options: DracoBuildOptions = {}): ArrayBuffer {\n    this.log = noop; // TODO\n    this._setOptions(options);\n\n    return options.pointcloud\n      ? this._encodePointCloud(mesh, options)\n      : this._encodeMesh(mesh, options);\n  }\n\n  // PRIVATE\n\n  _getAttributesFromMesh(mesh: DracoMeshData) {\n    // TODO - Change the encodePointCloud interface instead?\n    const attributes = {...mesh, ...mesh.attributes};\n    // Fold indices into the attributes\n    if (mesh.indices) {\n      attributes.indices = mesh.indices;\n    }\n    return attributes;\n  }\n\n  _encodePointCloud(pointcloud: DracoMeshData, options: DracoBuildOptions): ArrayBuffer {\n    const dracoPointCloud = new this.draco.PointCloud();\n\n    if (options.metadata) {\n      this._addGeometryMetadata(dracoPointCloud, options.metadata);\n    }\n\n    const attributes = this._getAttributesFromMesh(pointcloud);\n\n    // Build a `DracoPointCloud` from the input data\n    this._createDracoPointCloud(dracoPointCloud, attributes, options);\n\n    const dracoData = new this.draco.DracoInt8Array();\n\n    try {\n      const encodedLen = this.dracoEncoder.EncodePointCloudToDracoBuffer(\n        dracoPointCloud,\n        false,\n        dracoData\n      );\n\n      if (!(encodedLen > 0)) {\n        throw new Error('Draco encoding failed.');\n      }\n\n      this.log(`DRACO encoded ${dracoPointCloud.num_points()} points\n        with ${dracoPointCloud.num_attributes()} attributes into ${encodedLen} bytes`);\n\n      return dracoInt8ArrayToArrayBuffer(dracoData);\n    } finally {\n      this.destroyEncodedObject(dracoData);\n      this.destroyEncodedObject(dracoPointCloud);\n    }\n  }\n\n  _encodeMesh(mesh: DracoMeshData, options: DracoBuildOptions): ArrayBuffer {\n    const dracoMesh = new this.draco.Mesh();\n\n    if (options.metadata) {\n      this._addGeometryMetadata(dracoMesh, options.metadata);\n    }\n\n    const attributes = this._getAttributesFromMesh(mesh);\n\n    // Build a `DracoMeshData` from the input data\n    this._createDracoMesh(dracoMesh, attributes, options);\n\n    const dracoData = new this.draco.DracoInt8Array();\n\n    try {\n      const encodedLen = this.dracoEncoder.EncodeMeshToDracoBuffer(dracoMesh, dracoData);\n      if (encodedLen <= 0) {\n        throw new Error('Draco encoding failed.');\n      }\n\n      this.log(`DRACO encoded ${dracoMesh.num_points()} points\n        with ${dracoMesh.num_attributes()} attributes into ${encodedLen} bytes`);\n\n      return dracoInt8ArrayToArrayBuffer(dracoData);\n    } finally {\n      this.destroyEncodedObject(dracoData);\n      this.destroyEncodedObject(dracoMesh);\n    }\n  }\n\n  /**\n   * Set encoding options.\n   * @param {{speed?: any; method?: any; quantization?: any;}} options\n   */\n  _setOptions(options: DracoBuildOptions): void {\n    if ('speed' in options) {\n      // @ts-ignore\n      this.dracoEncoder.SetSpeedOptions(...options.speed);\n    }\n    if ('method' in options) {\n      const dracoMethod = this.draco[options.method || 'MESH_SEQUENTIAL_ENCODING'];\n      // assert(dracoMethod)\n      this.dracoEncoder.SetEncodingMethod(dracoMethod);\n    }\n    if ('quantization' in options) {\n      for (const attribute in options.quantization) {\n        const bits = options.quantization[attribute];\n        const dracoPosition = this.draco[attribute];\n        this.dracoEncoder.SetAttributeQuantization(dracoPosition, bits);\n      }\n    }\n  }\n\n  /**\n   * @param {Mesh} dracoMesh\n   * @param {object} attributes\n   * @returns {Mesh}\n   */\n  _createDracoMesh(dracoMesh: Mesh, attributes, options: DracoBuildOptions): Mesh {\n    const optionalMetadata = options.attributesMetadata || {};\n\n    try {\n      const positions = this._getPositionAttribute(attributes);\n      if (!positions) {\n        throw new Error('positions');\n      }\n      const vertexCount = positions.length / 3;\n\n      for (let attributeName in attributes) {\n        const attribute = attributes[attributeName];\n        attributeName = GLTF_TO_DRACO_ATTRIBUTE_NAME_MAP[attributeName] || attributeName;\n        const uniqueId = this._addAttributeToMesh(dracoMesh, attributeName, attribute, vertexCount);\n\n        if (uniqueId !== -1) {\n          this._addAttributeMetadata(dracoMesh, uniqueId, {\n            name: attributeName,\n            ...(optionalMetadata[attributeName] || {})\n          });\n        }\n      }\n    } catch (error) {\n      this.destroyEncodedObject(dracoMesh);\n      throw error;\n    }\n\n    return dracoMesh;\n  }\n\n  /**\n   * @param {} dracoPointCloud\n   * @param {object} attributes\n   */\n  _createDracoPointCloud(\n    dracoPointCloud: PointCloud,\n    attributes: object,\n    options: DracoBuildOptions\n  ): PointCloud {\n    const optionalMetadata = options.attributesMetadata || {};\n\n    try {\n      const positions = this._getPositionAttribute(attributes);\n      if (!positions) {\n        throw new Error('positions');\n      }\n      const vertexCount = positions.length / 3;\n\n      for (let attributeName in attributes) {\n        const attribute = attributes[attributeName];\n        attributeName = GLTF_TO_DRACO_ATTRIBUTE_NAME_MAP[attributeName] || attributeName;\n        const uniqueId = this._addAttributeToMesh(\n          dracoPointCloud,\n          attributeName,\n          attribute,\n          vertexCount\n        );\n        if (uniqueId !== -1) {\n          this._addAttributeMetadata(dracoPointCloud, uniqueId, {\n            name: attributeName,\n            ...(optionalMetadata[attributeName] || {})\n          });\n        }\n      }\n    } catch (error) {\n      this.destroyEncodedObject(dracoPointCloud);\n      throw error;\n    }\n\n    return dracoPointCloud;\n  }\n\n  /**\n   * @param mesh\n   * @param attributeName\n   * @param attribute\n   * @param vertexCount\n   */\n  _addAttributeToMesh(\n    mesh: PointCloud,\n    attributeName: string,\n    attribute: TypedArray,\n    vertexCount: number\n  ) {\n    if (!ArrayBuffer.isView(attribute)) {\n      return -1;\n    }\n\n    const type = this._getDracoAttributeType(attributeName);\n    // @ts-ignore TODO/fix types\n    const size = attribute.length / vertexCount;\n\n    if (type === 'indices') {\n      // @ts-ignore TODO/fix types\n      const numFaces = attribute.length / 3;\n      this.log(`Adding attribute ${attributeName}, size ${numFaces}`);\n\n      // @ts-ignore assumes mesh is a Mesh, not a point cloud\n      this.dracoMeshBuilder.AddFacesToMesh(mesh, numFaces, attribute);\n      return -1;\n    }\n\n    this.log(`Adding attribute ${attributeName}, size ${size}`);\n\n    const builder = this.dracoMeshBuilder;\n    const {buffer} = attribute;\n\n    switch (attribute.constructor) {\n      case Int8Array:\n        return builder.AddInt8Attribute(mesh, type, vertexCount, size, new Int8Array(buffer));\n\n      case Int16Array:\n        return builder.AddInt16Attribute(mesh, type, vertexCount, size, new Int16Array(buffer));\n\n      case Int32Array:\n        return builder.AddInt32Attribute(mesh, type, vertexCount, size, new Int32Array(buffer));\n      case Uint8Array:\n      case Uint8ClampedArray:\n        return builder.AddUInt8Attribute(mesh, type, vertexCount, size, new Uint8Array(buffer));\n\n      case Uint16Array:\n        return builder.AddUInt16Attribute(mesh, type, vertexCount, size, new Uint16Array(buffer));\n\n      case Uint32Array:\n        return builder.AddUInt32Attribute(mesh, type, vertexCount, size, new Uint32Array(buffer));\n\n      case Float32Array:\n      default:\n        return builder.AddFloatAttribute(mesh, type, vertexCount, size, new Float32Array(buffer));\n    }\n  }\n\n  /**\n   * DRACO can compress attributes of know type better\n   * TODO - expose an attribute type map?\n   * @param attributeName\n   */\n  _getDracoAttributeType(attributeName: string): draco_GeometryAttribute_Type | 'indices' {\n    switch (attributeName.toLowerCase()) {\n      case 'indices':\n        return 'indices';\n      case 'position':\n      case 'positions':\n      case 'vertices':\n        return this.draco.POSITION;\n      case 'normal':\n      case 'normals':\n        return this.draco.NORMAL;\n      case 'color':\n      case 'colors':\n        return this.draco.COLOR;\n      case 'texcoord':\n      case 'texcoords':\n        return this.draco.TEX_COORD;\n      default:\n        return this.draco.GENERIC;\n    }\n  }\n\n  _getPositionAttribute(attributes) {\n    for (const attributeName in attributes) {\n      const attribute = attributes[attributeName];\n      const dracoType = this._getDracoAttributeType(attributeName);\n      if (dracoType === this.draco.POSITION) {\n        return attribute;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Add metadata for the geometry.\n   * @param dracoGeometry - WASM Draco Object\n   * @param metadata\n   */\n  _addGeometryMetadata(dracoGeometry: PointCloud, metadata: {[key: string]: string}) {\n    const dracoMetadata = new this.draco.Metadata();\n    this._populateDracoMetadata(dracoMetadata, metadata);\n    this.dracoMeshBuilder.AddMetadata(dracoGeometry, dracoMetadata);\n  }\n\n  /**\n   * Add metadata for an attribute to geometry.\n   * @param dracoGeometry - WASM Draco Object\n   * @param uniqueAttributeId\n   * @param metadata\n   */\n  _addAttributeMetadata(\n    dracoGeometry: PointCloud,\n    uniqueAttributeId: number,\n    metadata: Map<string, string> | {[key: string]: string}\n  ) {\n    // Note: Draco JS IDL doesn't seem to expose draco.AttributeMetadata, however it seems to\n    // create such objects automatically from draco.Metadata object.\n    const dracoAttributeMetadata = new this.draco.Metadata();\n    this._populateDracoMetadata(dracoAttributeMetadata, metadata);\n    // Draco3d doc note: Directly add attribute metadata to geometry.\n    // You can do this without explicitly adding |GeometryMetadata| to mesh.\n    this.dracoMeshBuilder.SetMetadataForAttribute(\n      dracoGeometry,\n      uniqueAttributeId,\n      dracoAttributeMetadata\n    );\n  }\n\n  /**\n   * Add contents of object or map to a WASM Draco Metadata Object\n   * @param dracoMetadata - WASM Draco Object\n   * @param metadata\n   */\n  _populateDracoMetadata(\n    dracoMetadata: Metadata,\n    metadata: Map<string, string> | {[key: string]: string}\n  ) {\n    for (const [key, value] of getEntries(metadata)) {\n      switch (typeof value) {\n        case 'number':\n          if (Math.trunc(value) === value) {\n            this.dracoMetadataBuilder.AddIntEntry(dracoMetadata, key, value);\n          } else {\n            this.dracoMetadataBuilder.AddDoubleEntry(dracoMetadata, key, value);\n          }\n          break;\n        case 'object':\n          if (value instanceof Int32Array) {\n            this.dracoMetadataBuilder.AddIntEntryArray(dracoMetadata, key, value, value.length);\n          }\n          break;\n        case 'string':\n        default:\n          this.dracoMetadataBuilder.AddStringEntry(dracoMetadata, key, value);\n      }\n    }\n  }\n}\n\n// HELPER FUNCTIONS\n\n/**\n * Copy encoded data to buffer\n * @param dracoData\n */\nfunction dracoInt8ArrayToArrayBuffer(dracoData: DracoInt8Array) {\n  const byteLength = dracoData.size();\n  const outputBuffer = new ArrayBuffer(byteLength);\n  const outputData = new Int8Array(outputBuffer);\n  for (let i = 0; i < byteLength; ++i) {\n    outputData[i] = dracoData.GetValue(i);\n  }\n  return outputBuffer;\n}\n\n/** Enable iteration over either an object or a map */\nfunction getEntries(container) {\n  const hasEntriesFunc = container.entries && !container.hasOwnProperty('entries');\n  return hasEntriesFunc ? container.entries() : Object.entries(container);\n}\n"]},"metadata":{},"sourceType":"module"}