{"ast":null,"code":"import { assert, concatenateArrayBuffersAsync } from '@loaders.gl/loader-utils';\nimport { isLoaderObject } from '../loader-utils/normalize-loader';\nimport { normalizeOptions } from '../loader-utils/option-utils';\nimport { getLoaderContext } from '../loader-utils/loader-context';\nimport { getAsyncIterableFromData } from '../loader-utils/get-data';\nimport { getResourceUrlAndType } from '../utils/resource-utils';\nimport { selectLoader } from './select-loader';\nimport { parse } from './parse';\nexport async function parseInBatches(data, loaders, options, context) {\n  assert(!context || typeof context === 'object');\n\n  if (!Array.isArray(loaders) && !isLoaderObject(loaders)) {\n    context = undefined;\n    options = loaders;\n    loaders = undefined;\n  }\n\n  data = await data;\n  options = options || {};\n  const {\n    url\n  } = getResourceUrlAndType(data);\n  const loader = await selectLoader(data, loaders, options);\n\n  if (!loader) {\n    return null;\n  }\n\n  options = normalizeOptions(options, loader, loaders, url);\n  context = getLoaderContext({\n    url,\n    parseInBatches,\n    parse,\n    loaders: loaders\n  }, options, context);\n  return await parseWithLoaderInBatches(loader, data, options, context);\n}\n\nasync function parseWithLoaderInBatches(loader, data, options, context) {\n  const outputIterator = await parseToOutputIterator(loader, data, options, context);\n\n  if (!options.metadata) {\n    return outputIterator;\n  }\n\n  const metadataBatch = {\n    batchType: 'metadata',\n    metadata: {\n      _loader: loader,\n      _context: context\n    },\n    data: [],\n    bytesUsed: 0\n  };\n\n  async function* makeMetadataBatchIterator(iterator) {\n    yield metadataBatch;\n    yield* iterator;\n  }\n\n  return makeMetadataBatchIterator(outputIterator);\n}\n\nasync function parseToOutputIterator(loader, data, options, context) {\n  const inputIterator = await getAsyncIterableFromData(data, options);\n  const transformedIterator = await applyInputTransforms(inputIterator, (options === null || options === void 0 ? void 0 : options.transforms) || []);\n\n  if (loader.parseInBatches) {\n    return loader.parseInBatches(transformedIterator, options, context);\n  }\n\n  async function* parseChunkInBatches() {\n    const arrayBuffer = await concatenateArrayBuffersAsync(transformedIterator);\n    const parsedData = await parse(arrayBuffer, loader, { ...options,\n      mimeType: loader.mimeTypes[0]\n    }, context);\n    const batch = {\n      mimeType: loader.mimeTypes[0],\n      shape: Array.isArray(parsedData) ? 'row-table' : 'unknown',\n      batchType: 'data',\n      data: parsedData,\n      length: Array.isArray(parsedData) ? parsedData.length : 1\n    };\n    yield batch;\n  }\n\n  return parseChunkInBatches();\n}\n\nasync function applyInputTransforms(inputIterator) {\n  let transforms = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  let iteratorChain = inputIterator;\n\n  for await (const transformBatches of transforms) {\n    iteratorChain = transformBatches(iteratorChain);\n  }\n\n  return iteratorChain;\n}","map":{"version":3,"sources":["../../../../src/lib/api/parse-in-batches.ts"],"names":["assert","Array","isLoaderObject","context","options","loaders","data","url","getResourceUrlAndType","loader","selectLoader","normalizeOptions","getLoaderContext","parseWithLoaderInBatches","outputIterator","parseToOutputIterator","metadataBatch","batchType","metadata","_loader","_context","bytesUsed","makeMetadataBatchIterator","inputIterator","getAsyncIterableFromData","transformedIterator","applyInputTransforms","arrayBuffer","concatenateArrayBuffersAsync","parsedData","parse","mimeType","batch","shape","length","parseChunkInBatches","transforms","iteratorChain","transformBatches"],"mappings":"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","sourcesContent":["import type {Batch} from '@loaders.gl/schema';\nimport type {\n  BatchableDataType,\n  Loader,\n  LoaderWithParser,\n  LoaderContext,\n  LoaderOptions\n} from '@loaders.gl/loader-utils';\nimport {assert, concatenateArrayBuffersAsync} from '@loaders.gl/loader-utils';\nimport {isLoaderObject} from '../loader-utils/normalize-loader';\nimport {normalizeOptions} from '../loader-utils/option-utils';\nimport {getLoaderContext} from '../loader-utils/loader-context';\nimport {getAsyncIterableFromData} from '../loader-utils/get-data';\nimport {getResourceUrlAndType} from '../utils/resource-utils';\nimport {selectLoader} from './select-loader';\n\n// Ensure `parse` is available in context if loader falls back to `parse`\nimport {parse} from './parse';\n\n/**\n * Parses `data` using a specified loader\n * @param data\n * @param loaders\n * @param options\n * @param context\n */\nexport async function parseInBatches(\n  data: BatchableDataType,\n  loaders?: Loader | Loader[] | LoaderOptions,\n  options?: LoaderOptions,\n  context?: LoaderContext\n): Promise<AsyncIterable<any>> {\n  assert(!context || typeof context === 'object'); // parseInBatches no longer accepts final url\n\n  // Signature: parseInBatches(data, options, url) - Uses registered loaders\n  if (!Array.isArray(loaders) && !isLoaderObject(loaders)) {\n    context = undefined; // context not supported in short signature\n    options = loaders as LoaderOptions;\n    loaders = undefined;\n  }\n\n  data = await data; // Resolve any promise\n  options = options || {};\n\n  // Extract a url for auto detection\n  const {url} = getResourceUrlAndType(data);\n\n  // Chooses a loader and normalizes it\n  // Note - only uses URL and contentType for streams and iterator inputs\n  const loader = await selectLoader(data as ArrayBuffer, loaders as Loader[], options);\n  // Note: if options.nothrow was set, it is possible that no loader was found, if so just return null\n  if (!loader) {\n    // @ts-ignore\n    return null;\n  }\n\n  // Normalize options\n  // @ts-ignore\n  options = normalizeOptions(options, loader, loaders, url);\n  // @ts-ignore\n  context = getLoaderContext(\n    // @ts-ignore\n    {url, parseInBatches, parse, loaders: loaders as Loader[]},\n    options,\n    context\n  );\n\n  return await parseWithLoaderInBatches(loader as LoaderWithParser, data, options, context);\n}\n\n/**\n * Loader has been selected and context has been prepared, see if we need to emit a metadata batch\n */\nasync function parseWithLoaderInBatches(\n  loader: LoaderWithParser,\n  data: BatchableDataType,\n  options: LoaderOptions,\n  context: LoaderContext\n): Promise<AsyncIterable<any>> {\n  const outputIterator = await parseToOutputIterator(loader, data, options, context);\n\n  // Generate metadata batch if requested\n  if (!options.metadata) {\n    return outputIterator;\n  }\n\n  const metadataBatch = {\n    batchType: 'metadata',\n    metadata: {\n      _loader: loader,\n      _context: context\n    },\n    // Populate with some default fields to avoid crashing\n    data: [],\n    bytesUsed: 0\n  };\n\n  async function* makeMetadataBatchIterator(iterator) {\n    yield metadataBatch;\n    yield* iterator;\n  }\n\n  return makeMetadataBatchIterator(outputIterator);\n}\n\n/**\n * Prep work is done, now it is time to start parsing into an output operator\n * The approach depends on which parse function the loader exposes\n * `parseInBatches` (preferred), `parse` (fallback)\n */\nasync function parseToOutputIterator(\n  loader: LoaderWithParser,\n  data: BatchableDataType,\n  options: LoaderOptions,\n  context: LoaderContext\n): Promise<AsyncIterable<any>> {\n  // Get an iterator from the input\n  const inputIterator = await getAsyncIterableFromData(data, options);\n\n  // Apply any iterator transforms (options.transforms)\n  const transformedIterator = await applyInputTransforms(inputIterator, options?.transforms || []);\n\n  // If loader supports parseInBatches, we are done\n  if (loader.parseInBatches) {\n    return loader.parseInBatches(transformedIterator, options, context);\n  }\n\n  // Fallback: load atomically using `parse` concatenating input iterator into single chunk\n  async function* parseChunkInBatches() {\n    const arrayBuffer = await concatenateArrayBuffersAsync(transformedIterator);\n    // Call `parse` instead of `loader.parse` to ensure we can call workers etc.\n    const parsedData = await parse(\n      arrayBuffer,\n      loader,\n      // TODO - Hack: supply loaders MIME type to ensure we match it\n      {...options, mimeType: loader.mimeTypes[0]},\n      context\n    );\n    // yield a single batch, the output from loader.parse()\n    // TODO - run through batch builder to apply options etc...\n    const batch: Batch = {\n      mimeType: loader.mimeTypes[0],\n      shape: Array.isArray(parsedData) ? 'row-table' : 'unknown',\n      batchType: 'data',\n      data: parsedData,\n      length: Array.isArray(parsedData) ? parsedData.length : 1\n    };\n    yield batch;\n  }\n\n  return parseChunkInBatches();\n}\n\ntype TransformBatches = (\n  asyncIterator: AsyncIterable<ArrayBuffer> | Iterable<ArrayBuffer>\n) => AsyncIterable<ArrayBuffer>;\n\n/**\n * Create an iterator chain with any transform iterators (crypto, decompression)\n * @param inputIterator\n * @param options\n */\nasync function applyInputTransforms(\n  inputIterator: AsyncIterable<ArrayBuffer> | Iterable<ArrayBuffer>,\n  transforms: TransformBatches[] = []\n): Promise<AsyncIterable<ArrayBuffer> | Iterable<ArrayBuffer>> {\n  let iteratorChain = inputIterator;\n  for await (const transformBatches of transforms) {\n    iteratorChain = transformBatches(iteratorChain);\n  }\n  return iteratorChain;\n}\n"]},"metadata":{},"sourceType":"module"}