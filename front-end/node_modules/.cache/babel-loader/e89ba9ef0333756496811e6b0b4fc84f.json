{"ast":null,"code":"import Long from 'long';\nconst FACE_BITS = 3;\nconst MAX_LEVEL = 30;\nconst POS_BITS = 2 * MAX_LEVEL + 1;\nconst RADIAN_TO_DEGREE = 180 / Math.PI;\nexport function IJToST(ij, order, offsets) {\n  const maxSize = 1 << order;\n  return [(ij[0] + offsets[0]) / maxSize, (ij[1] + offsets[1]) / maxSize];\n}\n\nfunction singleSTtoUV(st) {\n  if (st >= 0.5) {\n    return 1 / 3.0 * (4 * st * st - 1);\n  }\n\n  return 1 / 3.0 * (1 - 4 * (1 - st) * (1 - st));\n}\n\nexport function STToUV(st) {\n  return [singleSTtoUV(st[0]), singleSTtoUV(st[1])];\n}\nexport function FaceUVToXYZ(face, _ref) {\n  let [u, v] = _ref;\n\n  switch (face) {\n    case 0:\n      return [1, u, v];\n\n    case 1:\n      return [-u, 1, v];\n\n    case 2:\n      return [-u, -v, 1];\n\n    case 3:\n      return [-1, -v, -u];\n\n    case 4:\n      return [v, -1, -u];\n\n    case 5:\n      return [v, u, -1];\n\n    default:\n      throw new Error('Invalid face');\n  }\n}\nexport function XYZToLngLat(_ref2) {\n  let [x, y, z] = _ref2;\n  const lat = Math.atan2(z, Math.sqrt(x * x + y * y));\n  const lng = Math.atan2(y, x);\n  return [lng * RADIAN_TO_DEGREE, lat * RADIAN_TO_DEGREE];\n}\nexport function toHilbertQuadkey(idS) {\n  let bin = Long.fromString(idS, true, 10).toString(2);\n\n  while (bin.length < FACE_BITS + POS_BITS) {\n    bin = '0' + bin;\n  }\n\n  const lsbIndex = bin.lastIndexOf('1');\n  const faceB = bin.substring(0, 3);\n  const posB = bin.substring(3, lsbIndex);\n  const levelN = posB.length / 2;\n  const faceS = Long.fromString(faceB, true, 2).toString(10);\n  let posS = Long.fromString(posB, true, 2).toString(4);\n\n  while (posS.length < levelN) {\n    posS = '0' + posS;\n  }\n\n  return \"\".concat(faceS, \"/\").concat(posS);\n}\n\nfunction rotateAndFlipQuadrant(n, point, rx, ry) {\n  if (ry === 0) {\n    if (rx === 1) {\n      point[0] = n - 1 - point[0];\n      point[1] = n - 1 - point[1];\n    }\n\n    const x = point[0];\n    point[0] = point[1];\n    point[1] = x;\n  }\n}\n\nexport function FromHilbertQuadKey(hilbertQuadkey) {\n  const parts = hilbertQuadkey.split('/');\n  const face = parseInt(parts[0], 10);\n  const position = parts[1];\n  const maxLevel = position.length;\n  const point = [0, 0];\n  let level;\n\n  for (let i = maxLevel - 1; i >= 0; i--) {\n    level = maxLevel - i;\n    const bit = position[i];\n    let rx = 0;\n    let ry = 0;\n\n    if (bit === '1') {\n      ry = 1;\n    } else if (bit === '2') {\n      rx = 1;\n      ry = 1;\n    } else if (bit === '3') {\n      rx = 1;\n    }\n\n    const val = Math.pow(2, level - 1);\n    rotateAndFlipQuadrant(val, point, rx, ry);\n    point[0] += val * rx;\n    point[1] += val * ry;\n  }\n\n  if (face % 2 === 1) {\n    const t = point[0];\n    point[0] = point[1];\n    point[1] = t;\n  }\n\n  return {\n    face,\n    ij: point,\n    level\n  };\n}","map":{"version":3,"sources":["../../../src/s2-layer/s2-geometry.js"],"names":["FACE_BITS","MAX_LEVEL","POS_BITS","RADIAN_TO_DEGREE","Math","maxSize","ij","offsets","st","singleSTtoUV","lat","x","y","lng","bin","Long","lsbIndex","faceB","posB","levelN","faceS","posS","ry","rx","point","n","parts","hilbertQuadkey","face","parseInt","position","maxLevel","i","level","bit","val","rotateAndFlipQuadrant","t"],"mappings":"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","sourcesContent":["/*\nAdapted from s2-geometry\n\nISC License (ISC)\n\nCopyright (c) 2012-2016, Jon Atkins <github@jonatkins.com>\nCopyright (c) 2016, AJ ONeal <aj@daplie.com>\n\nPermission to use, copy, modify, and/or distribute this software for any purpose with or without fee is hereby granted, provided that the above copyright notice and this permission notice appear in all copies.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n*/\n\nimport Long from 'long';\n\n//\n// Functional Style\n//\nconst FACE_BITS = 3;\nconst MAX_LEVEL = 30;\nconst POS_BITS = 2 * MAX_LEVEL + 1; // 61 (60 bits of data, 1 bit lsb marker)\nconst RADIAN_TO_DEGREE = 180 / Math.PI;\n\nexport function IJToST(ij, order, offsets) {\n  const maxSize = 1 << order;\n\n  return [(ij[0] + offsets[0]) / maxSize, (ij[1] + offsets[1]) / maxSize];\n}\n\nfunction singleSTtoUV(st) {\n  if (st >= 0.5) {\n    return (1 / 3.0) * (4 * st * st - 1);\n  }\n  return (1 / 3.0) * (1 - 4 * (1 - st) * (1 - st));\n}\n\nexport function STToUV(st) {\n  return [singleSTtoUV(st[0]), singleSTtoUV(st[1])];\n}\n\nexport function FaceUVToXYZ(face, [u, v]) {\n  switch (face) {\n    case 0:\n      return [1, u, v];\n    case 1:\n      return [-u, 1, v];\n    case 2:\n      return [-u, -v, 1];\n    case 3:\n      return [-1, -v, -u];\n    case 4:\n      return [v, -1, -u];\n    case 5:\n      return [v, u, -1];\n    default:\n      throw new Error('Invalid face');\n  }\n}\n\nexport function XYZToLngLat([x, y, z]) {\n  const lat = Math.atan2(z, Math.sqrt(x * x + y * y));\n  const lng = Math.atan2(y, x);\n\n  return [lng * RADIAN_TO_DEGREE, lat * RADIAN_TO_DEGREE];\n}\n\nexport function toHilbertQuadkey(idS) {\n  let bin = Long.fromString(idS, true, 10).toString(2);\n\n  while (bin.length < FACE_BITS + POS_BITS) {\n    // eslint-disable-next-line prefer-template\n    bin = '0' + bin;\n  }\n\n  // MUST come AFTER binstr has been left-padded with '0's\n  const lsbIndex = bin.lastIndexOf('1');\n  // substr(start, len)\n  // substring(start, end) // includes start, does not include end\n  const faceB = bin.substring(0, 3);\n  // posB will always be a multiple of 2 (or it's invalid)\n  const posB = bin.substring(3, lsbIndex);\n  const levelN = posB.length / 2;\n\n  const faceS = Long.fromString(faceB, true, 2).toString(10);\n  let posS = Long.fromString(posB, true, 2).toString(4);\n\n  while (posS.length < levelN) {\n    // eslint-disable-next-line prefer-template\n    posS = '0' + posS;\n  }\n\n  return `${faceS}/${posS}`;\n}\n\nfunction rotateAndFlipQuadrant(n, point, rx, ry) {\n  if (ry === 0) {\n    if (rx === 1) {\n      point[0] = n - 1 - point[0];\n      point[1] = n - 1 - point[1];\n    }\n\n    const x = point[0];\n    point[0] = point[1];\n    point[1] = x;\n  }\n}\n\nexport function FromHilbertQuadKey(hilbertQuadkey) {\n  const parts = hilbertQuadkey.split('/');\n  const face = parseInt(parts[0], 10);\n  const position = parts[1];\n  const maxLevel = position.length;\n  const point = [0, 0];\n  let level;\n\n  for (let i = maxLevel - 1; i >= 0; i--) {\n    level = maxLevel - i;\n    const bit = position[i];\n    let rx = 0;\n    let ry = 0;\n    if (bit === '1') {\n      ry = 1;\n    } else if (bit === '2') {\n      rx = 1;\n      ry = 1;\n    } else if (bit === '3') {\n      rx = 1;\n    }\n\n    const val = Math.pow(2, level - 1);\n    rotateAndFlipQuadrant(val, point, rx, ry);\n\n    point[0] += val * rx;\n    point[1] += val * ry;\n  }\n\n  if (face % 2 === 1) {\n    const t = point[0];\n    point[0] = point[1];\n    point[1] = t;\n  }\n\n  return {face, ij: point, level};\n}\n"]},"metadata":{},"sourceType":"module"}