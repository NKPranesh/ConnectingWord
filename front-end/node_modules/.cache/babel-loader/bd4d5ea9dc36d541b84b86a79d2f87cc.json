{"ast":null,"code":"import { global } from '../utils/globals';\nimport { getImageSize } from '../category-api/parsed-image-api';\nconst {\n  _encodeImageNode\n} = global;\nexport async function encodeImage(image, options) {\n  options = options || {};\n  options.image = options.image || {};\n  return _encodeImageNode ? _encodeImageNode(image, {\n    type: options.image.mimeType\n  }) : encodeImageInBrowser(image, options);\n}\nlet qualityParamSupported = true;\n\nasync function encodeImageInBrowser(image, options) {\n  const {\n    mimeType,\n    jpegQuality\n  } = options.image;\n  const {\n    width,\n    height\n  } = getImageSize(image);\n  const canvas = document.createElement('canvas');\n  canvas.width = width;\n  canvas.height = height;\n  drawImageToCanvas(image, canvas);\n  const blob = await new Promise(resolve => {\n    if (jpegQuality && qualityParamSupported) {\n      try {\n        canvas.toBlob(resolve, mimeType, jpegQuality);\n        return;\n      } catch (error) {\n        qualityParamSupported = false;\n      }\n    }\n\n    canvas.toBlob(resolve, mimeType);\n  });\n\n  if (!blob) {\n    throw new Error('image encoding failed');\n  }\n\n  return await blob.arrayBuffer();\n}\n\nfunction drawImageToCanvas(image, canvas) {\n  let x = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  let y = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n\n  if (x === 0 && y === 0 && typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {\n    const context = canvas.getContext('bitmaprenderer');\n\n    if (context) {\n      context.transferFromImageBitmap(image);\n      return canvas;\n    }\n  }\n\n  const context = canvas.getContext('2d');\n\n  if (image.data) {\n    const clampedArray = new Uint8ClampedArray(image.data);\n    const imageData = new ImageData(clampedArray, image.width, image.height);\n    context.putImageData(imageData, 0, 0);\n    return canvas;\n  }\n\n  context.drawImage(image, 0, 0);\n  return canvas;\n}","map":{"version":3,"sources":["../../../../src/lib/encoders/encode-image.ts"],"names":["_encodeImageNode","options","type","mimeType","encodeImageInBrowser","qualityParamSupported","jpegQuality","height","getImageSize","canvas","document","drawImageToCanvas","blob","resolve","x","y","image","context","clampedArray","imageData"],"mappings":"AACA,SAAA,MAAA,QAAA,kBAAA;AACA,SAAA,YAAA,QAAA,kCAAA;AAGA,MAAM;AAACA,EAAAA;AAAD,IAAN,MAAA;AAUA,OAAO,eAAA,WAAA,CAAA,KAAA,EAAA,OAAA,EAGiB;AACtBC,EAAAA,OAAO,GAAGA,OAAO,IAAjBA,EAAAA;AACAA,EAAAA,OAAO,CAAPA,KAAAA,GAAgBA,OAAO,CAAPA,KAAAA,IAAhBA,EAAAA;AAEA,SAAOD,gBAAgB,GACnBA,gBAAgB,CAAA,KAAA,EAAQ;AAACE,IAAAA,IAAI,EAAED,OAAO,CAAPA,KAAAA,CAAcE;AAArB,GAAR,CADG,GAEnBC,oBAAoB,CAAA,KAAA,EAFxB,OAEwB,CAFxB;AAGD;AAGD,IAAIC,qBAAqB,GAAzB,IAAA;;AASA,eAAA,oBAAA,CAAA,KAAA,EAAA,OAAA,EAAoD;AAClD,QAAM;AAAA,IAAA,QAAA;AAAWC,IAAAA;AAAX,MAA0BL,OAAO,CAAvC,KAAA;AAEA,QAAM;AAAA,IAAA,KAAA;AAAQM,IAAAA;AAAR,MAAkBC,YAAY,CAApC,KAAoC,CAApC;AAGA,QAAMC,MAAM,GAAGC,QAAQ,CAARA,aAAAA,CAAf,QAAeA,CAAf;AACAD,EAAAA,MAAM,CAANA,KAAAA,GAAAA,KAAAA;AACAA,EAAAA,MAAM,CAANA,MAAAA,GAAAA,MAAAA;AAEAE,EAAAA,iBAAiB,CAAA,KAAA,EAAjBA,MAAiB,CAAjBA;AAGA,QAAMC,IAAI,GAAG,MAAM,IAAA,OAAA,CAA0BC,OAAD,IAAa;AAEvD,QAAIP,WAAW,IAAf,qBAAA,EAA0C;AACxC,UAAI;AACFG,QAAAA,MAAM,CAANA,MAAAA,CAAAA,OAAAA,EAAAA,QAAAA,EAAAA,WAAAA;AACA;AAFF,OAAA,CAGE,OAAA,KAAA,EAAc;AACdJ,QAAAA,qBAAqB,GAArBA,KAAAA;AACD;AACF;;AACDI,IAAAA,MAAM,CAANA,MAAAA,CAAAA,OAAAA,EAAAA,QAAAA;AAVF,GAAmB,CAAnB;;AAaA,MAAI,CAAJ,IAAA,EAAW;AACT,UAAM,IAAA,KAAA,CAAN,uBAAM,CAAN;AACD;;AAED,SAAO,MAAMG,IAAI,CAAjB,WAAaA,EAAb;AACD;;AAED,SAAA,iBAAA,CAAA,KAAA,EAAA,MAAA,EAAwD;AAAA,MAAdE,CAAc,uEAAxD,CAAwD;AAAA,MAAPC,CAAO,uEAAxD,CAAwD;;AAEtD,MAAID,CAAC,KAADA,CAAAA,IAAWC,CAAC,KAAZD,CAAAA,IAAsB,OAAA,WAAA,KAAtBA,WAAAA,IAA4DE,KAAK,YAArE,WAAA,EAA8F;AAC5F,UAAMC,OAAO,GAAGR,MAAM,CAANA,UAAAA,CAAhB,gBAAgBA,CAAhB;;AACA,QAAA,OAAA,EAAa;AAEXQ,MAAAA,OAAO,CAAPA,uBAAAA,CAAAA,KAAAA;AACA,aAAA,MAAA;AACD;AACF;;AAGD,QAAMA,OAAO,GAAGR,MAAM,CAANA,UAAAA,CAAhB,IAAgBA,CAAhB;;AACA,MAAIO,KAAK,CAAT,IAAA,EAAgB;AAEd,UAAME,YAAY,GAAG,IAAA,iBAAA,CAAsBF,KAAK,CAAhD,IAAqB,CAArB;AACA,UAAMG,SAAS,GAAG,IAAA,SAAA,CAAA,YAAA,EAA4BH,KAAK,CAAjC,KAAA,EAAyCA,KAAK,CAAhE,MAAkB,CAAlB;AACAC,IAAAA,OAAO,CAAPA,YAAAA,CAAAA,SAAAA,EAAAA,CAAAA,EAAAA,CAAAA;AACA,WAAA,MAAA;AACD;;AAGDA,EAAAA,OAAO,CAAPA,SAAAA,CAAAA,KAAAA,EAAAA,CAAAA,EAAAA,CAAAA;AACA,SAAA,MAAA;AACD","sourcesContent":["// Image loading/saving for browser and Node.js\nimport {global} from '../utils/globals';\nimport {getImageSize} from '../category-api/parsed-image-api';\n\n// @ts-ignore TS2339: Property does not exist on type\nconst {_encodeImageNode} = global;\n\n/**\n * Returns data bytes representing a compressed image in PNG or JPG format,\n * This data can be saved using file system (f) methods or used in a request.\n * @param image - ImageBitmap Image or Canvas\n * @param options\n * param opt.type='png' - png, jpg or image/png, image/jpg are valid\n * param mimeType= - Whether to include a data URI header\n */\nexport async function encodeImage(\n  image: any,\n  options?: {[key: string]: any}\n): Promise<ArrayBuffer> {\n  options = options || {};\n  options.image = options.image || ({} as {[key: string]: any});\n\n  return _encodeImageNode\n    ? _encodeImageNode(image, {type: options.image.mimeType})\n    : encodeImageInBrowser(image, options);\n}\n\n// In case we get exceptions from canvas.toBlob(resolve, type, quality)\nlet qualityParamSupported = true;\n\n/**\n *\n * @param image\n * @param options\n * @note Based on canvas.toBlob\n * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob\n */\nasync function encodeImageInBrowser(image, options) {\n  const {mimeType, jpegQuality} = options.image;\n\n  const {width, height} = getImageSize(image);\n\n  // create a canvas and resize it to the size of our image\n  const canvas = document.createElement('canvas');\n  canvas.width = width;\n  canvas.height = height;\n\n  drawImageToCanvas(image, canvas);\n\n  // The actual encoding is done asynchronously with `canvas.toBlob()`\n  const blob = await new Promise<Blob | null>((resolve) => {\n    // get it back as a Blob\n    if (jpegQuality && qualityParamSupported) {\n      try {\n        canvas.toBlob(resolve, mimeType, jpegQuality);\n        return;\n      } catch (error) {\n        qualityParamSupported = false;\n      }\n    }\n    canvas.toBlob(resolve, mimeType);\n  });\n\n  if (!blob) {\n    throw new Error('image encoding failed');\n  }\n\n  return await blob.arrayBuffer();\n}\n\nfunction drawImageToCanvas(image, canvas, x = 0, y = 0) {\n  // Try optimized path for ImageBitmaps via bitmaprenderer context\n  if (x === 0 && y === 0 && typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {\n    const context = canvas.getContext('bitmaprenderer');\n    if (context) {\n      // transfer the ImageBitmap to it\n      context.transferFromImageBitmap(image);\n      return canvas;\n    }\n  }\n\n  // Available on most platforms, except IE11 and Andriod WebViews...\n  const context = canvas.getContext('2d');\n  if (image.data) {\n    // ImageData constructor expects clamped array even though getImageData does not return a clamped array...\n    const clampedArray = new Uint8ClampedArray(image.data);\n    const imageData = new ImageData(clampedArray, image.width, image.height);\n    context.putImageData(imageData, 0, 0);\n    return canvas;\n  }\n\n  // Fall back to generic image/image bitmap rendering path\n  context.drawImage(image, 0, 0);\n  return canvas;\n}\n"]},"metadata":{},"sourceType":"module"}