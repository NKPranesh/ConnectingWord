{"ast":null,"code":"import * as cartoColors from 'cartocolor';\nimport { assert } from './utils';\nexport const DEFAULT_PALETTE = 'PurpOr';\nexport const NULL_COLOR = [204, 204, 204];\nexport const OTHERS_COLOR = [119, 119, 119];\nexport default function getPalette(name, numCategories) {\n  const palette = cartoColors[name];\n  let paletteIndex = numCategories;\n  assert(palette, \"Palette \\\"\".concat(name, \"\\\" not found. Expected a CARTOColors string\"));\n  const palettesColorVariants = Object.keys(palette).filter(p => p !== 'tags').map(Number);\n  const longestPaletteIndex = Math.max(...palettesColorVariants);\n  const smallestPaletteIndex = Math.min(...palettesColorVariants);\n\n  if (!Number.isInteger(numCategories) || numCategories > longestPaletteIndex) {\n    paletteIndex = longestPaletteIndex;\n  } else if (numCategories < smallestPaletteIndex) {\n    paletteIndex = smallestPaletteIndex;\n  }\n\n  let colors = palette[paletteIndex];\n\n  if (palette.tags && palette.tags.includes('qualitative')) {\n    colors = colors.slice(0, -1);\n  }\n\n  return colors.map(c => hexToRgb(c));\n}\nexport function hexToRgb(hex) {\n  let result = /^#?([a-f\\d]{1})([a-f\\d]{1})([a-f\\d]{1})$/i.exec(hex);\n\n  if (result) {\n    return [parseInt(result[1] + result[1], 16), parseInt(result[2] + result[2], 16), parseInt(result[3] + result[3], 16), 255];\n  }\n\n  result = /^#?([a-f\\d]{1})([a-f\\d]{1})([a-f\\d]{1})([a-f\\d]{1})$/i.exec(hex);\n\n  if (result) {\n    return [parseInt(result[1] + result[1], 16), parseInt(result[2] + result[2], 16), parseInt(result[3] + result[3], 16), parseInt(result[4] + result[4], 16)];\n  }\n\n  result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n\n  if (result) {\n    return [parseInt(result[1], 16), parseInt(result[2], 16), parseInt(result[3], 16), 255];\n  }\n\n  result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n\n  if (result) {\n    return [parseInt(result[1], 16), parseInt(result[2], 16), parseInt(result[3], 16), parseInt(result[4], 16)];\n  }\n\n  assert(result, \"Hexadecimal color \\\"\".concat(hex, \"\\\" was not parsed correctly\"));\n  return NULL_COLOR;\n}","map":{"version":3,"sources":["../../../src/style/palette.js"],"names":["DEFAULT_PALETTE","NULL_COLOR","OTHERS_COLOR","palette","cartoColors","paletteIndex","assert","palettesColorVariants","Object","p","longestPaletteIndex","Math","smallestPaletteIndex","Number","numCategories","colors","c","hexToRgb","result","parseInt"],"mappings":"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","sourcesContent":["import * as cartoColors from 'cartocolor';\nimport {assert} from './utils';\n\nexport const DEFAULT_PALETTE = 'PurpOr';\nexport const NULL_COLOR = [204, 204, 204];\nexport const OTHERS_COLOR = [119, 119, 119];\n\nexport default function getPalette(name, numCategories) {\n  const palette = cartoColors[name];\n  let paletteIndex = numCategories;\n\n  assert(palette, `Palette \"${name}\" not found. Expected a CARTOColors string`);\n\n  const palettesColorVariants = Object.keys(palette)\n    .filter(p => p !== 'tags')\n    .map(Number);\n\n  const longestPaletteIndex = Math.max(...palettesColorVariants);\n  const smallestPaletteIndex = Math.min(...palettesColorVariants);\n\n  if (!Number.isInteger(numCategories) || numCategories > longestPaletteIndex) {\n    paletteIndex = longestPaletteIndex;\n  } else if (numCategories < smallestPaletteIndex) {\n    paletteIndex = smallestPaletteIndex;\n  }\n\n  let colors = palette[paletteIndex];\n\n  if (palette.tags && palette.tags.includes('qualitative')) {\n    colors = colors.slice(0, -1);\n  }\n\n  return colors.map(c => hexToRgb(c));\n}\n\nexport function hexToRgb(hex) {\n  // Evaluate #ABC\n  let result = /^#?([a-f\\d]{1})([a-f\\d]{1})([a-f\\d]{1})$/i.exec(hex);\n\n  if (result) {\n    return [\n      parseInt(result[1] + result[1], 16),\n      parseInt(result[2] + result[2], 16),\n      parseInt(result[3] + result[3], 16),\n      255\n    ];\n  }\n\n  // Evaluate #ABCD\n  result = /^#?([a-f\\d]{1})([a-f\\d]{1})([a-f\\d]{1})([a-f\\d]{1})$/i.exec(hex);\n\n  if (result) {\n    return [\n      parseInt(result[1] + result[1], 16),\n      parseInt(result[2] + result[2], 16),\n      parseInt(result[3] + result[3], 16),\n      parseInt(result[4] + result[4], 16)\n    ];\n  }\n\n  // Evaluate #ABCDEF\n  result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n\n  if (result) {\n    return [parseInt(result[1], 16), parseInt(result[2], 16), parseInt(result[3], 16), 255];\n  }\n\n  // Evaluate #ABCDEFAF\n  result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n\n  if (result) {\n    return [\n      parseInt(result[1], 16),\n      parseInt(result[2], 16),\n      parseInt(result[3], 16),\n      parseInt(result[4], 16)\n    ];\n  }\n\n  assert(result, `Hexadecimal color \"${hex}\" was not parsed correctly`);\n\n  return NULL_COLOR;\n}\n"]},"metadata":{},"sourceType":"module"}