{"ast":null,"code":"export default async function fetchProgress(response, onProgress) {\n  let onDone = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : () => {};\n  let onError = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : () => {};\n  response = await response;\n\n  if (!response.ok) {\n    return response;\n  }\n\n  const body = response.body;\n\n  if (!body) {\n    return response;\n  }\n\n  const contentLength = response.headers.get('content-length') || 0;\n  const totalBytes = contentLength && parseInt(contentLength);\n\n  if (!(contentLength > 0)) {\n    return response;\n  }\n\n  if (typeof ReadableStream === 'undefined' || !body.getReader) {\n    return response;\n  }\n\n  const progressStream = new ReadableStream({\n    async start(controller) {\n      const reader = body.getReader();\n      await read(controller, reader, 0, totalBytes, onProgress, onDone, onError);\n    }\n\n  });\n  return new Response(progressStream);\n}\n\nasync function read(controller, reader, loadedBytes, totalBytes, onProgress, onDone, onError) {\n  try {\n    const {\n      done,\n      value\n    } = await reader.read();\n\n    if (done) {\n      onDone();\n      controller.close();\n      return;\n    }\n\n    loadedBytes += value.byteLength;\n    const percent = Math.round(loadedBytes / totalBytes * 100);\n    onProgress(percent, {\n      loadedBytes,\n      totalBytes\n    });\n    controller.enqueue(value);\n    await read(controller, reader, loadedBytes, totalBytes, onProgress, onDone, onError);\n  } catch (error) {\n    controller.error(error);\n    onError(error);\n  }\n}","map":{"version":3,"sources":["../../../../src/lib/progress/fetch-progress.ts"],"names":["onDone","onError","response","body","contentLength","totalBytes","parseInt","progressStream","reader","read","value","controller","loadedBytes","percent","Math","onProgress"],"mappings":"AAKA,eAAe,eAAA,aAAA,CAAA,QAAA,EAAA,UAAA,EAKb;AAAA,MAFAA,MAEA,uEAFS,MAAM,CAHF,CAKb;AAAA,MADAC,OACA,uEADU,MAAM,CAJH,CAKb;AACAC,EAAAA,QAAQ,GAAG,MAAXA,QAAAA;;AACA,MAAI,CAACA,QAAQ,CAAb,EAAA,EAAkB;AAEhB,WAAA,QAAA;AACD;;AACD,QAAMC,IAAI,GAAGD,QAAQ,CAArB,IAAA;;AACA,MAAI,CAAJ,IAAA,EAAW;AAET,WAAA,QAAA;AACD;;AACD,QAAME,aAAa,GAAGF,QAAQ,CAARA,OAAAA,CAAAA,GAAAA,CAAAA,gBAAAA,KAAtB,CAAA;AACA,QAAMG,UAAU,GAAGD,aAAa,IAAIE,QAAQ,CAA5C,aAA4C,CAA5C;;AACA,MAAI,EAAEF,aAAa,GAAnB,CAAI,CAAJ,EAA0B;AACxB,WAAA,QAAA;AACD;;AAED,MAAI,OAAA,cAAA,KAAA,WAAA,IAAyC,CAACD,IAAI,CAAlD,SAAA,EAA8D;AAC5D,WAAA,QAAA;AACD;;AAGD,QAAMI,cAAc,GAAG,IAAA,cAAA,CAAmB;AACxC,UAAA,KAAA,CAAA,UAAA,EAAwB;AACtB,YAAMC,MAAM,GAAGL,IAAI,CAAnB,SAAeA,EAAf;AACA,YAAMM,IAAI,CAAA,UAAA,EAAA,MAAA,EAAA,CAAA,EAAA,UAAA,EAAA,UAAA,EAAA,MAAA,EAAV,OAAU,CAAV;AACD;;AAJuC,GAAnB,CAAvB;AAOA,SAAO,IAAA,QAAA,CAAP,cAAO,CAAP;AACD;;AAKD,eAAA,IAAA,CAAA,UAAA,EAAA,MAAA,EAAA,WAAA,EAAA,UAAA,EAAA,UAAA,EAAA,MAAA,EAAA,OAAA,EAA8F;AAC5F,MAAI;AACF,UAAM;AAAA,MAAA,IAAA;AAAOC,MAAAA;AAAP,QAAgB,MAAMF,MAAM,CAAlC,IAA4BA,EAA5B;;AACA,QAAA,IAAA,EAAU;AACRR,MAAAA,MAAM;AACNW,MAAAA,UAAU,CAAVA,KAAAA;AACA;AACD;;AACDC,IAAAA,WAAW,IAAIF,KAAK,CAApBE,UAAAA;AACA,UAAMC,OAAO,GAAGC,IAAI,CAAJA,KAAAA,CAAYF,WAAW,GAAZ,UAACA,GAA5B,GAAgBE,CAAhB;AACAC,IAAAA,UAAU,CAAA,OAAA,EAAU;AAAA,MAAA,WAAA;AAAcV,MAAAA;AAAd,KAAV,CAAVU;AACAJ,IAAAA,UAAU,CAAVA,OAAAA,CAAAA,KAAAA;AACA,UAAMF,IAAI,CAAA,UAAA,EAAA,MAAA,EAAA,WAAA,EAAA,UAAA,EAAA,UAAA,EAAA,MAAA,EAAV,OAAU,CAAV;AAXF,GAAA,CAYE,OAAA,KAAA,EAAc;AACdE,IAAAA,UAAU,CAAVA,KAAAA,CAAAA,KAAAA;AACAV,IAAAA,OAAO,CAAPA,KAAO,CAAPA;AACD;AACF","sourcesContent":["// Forked from github AnthumChris/fetch-progress-indicators under MIT license\n\n/**\n * Intercepts the Response stream and creates a new Response\n */\nexport default async function fetchProgress(\n  response: Response | Promise<Response>,\n  onProgress: any, // TODO better callback types\n  onDone = () => {},\n  onError = () => {}\n) {\n  response = await response;\n  if (!response.ok) {\n    // ERROR checking needs to be done separately\n    return response;\n  }\n  const body = response.body;\n  if (!body) {\n    // 'ReadableStream not yet supported in this browser.\n    return response;\n  }\n  const contentLength = response.headers.get('content-length') || 0;\n  const totalBytes = contentLength && parseInt(contentLength);\n  if (!(contentLength > 0)) {\n    return response;\n  }\n  // Currently override only implemented in browser\n  if (typeof ReadableStream === 'undefined' || !body.getReader) {\n    return response;\n  }\n\n  // Create a new stream that invisbly wraps original stream\n  const progressStream = new ReadableStream({\n    async start(controller) {\n      const reader = body.getReader();\n      await read(controller, reader, 0, totalBytes, onProgress, onDone, onError);\n    }\n  });\n\n  return new Response(progressStream);\n}\n\n// Forward to original streams controller\n// TODO - this causes a crazy deep \"async stack\"... rewrite as async iterator?\n// eslint-disable-next-line max-params\nasync function read(controller, reader, loadedBytes, totalBytes, onProgress, onDone, onError) {\n  try {\n    const {done, value} = await reader.read();\n    if (done) {\n      onDone();\n      controller.close();\n      return;\n    }\n    loadedBytes += value.byteLength;\n    const percent = Math.round((loadedBytes / totalBytes) * 100);\n    onProgress(percent, {loadedBytes, totalBytes});\n    controller.enqueue(value);\n    await read(controller, reader, loadedBytes, totalBytes, onProgress, onDone, onError);\n  } catch (error) {\n    controller.error(error);\n    onError(error);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}