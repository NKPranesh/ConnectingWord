{"ast":null,"code":"import GLTFScenegraph from '../api/gltf-scenegraph';\nimport { KHR_MATERIALS_UNLIT } from '../gltf-utils/gltf-constants';\nexport async function decode(gltfData) {\n  const gltfScenegraph = new GLTFScenegraph(gltfData);\n  const {\n    json\n  } = gltfScenegraph;\n  gltfScenegraph.removeExtension(KHR_MATERIALS_UNLIT);\n\n  for (const material of json.materials || []) {\n    const extension = material.extensions && material.extensions.KHR_materials_unlit;\n\n    if (extension) {\n      material.unlit = true;\n    }\n\n    gltfScenegraph.removeObjectExtension(material, KHR_MATERIALS_UNLIT);\n  }\n}\nexport function encode(gltfData) {\n  const gltfScenegraph = new GLTFScenegraph(gltfData);\n  const {\n    json\n  } = gltfScenegraph;\n\n  if (gltfScenegraph.materials) {\n    for (const material of json.materials || []) {\n      if (material.unlit) {\n        delete material.unlit;\n        gltfScenegraph.addObjectExtension(material, KHR_MATERIALS_UNLIT, {});\n        gltfScenegraph.addExtension(KHR_MATERIALS_UNLIT);\n      }\n    }\n  }\n}","map":{"version":3,"sources":["../../../../src/lib/extensions/KHR_materials_unlit.ts"],"names":["gltfScenegraph","json","extension","material"],"mappings":"AAKA,OAAA,cAAA,MAAA,wBAAA;AACA,SAAA,mBAAA,QAAA,8BAAA;AAEA,OAAO,eAAA,MAAA,CAAA,QAAA,EAA6D;AAClE,QAAMA,cAAc,GAAG,IAAA,cAAA,CAAvB,QAAuB,CAAvB;AACA,QAAM;AAACC,IAAAA;AAAD,MAAN,cAAA;AAGAD,EAAAA,cAAc,CAAdA,eAAAA,CAAAA,mBAAAA;;AAIA,OAAK,MAAL,QAAA,IAAuBC,IAAI,CAAJA,SAAAA,IAAvB,EAAA,EAA6C;AAC3C,UAAMC,SAAS,GAAGC,QAAQ,CAARA,UAAAA,IAAuBA,QAAQ,CAARA,UAAAA,CAAzC,mBAAA;;AACA,QAAA,SAAA,EAAe;AAEbA,MAAAA,QAAQ,CAARA,KAAAA,GAAAA,IAAAA;AACD;;AACDH,IAAAA,cAAc,CAAdA,qBAAAA,CAAAA,QAAAA,EAAAA,mBAAAA;AACD;AACF;AAED,OAAO,SAAA,MAAA,CAAA,QAAA,EAA0B;AAC/B,QAAMA,cAAc,GAAG,IAAA,cAAA,CAAvB,QAAuB,CAAvB;AACA,QAAM;AAACC,IAAAA;AAAD,MAAN,cAAA;;AAKA,MAAID,cAAc,CAAlB,SAAA,EAA8B;AAC5B,SAAK,MAAL,QAAA,IAAuBC,IAAI,CAAJA,SAAAA,IAAvB,EAAA,EAA6C;AAE3C,UAAIE,QAAQ,CAAZ,KAAA,EAAoB;AAElB,eAAOA,QAAQ,CAAf,KAAA;AACAH,QAAAA,cAAc,CAAdA,kBAAAA,CAAAA,QAAAA,EAAAA,mBAAAA,EAAAA,EAAAA;AACAA,QAAAA,cAAc,CAAdA,YAAAA,CAAAA,mBAAAA;AACD;AACF;AACF;AACF","sourcesContent":["// GLTF EXTENSION: KHR_materials_unlit\n// https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit\n\nimport type {GLTF} from '../types/gltf-types';\n\nimport GLTFScenegraph from '../api/gltf-scenegraph';\nimport {KHR_MATERIALS_UNLIT} from '../gltf-utils/gltf-constants';\n\nexport async function decode(gltfData: {json: GLTF}): Promise<void> {\n  const gltfScenegraph = new GLTFScenegraph(gltfData);\n  const {json} = gltfScenegraph;\n\n  // Remove the top-level extension\n  gltfScenegraph.removeExtension(KHR_MATERIALS_UNLIT);\n\n  // Any nodes that have the extension, add lights field pointing to light object\n  // and remove the extension\n  for (const material of json.materials || []) {\n    const extension = material.extensions && material.extensions.KHR_materials_unlit;\n    if (extension) {\n      // @ts-ignore TODO\n      material.unlit = true;\n    }\n    gltfScenegraph.removeObjectExtension(material, KHR_MATERIALS_UNLIT);\n  }\n}\n\nexport function encode(gltfData) {\n  const gltfScenegraph = new GLTFScenegraph(gltfData);\n  const {json} = gltfScenegraph;\n\n  // Any nodes that have lights field pointing to light object\n  // add the extension\n  // @ts-ignore\n  if (gltfScenegraph.materials) {\n    for (const material of json.materials || []) {\n      // @ts-ignore\n      if (material.unlit) {\n        // @ts-ignore\n        delete material.unlit;\n        gltfScenegraph.addObjectExtension(material, KHR_MATERIALS_UNLIT, {});\n        gltfScenegraph.addExtension(KHR_MATERIALS_UNLIT);\n      }\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}